import type { protocol, IPitcherClient } from "@codesandbox/pitcher-client";
import { Disposable } from "./utils/disposable";
import { type Event } from "./utils/event";
export interface RunningCommand extends Promise<{
    output: string;
    exitCode?: number;
}> {
    onOutput: Event<string>;
    kill(): void;
}
export type ShellCreateOpts = {
    ptySize?: ShellSize;
};
export type ShellRunOpts = {
    ptySize?: ShellSize;
    shellName?: string;
};
export type ShellOpenOpts = {
    ptySize?: ShellSize;
};
export type ShellSize = {
    cols: number;
    rows: number;
};
export type ShellStatus = "RUNNING" | "FINISHED" | "ERROR" | "KILLED" | "RESTARTING";
export declare const DEFAULT_SHELL_SIZE: ShellSize;
export declare class Shells extends Disposable {
    private pitcherClient;
    constructor(pitcherClient: IPitcherClient);
    readonly js: LanguageInterpreter;
    readonly python: LanguageInterpreter;
    /**
     * Creates a shell that can run commands, will return output as data is sent to stdin.
     *
     * ## Example
     *
     * ```ts
     * const shell = await sandbox.shell.create();
     *
     * const disposable = shell.onShellOut((data) => {
     *   console.log(data);
     * });
     *
     * // Write to the shell
     * shell.write("echo 'Hello, world!'");
     *
     * // Stop listening to the shell
     * disposable.dispose();
     *
     * // Kill the shell
     * await shell.kill();
     * ```
     *
     * @param command - The command to run in the shell.
     * @param shellSize - The size of the shell.
     * @returns A disposable shell instance.
     */
    create(command?: string, opts?: ShellCreateOpts): Promise<ShellInstance>;
    /**
     * Opens an existing shell.
     */
    open(shellId: string, opts?: ShellOpenOpts): Promise<ShellInstance>;
    /**
     * Runs the given command, and can be listened to for streaming output. To get all
     * output, you can optionally await the returned promise.
     *
     * ## Example
     *
     * ```ts
     * const shell = await sandbox.shell.runCommand("echo 'Hello, world!'");
     *
     * shell.onOutput((data) => {
     *   console.log(data);
     * });
     *
     * const result = await shell;
     *
     * console.log(result.output, result.exitCode);
     * ```
     */
    run(command: string, opts?: ShellRunOpts): RunningCommand;
    /**
     * Gets all shells that are running or have ran before in the current sandbox.
     */
    getShells(): Promise<ShellInstance[]>;
}
interface ILanguageInterpreterOpts {
    runtime: string;
    extension: string;
    env: Record<string, string>;
}
declare class LanguageInterpreter {
    private pitcherClient;
    private opts;
    constructor(pitcherClient: IPitcherClient, opts: ILanguageInterpreterOpts);
    run(code: string): Promise<RunningCommand>;
}
declare class ShellInstance extends Disposable {
    private shell;
    private pitcherClient;
    private onShellOutputEmitter;
    readonly onOutput: Event<string>;
    private onShellUpdatedEmitter;
    readonly onShellUpdated: Event<void>;
    private output;
    constructor(shell: protocol.shell.ShellDTO & {
        buffer?: string[];
    }, pitcherClient: IPitcherClient);
    /**
     * Gets the ID of the shell. Can be used to open the shell again.
     */
    get id(): string;
    /**
     * Gets the name of the shell.
     */
    get name(): string;
    get exitCode(): number | undefined;
    /**
     * Gets the status of the shell.
     */
    get status(): ShellStatus;
    write(input: string): Promise<void>;
    kill(): Promise<void>;
    /**
     * @returns The total output of the shell
     */
    getOutput(): string;
}
export {};
