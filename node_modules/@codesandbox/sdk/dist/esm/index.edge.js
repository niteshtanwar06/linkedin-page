import {createRequire} from 'module'
const require = createRequire(import.meta.url)
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@codesandbox/pitcher-common/dist/Barrier.js
var require_Barrier = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Barrier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClosableBarrier = exports.Barrier = void 0;
    var Barrier5 = class {
      _isOpen;
      _promise;
      _completePromise;
      constructor() {
        this._isOpen = false;
        this._promise = new Promise((resolve) => {
          this._completePromise = resolve;
        });
      }
      /**
       * Returns true if the barrier is open, false if it is closed
       * @returns true if the barrier is open, false if it is closed
       */
      isOpen() {
        return this._isOpen;
      }
      /**
       * Opens the barrier. If the barrier is already open, this method does nothing.
       * @param value the value to return when the barrier is opened
       * @returns
       */
      open(value) {
        if (this._isOpen) {
          return;
        }
        this._isOpen = true;
        this._completePromise({ status: "resolved", value });
      }
      /**
       *
       * @returns a promise that resolves when the barrier is opened. If the barrier is already open, the promise resolves immediately.
       */
      wait() {
        return this._promise;
      }
      /**
       * DO NOT USE THIS METHOD in production code. This is only for tests.
       * This is a convenience method that waits for the barrier to open and then returns the value.
       * If the Barrier is disposed while waiting to open, an error is thrown.
       * @returns the value if the barrier is open, otherwise throws an error
       */
      async __waitAndThrowIfDisposed() {
        const r3 = await this.wait();
        if (r3.status === "disposed") {
          throw new Error("Barrier was disposed");
        }
        return r3.value;
      }
      /**
       * Disposes the barrier.
       * If there is a promise waiting for the barrier to open, it will be resolved with a status of "disposed".
       */
      dispose() {
        this._completePromise({ status: "disposed" });
      }
    };
    exports.Barrier = Barrier5;
    var ClosableBarrier2 = class extends Barrier5 {
      close() {
        this._isOpen = false;
        this._promise = new Promise((resolve) => {
          this._completePromise = resolve;
        });
      }
    };
    exports.ClosableBarrier = ClosableBarrier2;
  }
});

// node_modules/uuid/dist/cjs-browser/max.js
var require_max = __commonJS({
  "node_modules/uuid/dist/cjs-browser/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/uuid/dist/cjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/cjs-browser/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/cjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/cjs-browser/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist/cjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/cjs-browser/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var regex_js_1 = require_regex();
    function validate(uuid) {
      return typeof uuid === "string" && regex_js_1.default.test(uuid);
    }
    exports.default = validate;
  }
});

// node_modules/uuid/dist/cjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/cjs-browser/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function parse(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v3;
      return Uint8Array.of((v3 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v3 >>> 16 & 255, v3 >>> 8 & 255, v3 & 255, (v3 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v3 / 4294967296 & 255, v3 >>> 24 & 255, v3 >>> 16 & 255, v3 >>> 8 & 255, v3 & 255);
    }
    exports.default = parse;
  }
});

// node_modules/uuid/dist/cjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/cjs-browser/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsafeStringify = unsafeStringify;
    var validate_js_1 = require_validate();
    var byteToHex = [];
    for (let i4 = 0; i4 < 256; ++i4) {
      byteToHex.push((i4 + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    exports.default = stringify;
  }
});

// node_modules/uuid/dist/cjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/cjs-browser/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        if (typeof crypto === "undefined" || !crypto.getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/cjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV1State = updateV1State;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v1(options, buf, offset) {
      let bytes;
      const isV6 = options?._v6 ?? false;
      if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
          options = void 0;
        }
      }
      if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
      }
      return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV1State(state, now, rnds) {
      state.msecs ??= -Infinity;
      state.nsecs ??= 0;
      if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 1e4) {
          state.node = void 0;
          state.nsecs = 0;
        }
      } else if (now > state.msecs) {
        state.nsecs = 0;
      } else if (now < state.msecs) {
        state.node = void 0;
      }
      if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 1;
        state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
      }
      state.msecs = now;
      return state;
    }
    function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      }
      msecs ??= Date.now();
      nsecs ??= 0;
      clockseq ??= (rnds[8] << 8 | rnds[9]) & 16383;
      node ??= rnds.slice(10, 16);
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      buf[offset++] = tl >>> 24 & 255;
      buf[offset++] = tl >>> 16 & 255;
      buf[offset++] = tl >>> 8 & 255;
      buf[offset++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      buf[offset++] = tmh >>> 8 & 255;
      buf[offset++] = tmh & 255;
      buf[offset++] = tmh >>> 24 & 15 | 16;
      buf[offset++] = tmh >>> 16 & 255;
      buf[offset++] = clockseq >>> 8 | 128;
      buf[offset++] = clockseq & 255;
      for (let n2 = 0; n2 < 6; ++n2) {
        buf[offset++] = node[n2];
      }
      return buf;
    }
    exports.default = v1;
  }
});

// node_modules/uuid/dist/cjs-browser/v1ToV6.js
var require_v1ToV6 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v1ToV6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = v1ToV6;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v1ToV6(uuid) {
      const v1Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v6Bytes = _v1ToV6(v1Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
    }
    function _v1ToV6(v1Bytes) {
      return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
    }
  }
});

// node_modules/uuid/dist/cjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function md5(bytes) {
      const words = uint8ToUint32(bytes);
      const md5Bytes = wordsToMd5(words, bytes.length * 8);
      return uint32ToUint8(md5Bytes);
    }
    function uint32ToUint8(input) {
      const bytes = new Uint8Array(input.length * 4);
      for (let i4 = 0; i4 < input.length * 4; i4++) {
        bytes[i4] = input[i4 >> 2] >>> i4 % 4 * 8 & 255;
      }
      return bytes;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x3, len) {
      const xpad = new Uint32Array(getOutputLength(len)).fill(0);
      xpad.set(x3);
      xpad[len >> 5] |= 128 << len % 32;
      xpad[xpad.length - 1] = len;
      x3 = xpad;
      let a3 = 1732584193;
      let b = -271733879;
      let c3 = -1732584194;
      let d2 = 271733878;
      for (let i4 = 0; i4 < x3.length; i4 += 16) {
        const olda = a3;
        const oldb = b;
        const oldc = c3;
        const oldd = d2;
        a3 = md5ff(a3, b, c3, d2, x3[i4], 7, -680876936);
        d2 = md5ff(d2, a3, b, c3, x3[i4 + 1], 12, -389564586);
        c3 = md5ff(c3, d2, a3, b, x3[i4 + 2], 17, 606105819);
        b = md5ff(b, c3, d2, a3, x3[i4 + 3], 22, -1044525330);
        a3 = md5ff(a3, b, c3, d2, x3[i4 + 4], 7, -176418897);
        d2 = md5ff(d2, a3, b, c3, x3[i4 + 5], 12, 1200080426);
        c3 = md5ff(c3, d2, a3, b, x3[i4 + 6], 17, -1473231341);
        b = md5ff(b, c3, d2, a3, x3[i4 + 7], 22, -45705983);
        a3 = md5ff(a3, b, c3, d2, x3[i4 + 8], 7, 1770035416);
        d2 = md5ff(d2, a3, b, c3, x3[i4 + 9], 12, -1958414417);
        c3 = md5ff(c3, d2, a3, b, x3[i4 + 10], 17, -42063);
        b = md5ff(b, c3, d2, a3, x3[i4 + 11], 22, -1990404162);
        a3 = md5ff(a3, b, c3, d2, x3[i4 + 12], 7, 1804603682);
        d2 = md5ff(d2, a3, b, c3, x3[i4 + 13], 12, -40341101);
        c3 = md5ff(c3, d2, a3, b, x3[i4 + 14], 17, -1502002290);
        b = md5ff(b, c3, d2, a3, x3[i4 + 15], 22, 1236535329);
        a3 = md5gg(a3, b, c3, d2, x3[i4 + 1], 5, -165796510);
        d2 = md5gg(d2, a3, b, c3, x3[i4 + 6], 9, -1069501632);
        c3 = md5gg(c3, d2, a3, b, x3[i4 + 11], 14, 643717713);
        b = md5gg(b, c3, d2, a3, x3[i4], 20, -373897302);
        a3 = md5gg(a3, b, c3, d2, x3[i4 + 5], 5, -701558691);
        d2 = md5gg(d2, a3, b, c3, x3[i4 + 10], 9, 38016083);
        c3 = md5gg(c3, d2, a3, b, x3[i4 + 15], 14, -660478335);
        b = md5gg(b, c3, d2, a3, x3[i4 + 4], 20, -405537848);
        a3 = md5gg(a3, b, c3, d2, x3[i4 + 9], 5, 568446438);
        d2 = md5gg(d2, a3, b, c3, x3[i4 + 14], 9, -1019803690);
        c3 = md5gg(c3, d2, a3, b, x3[i4 + 3], 14, -187363961);
        b = md5gg(b, c3, d2, a3, x3[i4 + 8], 20, 1163531501);
        a3 = md5gg(a3, b, c3, d2, x3[i4 + 13], 5, -1444681467);
        d2 = md5gg(d2, a3, b, c3, x3[i4 + 2], 9, -51403784);
        c3 = md5gg(c3, d2, a3, b, x3[i4 + 7], 14, 1735328473);
        b = md5gg(b, c3, d2, a3, x3[i4 + 12], 20, -1926607734);
        a3 = md5hh(a3, b, c3, d2, x3[i4 + 5], 4, -378558);
        d2 = md5hh(d2, a3, b, c3, x3[i4 + 8], 11, -2022574463);
        c3 = md5hh(c3, d2, a3, b, x3[i4 + 11], 16, 1839030562);
        b = md5hh(b, c3, d2, a3, x3[i4 + 14], 23, -35309556);
        a3 = md5hh(a3, b, c3, d2, x3[i4 + 1], 4, -1530992060);
        d2 = md5hh(d2, a3, b, c3, x3[i4 + 4], 11, 1272893353);
        c3 = md5hh(c3, d2, a3, b, x3[i4 + 7], 16, -155497632);
        b = md5hh(b, c3, d2, a3, x3[i4 + 10], 23, -1094730640);
        a3 = md5hh(a3, b, c3, d2, x3[i4 + 13], 4, 681279174);
        d2 = md5hh(d2, a3, b, c3, x3[i4], 11, -358537222);
        c3 = md5hh(c3, d2, a3, b, x3[i4 + 3], 16, -722521979);
        b = md5hh(b, c3, d2, a3, x3[i4 + 6], 23, 76029189);
        a3 = md5hh(a3, b, c3, d2, x3[i4 + 9], 4, -640364487);
        d2 = md5hh(d2, a3, b, c3, x3[i4 + 12], 11, -421815835);
        c3 = md5hh(c3, d2, a3, b, x3[i4 + 15], 16, 530742520);
        b = md5hh(b, c3, d2, a3, x3[i4 + 2], 23, -995338651);
        a3 = md5ii(a3, b, c3, d2, x3[i4], 6, -198630844);
        d2 = md5ii(d2, a3, b, c3, x3[i4 + 7], 10, 1126891415);
        c3 = md5ii(c3, d2, a3, b, x3[i4 + 14], 15, -1416354905);
        b = md5ii(b, c3, d2, a3, x3[i4 + 5], 21, -57434055);
        a3 = md5ii(a3, b, c3, d2, x3[i4 + 12], 6, 1700485571);
        d2 = md5ii(d2, a3, b, c3, x3[i4 + 3], 10, -1894986606);
        c3 = md5ii(c3, d2, a3, b, x3[i4 + 10], 15, -1051523);
        b = md5ii(b, c3, d2, a3, x3[i4 + 1], 21, -2054922799);
        a3 = md5ii(a3, b, c3, d2, x3[i4 + 8], 6, 1873313359);
        d2 = md5ii(d2, a3, b, c3, x3[i4 + 15], 10, -30611744);
        c3 = md5ii(c3, d2, a3, b, x3[i4 + 6], 15, -1560198380);
        b = md5ii(b, c3, d2, a3, x3[i4 + 13], 21, 1309151649);
        a3 = md5ii(a3, b, c3, d2, x3[i4 + 4], 6, -145523070);
        d2 = md5ii(d2, a3, b, c3, x3[i4 + 11], 10, -1120210379);
        c3 = md5ii(c3, d2, a3, b, x3[i4 + 2], 15, 718787259);
        b = md5ii(b, c3, d2, a3, x3[i4 + 9], 21, -343485551);
        a3 = safeAdd(a3, olda);
        b = safeAdd(b, oldb);
        c3 = safeAdd(c3, oldc);
        d2 = safeAdd(d2, oldd);
      }
      return Uint32Array.of(a3, b, c3, d2);
    }
    function uint8ToUint32(input) {
      if (input.length === 0) {
        return new Uint32Array();
      }
      const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
      for (let i4 = 0; i4 < input.length; i4++) {
        output[i4 >> 2] |= (input[i4] & 255) << i4 % 4 * 8;
      }
      return output;
    }
    function safeAdd(x3, y3) {
      const lsw = (x3 & 65535) + (y3 & 65535);
      const msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q2, a3, b, x3, s3, t3) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q2), safeAdd(x3, t3)), s3), b);
    }
    function md5ff(a3, b, c3, d2, x3, s3, t3) {
      return md5cmn(b & c3 | ~b & d2, a3, b, x3, s3, t3);
    }
    function md5gg(a3, b, c3, d2, x3, s3, t3) {
      return md5cmn(b & d2 | c3 & ~d2, a3, b, x3, s3, t3);
    }
    function md5hh(a3, b, c3, d2, x3, s3, t3) {
      return md5cmn(b ^ c3 ^ d2, a3, b, x3, s3, t3);
    }
    function md5ii(a3, b, c3, d2, x3, s3, t3) {
      return md5cmn(c3 ^ (b | ~d2), a3, b, x3, s3, t3);
    }
    exports.default = md5;
  }
});

// node_modules/uuid/dist/cjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    exports.stringToBytes = stringToBytes;
    exports.default = v35;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = new Uint8Array(str.length);
      for (let i4 = 0; i4 < str.length; ++i4) {
        bytes[i4] = str.charCodeAt(i4);
      }
      return bytes;
    }
    exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    function v35(version, hash, value, namespace, buf, offset) {
      const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
      const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1.default)(namespace) : namespace;
      if (typeof namespace === "string") {
        namespace = (0, parse_js_1.default)(namespace);
      }
      if (namespace?.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + valueBytes.length);
      bytes.set(namespaceBytes);
      bytes.set(valueBytes, namespaceBytes.length);
      bytes = hash(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i4 = 0; i4 < 16; ++i4) {
          buf[offset + i4] = bytes[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
  }
});

// node_modules/uuid/dist/cjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    var md5_js_1 = require_md5();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v3(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value, namespace, buf, offset);
    }
    v3.DNS = v35_js_1.DNS;
    v3.URL = v35_js_1.URL;
    exports.default = v3;
  }
});

// node_modules/uuid/dist/cjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/cjs-browser/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    exports.default = { randomUUID };
  }
});

// node_modules/uuid/dist/cjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var native_js_1 = require_native();
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    function v4(options, buf, offset) {
      if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || rng_js_1.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i4 = 0; i4 < 16; ++i4) {
          buf[offset + i4] = rnds[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(rnds);
    }
    exports.default = v4;
  }
});

// node_modules/uuid/dist/cjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function f3(s3, x3, y3, z4) {
      switch (s3) {
        case 0:
          return x3 & y3 ^ ~x3 & z4;
        case 1:
          return x3 ^ y3 ^ z4;
        case 2:
          return x3 & y3 ^ x3 & z4 ^ y3 & z4;
        case 3:
          return x3 ^ y3 ^ z4;
      }
    }
    function ROTL(x3, n2) {
      return x3 << n2 | x3 >>> 32 - n2;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      const newBytes = new Uint8Array(bytes.length + 1);
      newBytes.set(bytes);
      newBytes[bytes.length] = 128;
      bytes = newBytes;
      const l3 = bytes.length / 4 + 2;
      const N3 = Math.ceil(l3 / 16);
      const M2 = new Array(N3);
      for (let i4 = 0; i4 < N3; ++i4) {
        const arr = new Uint32Array(16);
        for (let j3 = 0; j3 < 16; ++j3) {
          arr[j3] = bytes[i4 * 64 + j3 * 4] << 24 | bytes[i4 * 64 + j3 * 4 + 1] << 16 | bytes[i4 * 64 + j3 * 4 + 2] << 8 | bytes[i4 * 64 + j3 * 4 + 3];
        }
        M2[i4] = arr;
      }
      M2[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M2[N3 - 1][14] = Math.floor(M2[N3 - 1][14]);
      M2[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i4 = 0; i4 < N3; ++i4) {
        const W = new Uint32Array(80);
        for (let t3 = 0; t3 < 16; ++t3) {
          W[t3] = M2[i4][t3];
        }
        for (let t3 = 16; t3 < 80; ++t3) {
          W[t3] = ROTL(W[t3 - 3] ^ W[t3 - 8] ^ W[t3 - 14] ^ W[t3 - 16], 1);
        }
        let a3 = H[0];
        let b = H[1];
        let c3 = H[2];
        let d2 = H[3];
        let e3 = H[4];
        for (let t3 = 0; t3 < 80; ++t3) {
          const s3 = Math.floor(t3 / 20);
          const T2 = ROTL(a3, 5) + f3(s3, b, c3, d2) + e3 + K[s3] + W[t3] >>> 0;
          e3 = d2;
          d2 = c3;
          c3 = ROTL(b, 30) >>> 0;
          b = a3;
          a3 = T2;
        }
        H[0] = H[0] + a3 >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c3 >>> 0;
        H[3] = H[3] + d2 >>> 0;
        H[4] = H[4] + e3 >>> 0;
      }
      return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
    }
    exports.default = sha1;
  }
});

// node_modules/uuid/dist/cjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    var sha1_js_1 = require_sha1();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v5(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace, buf, offset);
    }
    v5.DNS = v35_js_1.DNS;
    v5.URL = v35_js_1.URL;
    exports.default = v5;
  }
});

// node_modules/uuid/dist/cjs-browser/v6.js
var require_v6 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stringify_js_1 = require_stringify();
    var v1_js_1 = require_v1();
    var v1ToV6_js_1 = require_v1ToV6();
    function v6(options, buf, offset) {
      options ??= {};
      offset ??= 0;
      let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
      bytes = (0, v1ToV6_js_1.default)(bytes);
      if (buf) {
        for (let i4 = 0; i4 < 16; i4++) {
          buf[offset + i4] = bytes[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports.default = v6;
  }
});

// node_modules/uuid/dist/cjs-browser/v6ToV1.js
var require_v6ToV1 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v6ToV1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = v6ToV1;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v6ToV1(uuid) {
      const v6Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v1Bytes = _v6ToV1(v6Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
    }
    function _v6ToV1(v6Bytes) {
      return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
    }
  }
});

// node_modules/uuid/dist/cjs-browser/v7.js
var require_v7 = __commonJS({
  "node_modules/uuid/dist/cjs-browser/v7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV7State = updateV7State;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v7(options, buf, offset) {
      let bytes;
      if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
      }
      return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV7State(state, now, rnds) {
      state.msecs ??= -Infinity;
      state.seq ??= 0;
      if (now > state.msecs) {
        state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
        state.msecs = now;
      } else {
        state.seq = state.seq + 1 | 0;
        if (state.seq === 0) {
          state.msecs++;
        }
      }
      return state;
    }
    function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      }
      msecs ??= Date.now();
      seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
      buf[offset++] = msecs / 1099511627776 & 255;
      buf[offset++] = msecs / 4294967296 & 255;
      buf[offset++] = msecs / 16777216 & 255;
      buf[offset++] = msecs / 65536 & 255;
      buf[offset++] = msecs / 256 & 255;
      buf[offset++] = msecs & 255;
      buf[offset++] = 112 | seq >>> 28 & 15;
      buf[offset++] = seq >>> 20 & 255;
      buf[offset++] = 128 | seq >>> 14 & 63;
      buf[offset++] = seq >>> 6 & 255;
      buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
      buf[offset++] = rnds[11];
      buf[offset++] = rnds[12];
      buf[offset++] = rnds[13];
      buf[offset++] = rnds[14];
      buf[offset++] = rnds[15];
      return buf;
    }
    exports.default = v7;
  }
});

// node_modules/uuid/dist/cjs-browser/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/cjs-browser/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function version(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    exports.default = version;
  }
});

// node_modules/uuid/dist/cjs-browser/index.js
var require_cjs_browser = __commonJS({
  "node_modules/uuid/dist/cjs-browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
    var max_js_1 = require_max();
    Object.defineProperty(exports, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = require_nil();
    Object.defineProperty(exports, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = require_v1();
    Object.defineProperty(exports, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = require_v1ToV6();
    Object.defineProperty(exports, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = require_v3();
    Object.defineProperty(exports, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = require_v4();
    Object.defineProperty(exports, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = require_v5();
    Object.defineProperty(exports, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = require_v6();
    Object.defineProperty(exports, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = require_v6ToV1();
    Object.defineProperty(exports, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = require_v7();
    Object.defineProperty(exports, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = require_validate();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = require_version();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Id.js
var require_Id = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newId = void 0;
    var uuid_1 = require_cjs_browser();
    var newId5 = () => (0, uuid_1.v4)();
    exports.newId = newId5;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/sleep.js
var require_sleep = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = void 0;
    function sleep5(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports.sleep = sleep5;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/event.js
var require_event = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncEmitter = exports.Emitter = exports.onceEvent = exports.listenOnce = void 0;
    var Disposable_1 = require_Disposable();
    var sleep_1 = require_sleep();
    function listenOnce3(event, condition) {
      return new Promise((resolve) => {
        const disposable = event((result) => {
          if (typeof condition === "undefined" || condition(result)) {
            disposable.dispose();
            resolve(result);
          }
        });
      });
    }
    exports.listenOnce = listenOnce3;
    function onceEvent(event) {
      return (listener, thisArgs) => {
        const result = event((e3) => {
          result.dispose();
          return listener.call(thisArgs, e3);
        });
        return result;
      };
    }
    exports.onceEvent = onceEvent;
    var Emitter29 = class {
      registeredListeners = /* @__PURE__ */ new Set();
      _event;
      get event() {
        if (!this._event) {
          this._event = (listener) => {
            this.registeredListeners.add(listener);
            return Disposable_1.Disposable.create(() => {
              this.registeredListeners.delete(listener);
            });
          };
        }
        return this._event;
      }
      /** Invoke all listeners registered to this event. */
      fire(event) {
        this.registeredListeners.forEach((listener) => {
          listener(event);
        });
      }
      dispose() {
        this.registeredListeners = /* @__PURE__ */ new Set();
      }
    };
    exports.Emitter = Emitter29;
    var AsyncEmitter = class {
      timeoutMs;
      registeredListeners = /* @__PURE__ */ new Set();
      _event;
      constructor(timeoutMs) {
        this.timeoutMs = timeoutMs;
      }
      get event() {
        if (!this._event) {
          this._event = (listener) => {
            this.registeredListeners.add(listener);
            return Disposable_1.Disposable.create(() => {
              this.registeredListeners.delete(listener);
            });
          };
        }
        return this._event;
      }
      /** Invoke all listeners registered to this event and wait for them to resolve, unless timeout occurs. */
      fire(event) {
        return Promise.race([
          (0, sleep_1.sleep)(this.timeoutMs).then(() => {
            throw new Error("Timeout firing async event");
          }),
          // We run all listeners in parallel, where if any fails, the firing of the event fails
          Promise.allSettled(Array.from(this.registeredListeners).map((listener) => listener(event))).then((results) => {
            for (const result of results) {
              if (result.status === "rejected") {
                throw result.reason;
              }
            }
          })
        ]);
      }
      dispose() {
        this.registeredListeners = /* @__PURE__ */ new Set();
      }
    };
    exports.AsyncEmitter = AsyncEmitter;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Disposable.js
var require_Disposable = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DisposableStore = exports.Disposable = void 0;
    var event_1 = require_event();
    var Disposable17 = class _Disposable {
      onWillDisposeEmitter = new event_1.Emitter();
      onWillDispose = this.onWillDisposeEmitter.event;
      onDidDisposeEmitter = new event_1.Emitter();
      onDidDispose = this.onDidDisposeEmitter.event;
      toDispose = [];
      isDisposed = false;
      addDisposable(disposable) {
        this.toDispose.push(disposable);
        return disposable;
      }
      onDispose(cb) {
        this.toDispose.push(_Disposable.create(cb));
      }
      dispose() {
        if (this.isDisposed)
          return;
        this.onWillDisposeEmitter.fire(null);
        this.isDisposed = true;
        this.toDispose.forEach((disposable) => {
          disposable.dispose();
        });
        this.onDidDisposeEmitter.fire(null);
        this.onWillDisposeEmitter.dispose();
        this.onDidDisposeEmitter.dispose();
      }
      static is(arg) {
        return typeof arg["dispose"] === "function";
      }
      static create(cb) {
        return {
          dispose: cb
        };
      }
    };
    exports.Disposable = Disposable17;
    var DisposableStore3 = class _DisposableStore {
      static DISABLE_DISPOSED_WARNING = false;
      _toDispose = /* @__PURE__ */ new Set();
      _isDisposed = false;
      /**
       * Dispose of all registered disposables and mark this object as disposed.
       *
       * Any future disposables added to this object will be disposed of on `add`.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.clear();
      }
      /**
       * Dispose of all registered disposables but do not mark this object as disposed.
       */
      clear() {
        try {
          for (const disposable of this._toDispose.values()) {
            disposable.dispose();
          }
        } finally {
          this._toDispose.clear();
        }
      }
      add(o2) {
        if (!o2) {
          return o2;
        }
        if (o2 === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        if (this._isDisposed) {
          if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
            console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
          }
        } else {
          this._toDispose.add(o2);
        }
        return o2;
      }
    };
    exports.DisposableStore = DisposableStore3;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/SliceList.js
var require_SliceList = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/SliceList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SliceList = void 0;
    var SliceList3 = class {
      idx = 0;
      store = /* @__PURE__ */ new Map();
      /**
       * Add a value to the list
       *
       * @returns a unique reference to delete the item
       */
      add(value) {
        const nextIdx = this.idx + 1;
        this.idx = nextIdx;
        this.store.set(nextIdx, value);
        return nextIdx;
      }
      /**
       * Remove a value using the unique reference
       */
      remove(idx) {
        this.store.delete(idx);
      }
      /**
       * Get values as an iterator
       */
      values() {
        return this.store.values();
      }
      /**
       * Get values as an array
       */
      array() {
        return Array.from(this.store.values());
      }
      /**
       * Get amount of items in the list
       */
      size() {
        return this.store.size;
      }
    };
    exports.SliceList = SliceList3;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/EventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    var Disposable_1 = require_Disposable();
    var SliceList_1 = require_SliceList();
    var EventEmitter2 = class extends Disposable_1.Disposable {
      registeredListeners = {};
      _on;
      constructor() {
        super();
        this.onWillDispose(() => {
          this.registeredListeners = {};
        });
      }
      // This is a trick that allows us to reference "on" directly
      // and still bind it to the instance
      get on() {
        if (!this._on) {
          this._on = (type, listener) => {
            if (!this.registeredListeners[type]) {
              this.registeredListeners[type] = new SliceList_1.SliceList();
            }
            const idx = this.registeredListeners[type].add(listener);
            const disposable = {
              dispose: () => {
                if (this.registeredListeners[type]) {
                  this.registeredListeners[type].remove(idx);
                }
              }
            };
            return disposable;
          };
        }
        return this._on;
      }
      onType(type) {
        return this.on.bind(this, type);
      }
      emit(type, data) {
        if (!this.registeredListeners[type]) {
          return;
        }
        for (const listener of this.registeredListeners[type].values()) {
          listener(data);
        }
      }
      emitType(type) {
        return this.emit.bind(this, type);
      }
    };
    exports.EventEmitter = EventEmitter2;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/errors.js
var require_errors = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BugIndicatingError = exports.ErrorNoTelemetry = exports.CancellationError = exports.isCancellationError = exports.onUnexpectedError = exports.errorHandler = exports.ErrorHandler = void 0;
    var ErrorHandler = class {
      constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function(e3) {
          setTimeout(() => {
            if (e3.stack) {
              if (ErrorNoTelemetry.isErrorNoTelemetry(e3)) {
                throw new ErrorNoTelemetry(e3.message + "\n\n" + e3.stack);
              }
              throw new Error(e3.message + "\n\n" + e3.stack);
            }
            throw e3;
          }, 0);
        };
      }
      addListener(listener) {
        this.listeners.push(listener);
        return () => {
          this._removeListener(listener);
        };
      }
      emit(e3) {
        this.listeners.forEach((listener) => {
          listener(e3);
        });
      }
      _removeListener(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
      }
      setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
      }
      getUnexpectedErrorHandler() {
        return this.unexpectedErrorHandler;
      }
      onUnexpectedError(e3) {
        this.unexpectedErrorHandler(e3);
        this.emit(e3);
      }
      // For external errors, we don't want the listeners to be called
      onUnexpectedExternalError(e3) {
        this.unexpectedErrorHandler(e3);
      }
    };
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function onUnexpectedError(e3) {
      if (!isCancellationError(e3)) {
        exports.errorHandler.onUnexpectedError(e3);
      }
      return void 0;
    }
    exports.onUnexpectedError = onUnexpectedError;
    var canceledName = "Canceled";
    function isCancellationError(error) {
      if (error instanceof CancellationError2) {
        return true;
      }
      return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isCancellationError = isCancellationError;
    var CancellationError2 = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    exports.CancellationError = CancellationError2;
    var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
      constructor(msg) {
        super(msg);
        this.name = "CodeExpectedError";
      }
      static fromError(err) {
        if (err instanceof _ErrorNoTelemetry) {
          return err;
        }
        const result = new _ErrorNoTelemetry();
        result.message = err.message;
        result.stack = err.stack;
        return result;
      }
      static isErrorNoTelemetry(err) {
        return err.name === "CodeExpectedError";
      }
    };
    exports.ErrorNoTelemetry = ErrorNoTelemetry;
    var BugIndicatingError = class _BugIndicatingError extends Error {
      constructor(message) {
        super(message || "An unexpected bug occurred.");
        Object.setPrototypeOf(this, _BugIndicatingError.prototype);
      }
    };
    exports.BugIndicatingError = BugIndicatingError;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/offsetRange.js
var require_offsetRange = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/offsetRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OffsetRangeSet = exports.OffsetRange = void 0;
    var errors_1 = require_errors();
    var OffsetRange = class _OffsetRange {
      static addRange(range, sortedRanges) {
        let i4 = 0;
        while (i4 < sortedRanges.length && sortedRanges[i4].endExclusive < range.start) {
          i4++;
        }
        let j3 = i4;
        while (j3 < sortedRanges.length && sortedRanges[j3].start <= range.endExclusive) {
          j3++;
        }
        if (i4 === j3) {
          sortedRanges.splice(i4, 0, range);
        } else {
          const start = Math.min(range.start, sortedRanges[i4].start);
          const end = Math.max(range.endExclusive, sortedRanges[j3 - 1].endExclusive);
          sortedRanges.splice(i4, j3 - i4, new _OffsetRange(start, end));
        }
      }
      static tryCreate(start, endExclusive) {
        if (start > endExclusive) {
          return void 0;
        }
        return new _OffsetRange(start, endExclusive);
      }
      static ofLength(length) {
        return new _OffsetRange(0, length);
      }
      constructor(start, endExclusive) {
        this.start = start;
        this.endExclusive = endExclusive;
        if (start > endExclusive) {
          throw new errors_1.BugIndicatingError(`Invalid range: ${this.toString()}`);
        }
      }
      get isEmpty() {
        return this.start === this.endExclusive;
      }
      delta(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive + offset);
      }
      deltaStart(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive);
      }
      deltaEnd(offset) {
        return new _OffsetRange(this.start, this.endExclusive + offset);
      }
      get length() {
        return this.endExclusive - this.start;
      }
      toString() {
        return `[${this.start}, ${this.endExclusive})`;
      }
      equals(other) {
        return this.start === other.start && this.endExclusive === other.endExclusive;
      }
      containsRange(other) {
        return this.start <= other.start && other.endExclusive <= this.endExclusive;
      }
      contains(offset) {
        return this.start <= offset && offset < this.endExclusive;
      }
      /**
       * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
       * The joined range is the smallest range that contains both ranges.
       */
      join(other) {
        return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
      }
      /**
       * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
       *
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        if (start <= end) {
          return new _OffsetRange(start, end);
        }
        return void 0;
      }
      slice(arr) {
        return arr.slice(this.start, this.endExclusive);
      }
      /**
       * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
       * The range must not be empty.
       */
      clip(value) {
        if (this.isEmpty) {
          throw new errors_1.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        return Math.max(this.start, Math.min(this.endExclusive - 1, value));
      }
      /**
       * Returns `r := value + k * length` such that `r` is contained in this range.
       * The range must not be empty.
       *
       * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
       */
      clipCyclic(value) {
        if (this.isEmpty) {
          throw new errors_1.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        if (value < this.start) {
          return this.endExclusive - (this.start - value) % this.length;
        }
        if (value >= this.endExclusive) {
          return this.start + (value - this.start) % this.length;
        }
        return value;
      }
    };
    exports.OffsetRange = OffsetRange;
    var OffsetRangeSet = class _OffsetRangeSet {
      constructor() {
        this._sortedRanges = [];
      }
      addRange(range) {
        let i4 = 0;
        while (i4 < this._sortedRanges.length && this._sortedRanges[i4].endExclusive < range.start) {
          i4++;
        }
        let j3 = i4;
        while (j3 < this._sortedRanges.length && this._sortedRanges[j3].start <= range.endExclusive) {
          j3++;
        }
        if (i4 === j3) {
          this._sortedRanges.splice(i4, 0, range);
        } else {
          const start = Math.min(range.start, this._sortedRanges[i4].start);
          const end = Math.max(range.endExclusive, this._sortedRanges[j3 - 1].endExclusive);
          this._sortedRanges.splice(i4, j3 - i4, new OffsetRange(start, end));
        }
      }
      toString() {
        return this._sortedRanges.map((r3) => r3.toString()).join(", ");
      }
      /**
       * Returns of there is a value that is contained in this instance and the given range.
       */
      intersectsStrict(other) {
        let i4 = 0;
        while (i4 < this._sortedRanges.length && this._sortedRanges[i4].endExclusive <= other.start) {
          i4++;
        }
        return i4 < this._sortedRanges.length && this._sortedRanges[i4].start < other.endExclusive;
      }
      intersectWithRange(other) {
        const result = new _OffsetRangeSet();
        for (const range of this._sortedRanges) {
          const intersection = range.intersect(other);
          if (intersection) {
            result.addRange(intersection);
          }
        }
        return result;
      }
      intersectWithRangeLength(other) {
        return this.intersectWithRange(other).length;
      }
      get length() {
        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);
      }
    };
    exports.OffsetRangeSet = OffsetRangeSet;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/position.js
var require_position = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/position.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Position = void 0;
    var Position = class _Position {
      constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
      }
      /**
       * Create a new position from this position.
       *
       * @param newLineNumber new line number
       * @param newColumn new column
       */
      with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
          return this;
        } else {
          return new _Position(newLineNumber, newColumn);
        }
      }
      /**
       * Derive a new position from this position.
       *
       * @param deltaLineNumber line number delta
       * @param deltaColumn column delta
       */
      delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
      }
      /**
       * Test if this position equals other position
       */
      equals(other) {
        return _Position.equals(this, other);
      }
      /**
       * Test if position `a` equals position `b`
       */
      static equals(a3, b) {
        if (!a3 && !b) {
          return true;
        }
        return !!a3 && !!b && a3.lineNumber === b.lineNumber && a3.column === b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be false.
       */
      isBefore(other) {
        return _Position.isBefore(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be false.
       */
      static isBefore(a3, b) {
        if (a3.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a3.lineNumber) {
          return false;
        }
        return a3.column < b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be true.
       */
      isBeforeOrEqual(other) {
        return _Position.isBeforeOrEqual(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be true.
       */
      static isBeforeOrEqual(a3, b) {
        if (a3.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a3.lineNumber) {
          return false;
        }
        return a3.column <= b.column;
      }
      /**
       * A function that compares positions, useful for sorting
       */
      static compare(a3, b) {
        const aLineNumber = a3.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
          const aColumn = a3.column | 0;
          const bColumn = b.column | 0;
          return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
      }
      /**
       * Clone this position.
       */
      clone() {
        return new _Position(this.lineNumber, this.column);
      }
      /**
       * Convert to a human-readable representation.
       */
      toString() {
        return "(" + this.lineNumber + "," + this.column + ")";
      }
      // ---
      /**
       * Create a `Position` from an `IPosition`.
       */
      static lift(pos) {
        return new _Position(pos.lineNumber, pos.column);
      }
      /**
       * Test if `obj` is an `IPosition`.
       */
      static isIPosition(obj) {
        return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
      }
    };
    exports.Position = Position;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/range.js
var require_range = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Range = void 0;
    var position_1 = require_position();
    var Range = class _Range {
      constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
          this.startLineNumber = endLineNumber;
          this.startColumn = endColumn;
          this.endLineNumber = startLineNumber;
          this.endColumn = startColumn;
        } else {
          this.startLineNumber = startLineNumber;
          this.startColumn = startColumn;
          this.endLineNumber = endLineNumber;
          this.endColumn = endColumn;
        }
      }
      /**
       * Test if this range is empty.
       */
      isEmpty() {
        return _Range.isEmpty(this);
      }
      /**
       * Test if `range` is empty.
       */
      static isEmpty(range) {
        return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
      }
      /**
       * Test if position is in this range. If the position is at the edges, will return true.
       */
      containsPosition(position) {
        return _Range.containsPosition(this, position);
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return true.
       */
      static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return false.
       * @internal
       */
      static strictContainsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if range is in this range. If the range is equal to this range, will return true.
       */
      containsRange(range) {
        return _Range.containsRange(this, range);
      }
      /**
       * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
       */
      static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
       */
      strictContainsRange(range) {
        return _Range.strictContainsRange(this, range);
      }
      /**
       * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
       */
      static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      plusRange(range) {
        return _Range.plusRange(this, range);
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      static plusRange(a3, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a3.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = b.startColumn;
        } else if (b.startLineNumber === a3.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = Math.min(b.startColumn, a3.startColumn);
        } else {
          startLineNumber = a3.startLineNumber;
          startColumn = a3.startColumn;
        }
        if (b.endLineNumber > a3.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = b.endColumn;
        } else if (b.endLineNumber === a3.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = Math.max(b.endColumn, a3.endColumn);
        } else {
          endLineNumber = a3.endLineNumber;
          endColumn = a3.endColumn;
        }
        return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      /**
       * A intersection of the two ranges.
       */
      intersectRanges(range) {
        return _Range.intersectRanges(this, range);
      }
      /**
       * A intersection of the two ranges.
       */
      static intersectRanges(a3, b) {
        let resultStartLineNumber = a3.startLineNumber;
        let resultStartColumn = a3.startColumn;
        let resultEndLineNumber = a3.endLineNumber;
        let resultEndColumn = a3.endColumn;
        const otherStartLineNumber = b.startLineNumber;
        const otherStartColumn = b.startColumn;
        const otherEndLineNumber = b.endLineNumber;
        const otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
          resultStartLineNumber = otherStartLineNumber;
          resultStartColumn = otherStartColumn;
        } else if (resultStartLineNumber === otherStartLineNumber) {
          resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
          resultEndLineNumber = otherEndLineNumber;
          resultEndColumn = otherEndColumn;
        } else if (resultEndLineNumber === otherEndLineNumber) {
          resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        if (resultStartLineNumber > resultEndLineNumber) {
          return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
          return null;
        }
        return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
      }
      /**
       * Test if this range equals other.
       */
      equalsRange(other) {
        return _Range.equalsRange(this, other);
      }
      /**
       * Test if range `a` equals `b`.
       */
      static equalsRange(a3, b) {
        if (!a3 && !b) {
          return true;
        }
        return !!a3 && !!b && a3.startLineNumber === b.startLineNumber && a3.startColumn === b.startColumn && a3.endLineNumber === b.endLineNumber && a3.endColumn === b.endColumn;
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      getEndPosition() {
        return _Range.getEndPosition(this);
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      static getEndPosition(range) {
        return new position_1.Position(range.endLineNumber, range.endColumn);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      getStartPosition() {
        return _Range.getStartPosition(this);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      static getStartPosition(range) {
        return new position_1.Position(range.startLineNumber, range.startColumn);
      }
      /**
       * Transform to a user presentable string representation.
       */
      toString() {
        return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
      }
      /**
       * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
       */
      setEndPosition(endLineNumber, endColumn) {
        return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      /**
       * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
       */
      setStartPosition(startLineNumber, startColumn) {
        return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      collapseToStart() {
        return _Range.collapseToStart(this);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      static collapseToStart(range) {
        return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      collapseToEnd() {
        return _Range.collapseToEnd(this);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      static collapseToEnd(range) {
        return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Moves the range by the given amount of lines.
       */
      delta(lineCount) {
        return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
      }
      // ---
      static fromPositions(start, end = start) {
        return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
      }
      static lift(range) {
        if (!range) {
          return null;
        }
        return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Test if `obj` is an `IRange`.
       */
      static isIRange(obj) {
        return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
      }
      /**
       * Test if the two ranges are touching in any way.
       */
      static areIntersectingOrTouching(a3, b) {
        if (a3.endLineNumber < b.startLineNumber || a3.endLineNumber === b.startLineNumber && a3.endColumn < b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a3.startLineNumber || b.endLineNumber === a3.startLineNumber && b.endColumn < a3.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if the two ranges are intersecting. If the ranges are touching it returns true.
       */
      static areIntersecting(a3, b) {
        if (a3.endLineNumber < b.startLineNumber || a3.endLineNumber === b.startLineNumber && a3.endColumn <= b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a3.startLineNumber || b.endLineNumber === a3.startLineNumber && b.endColumn <= a3.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the startPosition and then on the endPosition
       */
      static compareRangesUsingStarts(a3, b) {
        if (a3 && b) {
          const aStartLineNumber = a3.startLineNumber | 0;
          const bStartLineNumber = b.startLineNumber | 0;
          if (aStartLineNumber === bStartLineNumber) {
            const aStartColumn = a3.startColumn | 0;
            const bStartColumn = b.startColumn | 0;
            if (aStartColumn === bStartColumn) {
              const aEndLineNumber = a3.endLineNumber | 0;
              const bEndLineNumber = b.endLineNumber | 0;
              if (aEndLineNumber === bEndLineNumber) {
                const aEndColumn = a3.endColumn | 0;
                const bEndColumn = b.endColumn | 0;
                return aEndColumn - bEndColumn;
              }
              return aEndLineNumber - bEndLineNumber;
            }
            return aStartColumn - bStartColumn;
          }
          return aStartLineNumber - bStartLineNumber;
        }
        const aExists = a3 ? 1 : 0;
        const bExists = b ? 1 : 0;
        return aExists - bExists;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the endPosition and then on the startPosition
       */
      static compareRangesUsingEnds(a3, b) {
        if (a3.endLineNumber === b.endLineNumber) {
          if (a3.endColumn === b.endColumn) {
            if (a3.startLineNumber === b.startLineNumber) {
              return a3.startColumn - b.startColumn;
            }
            return a3.startLineNumber - b.startLineNumber;
          }
          return a3.endColumn - b.endColumn;
        }
        return a3.endLineNumber - b.endLineNumber;
      }
      /**
       * Test if the range spans multiple lines.
       */
      static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
      }
      toJSON() {
        return this;
      }
    };
    exports.Range = Range;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/lineRange.js
var require_lineRange = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/lineRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineRange = void 0;
    var errors_1 = require_errors();
    var offsetRange_1 = require_offsetRange();
    var range_1 = require_range();
    var LineRange = class _LineRange {
      static fromRange(range) {
        return new _LineRange(range.startLineNumber, range.endLineNumber);
      }
      static subtract(a3, b) {
        if (!b) {
          return [a3];
        }
        if (a3.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a3.endLineNumberExclusive) {
          return [
            new _LineRange(a3.startLineNumber, b.startLineNumber),
            new _LineRange(b.endLineNumberExclusive, a3.endLineNumberExclusive)
          ];
        } else if (b.startLineNumber <= a3.startLineNumber && a3.endLineNumberExclusive <= b.endLineNumberExclusive) {
          return [];
        } else if (b.endLineNumberExclusive < a3.endLineNumberExclusive) {
          return [new _LineRange(Math.max(b.endLineNumberExclusive, a3.startLineNumber), a3.endLineNumberExclusive)];
        } else {
          return [new _LineRange(a3.startLineNumber, Math.min(b.startLineNumber, a3.endLineNumberExclusive))];
        }
      }
      /**
       * @param lineRanges An array of sorted line ranges.
       */
      static joinMany(lineRanges) {
        if (lineRanges.length === 0) {
          return [];
        }
        let result = lineRanges[0];
        for (let i4 = 1; i4 < lineRanges.length; i4++) {
          result = this.join(result, lineRanges[i4]);
        }
        return result;
      }
      /**
       * @param lineRanges1 Must be sorted.
       * @param lineRanges2 Must be sorted.
       */
      static join(lineRanges1, lineRanges2) {
        if (lineRanges1.length === 0) {
          return lineRanges2;
        }
        if (lineRanges2.length === 0) {
          return lineRanges1;
        }
        const result = [];
        let i1 = 0;
        let i22 = 0;
        let current = null;
        while (i1 < lineRanges1.length || i22 < lineRanges2.length) {
          let next = null;
          if (i1 < lineRanges1.length && i22 < lineRanges2.length) {
            const lineRange1 = lineRanges1[i1];
            const lineRange2 = lineRanges2[i22];
            if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
              next = lineRange1;
              i1++;
            } else {
              next = lineRange2;
              i22++;
            }
          } else if (i1 < lineRanges1.length) {
            next = lineRanges1[i1];
            i1++;
          } else {
            next = lineRanges2[i22];
            i22++;
          }
          if (current === null) {
            current = next;
          } else {
            if (current.endLineNumberExclusive >= next.startLineNumber) {
              current = new _LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
            } else {
              result.push(current);
              current = next;
            }
          }
        }
        if (current !== null) {
          result.push(current);
        }
        return result;
      }
      static ofLength(startLineNumber, length) {
        return new _LineRange(startLineNumber, startLineNumber + length);
      }
      /**
       * @internal
       */
      static deserialize(lineRange) {
        return new _LineRange(lineRange[0], lineRange[1]);
      }
      constructor(startLineNumber, endLineNumberExclusive) {
        if (startLineNumber > endLineNumberExclusive) {
          throw new errors_1.BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
        }
        this.startLineNumber = startLineNumber;
        this.endLineNumberExclusive = endLineNumberExclusive;
      }
      /**
       * Indicates if this line range contains the given line number.
       */
      contains(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Indicates if this line range is empty.
       */
      get isEmpty() {
        return this.startLineNumber === this.endLineNumberExclusive;
      }
      /**
       * Moves this line range by the given offset of line numbers.
       */
      delta(offset) {
        return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
      }
      deltaLength(offset) {
        return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
      }
      /**
       * The number of lines this line range spans.
       */
      get length() {
        return this.endLineNumberExclusive - this.startLineNumber;
      }
      /**
       * Creates a line range that combines this and the given line range.
       */
      join(other) {
        return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
      }
      toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
      }
      /**
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
        if (startLineNumber <= endLineNumberExclusive) {
          return new _LineRange(startLineNumber, endLineNumberExclusive);
        }
        return void 0;
      }
      intersectsStrict(other) {
        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
      }
      overlapOrTouch(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
      }
      equals(b) {
        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
      }
      toInclusiveRange() {
        if (this.isEmpty) {
          return null;
        }
        return new range_1.Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
      }
      toExclusiveRange() {
        return new range_1.Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
      }
      mapToLineArray(f3) {
        const result = [];
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          result.push(f3(lineNumber));
        }
        return result;
      }
      forEach(f3) {
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          f3(lineNumber);
        }
      }
      /**
       * @internal
       */
      serialize() {
        return [this.startLineNumber, this.endLineNumberExclusive];
      }
      includes(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
       * @internal
       */
      toOffsetRange() {
        return new offsetRange_1.OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
      }
    };
    exports.LineRange = LineRange;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/linesDiffComputer.js
var require_linesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/linesDiffComputer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MovedText = exports.SimpleLineRangeMapping = exports.RangeMapping = exports.LineRangeMapping = exports.LinesDiff = void 0;
    var lineRange_1 = require_lineRange();
    var LinesDiff = class {
      constructor(changes, moves, hitTimeout) {
        this.changes = changes;
        this.moves = moves;
        this.hitTimeout = hitTimeout;
      }
    };
    exports.LinesDiff = LinesDiff;
    var LineRangeMapping = class _LineRangeMapping {
      static inverse(mapping, originalLineCount, modifiedLineCount) {
        const result = [];
        let lastOriginalEndLineNumber = 1;
        let lastModifiedEndLineNumber = 1;
        for (const m3 of mapping) {
          const r4 = new _LineRangeMapping(new lineRange_1.LineRange(lastOriginalEndLineNumber, m3.originalRange.startLineNumber), new lineRange_1.LineRange(lastModifiedEndLineNumber, m3.modifiedRange.startLineNumber), void 0);
          if (!r4.modifiedRange.isEmpty) {
            result.push(r4);
          }
          lastOriginalEndLineNumber = m3.originalRange.endLineNumberExclusive;
          lastModifiedEndLineNumber = m3.modifiedRange.endLineNumberExclusive;
        }
        const r3 = new _LineRangeMapping(new lineRange_1.LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new lineRange_1.LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), void 0);
        if (!r3.modifiedRange.isEmpty) {
          result.push(r3);
        }
        return result;
      }
      constructor(originalRange, modifiedRange, innerChanges) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
        this.innerChanges = innerChanges;
      }
      toString() {
        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
      }
      get changedLineCount() {
        return Math.max(this.originalRange.length, this.modifiedRange.length);
      }
      flip() {
        return new _LineRangeMapping(this.modifiedRange, this.originalRange, this.innerChanges?.map((c3) => c3.flip()));
      }
    };
    exports.LineRangeMapping = LineRangeMapping;
    var RangeMapping = class _RangeMapping {
      constructor(originalRange, modifiedRange) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
      }
      toString() {
        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
      }
      flip() {
        return new _RangeMapping(this.modifiedRange, this.originalRange);
      }
    };
    exports.RangeMapping = RangeMapping;
    var SimpleLineRangeMapping = class _SimpleLineRangeMapping {
      constructor(original, modified) {
        this.original = original;
        this.modified = modified;
      }
      toString() {
        return `{${this.original.toString()}->${this.modified.toString()}}`;
      }
      flip() {
        return new _SimpleLineRangeMapping(this.modified, this.original);
      }
      join(other) {
        return new _SimpleLineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
      }
    };
    exports.SimpleLineRangeMapping = SimpleLineRangeMapping;
    var MovedText = class _MovedText {
      constructor(lineRangeMapping, changes) {
        this.lineRangeMapping = lineRangeMapping;
        this.changes = changes;
      }
      flip() {
        return new _MovedText(this.lineRangeMapping.flip(), this.changes.map((c3) => c3.flip()));
      }
    };
    exports.MovedText = MovedText;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/strings.js
var require_strings = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = exports.lastNonWhitespaceIndex = exports.firstNonWhitespaceIndex = void 0;
    function firstNonWhitespaceIndex(str) {
      for (let i4 = 0, len = str.length; i4 < len; i4++) {
        const chCode = str.charCodeAt(i4);
        if (chCode !== 32 && chCode !== 9) {
          return i4;
        }
      }
      return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
      for (let i4 = startIndex; i4 >= 0; i4--) {
        const chCode = str.charCodeAt(i4);
        if (chCode !== 32 && chCode !== 9) {
          return i4;
        }
      }
      return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function isHighSurrogate(charCode) {
      return 55296 <= charCode && charCode <= 56319;
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
      return 56320 <= charCode && charCode <= 57343;
    }
    exports.isLowSurrogate = isLowSurrogate;
    function computeCodePoint(highSurrogate, lowSurrogate) {
      return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
    }
    exports.computeCodePoint = computeCodePoint;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/hash.js
var require_hash = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringSHA1 = exports.toHexString = exports.stringHash = exports.numberHash = exports.doHash = void 0;
    var strings = require_strings();
    function doHash(obj, hashVal) {
      switch (typeof obj) {
        case "object":
          if (obj === null) {
            return numberHash(349, hashVal);
          } else if (Array.isArray(obj)) {
            return arrayHash(obj, hashVal);
          }
          return objectHash(obj, hashVal);
        case "string":
          return stringHash(obj, hashVal);
        case "boolean":
          return booleanHash(obj, hashVal);
        case "number":
          return numberHash(obj, hashVal);
        case "undefined":
          return numberHash(937, hashVal);
        default:
          return numberHash(617, hashVal);
      }
    }
    exports.doHash = doHash;
    function numberHash(val, initialHashVal) {
      return (initialHashVal << 5) - initialHashVal + val | 0;
    }
    exports.numberHash = numberHash;
    function booleanHash(b, initialHashVal) {
      return numberHash(b ? 433 : 863, initialHashVal);
    }
    function stringHash(s3, hashVal) {
      hashVal = numberHash(149417, hashVal);
      for (let i4 = 0, length = s3.length; i4 < length; i4++) {
        hashVal = numberHash(s3.charCodeAt(i4), hashVal);
      }
      return hashVal;
    }
    exports.stringHash = stringHash;
    function arrayHash(arr, initialHashVal) {
      initialHashVal = numberHash(104579, initialHashVal);
      return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
    }
    function objectHash(obj, initialHashVal) {
      initialHashVal = numberHash(181387, initialHashVal);
      return Object.keys(obj).sort().reduce((hashVal, key) => {
        hashVal = stringHash(key, hashVal);
        return doHash(obj[key], hashVal);
      }, initialHashVal);
    }
    function leftRotate(value, bits, totalBits = 32) {
      const delta = totalBits - bits;
      const mask = ~((1 << delta) - 1);
      return (value << bits | (mask & value) >>> delta) >>> 0;
    }
    function fill(dest, index = 0, count = dest.byteLength, value = 0) {
      for (let i4 = 0; i4 < count; i4++) {
        dest[index + i4] = value;
      }
    }
    function leftPad(value, length, char = "0") {
      while (value.length < length) {
        value = char + value;
      }
      return value;
    }
    function toHexString(bufferOrValue, bitsize = 32) {
      if (bufferOrValue instanceof ArrayBuffer) {
        return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
      }
      return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
    }
    exports.toHexString = toHexString;
    var StringSHA1 = class _StringSHA1 {
      constructor() {
        this._h0 = 1732584193;
        this._h1 = 4023233417;
        this._h2 = 2562383102;
        this._h3 = 271733878;
        this._h4 = 3285377520;
        this._buff = new Uint8Array(
          64 + 3
          /* to fit any utf-8 */
        );
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
      }
      update(str) {
        const strLen = str.length;
        if (strLen === 0) {
          return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
          charCode = leftoverHighSurrogate;
          offset = -1;
          leftoverHighSurrogate = 0;
        } else {
          charCode = str.charCodeAt(0);
          offset = 0;
        }
        while (true) {
          let codePoint = charCode;
          if (strings.isHighSurrogate(charCode)) {
            if (offset + 1 < strLen) {
              const nextCharCode = str.charCodeAt(offset + 1);
              if (strings.isLowSurrogate(nextCharCode)) {
                offset++;
                codePoint = strings.computeCodePoint(charCode, nextCharCode);
              } else {
                codePoint = 65533;
              }
            } else {
              leftoverHighSurrogate = charCode;
              break;
            }
          } else if (strings.isLowSurrogate(charCode)) {
            codePoint = 65533;
          }
          buffLen = this._push(buff, buffLen, codePoint);
          offset++;
          if (offset < strLen) {
            charCode = str.charCodeAt(offset);
          } else {
            break;
          }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
      }
      _push(buff, buffLen, codePoint) {
        if (codePoint < 128) {
          buff[buffLen++] = codePoint;
        } else if (codePoint < 2048) {
          buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else if (codePoint < 65536) {
          buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else {
          buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
          buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        }
        if (buffLen >= 64) {
          this._step();
          buffLen -= 64;
          this._totalLen += 64;
          buff[0] = buff[64 + 0];
          buff[1] = buff[64 + 1];
          buff[2] = buff[64 + 2];
        }
        return buffLen;
      }
      digest() {
        if (!this._finished) {
          this._finished = true;
          if (this._leftoverHighSurrogate) {
            this._leftoverHighSurrogate = 0;
            this._buffLen = this._push(
              this._buff,
              this._buffLen,
              65533
              /* SHA1Constant.UNICODE_REPLACEMENT */
            );
          }
          this._totalLen += this._buffLen;
          this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
      }
      _wrapUp() {
        this._buff[this._buffLen++] = 128;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
          this._step();
          fill(this._buff);
        }
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
      }
      _step() {
        const bigBlock32 = _StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j3 = 0; j3 < 64; j3 += 4) {
          bigBlock32.setUint32(j3, data.getUint32(j3, false), false);
        }
        for (let j3 = 64; j3 < 320; j3 += 4) {
          bigBlock32.setUint32(j3, leftRotate(bigBlock32.getUint32(j3 - 12, false) ^ bigBlock32.getUint32(j3 - 32, false) ^ bigBlock32.getUint32(j3 - 56, false) ^ bigBlock32.getUint32(j3 - 64, false), 1), false);
        }
        let a3 = this._h0;
        let b = this._h1;
        let c3 = this._h2;
        let d2 = this._h3;
        let e3 = this._h4;
        let f3, k4;
        let temp;
        for (let j3 = 0; j3 < 80; j3++) {
          if (j3 < 20) {
            f3 = b & c3 | ~b & d2;
            k4 = 1518500249;
          } else if (j3 < 40) {
            f3 = b ^ c3 ^ d2;
            k4 = 1859775393;
          } else if (j3 < 60) {
            f3 = b & c3 | b & d2 | c3 & d2;
            k4 = 2400959708;
          } else {
            f3 = b ^ c3 ^ d2;
            k4 = 3395469782;
          }
          temp = leftRotate(a3, 5) + f3 + e3 + k4 + bigBlock32.getUint32(j3 * 4, false) & 4294967295;
          e3 = d2;
          d2 = c3;
          c3 = leftRotate(b, 30);
          b = a3;
          a3 = temp;
        }
        this._h0 = this._h0 + a3 & 4294967295;
        this._h1 = this._h1 + b & 4294967295;
        this._h2 = this._h2 + c3 & 4294967295;
        this._h3 = this._h3 + d2 & 4294967295;
        this._h4 = this._h4 + e3 & 4294967295;
      }
    };
    exports.StringSHA1 = StringSHA1;
    StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
});

// node_modules/vscode-diff/dist/vs/base/common/diff/diffChange.js
var require_diffChange = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/diff/diffChange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiffChange = void 0;
    var DiffChange = class {
      /**
       * Constructs a new DiffChange with the given sequence information
       * and content.
       */
      constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
      }
      /**
       * The end point (exclusive) of the change in the original sequence.
       */
      getOriginalEnd() {
        return this.originalStart + this.originalLength;
      }
      /**
       * The end point (exclusive) of the change in the modified sequence.
       */
      getModifiedEnd() {
        return this.modifiedStart + this.modifiedLength;
      }
    };
    exports.DiffChange = DiffChange;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/diff/diff.js
var require_diff = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/diff/diff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LcsDiff = exports.stringDiff = exports.StringDiffSequence = void 0;
    var hash_1 = require_hash();
    var diffChange_1 = require_diffChange();
    var StringDiffSequence = class {
      constructor(source) {
        this.source = source;
      }
      getElements() {
        const source = this.source;
        const characters = new Int32Array(source.length);
        for (let i4 = 0, len = source.length; i4 < len; i4++) {
          characters[i4] = source.charCodeAt(i4);
        }
        return characters;
      }
    };
    exports.StringDiffSequence = StringDiffSequence;
    function stringDiff(original, modified, pretty) {
      return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
    }
    exports.stringDiff = stringDiff;
    var Debug = class {
      static Assert(condition, message) {
        if (!condition) {
          throw new Error(message);
        }
      }
    };
    var MyArray = class {
      /**
       * Copies a range of elements from an Array starting at the specified source index and pastes
       * them to another Array starting at the specified destination index. The length and the indexes
       * are specified as 64-bit integers.
       * sourceArray:
       *		The Array that contains the data to copy.
       * sourceIndex:
       *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
       * destinationArray:
       *		The Array that receives the data.
       * destinationIndex:
       *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
       * length:
       *		A 64-bit integer that represents the number of elements to copy.
       */
      static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i4 = 0; i4 < length; i4++) {
          destinationArray[destinationIndex + i4] = sourceArray[sourceIndex + i4];
        }
      }
      static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i4 = 0; i4 < length; i4++) {
          destinationArray[destinationIndex + i4] = sourceArray[sourceIndex + i4];
        }
      }
    };
    var DiffChangeHelper = class {
      /**
       * Constructs a new DiffChangeHelper for the given DiffSequences.
       */
      constructor() {
        this.m_changes = [];
        this.m_originalStart = 1073741824;
        this.m_modifiedStart = 1073741824;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
      }
      /**
       * Marks the beginning of the next change in the set of differences.
       */
      MarkNextChange() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824;
        this.m_modifiedStart = 1073741824;
      }
      /**
       * Adds the original element at the given position to the elements
       * affected by the current change. The modified index gives context
       * to the change position with respect to the original sequence.
       * @param originalIndex The index of the original element to add.
       * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
       */
      AddOriginalElement(originalIndex, modifiedIndex) {
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
      }
      /**
       * Adds the modified element at the given position to the elements
       * affected by the current change. The original index gives context
       * to the change position with respect to the modified sequence.
       * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
       * @param modifiedIndex The index of the modified element to add.
       */
      AddModifiedElement(originalIndex, modifiedIndex) {
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
      }
      /**
       * Retrieves all of the changes marked by the class.
       */
      getChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.MarkNextChange();
        }
        return this.m_changes;
      }
      /**
       * Retrieves all of the changes marked by the class in the reverse order
       */
      getReverseChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
      }
    };
    var LcsDiff = class _LcsDiff {
      /**
       * Constructs the DiffFinder
       */
      constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        this._originalSequence = originalSequence;
        this._modifiedSequence = modifiedSequence;
        const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
        this._hasStrings = originalHasStrings && modifiedHasStrings;
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
      }
      static _isStringArray(arr) {
        return arr.length > 0 && typeof arr[0] === "string";
      }
      static _getElements(sequence) {
        const elements = sequence.getElements();
        if (_LcsDiff._isStringArray(elements)) {
          const hashes = new Int32Array(elements.length);
          for (let i4 = 0, len = elements.length; i4 < len; i4++) {
            hashes[i4] = (0, hash_1.stringHash)(elements[i4], 0);
          }
          return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
          return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
      }
      ElementsAreEqual(originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
          return false;
        }
        return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
      }
      ElementsAreStrictEqual(originalIndex, newIndex) {
        if (!this.ElementsAreEqual(originalIndex, newIndex)) {
          return false;
        }
        const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
        const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
        return originalElement === modifiedElement;
      }
      static _getStrictElement(sequence, index) {
        if (typeof sequence.getStrictElement === "function") {
          return sequence.getStrictElement(index);
        }
        return null;
      }
      OriginalElementsAreEqual(index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
          return false;
        }
        return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
      }
      ModifiedElementsAreEqual(index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
          return false;
        }
        return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
      }
      ComputeDiff(pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
      }
      /**
       * Computes the differences between the original and modified input
       * sequences on the bounded range.
       * @returns An array of the differences between the two input sequences.
       */
      _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        const quitEarlyArr = [false];
        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
          changes = this.PrettifyChanges(changes);
        }
        return {
          quitEarly: quitEarlyArr[0],
          changes
        };
      }
      /**
       * Private helper method which computes the differences on the bounded range
       * recursively.
       * @returns An array of the differences between the two input sequences.
       */
      ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
          originalStart++;
          modifiedStart++;
        }
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
          originalEnd--;
          modifiedEnd--;
        }
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
          let changes;
          if (modifiedStart <= modifiedEnd) {
            Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
            changes = [
              new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          } else if (originalStart <= originalEnd) {
            Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
            changes = [
              new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
            ];
          } else {
            Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
            Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
            changes = [];
          }
          return changes;
        }
        const midOriginalArr = [0];
        const midModifiedArr = [0];
        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        const midOriginal = midOriginalArr[0];
        const midModified = midModifiedArr[0];
        if (result !== null) {
          return result;
        } else if (!quitEarlyArr[0]) {
          const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
          let rightChanges = [];
          if (!quitEarlyArr[0]) {
            rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
          } else {
            rightChanges = [
              new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
            ];
          }
          return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        return [
          new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
      }
      WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        let forwardChanges = null;
        let reverseChanges = null;
        let changeHelper = new DiffChangeHelper();
        let diagonalMin = diagonalForwardStart;
        let diagonalMax = diagonalForwardEnd;
        let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
        let lastOriginalIndex = -1073741824;
        let historyIndex = this.m_forwardHistory.length - 1;
        do {
          const diagonal = diagonalRelative + diagonalForwardBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
            if (originalIndex < lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
            diagonalRelative = diagonal + 1 - diagonalForwardBase;
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
            if (originalIndex < lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex - 1;
            changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalForwardBase;
          }
          if (historyIndex >= 0) {
            forwardPoints = this.m_forwardHistory[historyIndex];
            diagonalForwardBase = forwardPoints[0];
            diagonalMin = 1;
            diagonalMax = forwardPoints.length - 1;
          }
        } while (--historyIndex >= -1);
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
          let originalStartPoint = midOriginalArr[0] + 1;
          let modifiedStartPoint = midModifiedArr[0] + 1;
          if (forwardChanges !== null && forwardChanges.length > 0) {
            const lastForwardChange = forwardChanges[forwardChanges.length - 1];
            originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
            modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
          }
          reverseChanges = [
            new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
          ];
        } else {
          changeHelper = new DiffChangeHelper();
          diagonalMin = diagonalReverseStart;
          diagonalMax = diagonalReverseEnd;
          diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
          lastOriginalIndex = 1073741824;
          historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
          do {
            const diagonal = diagonalRelative + diagonalReverseBase;
            if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
              originalIndex = reversePoints[diagonal + 1] - 1;
              modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
              if (originalIndex > lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex + 1;
              changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
              diagonalRelative = diagonal + 1 - diagonalReverseBase;
            } else {
              originalIndex = reversePoints[diagonal - 1];
              modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
              if (originalIndex > lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex;
              changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
              diagonalRelative = diagonal - 1 - diagonalReverseBase;
            }
            if (historyIndex >= 0) {
              reversePoints = this.m_reverseHistory[historyIndex];
              diagonalReverseBase = reversePoints[0];
              diagonalMin = 1;
              diagonalMax = reversePoints.length - 1;
            }
          } while (--historyIndex >= -1);
          reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
      }
      /**
       * Given the range to compute the diff on, this method finds the point:
       * (midOriginal, midModified)
       * that exists in the middle of the LCS of the two sequences and
       * is the point at which the LCS problem may be broken down recursively.
       * This method will try to keep the LCS trace in memory. If the LCS recursion
       * point is calculated and the full trace is available in memory, then this method
       * will return the change list.
       * @param originalStart The start bound of the original sequence range
       * @param originalEnd The end bound of the original sequence range
       * @param modifiedStart The start bound of the modified sequence range
       * @param modifiedEnd The end bound of the modified sequence range
       * @param midOriginal The middle point of the original sequence range
       * @param midModified The middle point of the modified sequence range
       * @returns The diff changes, if available, otherwise null
       */
      ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        let originalIndex = 0, modifiedIndex = 0;
        let diagonalForwardStart = 0, diagonalForwardEnd = 0;
        let diagonalReverseStart = 0, diagonalReverseEnd = 0;
        originalStart--;
        modifiedStart--;
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
        const numDiagonals = maxDifferences + 1;
        const forwardPoints = new Int32Array(numDiagonals);
        const reversePoints = new Int32Array(numDiagonals);
        const diagonalForwardBase = modifiedEnd - modifiedStart;
        const diagonalReverseBase = originalEnd - originalStart;
        const diagonalForwardOffset = originalStart - modifiedStart;
        const diagonalReverseOffset = originalEnd - modifiedEnd;
        const delta = diagonalReverseBase - diagonalForwardBase;
        const deltaIsEven = delta % 2 === 0;
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        quitEarlyArr[0] = false;
        for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
          let furthestOriginalIndex = 0;
          let furthestModifiedIndex = 0;
          diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
          diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
          for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
            if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
              originalIndex = forwardPoints[diagonal + 1];
            } else {
              originalIndex = forwardPoints[diagonal - 1] + 1;
            }
            modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
            const tempOriginalIndex = originalIndex;
            while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
              originalIndex++;
              modifiedIndex++;
            }
            forwardPoints[diagonal] = originalIndex;
            if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
              furthestOriginalIndex = originalIndex;
              furthestModifiedIndex = modifiedIndex;
            }
            if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
              if (originalIndex >= reversePoints[diagonal]) {
                midOriginalArr[0] = originalIndex;
                midModifiedArr[0] = modifiedIndex;
                if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                  return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                } else {
                  return null;
                }
              }
            }
          }
          const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
          if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
            quitEarlyArr[0] = true;
            midOriginalArr[0] = furthestOriginalIndex;
            midModifiedArr[0] = furthestModifiedIndex;
            if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              originalStart++;
              modifiedStart++;
              return [
                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
              ];
            }
          }
          diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
          diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
          for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
            if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
              originalIndex = reversePoints[diagonal + 1] - 1;
            } else {
              originalIndex = reversePoints[diagonal - 1];
            }
            modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
            const tempOriginalIndex = originalIndex;
            while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
              originalIndex--;
              modifiedIndex--;
            }
            reversePoints[diagonal] = originalIndex;
            if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
              if (originalIndex <= forwardPoints[diagonal]) {
                midOriginalArr[0] = originalIndex;
                midModifiedArr[0] = modifiedIndex;
                if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                  return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                } else {
                  return null;
                }
              }
            }
          }
          if (numDifferences <= 1447) {
            let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
            temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
            MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
            this.m_forwardHistory.push(temp);
            temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
            temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
            MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
            this.m_reverseHistory.push(temp);
          }
        }
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
      }
      /**
       * Shifts the given changes to provide a more intuitive diff.
       * While the first element in a diff matches the first element after the diff,
       * we shift the diff down.
       *
       * @param changes The list of changes to shift
       * @returns The shifted changes
       */
      PrettifyChanges(changes) {
        for (let i4 = 0; i4 < changes.length; i4++) {
          const change = changes[i4];
          const originalStop = i4 < changes.length - 1 ? changes[i4 + 1].originalStart : this._originalElementsOrHash.length;
          const modifiedStop = i4 < changes.length - 1 ? changes[i4 + 1].modifiedStart : this._modifiedElementsOrHash.length;
          const checkOriginal = change.originalLength > 0;
          const checkModified = change.modifiedLength > 0;
          while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
            const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
            const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
            if (endStrictEqual && !startStrictEqual) {
              break;
            }
            change.originalStart++;
            change.modifiedStart++;
          }
          const mergedChangeArr = [null];
          if (i4 < changes.length - 1 && this.ChangesOverlap(changes[i4], changes[i4 + 1], mergedChangeArr)) {
            changes[i4] = mergedChangeArr[0];
            changes.splice(i4 + 1, 1);
            i4--;
            continue;
          }
        }
        for (let i4 = changes.length - 1; i4 >= 0; i4--) {
          const change = changes[i4];
          let originalStop = 0;
          let modifiedStop = 0;
          if (i4 > 0) {
            const prevChange = changes[i4 - 1];
            originalStop = prevChange.originalStart + prevChange.originalLength;
            modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
          }
          const checkOriginal = change.originalLength > 0;
          const checkModified = change.modifiedLength > 0;
          let bestDelta = 0;
          let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
          for (let delta = 1; ; delta++) {
            const originalStart = change.originalStart - delta;
            const modifiedStart = change.modifiedStart - delta;
            if (originalStart < originalStop || modifiedStart < modifiedStop) {
              break;
            }
            if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
              break;
            }
            if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
              break;
            }
            const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
            const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
            if (score > bestScore) {
              bestScore = score;
              bestDelta = delta;
            }
          }
          change.originalStart -= bestDelta;
          change.modifiedStart -= bestDelta;
          const mergedChangeArr = [null];
          if (i4 > 0 && this.ChangesOverlap(changes[i4 - 1], changes[i4], mergedChangeArr)) {
            changes[i4 - 1] = mergedChangeArr[0];
            changes.splice(i4, 1);
            i4++;
            continue;
          }
        }
        if (this._hasStrings) {
          for (let i4 = 1, len = changes.length; i4 < len; i4++) {
            const aChange = changes[i4 - 1];
            const bChange = changes[i4];
            const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
            const aOriginalStart = aChange.originalStart;
            const bOriginalEnd = bChange.originalStart + bChange.originalLength;
            const abOriginalLength = bOriginalEnd - aOriginalStart;
            const aModifiedStart = aChange.modifiedStart;
            const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
            const abModifiedLength = bModifiedEnd - aModifiedStart;
            if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
              const t3 = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
              if (t3) {
                const [originalMatchStart, modifiedMatchStart] = t3;
                if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                  aChange.originalLength = originalMatchStart - aChange.originalStart;
                  aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                  bChange.originalStart = originalMatchStart + matchedLength;
                  bChange.modifiedStart = modifiedMatchStart + matchedLength;
                  bChange.originalLength = bOriginalEnd - bChange.originalStart;
                  bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                }
              }
            }
          }
        }
        return changes;
      }
      _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
        if (originalLength < desiredLength || modifiedLength < desiredLength) {
          return null;
        }
        const originalMax = originalStart + originalLength - desiredLength + 1;
        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
        let bestScore = 0;
        let bestOriginalStart = 0;
        let bestModifiedStart = 0;
        for (let i4 = originalStart; i4 < originalMax; i4++) {
          for (let j3 = modifiedStart; j3 < modifiedMax; j3++) {
            const score = this._contiguousSequenceScore(i4, j3, desiredLength);
            if (score > 0 && score > bestScore) {
              bestScore = score;
              bestOriginalStart = i4;
              bestModifiedStart = j3;
            }
          }
        }
        if (bestScore > 0) {
          return [bestOriginalStart, bestModifiedStart];
        }
        return null;
      }
      _contiguousSequenceScore(originalStart, modifiedStart, length) {
        let score = 0;
        for (let l3 = 0; l3 < length; l3++) {
          if (!this.ElementsAreEqual(originalStart + l3, modifiedStart + l3)) {
            return 0;
          }
          score += this._originalStringElements[originalStart + l3].length;
        }
        return score;
      }
      _OriginalIsBoundary(index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
          return true;
        }
        return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
      }
      _OriginalRegionIsBoundary(originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
          return true;
        }
        if (originalLength > 0) {
          const originalEnd = originalStart + originalLength;
          if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
            return true;
          }
        }
        return false;
      }
      _ModifiedIsBoundary(index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
          return true;
        }
        return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
      }
      _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
          return true;
        }
        if (modifiedLength > 0) {
          const modifiedEnd = modifiedStart + modifiedLength;
          if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
            return true;
          }
        }
        return false;
      }
      _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
        const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
        const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
        return originalScore + modifiedScore;
      }
      /**
       * Concatenates the two input DiffChange lists and returns the resulting
       * list.
       * @param The left changes
       * @param The right changes
       * @returns The concatenated list
       */
      ConcatenateChanges(left, right) {
        const mergedChangeArr = [];
        if (left.length === 0 || right.length === 0) {
          return right.length > 0 ? right : left;
        } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
          const result = new Array(left.length + right.length - 1);
          MyArray.Copy(left, 0, result, 0, left.length - 1);
          result[left.length - 1] = mergedChangeArr[0];
          MyArray.Copy(right, 1, result, left.length, right.length - 1);
          return result;
        } else {
          const result = new Array(left.length + right.length);
          MyArray.Copy(left, 0, result, 0, left.length);
          MyArray.Copy(right, 0, result, left.length, right.length);
          return result;
        }
      }
      /**
       * Returns true if the two changes overlap and can be merged into a single
       * change
       * @param left The left change
       * @param right The right change
       * @param mergedChange The merged change if the two overlap, null otherwise
       * @returns True if the two changes overlap
       */
      ChangesOverlap(left, right, mergedChangeArr) {
        Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
        Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          const originalStart = left.originalStart;
          let originalLength = left.originalLength;
          const modifiedStart = left.modifiedStart;
          let modifiedLength = left.modifiedLength;
          if (left.originalStart + left.originalLength >= right.originalStart) {
            originalLength = right.originalStart + right.originalLength - left.originalStart;
          }
          if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
          }
          mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
          return true;
        } else {
          mergedChangeArr[0] = null;
          return false;
        }
      }
      /**
       * Helper method used to clip a diagonal index to the range of valid
       * diagonals. This also decides whether or not the diagonal index,
       * if it exceeds the boundary, should be clipped to the boundary or clipped
       * one inside the boundary depending on the Even/Odd status of the boundary
       * and numDifferences.
       * @param diagonal The index of the diagonal to clip.
       * @param numDifferences The current number of differences being iterated upon.
       * @param diagonalBaseIndex The base reference diagonal.
       * @param numDiagonals The total number of diagonals.
       * @returns The clipped diagonal index.
       */
      ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
          return diagonal;
        }
        const diagonalsBelow = diagonalBaseIndex;
        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        const diffEven = numDifferences % 2 === 0;
        if (diagonal < 0) {
          const lowerBoundEven = diagonalsBelow % 2 === 0;
          return diffEven === lowerBoundEven ? 0 : 1;
        } else {
          const upperBoundEven = diagonalsAbove % 2 === 0;
          return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
        }
      }
    };
    exports.LcsDiff = LcsDiff;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/assert.js
var require_assert = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkAdjacentItems = exports.assertFn = void 0;
    var errors_1 = require_errors();
    function assertFn(condition) {
      if (!condition()) {
        debugger;
        condition();
        (0, errors_1.onUnexpectedError)(new errors_1.BugIndicatingError("Assertion Failed"));
      }
    }
    exports.assertFn = assertFn;
    function checkAdjacentItems(items, predicate) {
      let i4 = 0;
      while (i4 < items.length - 1) {
        const a3 = items[i4];
        const b = items[i4 + 1];
        if (!predicate(a3, b)) {
          return false;
        }
        i4++;
      }
      return true;
    }
    exports.checkAdjacentItems = checkAdjacentItems;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/legacyLinesDiffComputer.js
var require_legacyLinesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/legacyLinesDiffComputer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiffComputer = exports.LegacyLinesDiffComputer = void 0;
    var assert_1 = require_assert();
    var diff_1 = require_diff();
    var strings = require_strings();
    var lineRange_1 = require_lineRange();
    var range_1 = require_range();
    var linesDiffComputer_1 = require_linesDiffComputer();
    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
    var LegacyLinesDiffComputer = class {
      computeDiff(originalLines, modifiedLines, options) {
        const diffComputer = new DiffComputer(originalLines, modifiedLines, {
          maxComputationTime: options.maxComputationTimeMs,
          shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
          shouldComputeCharChanges: true,
          shouldMakePrettyDiff: true,
          shouldPostProcessCharChanges: true
        });
        const result = diffComputer.computeDiff();
        const changes = [];
        let lastChange = null;
        for (const c3 of result.changes) {
          let originalRange;
          if (c3.originalEndLineNumber === 0) {
            originalRange = new lineRange_1.LineRange(c3.originalStartLineNumber + 1, c3.originalStartLineNumber + 1);
          } else {
            originalRange = new lineRange_1.LineRange(c3.originalStartLineNumber, c3.originalEndLineNumber + 1);
          }
          let modifiedRange;
          if (c3.modifiedEndLineNumber === 0) {
            modifiedRange = new lineRange_1.LineRange(c3.modifiedStartLineNumber + 1, c3.modifiedStartLineNumber + 1);
          } else {
            modifiedRange = new lineRange_1.LineRange(c3.modifiedStartLineNumber, c3.modifiedEndLineNumber + 1);
          }
          let change = new linesDiffComputer_1.LineRangeMapping(originalRange, modifiedRange, c3.charChanges?.map((c4) => new linesDiffComputer_1.RangeMapping(new range_1.Range(c4.originalStartLineNumber, c4.originalStartColumn, c4.originalEndLineNumber, c4.originalEndColumn), new range_1.Range(c4.modifiedStartLineNumber, c4.modifiedStartColumn, c4.modifiedEndLineNumber, c4.modifiedEndColumn))));
          if (lastChange) {
            if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {
              change = new linesDiffComputer_1.LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
              changes.pop();
            }
          }
          changes.push(change);
          lastChange = change;
        }
        (0, assert_1.assertFn)(() => {
          return (0, assert_1.checkAdjacentItems)(changes, (m1, m22) => m22.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m22.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
          m1.originalRange.endLineNumberExclusive < m22.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m22.modifiedRange.startLineNumber);
        });
        return new linesDiffComputer_1.LinesDiff(changes, [], result.quitEarly);
      }
    };
    exports.LegacyLinesDiffComputer = LegacyLinesDiffComputer;
    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
      const diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
      return diffAlgo.ComputeDiff(pretty);
    }
    var LineSequence = class {
      constructor(lines) {
        const startColumns = [];
        const endColumns = [];
        for (let i4 = 0, length = lines.length; i4 < length; i4++) {
          startColumns[i4] = getFirstNonBlankColumn(lines[i4], 1);
          endColumns[i4] = getLastNonBlankColumn(lines[i4], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
      }
      getElements() {
        const elements = [];
        for (let i4 = 0, len = this.lines.length; i4 < len; i4++) {
          elements[i4] = this.lines[i4].substring(this._startColumns[i4] - 1, this._endColumns[i4] - 1);
        }
        return elements;
      }
      getStrictElement(index) {
        return this.lines[index];
      }
      getStartLineNumber(i4) {
        return i4 + 1;
      }
      getEndLineNumber(i4) {
        return i4 + 1;
      }
      createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        const charCodes = [];
        const lineNumbers = [];
        const columns = [];
        let len = 0;
        for (let index = startIndex; index <= endIndex; index++) {
          const lineContent = this.lines[index];
          const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
          const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
          for (let col = startColumn; col < endColumn; col++) {
            charCodes[len] = lineContent.charCodeAt(col - 1);
            lineNumbers[len] = index + 1;
            columns[len] = col;
            len++;
          }
          if (!shouldIgnoreTrimWhitespace && index < endIndex) {
            charCodes[len] = 10;
            lineNumbers[len] = index + 1;
            columns[len] = lineContent.length + 1;
            len++;
          }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
      }
    };
    var CharSequence = class {
      constructor(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
      }
      toString() {
        return "[" + this._charCodes.map((s3, idx) => (s3 === 10 ? "\\n" : String.fromCharCode(s3)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
      }
      _assertIndex(index, arr) {
        if (index < 0 || index >= arr.length) {
          throw new Error(`Illegal index`);
        }
      }
      getElements() {
        return this._charCodes;
      }
      getStartLineNumber(i4) {
        if (i4 > 0 && i4 === this._lineNumbers.length) {
          return this.getEndLineNumber(i4 - 1);
        }
        this._assertIndex(i4, this._lineNumbers);
        return this._lineNumbers[i4];
      }
      getEndLineNumber(i4) {
        if (i4 === -1) {
          return this.getStartLineNumber(i4 + 1);
        }
        this._assertIndex(i4, this._lineNumbers);
        if (this._charCodes[i4] === 10) {
          return this._lineNumbers[i4] + 1;
        }
        return this._lineNumbers[i4];
      }
      getStartColumn(i4) {
        if (i4 > 0 && i4 === this._columns.length) {
          return this.getEndColumn(i4 - 1);
        }
        this._assertIndex(i4, this._columns);
        return this._columns[i4];
      }
      getEndColumn(i4) {
        if (i4 === -1) {
          return this.getStartColumn(i4 + 1);
        }
        this._assertIndex(i4, this._columns);
        if (this._charCodes[i4] === 10) {
          return 1;
        }
        return this._columns[i4] + 1;
      }
    };
    var CharChange = class _CharChange {
      constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
      }
      static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
      }
    };
    function postProcessCharChanges(rawChanges) {
      if (rawChanges.length <= 1) {
        return rawChanges;
      }
      const result = [rawChanges[0]];
      let prevChange = result[0];
      for (let i4 = 1, len = rawChanges.length; i4 < len; i4++) {
        const currChange = rawChanges[i4];
        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
          prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
          prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
        } else {
          result.push(currChange);
          prevChange = currChange;
        }
      }
      return result;
    }
    var LineChange = class _LineChange {
      constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
      }
      static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let charChanges = void 0;
        if (diffChange.originalLength === 0) {
          originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
          originalEndLineNumber = 0;
        } else {
          originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
          originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
          modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
          modifiedEndLineNumber = 0;
        } else {
          modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
          modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
          const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
          const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
          if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
              rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i4 = 0, length = rawChanges.length; i4 < length; i4++) {
              charChanges.push(CharChange.createFromDiffChange(rawChanges[i4], originalCharSequence, modifiedCharSequence));
            }
          }
        }
        return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
      }
    };
    var DiffComputer = class {
      constructor(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
      }
      computeDiff() {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            return {
              quitEarly: false,
              changes: []
            };
          }
          return {
            quitEarly: false,
            changes: [{
              originalStartLineNumber: 1,
              originalEndLineNumber: 1,
              modifiedStartLineNumber: 1,
              modifiedEndLineNumber: this.modified.lines.length,
              charChanges: void 0
            }]
          };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: [{
              originalStartLineNumber: 1,
              originalEndLineNumber: this.original.lines.length,
              modifiedStartLineNumber: 1,
              modifiedEndLineNumber: 1,
              charChanges: void 0
            }]
          };
        }
        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        const rawChanges = diffResult.changes;
        const quitEarly = diffResult.quitEarly;
        if (this.shouldIgnoreTrimWhitespace) {
          const lineChanges = [];
          for (let i4 = 0, length = rawChanges.length; i4 < length; i4++) {
            lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i4], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          }
          return {
            quitEarly,
            changes: lineChanges
          };
        }
        const result = [];
        let originalLineIndex = 0;
        let modifiedLineIndex = 0;
        for (let i4 = -1, len = rawChanges.length; i4 < len; i4++) {
          const nextChange = i4 + 1 < len ? rawChanges[i4 + 1] : null;
          const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
          const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
          while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
            const originalLine = this.originalLines[originalLineIndex];
            const modifiedLine = this.modifiedLines[modifiedLineIndex];
            if (originalLine !== modifiedLine) {
              {
                let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                  const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                  const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                  if (originalChar !== modifiedChar) {
                    break;
                  }
                  originalStartColumn--;
                  modifiedStartColumn--;
                }
                if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                  this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                }
              }
              {
                let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                const originalMaxColumn = originalLine.length + 1;
                const modifiedMaxColumn = modifiedLine.length + 1;
                while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                  const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                  const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                  if (originalChar !== modifiedChar) {
                    break;
                  }
                  originalEndColumn++;
                  modifiedEndColumn++;
                }
                if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                  this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                }
              }
            }
            originalLineIndex++;
            modifiedLineIndex++;
          }
          if (nextChange) {
            result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            originalLineIndex += nextChange.originalLength;
            modifiedLineIndex += nextChange.modifiedLength;
          }
        }
        return {
          quitEarly,
          changes: result
        };
      }
      _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
          return;
        }
        let charChanges = void 0;
        if (this.shouldComputeCharChanges) {
          charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
      }
      _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        const len = result.length;
        if (len === 0) {
          return false;
        }
        const prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
          return false;
        }
        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
          if (this.shouldComputeCharChanges && prevChange.charChanges) {
            prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
          }
          return true;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
          prevChange.originalEndLineNumber = originalLineNumber;
          prevChange.modifiedEndLineNumber = modifiedLineNumber;
          if (this.shouldComputeCharChanges && prevChange.charChanges) {
            prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
          }
          return true;
        }
        return false;
      }
    };
    exports.DiffComputer = DiffComputer;
    function getFirstNonBlankColumn(txt, defaultValue) {
      const r3 = strings.firstNonWhitespaceIndex(txt);
      if (r3 === -1) {
        return defaultValue;
      }
      return r3 + 1;
    }
    function getLastNonBlankColumn(txt, defaultValue) {
      const r3 = strings.lastNonWhitespaceIndex(txt);
      if (r3 === -1) {
        return defaultValue;
      }
      return r3 + 2;
    }
    function createContinueProcessingPredicate(maximumRuntime) {
      if (maximumRuntime === 0) {
        return () => true;
      }
      const startTime = Date.now();
      return () => {
        return Date.now() - startTime < maximumRuntime;
      };
    }
  }
});

// node_modules/vscode-diff/dist/vs/base/common/arrays.js
var require_arrays = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallbackIterable = exports.reverseOrder = exports.numberComparator = exports.compareBy = exports.CompareResult = exports.findLastIndex = exports.equals = void 0;
    function equals(one, other, itemEquals = (a3, b) => a3 === b) {
      if (one === other) {
        return true;
      }
      if (!one || !other) {
        return false;
      }
      if (one.length !== other.length) {
        return false;
      }
      for (let i4 = 0, len = one.length; i4 < len; i4++) {
        if (!itemEquals(one[i4], other[i4])) {
          return false;
        }
      }
      return true;
    }
    exports.equals = equals;
    function findLastIndex(array, fn) {
      for (let i4 = array.length - 1; i4 >= 0; i4--) {
        const element = array[i4];
        if (fn(element)) {
          return i4;
        }
      }
      return -1;
    }
    exports.findLastIndex = findLastIndex;
    var CompareResult;
    (function(CompareResult2) {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult2.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult2.isGreaterThan = isGreaterThan;
    })(CompareResult || (exports.CompareResult = CompareResult = {}));
    function compareBy(selector, comparator) {
      return (a3, b) => comparator(selector(a3), selector(b));
    }
    exports.compareBy = compareBy;
    var numberComparator = (a3, b) => a3 - b;
    exports.numberComparator = numberComparator;
    function reverseOrder(comparator) {
      return (a3, b) => -comparator(a3, b);
    }
    exports.reverseOrder = reverseOrder;
    var CallbackIterable = class _CallbackIterable {
      constructor(iterate) {
        this.iterate = iterate;
      }
      forEach(handler) {
        this.iterate((item) => {
          handler(item);
          return true;
        });
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      some(predicate) {
        let result = false;
        this.iterate((item) => {
          result = predicate(item);
          return !result;
        });
        return result;
      }
      findFirst(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
            return false;
          }
          return true;
        });
        return result;
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
    exports.CallbackIterable = CallbackIterable;
    CallbackIterable.empty = new CallbackIterable((_callback) => {
    });
  }
});

// node_modules/vscode-diff/dist/vs/base/common/collections.js
var require_collections = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetMap = void 0;
    var SetMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      add(key, value) {
        let values = this.map.get(key);
        if (!values) {
          values = /* @__PURE__ */ new Set();
          this.map.set(key, values);
        }
        values.add(value);
      }
      delete(key, value) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.delete(value);
        if (values.size === 0) {
          this.map.delete(key);
        }
      }
      forEach(key, fn) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.forEach(fn);
      }
      get(key) {
        const values = this.map.get(key);
        if (!values) {
          return /* @__PURE__ */ new Set();
        }
        return values;
      }
    };
    exports.SetMap = SetMap;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/diffAlgorithm.js
var require_diffAlgorithm = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/diffAlgorithm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTimeout = exports.InfiniteTimeout = exports.SequenceDiff = exports.DiffAlgorithmResult = void 0;
    var errors_1 = require_errors();
    var offsetRange_1 = require_offsetRange();
    var DiffAlgorithmResult = class _DiffAlgorithmResult {
      static trivial(seq1, seq2) {
        return new _DiffAlgorithmResult([new SequenceDiff(new offsetRange_1.OffsetRange(0, seq1.length), new offsetRange_1.OffsetRange(0, seq2.length))], false);
      }
      static trivialTimedOut(seq1, seq2) {
        return new _DiffAlgorithmResult([new SequenceDiff(new offsetRange_1.OffsetRange(0, seq1.length), new offsetRange_1.OffsetRange(0, seq2.length))], true);
      }
      constructor(diffs, hitTimeout) {
        this.diffs = diffs;
        this.hitTimeout = hitTimeout;
      }
    };
    exports.DiffAlgorithmResult = DiffAlgorithmResult;
    var SequenceDiff = class _SequenceDiff {
      constructor(seq1Range, seq2Range) {
        this.seq1Range = seq1Range;
        this.seq2Range = seq2Range;
      }
      reverse() {
        return new _SequenceDiff(this.seq2Range, this.seq1Range);
      }
      toString() {
        return `${this.seq1Range} <-> ${this.seq2Range}`;
      }
      join(other) {
        return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
      }
      delta(offset) {
        if (offset === 0) {
          return this;
        }
        return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
      }
    };
    exports.SequenceDiff = SequenceDiff;
    var InfiniteTimeout = class {
      isValid() {
        return true;
      }
    };
    exports.InfiniteTimeout = InfiniteTimeout;
    InfiniteTimeout.instance = new InfiniteTimeout();
    var DateTimeout = class {
      constructor(timeout) {
        this.timeout = timeout;
        this.startTime = Date.now();
        this.valid = true;
        if (timeout <= 0) {
          throw new errors_1.BugIndicatingError("timeout must be positive");
        }
      }
      // Recommendation: Set a log-point `{this.disable()}` in the body
      isValid() {
        const valid = Date.now() - this.startTime < this.timeout;
        if (!valid && this.valid) {
          this.valid = false;
          debugger;
        }
        return this.valid;
      }
      disable() {
        this.timeout = Number.MAX_SAFE_INTEGER;
        this.isValid = () => true;
        this.valid = true;
      }
    };
    exports.DateTimeout = DateTimeout;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/utils.js
var require_utils = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2D = void 0;
    var Array2D = class {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.array = [];
        this.array = new Array(width * height);
      }
      get(x3, y3) {
        return this.array[x3 + y3 * this.width];
      }
      set(x3, y3, value) {
        this.array[x3 + y3 * this.width] = value;
      }
    };
    exports.Array2D = Array2D;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js
var require_dynamicProgrammingDiffing = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DynamicProgrammingDiffing = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var utils_1 = require_utils();
    var DynamicProgrammingDiffing = class {
      compute(sequence1, sequence2, timeout = diffAlgorithm_1.InfiniteTimeout.instance, equalityScore) {
        if (sequence1.length === 0 || sequence2.length === 0) {
          return diffAlgorithm_1.DiffAlgorithmResult.trivial(sequence1, sequence2);
        }
        const lcsLengths = new utils_1.Array2D(sequence1.length, sequence2.length);
        const directions = new utils_1.Array2D(sequence1.length, sequence2.length);
        const lengths = new utils_1.Array2D(sequence1.length, sequence2.length);
        for (let s12 = 0; s12 < sequence1.length; s12++) {
          for (let s23 = 0; s23 < sequence2.length; s23++) {
            if (!timeout.isValid()) {
              return diffAlgorithm_1.DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
            }
            const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s23);
            const verticalLen = s23 === 0 ? 0 : lcsLengths.get(s12, s23 - 1);
            let extendedSeqScore;
            if (sequence1.getElement(s12) === sequence2.getElement(s23)) {
              if (s12 === 0 || s23 === 0) {
                extendedSeqScore = 0;
              } else {
                extendedSeqScore = lcsLengths.get(s12 - 1, s23 - 1);
              }
              if (s12 > 0 && s23 > 0 && directions.get(s12 - 1, s23 - 1) === 3) {
                extendedSeqScore += lengths.get(s12 - 1, s23 - 1);
              }
              extendedSeqScore += equalityScore ? equalityScore(s12, s23) : 1;
            } else {
              extendedSeqScore = -1;
            }
            const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
            if (newValue === extendedSeqScore) {
              const prevLen = s12 > 0 && s23 > 0 ? lengths.get(s12 - 1, s23 - 1) : 0;
              lengths.set(s12, s23, prevLen + 1);
              directions.set(s12, s23, 3);
            } else if (newValue === horizontalLen) {
              lengths.set(s12, s23, 0);
              directions.set(s12, s23, 1);
            } else if (newValue === verticalLen) {
              lengths.set(s12, s23, 0);
              directions.set(s12, s23, 2);
            }
            lcsLengths.set(s12, s23, newValue);
          }
        }
        const result = [];
        let lastAligningPosS1 = sequence1.length;
        let lastAligningPosS2 = sequence2.length;
        function reportDecreasingAligningPositions(s12, s23) {
          if (s12 + 1 !== lastAligningPosS1 || s23 + 1 !== lastAligningPosS2) {
            result.push(new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(s12 + 1, lastAligningPosS1), new offsetRange_1.OffsetRange(s23 + 1, lastAligningPosS2)));
          }
          lastAligningPosS1 = s12;
          lastAligningPosS2 = s23;
        }
        let s1 = sequence1.length - 1;
        let s22 = sequence2.length - 1;
        while (s1 >= 0 && s22 >= 0) {
          if (directions.get(s1, s22) === 3) {
            reportDecreasingAligningPositions(s1, s22);
            s1--;
            s22--;
          } else {
            if (directions.get(s1, s22) === 1) {
              s1--;
            } else {
              s22--;
            }
          }
        }
        reportDecreasingAligningPositions(-1, -1);
        result.reverse();
        return new diffAlgorithm_1.DiffAlgorithmResult(result, false);
      }
    };
    exports.DynamicProgrammingDiffing = DynamicProgrammingDiffing;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/joinSequenceDiffs.js
var require_joinSequenceDiffs = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/joinSequenceDiffs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shiftSequenceDiffs = exports.joinSequenceDiffs = exports.removeRandomMatches = exports.removeRandomLineMatches = exports.smoothenSequenceDiffs = exports.optimizeSequenceDiffs = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      let result = sequenceDiffs;
      result = joinSequenceDiffs(sequence1, sequence2, result);
      result = shiftSequenceDiffs(sequence1, sequence2, result);
      return result;
    }
    exports.optimizeSequenceDiffs = optimizeSequenceDiffs;
    function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      const result = [];
      for (const s3 of sequenceDiffs) {
        const last = result[result.length - 1];
        if (!last) {
          result.push(s3);
          continue;
        }
        if (s3.seq1Range.start - last.seq1Range.endExclusive <= 2 || s3.seq2Range.start - last.seq2Range.endExclusive <= 2) {
          result[result.length - 1] = new diffAlgorithm_1.SequenceDiff(last.seq1Range.join(s3.seq1Range), last.seq2Range.join(s3.seq2Range));
        } else {
          result.push(s3);
        }
      }
      return result;
    }
    exports.smoothenSequenceDiffs = smoothenSequenceDiffs;
    function removeRandomLineMatches(sequence1, _sequence2, sequenceDiffs) {
      let diffs = sequenceDiffs;
      if (diffs.length === 0) {
        return diffs;
      }
      let counter = 0;
      let shouldRepeat;
      do {
        shouldRepeat = false;
        const result = [
          diffs[0]
        ];
        for (let i4 = 1; i4 < diffs.length; i4++) {
          let shouldJoinDiffs = function(before, after) {
            const unchangedRange = new offsetRange_1.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
            const unchangedText = sequence1.getText(unchangedRange);
            const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
            if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
              return true;
            }
            return false;
          };
          const cur = diffs[i4];
          const lastResult = result[result.length - 1];
          const shouldJoin = shouldJoinDiffs(lastResult, cur);
          if (shouldJoin) {
            shouldRepeat = true;
            result[result.length - 1] = result[result.length - 1].join(cur);
          } else {
            result.push(cur);
          }
        }
        diffs = result;
      } while (counter++ < 10 && shouldRepeat);
      return diffs;
    }
    exports.removeRandomLineMatches = removeRandomLineMatches;
    function removeRandomMatches(sequence1, sequence2, sequenceDiffs) {
      let diffs = sequenceDiffs;
      if (diffs.length === 0) {
        return diffs;
      }
      let counter = 0;
      let shouldRepeat;
      do {
        shouldRepeat = false;
        const result = [
          diffs[0]
        ];
        for (let i4 = 1; i4 < diffs.length; i4++) {
          let shouldJoinDiffs = function(before, after) {
            const unchangedRange = new offsetRange_1.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
            const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
            if (unchangedLineCount > 5 || unchangedRange.length > 500) {
              return false;
            }
            const unchangedText = sequence1.getText(unchangedRange).trim();
            if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
              return false;
            }
            const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
            const beforeSeq1Length = before.seq1Range.length;
            const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
            const beforeSeq2Length = before.seq2Range.length;
            const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
            const afterSeq1Length = after.seq1Range.length;
            const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
            const afterSeq2Length = after.seq2Range.length;
            const max = 2 * 40 + 50;
            function cap(v3) {
              return Math.min(v3, max);
            }
            if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
              return true;
            }
            return false;
          };
          const cur = diffs[i4];
          const lastResult = result[result.length - 1];
          const shouldJoin = shouldJoinDiffs(lastResult, cur);
          if (shouldJoin) {
            shouldRepeat = true;
            result[result.length - 1] = result[result.length - 1].join(cur);
          } else {
            result.push(cur);
          }
        }
        diffs = result;
      } while (counter++ < 10 && shouldRepeat);
      for (let i4 = 0; i4 < diffs.length; i4++) {
        const cur = diffs[i4];
        let range1 = cur.seq1Range;
        let range2 = cur.seq2Range;
        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
        const prefix = sequence1.getText(new offsetRange_1.OffsetRange(fullRange1.start, cur.seq1Range.start));
        if (prefix.length > 0 && prefix.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100) {
          range1 = cur.seq1Range.deltaStart(-prefix.length);
          range2 = cur.seq2Range.deltaStart(-prefix.length);
        }
        const suffix = sequence1.getText(new offsetRange_1.OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
        if (suffix.length > 0 && (suffix.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 150)) {
          range1 = range1.deltaEnd(suffix.length);
          range2 = range2.deltaEnd(suffix.length);
        }
        diffs[i4] = new diffAlgorithm_1.SequenceDiff(range1, range2);
      }
      return diffs;
    }
    exports.removeRandomMatches = removeRandomMatches;
    function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      if (sequenceDiffs.length === 0) {
        return sequenceDiffs;
      }
      const result = [];
      result.push(sequenceDiffs[0]);
      for (let i4 = 1; i4 < sequenceDiffs.length; i4++) {
        const prevResult = result[result.length - 1];
        let cur = sequenceDiffs[i4];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
          const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
          let d2;
          for (d2 = 1; d2 <= length; d2++) {
            if (sequence1.getElement(cur.seq1Range.start - d2) !== sequence1.getElement(cur.seq1Range.endExclusive - d2) || sequence2.getElement(cur.seq2Range.start - d2) !== sequence2.getElement(cur.seq2Range.endExclusive - d2)) {
              break;
            }
          }
          d2--;
          if (d2 === length) {
            result[result.length - 1] = new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new offsetRange_1.OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
            continue;
          }
          cur = cur.delta(-d2);
        }
        result.push(cur);
      }
      const result2 = [];
      for (let i4 = 0; i4 < result.length - 1; i4++) {
        const nextResult = result[i4 + 1];
        let cur = result[i4];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
          const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
          let d2;
          for (d2 = 0; d2 < length; d2++) {
            if (sequence1.getElement(cur.seq1Range.start + d2) !== sequence1.getElement(cur.seq1Range.endExclusive + d2) || sequence2.getElement(cur.seq2Range.start + d2) !== sequence2.getElement(cur.seq2Range.endExclusive + d2)) {
              break;
            }
          }
          if (d2 === length) {
            result[i4 + 1] = new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new offsetRange_1.OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
            continue;
          }
          if (d2 > 0) {
            cur = cur.delta(d2);
          }
        }
        result2.push(cur);
      }
      if (result.length > 0) {
        result2.push(result[result.length - 1]);
      }
      return result2;
    }
    exports.joinSequenceDiffs = joinSequenceDiffs;
    function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
        return sequenceDiffs;
      }
      for (let i4 = 0; i4 < sequenceDiffs.length; i4++) {
        const prevDiff = i4 > 0 ? sequenceDiffs[i4 - 1] : void 0;
        const diff = sequenceDiffs[i4];
        const nextDiff = i4 + 1 < sequenceDiffs.length ? sequenceDiffs[i4 + 1] : void 0;
        const seq1ValidRange = new offsetRange_1.OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);
        const seq2ValidRange = new offsetRange_1.OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);
        if (diff.seq1Range.isEmpty) {
          sequenceDiffs[i4] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
        } else if (diff.seq2Range.isEmpty) {
          sequenceDiffs[i4] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();
        }
      }
      return sequenceDiffs;
    }
    exports.shiftSequenceDiffs = shiftSequenceDiffs;
    function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
      const maxShiftLimit = 100;
      let deltaBefore = 1;
      while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
        deltaBefore++;
      }
      deltaBefore--;
      let deltaAfter = 0;
      while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
        deltaAfter++;
      }
      if (deltaBefore === 0 && deltaAfter === 0) {
        return diff;
      }
      let bestDelta = 0;
      let bestScore = -1;
      for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
        const seq2OffsetStart = diff.seq2Range.start + delta;
        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
        const seq1Offset = diff.seq1Range.start + delta;
        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
        if (score > bestScore) {
          bestScore = score;
          bestDelta = delta;
        }
      }
      return diff.delta(bestDelta);
    }
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js
var require_myersDiffAlgorithm = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MyersDiffAlgorithm = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var MyersDiffAlgorithm = class {
      compute(seq1, seq2, timeout = diffAlgorithm_1.InfiniteTimeout.instance) {
        if (seq1.length === 0 || seq2.length === 0) {
          return diffAlgorithm_1.DiffAlgorithmResult.trivial(seq1, seq2);
        }
        function getXAfterSnake(x3, y3) {
          while (x3 < seq1.length && y3 < seq2.length && seq1.getElement(x3) === seq2.getElement(y3)) {
            x3++;
            y3++;
          }
          return x3;
        }
        let d2 = 0;
        const V2 = new FastInt32Array();
        V2.set(0, getXAfterSnake(0, 0));
        const paths = new FastArrayNegativeIndices();
        paths.set(0, V2.get(0) === 0 ? null : new SnakePath(null, 0, 0, V2.get(0)));
        let k4 = 0;
        loop: while (true) {
          d2++;
          if (!timeout.isValid()) {
            return diffAlgorithm_1.DiffAlgorithmResult.trivialTimedOut(seq1, seq2);
          }
          const lowerBound = -Math.min(d2, seq2.length + d2 % 2);
          const upperBound = Math.min(d2, seq1.length + d2 % 2);
          for (k4 = lowerBound; k4 <= upperBound; k4 += 2) {
            const maxXofDLineTop = k4 === upperBound ? -1 : V2.get(k4 + 1);
            const maxXofDLineLeft = k4 === lowerBound ? -1 : V2.get(k4 - 1) + 1;
            const x3 = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);
            const y3 = x3 - k4;
            if (x3 > seq1.length || y3 > seq2.length) {
              continue;
            }
            const newMaxX = getXAfterSnake(x3, y3);
            V2.set(k4, newMaxX);
            const lastPath = x3 === maxXofDLineTop ? paths.get(k4 + 1) : paths.get(k4 - 1);
            paths.set(k4, newMaxX !== x3 ? new SnakePath(lastPath, x3, y3, newMaxX - x3) : lastPath);
            if (V2.get(k4) === seq1.length && V2.get(k4) - k4 === seq2.length) {
              break loop;
            }
          }
        }
        let path = paths.get(k4);
        const result = [];
        let lastAligningPosS1 = seq1.length;
        let lastAligningPosS2 = seq2.length;
        while (true) {
          const endX = path ? path.x + path.length : 0;
          const endY = path ? path.y + path.length : 0;
          if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
            result.push(new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(endX, lastAligningPosS1), new offsetRange_1.OffsetRange(endY, lastAligningPosS2)));
          }
          if (!path) {
            break;
          }
          lastAligningPosS1 = path.x;
          lastAligningPosS2 = path.y;
          path = path.prev;
        }
        result.reverse();
        return new diffAlgorithm_1.DiffAlgorithmResult(result, false);
      }
    };
    exports.MyersDiffAlgorithm = MyersDiffAlgorithm;
    var SnakePath = class {
      constructor(prev, x3, y3, length) {
        this.prev = prev;
        this.x = x3;
        this.y = y3;
        this.length = length;
      }
    };
    var FastInt32Array = class {
      constructor() {
        this.positiveArr = new Int32Array(10);
        this.negativeArr = new Int32Array(10);
      }
      get(idx) {
        if (idx < 0) {
          idx = -idx - 1;
          return this.negativeArr[idx];
        } else {
          return this.positiveArr[idx];
        }
      }
      set(idx, value) {
        if (idx < 0) {
          idx = -idx - 1;
          if (idx >= this.negativeArr.length) {
            const arr = this.negativeArr;
            this.negativeArr = new Int32Array(arr.length * 2);
            this.negativeArr.set(arr);
          }
          this.negativeArr[idx] = value;
        } else {
          if (idx >= this.positiveArr.length) {
            const arr = this.positiveArr;
            this.positiveArr = new Int32Array(arr.length * 2);
            this.positiveArr.set(arr);
          }
          this.positiveArr[idx] = value;
        }
      }
    };
    var FastArrayNegativeIndices = class {
      constructor() {
        this.positiveArr = [];
        this.negativeArr = [];
      }
      get(idx) {
        if (idx < 0) {
          idx = -idx - 1;
          return this.negativeArr[idx];
        } else {
          return this.positiveArr[idx];
        }
      }
      set(idx, value) {
        if (idx < 0) {
          idx = -idx - 1;
          this.negativeArr[idx] = value;
        } else {
          this.positiveArr[idx] = value;
        }
      }
    };
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/advancedLinesDiffComputer.js
var require_advancedLinesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/advancedLinesDiffComputer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findFirstMonotonous = exports.findLastMonotonous = exports.LinesSliceCharSequence = exports.LineSequence = exports.getLineRangeMapping = exports.lineRangeMappingFromRangeMappings = exports.AdvancedLinesDiffComputer = void 0;
    var arrays_1 = require_arrays();
    var assert_1 = require_assert();
    var collections_1 = require_collections();
    var errors_1 = require_errors();
    var lineRange_1 = require_lineRange();
    var offsetRange_1 = require_offsetRange();
    var position_1 = require_position();
    var range_1 = require_range();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var dynamicProgrammingDiffing_1 = require_dynamicProgrammingDiffing();
    var joinSequenceDiffs_1 = require_joinSequenceDiffs();
    var myersDiffAlgorithm_1 = require_myersDiffAlgorithm();
    var linesDiffComputer_1 = require_linesDiffComputer();
    var AdvancedLinesDiffComputer = class {
      constructor() {
        this.dynamicProgrammingDiffing = new dynamicProgrammingDiffing_1.DynamicProgrammingDiffing();
        this.myersDiffingAlgorithm = new myersDiffAlgorithm_1.MyersDiffAlgorithm();
      }
      computeDiff(originalLines, modifiedLines, options) {
        if (originalLines.length <= 1 && (0, arrays_1.equals)(originalLines, modifiedLines, (a3, b) => a3 === b)) {
          return new linesDiffComputer_1.LinesDiff([], [], false);
        }
        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
          return new linesDiffComputer_1.LinesDiff([
            new linesDiffComputer_1.LineRangeMapping(new lineRange_1.LineRange(1, originalLines.length + 1), new lineRange_1.LineRange(1, modifiedLines.length + 1), [
              new linesDiffComputer_1.RangeMapping(new range_1.Range(1, 1, originalLines.length, originalLines[0].length + 1), new range_1.Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))
            ])
          ], [], false);
        }
        const timeout = options.maxComputationTimeMs === 0 ? diffAlgorithm_1.InfiniteTimeout.instance : new diffAlgorithm_1.DateTimeout(options.maxComputationTimeMs);
        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
        const perfectHashes = /* @__PURE__ */ new Map();
        function getOrCreateHash(text) {
          let hash = perfectHashes.get(text);
          if (hash === void 0) {
            hash = perfectHashes.size;
            perfectHashes.set(text, hash);
          }
          return hash;
        }
        const srcDocLines = originalLines.map((l3) => getOrCreateHash(l3.trim()));
        const tgtDocLines = modifiedLines.map((l3) => getOrCreateHash(l3.trim()));
        const sequence1 = new LineSequence(srcDocLines, originalLines);
        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);
        const lineAlignmentResult = (() => {
          if (sequence1.length + sequence2.length < 1700) {
            return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
          }
          return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
        })();
        let lineAlignments = lineAlignmentResult.diffs;
        let hitTimeout = lineAlignmentResult.hitTimeout;
        lineAlignments = (0, joinSequenceDiffs_1.optimizeSequenceDiffs)(sequence1, sequence2, lineAlignments);
        lineAlignments = (0, joinSequenceDiffs_1.removeRandomLineMatches)(sequence1, sequence2, lineAlignments);
        const alignments = [];
        const scanForWhitespaceChanges = (equalLinesCount) => {
          if (!considerWhitespaceChanges) {
            return;
          }
          for (let i4 = 0; i4 < equalLinesCount; i4++) {
            const seq1Offset = seq1LastStart + i4;
            const seq2Offset = seq2LastStart + i4;
            if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
              const characterDiffs = this.refineDiff(originalLines, modifiedLines, new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(seq1Offset, seq1Offset + 1), new offsetRange_1.OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
              for (const a3 of characterDiffs.mappings) {
                alignments.push(a3);
              }
              if (characterDiffs.hitTimeout) {
                hitTimeout = true;
              }
            }
          }
        };
        let seq1LastStart = 0;
        let seq2LastStart = 0;
        for (const diff of lineAlignments) {
          (0, assert_1.assertFn)(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
          const equalLinesCount = diff.seq1Range.start - seq1LastStart;
          scanForWhitespaceChanges(equalLinesCount);
          seq1LastStart = diff.seq1Range.endExclusive;
          seq2LastStart = diff.seq2Range.endExclusive;
          const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
          if (characterDiffs.hitTimeout) {
            hitTimeout = true;
          }
          for (const a3 of characterDiffs.mappings) {
            alignments.push(a3);
          }
        }
        scanForWhitespaceChanges(originalLines.length - seq1LastStart);
        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
        let moves = [];
        if (options.computeMoves) {
          moves = this.computeMoves(changes, originalLines, modifiedLines, srcDocLines, tgtDocLines, timeout, considerWhitespaceChanges);
        }
        (0, assert_1.assertFn)(() => {
          function validatePosition(pos, lines) {
            if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
              return false;
            }
            const line = lines[pos.lineNumber - 1];
            if (pos.column < 1 || pos.column > line.length + 1) {
              return false;
            }
            return true;
          }
          function validateRange(range, lines) {
            if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
              return false;
            }
            if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
              return false;
            }
            return true;
          }
          for (const c3 of changes) {
            if (!c3.innerChanges) {
              return false;
            }
            for (const ic of c3.innerChanges) {
              const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
              if (!valid) {
                return false;
              }
            }
            if (!validateRange(c3.modifiedRange, modifiedLines) || !validateRange(c3.originalRange, originalLines)) {
              return false;
            }
          }
          return true;
        });
        return new linesDiffComputer_1.LinesDiff(changes, moves, hitTimeout);
      }
      computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
        const moves = [];
        const deletions = changes.filter((c3) => c3.modifiedRange.isEmpty && c3.originalRange.length >= 3).map((d2) => new LineRangeFragment(d2.originalRange, originalLines, d2));
        const insertions = new Set(changes.filter((c3) => c3.originalRange.isEmpty && c3.modifiedRange.length >= 3).map((d2) => new LineRangeFragment(d2.modifiedRange, modifiedLines, d2)));
        const excludedChanges = /* @__PURE__ */ new Set();
        for (const deletion of deletions) {
          let highestSimilarity = -1;
          let best;
          for (const insertion of insertions) {
            const similarity = deletion.computeSimilarity(insertion);
            if (similarity > highestSimilarity) {
              highestSimilarity = similarity;
              best = insertion;
            }
          }
          if (highestSimilarity > 0.9 && best) {
            insertions.delete(best);
            moves.push(new linesDiffComputer_1.SimpleLineRangeMapping(deletion.range, best.range));
            excludedChanges.add(deletion.source);
            excludedChanges.add(best.source);
          }
          if (!timeout.isValid()) {
            return [];
          }
        }
        const original3LineHashes = new collections_1.SetMap();
        for (const change of changes) {
          if (excludedChanges.has(change)) {
            continue;
          }
          for (let i4 = change.originalRange.startLineNumber; i4 < change.originalRange.endLineNumberExclusive - 2; i4++) {
            const key = `${hashedOriginalLines[i4 - 1]}:${hashedOriginalLines[i4 + 1 - 1]}:${hashedOriginalLines[i4 + 2 - 1]}`;
            original3LineHashes.add(key, { range: new lineRange_1.LineRange(i4, i4 + 3) });
          }
        }
        const possibleMappings = [];
        changes.sort((0, arrays_1.compareBy)((c3) => c3.modifiedRange.startLineNumber, arrays_1.numberComparator));
        for (const change of changes) {
          if (excludedChanges.has(change)) {
            continue;
          }
          let lastMappings = [];
          for (let i4 = change.modifiedRange.startLineNumber; i4 < change.modifiedRange.endLineNumberExclusive - 2; i4++) {
            const key = `${hashedModifiedLines[i4 - 1]}:${hashedModifiedLines[i4 + 1 - 1]}:${hashedModifiedLines[i4 + 2 - 1]}`;
            const currentModifiedRange = new lineRange_1.LineRange(i4, i4 + 3);
            const nextMappings = [];
            original3LineHashes.forEach(key, ({ range }) => {
              for (const lastMapping of lastMappings) {
                if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
                  lastMapping.originalLineRange = new lineRange_1.LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
                  lastMapping.modifiedLineRange = new lineRange_1.LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
                  nextMappings.push(lastMapping);
                  return;
                }
              }
              const mapping = {
                modifiedLineRange: currentModifiedRange,
                originalLineRange: range
              };
              possibleMappings.push(mapping);
              nextMappings.push(mapping);
            });
            lastMappings = nextMappings;
          }
          if (!timeout.isValid()) {
            return [];
          }
        }
        possibleMappings.sort((0, arrays_1.reverseOrder)((0, arrays_1.compareBy)((m3) => m3.modifiedLineRange.length, arrays_1.numberComparator)));
        const modifiedSet = new LineRangeSet();
        const originalSet = new LineRangeSet();
        for (const mapping of possibleMappings) {
          const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
          const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
          const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).map((r3) => r3.delta(diffOrigToMod));
          const modifiedIntersectedSections = intersectRanges(modifiedSections, originalTranslatedSections);
          for (const s3 of modifiedIntersectedSections) {
            if (s3.length < 3) {
              continue;
            }
            const modifiedLineRange = s3;
            const originalLineRange = s3.delta(-diffOrigToMod);
            moves.push(new linesDiffComputer_1.SimpleLineRangeMapping(originalLineRange, modifiedLineRange));
            modifiedSet.addRange(modifiedLineRange);
            originalSet.addRange(originalLineRange);
          }
        }
        moves.sort((0, arrays_1.compareBy)((m3) => m3.original.startLineNumber, arrays_1.numberComparator));
        if (moves.length === 0) {
          return [];
        }
        let joinedMoves = [moves[0]];
        for (let i4 = 1; i4 < moves.length; i4++) {
          const last = joinedMoves[joinedMoves.length - 1];
          const current = moves[i4];
          const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
          const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
          const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
          if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
            joinedMoves[joinedMoves.length - 1] = last.join(current);
            continue;
          }
          const originalText = current.original.toOffsetRange().slice(originalLines).map((l3) => l3.trim()).join("\n");
          if (originalText.length <= 10) {
            continue;
          }
          joinedMoves.push(current);
        }
        const originalChanges = MonotonousFinder.createOfSorted(changes, (c3) => c3.originalRange.endLineNumberExclusive, arrays_1.numberComparator);
        joinedMoves = joinedMoves.filter((m3) => {
          const diffBeforeOriginalMove = originalChanges.findLastItemBeforeOrEqual(m3.original.startLineNumber) || new linesDiffComputer_1.LineRangeMapping(new lineRange_1.LineRange(1, 1), new lineRange_1.LineRange(1, 1), []);
          const modifiedDistToPrevDiff = m3.modified.startLineNumber - diffBeforeOriginalMove.modifiedRange.endLineNumberExclusive;
          const originalDistToPrevDiff = m3.original.startLineNumber - diffBeforeOriginalMove.originalRange.endLineNumberExclusive;
          const differentDistances = modifiedDistToPrevDiff !== originalDistToPrevDiff;
          return differentDistances;
        });
        const fullMoves = joinedMoves.map((m3) => {
          const moveChanges = this.refineDiff(originalLines, modifiedLines, new diffAlgorithm_1.SequenceDiff(m3.original.toOffsetRange(), m3.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
          const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
          return new linesDiffComputer_1.MovedText(m3, mappings);
        });
        return fullMoves;
      }
      refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
        const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
        let diffs = diffResult.diffs;
        diffs = (0, joinSequenceDiffs_1.optimizeSequenceDiffs)(slice1, slice2, diffs);
        diffs = coverFullWords(slice1, slice2, diffs);
        diffs = (0, joinSequenceDiffs_1.smoothenSequenceDiffs)(slice1, slice2, diffs);
        diffs = (0, joinSequenceDiffs_1.removeRandomMatches)(slice1, slice2, diffs);
        const result = diffs.map((d2) => new linesDiffComputer_1.RangeMapping(slice1.translateRange(d2.seq1Range), slice2.translateRange(d2.seq2Range)));
        return {
          mappings: result,
          hitTimeout: diffResult.hitTimeout
        };
      }
    };
    exports.AdvancedLinesDiffComputer = AdvancedLinesDiffComputer;
    var MonotonousFinder = class _MonotonousFinder {
      static create(items, itemToDomain, domainComparator) {
        items.sort((a3, b) => domainComparator(itemToDomain(a3), itemToDomain(b)));
        return new _MonotonousFinder(items, itemToDomain, domainComparator);
      }
      static createOfSorted(items, itemToDomain, domainComparator) {
        return new _MonotonousFinder(items, itemToDomain, domainComparator);
      }
      constructor(_items, _itemToDomain, _domainComparator) {
        this._items = _items;
        this._itemToDomain = _itemToDomain;
        this._domainComparator = _domainComparator;
        this._currentIdx = 0;
        this._lastValue = void 0;
        this._hasLastValue = false;
      }
      /**
       * Assumes the values are monotonously increasing.
       */
      findLastItemBeforeOrEqual(value) {
        if (this._hasLastValue && arrays_1.CompareResult.isLessThan(this._domainComparator(value, this._lastValue))) {
          throw new errors_1.BugIndicatingError();
        }
        this._lastValue = value;
        this._hasLastValue = true;
        while (this._currentIdx < this._items.length && arrays_1.CompareResult.isLessThanOrEqual(this._domainComparator(this._itemToDomain(this._items[this._currentIdx]), value))) {
          this._currentIdx++;
        }
        return this._currentIdx === 0 ? void 0 : this._items[this._currentIdx - 1];
      }
    };
    function intersectRanges(ranges1, ranges2) {
      const result = [];
      let i1 = 0;
      let i22 = 0;
      while (i1 < ranges1.length && i22 < ranges2.length) {
        const r1 = ranges1[i1];
        const r22 = ranges2[i22];
        const i4 = r1.intersect(r22);
        if (i4 && !i4.isEmpty) {
          result.push(i4);
        }
        if (r1.endLineNumberExclusive < r22.endLineNumberExclusive) {
          i1++;
        } else {
          i22++;
        }
      }
      return result;
    }
    var LineRangeSet = class {
      constructor() {
        this._normalizedRanges = [];
      }
      addRange(range) {
        const joinRangeStartIdx = mapMinusOne(this._normalizedRanges.findIndex((r3) => r3.endLineNumberExclusive >= range.startLineNumber), this._normalizedRanges.length);
        const joinRangeEndIdxExclusive = (0, arrays_1.findLastIndex)(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
        } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
          const joinRange = this._normalizedRanges[joinRangeStartIdx];
          this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
        } else {
          const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
          this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
      }
      intersects(range) {
        for (const r3 of this._normalizedRanges) {
          if (r3.intersectsStrict(range)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Subtracts all ranges in this set from `range` and returns the result.
       */
      subtractFrom(range) {
        const joinRangeStartIdx = mapMinusOne(this._normalizedRanges.findIndex((r3) => r3.endLineNumberExclusive >= range.startLineNumber), this._normalizedRanges.length);
        const joinRangeEndIdxExclusive = (0, arrays_1.findLastIndex)(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          return [range];
        }
        const result = [];
        let startLineNumber = range.startLineNumber;
        for (let i4 = joinRangeStartIdx; i4 < joinRangeEndIdxExclusive; i4++) {
          const r3 = this._normalizedRanges[i4];
          if (r3.startLineNumber > startLineNumber) {
            result.push(new lineRange_1.LineRange(startLineNumber, r3.startLineNumber));
          }
          startLineNumber = r3.endLineNumberExclusive;
        }
        if (startLineNumber < range.endLineNumberExclusive) {
          result.push(new lineRange_1.LineRange(startLineNumber, range.endLineNumberExclusive));
        }
        return result;
      }
    };
    function mapMinusOne(idx, mapTo) {
      return idx === -1 ? mapTo : idx;
    }
    function coverFullWords(sequence1, sequence2, sequenceDiffs) {
      const additional = [];
      let lastModifiedWord = void 0;
      function maybePushWordToAdditional() {
        if (!lastModifiedWord) {
          return;
        }
        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;
        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;
        if (originalLength1 !== originalLength2) {
        }
        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {
          additional.push(new diffAlgorithm_1.SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));
        }
        lastModifiedWord = void 0;
      }
      for (const s3 of sequenceDiffs) {
        let processWord = function(s1Range, s2Range) {
          if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {
            if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {
              const s1Added = offsetRange_1.OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);
              const s2Added = offsetRange_1.OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);
              lastModifiedWord.deleted += s1Added?.length ?? 0;
              lastModifiedWord.added += s2Added?.length ?? 0;
              lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);
              lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);
            } else {
              maybePushWordToAdditional();
              lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range, s2Range };
            }
          }
          const changedS1 = s1Range.intersect(s3.seq1Range);
          const changedS2 = s2Range.intersect(s3.seq2Range);
          lastModifiedWord.count++;
          lastModifiedWord.deleted += changedS1?.length ?? 0;
          lastModifiedWord.added += changedS2?.length ?? 0;
        };
        const w1Before = sequence1.findWordContaining(s3.seq1Range.start - 1);
        const w2Before = sequence2.findWordContaining(s3.seq2Range.start - 1);
        const w1After = sequence1.findWordContaining(s3.seq1Range.endExclusive);
        const w2After = sequence2.findWordContaining(s3.seq2Range.endExclusive);
        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {
          processWord(w1Before, w2Before);
        } else {
          if (w1Before && w2Before) {
            processWord(w1Before, w2Before);
          }
          if (w1After && w2After) {
            processWord(w1After, w2After);
          }
        }
      }
      maybePushWordToAdditional();
      const merged = mergeSequenceDiffs(sequenceDiffs, additional);
      return merged;
    }
    function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
      const result = [];
      while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
        const sd1 = sequenceDiffs1[0];
        const sd2 = sequenceDiffs2[0];
        let next;
        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
          next = sequenceDiffs1.shift();
        } else {
          next = sequenceDiffs2.shift();
        }
        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
          result[result.length - 1] = result[result.length - 1].join(next);
        } else {
          result.push(next);
        }
      }
      return result;
    }
    function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
      const changes = [];
      for (const g of group(alignments.map((a3) => getLineRangeMapping(a3, originalLines, modifiedLines)), (a1, a22) => a1.originalRange.overlapOrTouch(a22.originalRange) || a1.modifiedRange.overlapOrTouch(a22.modifiedRange))) {
        const first = g[0];
        const last = g[g.length - 1];
        changes.push(new linesDiffComputer_1.LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map((a3) => a3.innerChanges[0])));
      }
      (0, assert_1.assertFn)(() => {
        if (!dontAssertStartLine) {
          if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {
            return false;
          }
        }
        return (0, assert_1.checkAdjacentItems)(changes, (m1, m22) => m22.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m22.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.originalRange.endLineNumberExclusive < m22.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m22.modifiedRange.startLineNumber);
      });
      return changes;
    }
    exports.lineRangeMappingFromRangeMappings = lineRangeMappingFromRangeMappings;
    function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
      let lineStartDelta = 0;
      let lineEndDelta = 0;
      if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
        lineEndDelta = -1;
      }
      if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
        lineStartDelta = 1;
      }
      const originalLineRange = new lineRange_1.LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
      const modifiedLineRange = new lineRange_1.LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
      return new linesDiffComputer_1.LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
    }
    exports.getLineRangeMapping = getLineRangeMapping;
    function* group(items, shouldBeGrouped) {
      let currentGroup;
      let last;
      for (const item of items) {
        if (last !== void 0 && shouldBeGrouped(last, item)) {
          currentGroup.push(item);
        } else {
          if (currentGroup) {
            yield currentGroup;
          }
          currentGroup = [item];
        }
        last = item;
      }
      if (currentGroup) {
        yield currentGroup;
      }
    }
    var LineSequence = class {
      constructor(trimmedHash, lines) {
        this.trimmedHash = trimmedHash;
        this.lines = lines;
      }
      getElement(offset) {
        return this.trimmedHash[offset];
      }
      get length() {
        return this.trimmedHash.length;
      }
      getBoundaryScore(length) {
        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
        return 1e3 - (indentationBefore + indentationAfter);
      }
      getText(range) {
        return this.lines.slice(range.start, range.endExclusive).join("\n");
      }
      isStronglyEqual(offset1, offset2) {
        return this.lines[offset1] === this.lines[offset2];
      }
    };
    exports.LineSequence = LineSequence;
    function getIndentation(str) {
      let i4 = 0;
      while (i4 < str.length && (str.charCodeAt(i4) === 32 || str.charCodeAt(i4) === 9)) {
        i4++;
      }
      return i4;
    }
    var LinesSliceCharSequence = class {
      constructor(lines, lineRange, considerWhitespaceChanges) {
        this.lines = lines;
        this.considerWhitespaceChanges = considerWhitespaceChanges;
        this.elements = [];
        this.firstCharOffsetByLineMinusOne = [];
        this.additionalOffsetByLine = [];
        let trimFirstLineFully = false;
        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
          lineRange = new offsetRange_1.OffsetRange(lineRange.start - 1, lineRange.endExclusive);
          trimFirstLineFully = true;
        }
        this.lineRange = lineRange;
        for (let i4 = this.lineRange.start; i4 < this.lineRange.endExclusive; i4++) {
          let line = lines[i4];
          let offset = 0;
          if (trimFirstLineFully) {
            offset = line.length;
            line = "";
            trimFirstLineFully = false;
          } else if (!considerWhitespaceChanges) {
            const trimmedStartLine = line.trimStart();
            offset = line.length - trimmedStartLine.length;
            line = trimmedStartLine.trimEnd();
          }
          this.additionalOffsetByLine.push(offset);
          for (let i5 = 0; i5 < line.length; i5++) {
            this.elements.push(line.charCodeAt(i5));
          }
          if (i4 < lines.length - 1) {
            this.elements.push("\n".charCodeAt(0));
            this.firstCharOffsetByLineMinusOne[i4 - this.lineRange.start] = this.elements.length;
          }
        }
        this.additionalOffsetByLine.push(0);
      }
      toString() {
        return `Slice: "${this.text}"`;
      }
      get text() {
        return this.getText(new offsetRange_1.OffsetRange(0, this.length));
      }
      getText(range) {
        return this.elements.slice(range.start, range.endExclusive).map((e3) => String.fromCharCode(e3)).join("");
      }
      getElement(offset) {
        return this.elements[offset];
      }
      get length() {
        return this.elements.length;
      }
      getBoundaryScore(length) {
        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
        if (prevCategory === 6 && nextCategory === 7) {
          return 0;
        }
        let score2 = 0;
        if (prevCategory !== nextCategory) {
          score2 += 10;
          if (nextCategory === 1) {
            score2 += 1;
          }
        }
        score2 += getCategoryBoundaryScore(prevCategory);
        score2 += getCategoryBoundaryScore(nextCategory);
        return score2;
      }
      translateOffset(offset) {
        if (this.lineRange.isEmpty) {
          return new position_1.Position(this.lineRange.start + 1, 1);
        }
        let i4 = 0;
        let j3 = this.firstCharOffsetByLineMinusOne.length;
        while (i4 < j3) {
          const k4 = Math.floor((i4 + j3) / 2);
          if (this.firstCharOffsetByLineMinusOne[k4] > offset) {
            j3 = k4;
          } else {
            i4 = k4 + 1;
          }
        }
        const offsetOfFirstCharInLine = i4 === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i4 - 1];
        return new position_1.Position(this.lineRange.start + i4 + 1, offset - offsetOfFirstCharInLine + 1 + this.additionalOffsetByLine[i4]);
      }
      translateRange(range) {
        return range_1.Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
      }
      /**
       * Finds the word that contains the character at the given offset
       */
      findWordContaining(offset) {
        if (offset < 0 || offset >= this.elements.length) {
          return void 0;
        }
        if (!isWordChar(this.elements[offset])) {
          return void 0;
        }
        let start = offset;
        while (start > 0 && isWordChar(this.elements[start - 1])) {
          start--;
        }
        let end = offset;
        while (end < this.elements.length && isWordChar(this.elements[end])) {
          end++;
        }
        return new offsetRange_1.OffsetRange(start, end);
      }
      countLinesIn(range) {
        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
      }
      isStronglyEqual(offset1, offset2) {
        return this.elements[offset1] === this.elements[offset2];
      }
      extendToFullLines(range) {
        const start = findLastMonotonous(this.firstCharOffsetByLineMinusOne, (x3) => x3 <= range.start) ?? 0;
        const end = findFirstMonotonous(this.firstCharOffsetByLineMinusOne, (x3) => range.endExclusive <= x3) ?? this.elements.length;
        return new offsetRange_1.OffsetRange(start, end);
      }
    };
    exports.LinesSliceCharSequence = LinesSliceCharSequence;
    function findLastIdxMonotonous(arr, predicate) {
      let i4 = 0;
      let j3 = arr.length;
      while (i4 < j3) {
        const k4 = Math.floor((i4 + j3) / 2);
        if (predicate(arr[k4])) {
          i4 = k4 + 1;
        } else {
          j3 = k4;
        }
      }
      return i4 - 1;
    }
    function findLastMonotonous(arr, predicate) {
      const idx = findLastIdxMonotonous(arr, predicate);
      return idx === -1 ? void 0 : arr[idx];
    }
    exports.findLastMonotonous = findLastMonotonous;
    function findFirstIdxMonotonous(arr, predicate) {
      let i4 = 0;
      let j3 = arr.length;
      while (i4 < j3) {
        const k4 = Math.floor((i4 + j3) / 2);
        if (predicate(arr[k4])) {
          j3 = k4;
        } else {
          i4 = k4 + 1;
        }
      }
      return i4;
    }
    function findFirstMonotonous(arr, predicate) {
      const idx = findFirstIdxMonotonous(arr, predicate);
      return idx === arr.length ? void 0 : arr[idx];
    }
    exports.findFirstMonotonous = findFirstMonotonous;
    function isWordChar(charCode) {
      return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
    }
    var score = {
      [
        0
        /* CharBoundaryCategory.WordLower */
      ]: 0,
      [
        1
        /* CharBoundaryCategory.WordUpper */
      ]: 0,
      [
        2
        /* CharBoundaryCategory.WordNumber */
      ]: 0,
      [
        3
        /* CharBoundaryCategory.End */
      ]: 10,
      [
        4
        /* CharBoundaryCategory.Other */
      ]: 2,
      [
        5
        /* CharBoundaryCategory.Space */
      ]: 3,
      [
        6
        /* CharBoundaryCategory.LineBreakCR */
      ]: 10,
      [
        7
        /* CharBoundaryCategory.LineBreakLF */
      ]: 10
    };
    function getCategoryBoundaryScore(category) {
      return score[category];
    }
    function getCategory(charCode) {
      if (charCode === 10) {
        return 7;
      } else if (charCode === 13) {
        return 6;
      } else if (isSpace(charCode)) {
        return 5;
      } else if (charCode >= 97 && charCode <= 122) {
        return 0;
      } else if (charCode >= 65 && charCode <= 90) {
        return 1;
      } else if (charCode >= 48 && charCode <= 57) {
        return 2;
      } else if (charCode === -1) {
        return 3;
      } else {
        return 4;
      }
    }
    function isSpace(charCode) {
      return charCode === 32 || charCode === 9;
    }
    var chrKeys = /* @__PURE__ */ new Map();
    function getKey(chr) {
      let key = chrKeys.get(chr);
      if (key === void 0) {
        key = chrKeys.size;
        chrKeys.set(chr, key);
      }
      return key;
    }
    var LineRangeFragment = class {
      constructor(range, lines, source) {
        this.range = range;
        this.lines = lines;
        this.source = source;
        this.histogram = [];
        let counter = 0;
        for (let i4 = range.startLineNumber - 1; i4 < range.endLineNumberExclusive - 1; i4++) {
          const line = lines[i4];
          for (let j3 = 0; j3 < line.length; j3++) {
            counter++;
            const chr = line[j3];
            const key2 = getKey(chr);
            this.histogram[key2] = (this.histogram[key2] || 0) + 1;
          }
          counter++;
          const key = getKey("\n");
          this.histogram[key] = (this.histogram[key] || 0) + 1;
        }
        this.totalCount = counter;
      }
      computeSimilarity(other) {
        let sumDifferences = 0;
        const maxLength = Math.max(this.histogram.length, other.histogram.length);
        for (let i4 = 0; i4 < maxLength; i4++) {
          sumDifferences += Math.abs((this.histogram[i4] ?? 0) - (other.histogram[i4] ?? 0));
        }
        return 1 - sumDifferences / (this.totalCount + other.totalCount);
      }
    };
  }
});

// node_modules/vscode-diff/dist/index.js
var require_dist = __commonJS({
  "node_modules/vscode-diff/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_linesDiffComputer(), exports);
    __exportStar(require_diff(), exports);
    __exportStar(require_diffChange(), exports);
    __exportStar(require_legacyLinesDiffComputer(), exports);
    __exportStar(require_advancedLinesDiffComputer(), exports);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/TextOperation.js
var require_TextOperation = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/TextOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextOperation = void 0;
    var TextOperation = class _TextOperation {
      // When an operation is applied to an input string, you can think of this as
      // if an imaginary cursor runs over the entire string and skips over some
      // parts, deletes some parts and inserts characters at some positions. These
      // actions (skip/delete/insert) are stored as an array in the "ops" property.
      ops = [];
      // An operation's baseLength is the length of every string the operation
      // can be applied to.
      baseLength = 0;
      // The targetLength is the length of every string that results from applying
      // the operation on a valid input string.
      targetLength = 0;
      /**
       * Transform takes two operations A and B that happened concurrently and
       * produces two operations A' and B' (in an array) such that
       * `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the
       * heart of OT.
       */
      static transform(operation1, operation2) {
        if (operation1.baseLength !== operation2.baseLength) {
          throw new Error("Both operations have to have the same base length");
        }
        const operation1prime = new _TextOperation();
        const operation2prime = new _TextOperation();
        const ops1 = operation1.ops, ops2 = operation2.ops;
        let i1 = 0, i22 = 0;
        let op1 = ops1[i1++], op2 = ops2[i22++];
        while (true) {
          if (typeof op1 === "undefined" && typeof op2 === "undefined") {
            break;
          }
          if (_TextOperation.isInsert(op1)) {
            operation1prime.insert(op1);
            operation2prime.retain(op1.length);
            op1 = ops1[i1++];
            continue;
          }
          if (_TextOperation.isInsert(op2)) {
            operation1prime.retain(op2.length);
            operation2prime.insert(op2);
            op2 = ops2[i22++];
            continue;
          }
          if (typeof op1 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too short.");
          }
          if (typeof op2 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too long.");
          }
          let minl;
          if (_TextOperation.isRetain(op1) && _TextOperation.isRetain(op2)) {
            if (op1 > op2) {
              minl = op2;
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              minl = op2;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = op1;
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
            operation1prime.retain(minl);
            operation2prime.retain(minl);
          } else if (_TextOperation.isDelete(op1) && _TextOperation.isDelete(op2)) {
            if (-op1 > -op2) {
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isDelete(op1) && _TextOperation.isRetain(op2)) {
            if (-op1 > op2) {
              minl = op2;
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (-op1 === op2) {
              minl = op2;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = -op1;
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
            operation1prime["delete"](minl);
          } else if (_TextOperation.isRetain(op1) && _TextOperation.isDelete(op2)) {
            if (op1 > -op2) {
              minl = -op2;
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (op1 === -op2) {
              minl = op1;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = op1;
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
            operation2prime["delete"](minl);
          } else {
            throw new Error("The two operations aren't compatible");
          }
        }
        return [operation1prime, operation2prime];
      }
      // Operation are essentially lists of ops. There are three types of ops:
      // 1. Retain ops: Advance the cursor position by a given number of characters.
      //   Represented by positive ints.
      static isRetain(op) {
        return typeof op === "number" && op > 0;
      }
      // 2. Insert ops: Insert a given string at the current cursor position.
      //   Represented by strings.
      static isInsert(op) {
        return typeof op === "string";
      }
      // 3. Delete ops: Delete the next n characters. Represented by negative ints.
      static isDelete(op) {
        return typeof op === "number" && op < 0;
      }
      // Converts a plain JS object into an operation and validates it.
      static fromJSON(ops) {
        const o2 = new _TextOperation();
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            o2.retain(op);
          } else if (_TextOperation.isInsert(op)) {
            o2.insert(op);
          } else if (_TextOperation.isDelete(op)) {
            o2["delete"](op);
          } else {
            throw new Error("unknown operation: " + JSON.stringify(op));
          }
        }
        return o2;
      }
      invert(str) {
        let strIndex = 0;
        const inverse = new _TextOperation();
        const ops = this.ops;
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            inverse.retain(op);
            strIndex += op;
          } else if (_TextOperation.isInsert(op)) {
            inverse["delete"](op.length);
          } else {
            inverse.insert(str.slice(strIndex, strIndex - op));
            strIndex -= op;
          }
        }
        return inverse;
      }
      equals(other) {
        if (this.baseLength !== other.baseLength) {
          return false;
        }
        if (this.targetLength !== other.targetLength) {
          return false;
        }
        if (this.ops.length !== other.ops.length) {
          return false;
        }
        for (let i4 = 0; i4 < this.ops.length; i4++) {
          if (this.ops[i4] !== other.ops[i4]) {
            return false;
          }
        }
        return true;
      }
      // Skip over a given number of characters.
      retain(n2) {
        if (typeof n2 !== "number") {
          throw new Error("retain expects an integer");
        }
        if (n2 === 0) {
          return this;
        }
        this.baseLength += n2;
        this.targetLength += n2;
        if (_TextOperation.isRetain(this.ops[this.ops.length - 1])) {
          this.ops[this.ops.length - 1] += n2;
        } else {
          this.ops.push(n2);
        }
        return this;
      }
      // Insert a string at the current position.
      insert(str) {
        if (typeof str !== "string") {
          throw new Error("insert expects a string");
        }
        if (str === "") {
          return this;
        }
        this.targetLength += str.length;
        const ops = this.ops;
        if (_TextOperation.isInsert(ops[ops.length - 1])) {
          ops[ops.length - 1] += str;
        } else if (_TextOperation.isDelete(ops[ops.length - 1])) {
          if (_TextOperation.isInsert(ops[ops.length - 2])) {
            ops[ops.length - 2] += str;
          } else {
            ops[ops.length] = ops[ops.length - 1];
            ops[ops.length - 2] = str;
          }
        } else {
          ops.push(str);
        }
        return this;
      }
      // Delete a string at the current position.
      delete(n2) {
        if (typeof n2 === "string") {
          n2 = n2.length;
        }
        if (typeof n2 !== "number") {
          throw new Error("delete expects an integer or a string");
        }
        if (n2 === 0) {
          return this;
        }
        if (n2 > 0) {
          n2 = -n2;
        }
        this.baseLength -= n2;
        if (_TextOperation.isDelete(this.ops[this.ops.length - 1])) {
          this.ops[this.ops.length - 1] += n2;
        } else {
          this.ops.push(n2);
        }
        return this;
      }
      // Tests whether this operation has no effect.
      isNoop() {
        return this.ops.length === 0 || this.ops.length === 1 && _TextOperation.isRetain(this.ops[0]);
      }
      // Apply an operation to a string, returning a new string. Throws an error if
      // there's a mismatch between the input string and the operation.
      apply(str) {
        if (str.length !== this.baseLength) {
          throw new Error("The operation's base length must be equal to the string's length.");
        }
        const newStr = [];
        let j3 = 0;
        let strIndex = 0;
        const ops = this.ops;
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            if (strIndex + op > str.length) {
              throw new Error("Operation can't retain more characters than are left in the string.");
            }
            newStr[j3++] = str.slice(strIndex, strIndex + op);
            strIndex += op;
          } else if (_TextOperation.isInsert(op)) {
            newStr[j3++] = op;
          } else {
            strIndex -= op;
          }
        }
        if (strIndex !== str.length) {
          throw new Error("The operation didn't operate on the whole string.");
        }
        return newStr.join("");
      }
      /**
       * Compose merges two consecutive operations into one operation, that
       * preserves the changes of both. Or, in other words, for each input string S
       * and a pair of consecutive operations A and B,
       * apply(apply(S, A), B) = apply(S, compose(A, B)) must hold.
       */
      compose(operation2) {
        if (this.targetLength !== operation2.baseLength) {
          throw new Error("The base length of the second operation has to be the target length of the first operation");
        }
        const operation = new _TextOperation();
        const ops1 = this.ops, ops2 = operation2.ops;
        let i1 = 0, i22 = 0;
        let op1 = ops1[i1++], op2 = ops2[i22++];
        while (true) {
          if (typeof op1 === "undefined" && typeof op2 === "undefined") {
            break;
          }
          if (_TextOperation.isDelete(op1)) {
            operation["delete"](op1);
            op1 = ops1[i1++];
            continue;
          }
          if (_TextOperation.isInsert(op2)) {
            operation.insert(op2);
            op2 = ops2[i22++];
            continue;
          }
          if (typeof op1 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too short.");
          }
          if (typeof op2 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too long.");
          }
          if (_TextOperation.isRetain(op1) && _TextOperation.isRetain(op2)) {
            if (op1 > op2) {
              operation.retain(op2);
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              operation.retain(op1);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation.retain(op1);
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isInsert(op1) && _TextOperation.isDelete(op2)) {
            if (op1.length > -op2) {
              op1 = op1.slice(-op2);
              op2 = ops2[i22++];
            } else if (op1.length === -op2) {
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              op2 = op2 + op1.length;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isInsert(op1) && _TextOperation.isRetain(op2)) {
            if (op1.length > op2) {
              operation.insert(op1.slice(0, op2));
              op1 = op1.slice(op2);
              op2 = ops2[i22++];
            } else if (op1.length === op2) {
              operation.insert(op1);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation.insert(op1);
              op2 = op2 - op1.length;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isRetain(op1) && _TextOperation.isDelete(op2)) {
            if (op1 > -op2) {
              operation["delete"](op2);
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (op1 === -op2) {
              operation["delete"](op2);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation["delete"](op1);
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
          } else {
            throw new Error("This shouldn't happen: op1: " + JSON.stringify(op1) + ", op2: " + JSON.stringify(op2));
          }
        }
        return operation;
      }
      // Pretty printing
      toString() {
        return this.ops.map((op) => {
          if (_TextOperation.isRetain(op)) {
            return "retain " + op;
          } else if (_TextOperation.isInsert(op)) {
            return "insert '" + op + "'";
          } else {
            return "delete " + -op;
          }
        }).join(", ");
      }
      toJSON() {
        return this.ops;
      }
    };
    exports.TextOperation = TextOperation;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/utils.js
var require_utils2 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDiffTextOperation = exports.findDiff = void 0;
    var vscode_diff_1 = require_dist();
    var TextOperation_1 = require_TextOperation();
    function findDiff(originalText, modifiedText, pretty) {
      return (0, vscode_diff_1.stringDiff)(originalText, modifiedText, pretty);
    }
    exports.findDiff = findDiff;
    function createDiffTextOperation(originalText, modifiedText) {
      const ot5 = new TextOperation_1.TextOperation();
      if (originalText === modifiedText) {
        ot5.retain(originalText.length);
        return ot5;
      }
      const diffs = findDiff(originalText, modifiedText, false);
      let previousOriginalEndIndex = 0;
      diffs.forEach((change) => {
        const originalStartIndex = change.originalStart;
        const originalEndIndex = change.originalStart + change.originalLength;
        const charsToRetain = originalStartIndex - previousOriginalEndIndex;
        if (charsToRetain > 0) {
          ot5.retain(charsToRetain);
        } else if (charsToRetain < 0) {
          throw new Error("Invalid diff change start index, overlapping changes detected");
        }
        previousOriginalEndIndex = originalEndIndex;
        const oldText = originalText.substring(originalStartIndex, originalEndIndex);
        const newText = modifiedText.substring(change.modifiedStart, change.modifiedStart + change.modifiedLength);
        if (oldText !== newText) {
          ot5.insert(newText);
          ot5.delete(change.originalLength);
        }
      });
      const remainingChars = originalText.length - ot5.baseLength;
      if (remainingChars > 0) {
        ot5.retain(remainingChars);
      } else if (remainingChars < 0) {
        throw new Error("Invalid text diff, remaining chars is negative");
      }
      return ot5;
    }
    exports.createDiffTextOperation = createDiffTextOperation;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/types.js
var require_types = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationReason = void 0;
    var OperationReason;
    (function(OperationReason2) {
      OperationReason2[OperationReason2["USER"] = 0] = "USER";
      OperationReason2[OperationReason2["FS"] = 1] = "FS";
      OperationReason2[OperationReason2["RESYNC"] = 2] = "RESYNC";
    })(OperationReason || (exports.OperationReason = OperationReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Client.js
var require_Client = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = void 0;
    var utils_1 = require_utils2();
    var TextOperation_1 = require_TextOperation();
    var types_1 = require_types();
    var event_1 = require_event();
    var Client = class {
      incomingOperationEmitter = new event_1.Emitter();
      onIncomingOperation = this.incomingOperationEmitter.event;
      operationAckEmitter = new event_1.Emitter();
      onOperationAck = this.operationAckEmitter.event;
      outgoingOperationEmitter = new event_1.Emitter();
      onOutgoingOperation = this.outgoingOperationEmitter.event;
      documentChangeEmitter = new event_1.Emitter();
      onDocumentChange = this.documentChangeEmitter.event;
      // Current document content state
      _document;
      // Last known server document state, based on incoming operations and
      // acknowledged outgoing operations. This is used to sync server state after
      // disconnects
      _serverDocument;
      // Current revision of the document
      revision;
      // Callback to send an operation
      sendOperation;
      sendOperationAck;
      // Operation that has been sent to the server but hasn't been acknowledged yet
      pendingOperation = null;
      // Any edits that the user has done since the pendingOperation, get combined into a queued operation
      // and gets sent from the moment pending operation has been acknowledged
      queuedOperation = null;
      constructor(document2, revision, sendOperation, sendOperationAck) {
        this._document = document2;
        this._serverDocument = document2;
        this.revision = revision;
        this.sendOperation = sendOperation;
        this.sendOperationAck = sendOperationAck;
      }
      /** Check if client has pending operation, used for testing */
      get hasPendingOperation() {
        return Boolean(this.pendingOperation);
      }
      /** Check if client has pending operation, used for testing */
      get hasQueuedOperation() {
        return Boolean(this.queuedOperation);
      }
      /** returns the current state of the document */
      get document() {
        return this._document;
      }
      /** sets the content of the document and emits a documentChange event */
      set document(newContent) {
        this._document = newContent;
        this.documentChangeEmitter.fire({ newContent });
      }
      /** Enqueue operation to send to the server */
      enqueueOperation(op) {
        if (this.queuedOperation) {
          this.queuedOperation = this.queuedOperation.compose(op);
        } else {
          this.queuedOperation = op;
        }
        if (!this.pendingOperation) {
          this.sendQueuedOperation();
        }
      }
      transformServerOperation(serverOperation) {
        let incomingOperation = serverOperation;
        if (this.pendingOperation) {
          const transformed = TextOperation_1.TextOperation.transform(this.pendingOperation, incomingOperation);
          this.pendingOperation = transformed[0];
          incomingOperation = transformed[1];
        }
        if (this.queuedOperation) {
          const transformed = TextOperation_1.TextOperation.transform(this.queuedOperation, incomingOperation);
          this.queuedOperation = transformed[0];
          incomingOperation = transformed[1];
        }
        return incomingOperation;
      }
      sendPendingOperation() {
        if (this.pendingOperation) {
          const operation = this.pendingOperation;
          this.sendOperation(this.revision, operation);
        }
      }
      sendQueuedOperation() {
        if (!this.pendingOperation && this.queuedOperation) {
          this.pendingOperation = this.queuedOperation;
          this.queuedOperation = null;
          this.sendPendingOperation();
        }
      }
      /**
       * Resync with the server using the new content and last known revision
       *
       * Transforms the queued and pending operation on top of the diff between
       * our last known state and the expected state
       **/
      syncServerDocument(serverDocument, newRevision) {
        if (this.pendingOperation) {
          if (this.queuedOperation) {
            this.queuedOperation = this.pendingOperation.compose(this.queuedOperation);
          } else {
            this.queuedOperation = this.pendingOperation;
          }
          this.pendingOperation = null;
        }
        const diff = (0, utils_1.createDiffTextOperation)(this._serverDocument, serverDocument);
        if (diff.isNoop()) {
          this.revision = newRevision;
          this.sendQueuedOperation();
          return;
        }
        this.revision = newRevision - 1;
        return this.applyServerOperation(diff, types_1.OperationReason.RESYNC);
      }
      /**
       * If the OTClient errors on applying new operations from
       * the client, we can recover the state of the client document
       * by calling this method. It can potentially override server changes, but it is
       * more important that users do not loose any work
       */
      applyClientDocument(clientDocument) {
        const diff = (0, utils_1.createDiffTextOperation)(this.document, clientDocument);
        this.applyClientOperation(diff);
      }
      /**
       * Apply an operation originating from this client
       *
       * @param clientOperation the operation to apply to the document
       */
      applyClientOperation(clientOperation) {
        if (clientOperation.isNoop())
          return;
        this.document = clientOperation.apply(this.document);
        this.enqueueOperation(clientOperation);
        this.outgoingOperationEmitter.fire({
          operation: clientOperation,
          revision: this.revision
        });
      }
      /**
       * Apply operation coming from the ot server
       *
       * @param serverOperation the operation from the server that should be applied to the document
       * @param reason the reason for the operation to occur
       */
      applyServerOperation(op, reason) {
        this.revision++;
        const transformedOp = this.transformServerOperation(op);
        this.document = transformedOp.apply(this.document);
        this._serverDocument = op.apply(this._serverDocument);
        this.sendQueuedOperation();
        this.sendOperationAck(this.revision);
        this.incomingOperationEmitter.fire({
          operation: transformedOp,
          revision: this.revision,
          reason
        });
      }
      /**
       * On successful passing of an operation to the server. Any queued
       * operations will now be sent. The "onOperationAck" event is emitted when
       * there are no more pending operations or after we send any queued operations
       */
      serverAck() {
        if (this.pendingOperation) {
          this._serverDocument = this.pendingOperation.apply(this._serverDocument);
          this.revision++;
          this.pendingOperation = null;
          this.sendOperationAck(this.revision);
          this.sendQueuedOperation();
        }
        this.operationAckEmitter.fire({
          revision: this.revision
        });
      }
      dispose() {
        this.sendOperation = () => void 0;
        this.sendOperationAck = () => void 0;
        this.incomingOperationEmitter.dispose();
        this.operationAckEmitter.dispose();
        this.outgoingOperationEmitter.dispose();
        this.documentChangeEmitter.dispose();
      }
    };
    exports.Client = Client;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/OperationBuffer.js
var require_OperationBuffer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/OperationBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationBuffer = void 0;
    var OperationBuffer = class {
      offset;
      operations;
      constructor() {
        this.offset = 0;
        this.operations = [];
      }
      /**
       * Returns the current revision in the buffer
       */
      get revision() {
        return this.offset + this.operations.length;
      }
      /**
       * Add new operation to the buffer
       */
      push(operation) {
        this.operations.push(operation);
      }
      /**
       * Get operation from buffer at given revision
       */
      get(revision) {
        return this.operations[revision - this.offset] ?? null;
      }
      /**
       * Get all operations after a certain revision/offset
       */
      slice(offset) {
        if (offset < this.offset) {
          throw new Error("Tried to get removed operations");
        }
        return this.operations.slice(offset - this.offset);
      }
      /**
       * Remove all operations from the buffer that happened before the specified revision
       *
       * @param revision the oldest revision that should be kept in the buffer
       */
      clear(revision) {
        const keepFromIndex = revision - this.offset;
        this.operations = this.operations.slice(keepFromIndex);
        this.offset += keepFromIndex;
      }
    };
    exports.OperationBuffer = OperationBuffer;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Server.js
var require_Server = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Server = void 0;
    var OperationBuffer_1 = require_OperationBuffer();
    var TextOperation_1 = require_TextOperation();
    var MAX_OPERATIONS = 100;
    var Server = class {
      document;
      clientRevisions = /* @__PURE__ */ new Map();
      operationBuffer;
      /**
       * Create a server instance, provided a document as a string and an array of
       * operations.
       */
      constructor(document2) {
        this.document = document2;
        this.operationBuffer = new OperationBuffer_1.OperationBuffer();
      }
      /** Get the current server revision of the document */
      get revision() {
        return this.operationBuffer.revision;
      }
      /** Call this whenever a client disconnects from the server, this cleans up their data */
      addClient(clientId, revision) {
        this.clientRevisions.set(clientId, revision);
      }
      /** Call this whenever a client disconnects from the server, this cleans up their data */
      removeClient(clientId) {
        this.clientRevisions.delete(clientId);
      }
      /** Use this to get the client's ot state */
      getClientRevision(clientId) {
        return this.clientRevisions.get(clientId) ?? null;
      }
      /** Call this whenever a client acknowledges a server operation */
      ack(clientId, revision) {
        const clientRevision = this.clientRevisions.get(clientId);
        if (clientRevision != null && revision > clientRevision) {
          this.clientRevisions.set(clientId, revision);
        }
      }
      /**
       * This will clear as many operations as possible. Meaning that clients
       * on older revisions will still stay in history so we can still transform
       * their incoming operations
       */
      clearOperations() {
        const fromRevision = Math.max(
          this.revision - MAX_OPERATIONS,
          // 220 - 100
          Math.min(...this.clientRevisions.values())
        );
        this.operationBuffer.clear(fromRevision);
      }
      getOperations() {
        return this.operationBuffer.operations;
      }
      /** Call this method whenever you receive an operation from a client. */
      receiveOperation(revision, operation) {
        if (revision < 0 || this.operationBuffer.revision < revision) {
          throw new Error("operation revision not in history");
        }
        const concurrentOperations = this.operationBuffer.slice(revision);
        for (let i4 = 0; i4 < concurrentOperations.length; i4++) {
          operation = TextOperation_1.TextOperation.transform(operation, concurrentOperations[i4])[0];
        }
        this.applyOperation(operation);
        return operation;
      }
      /** Call this method whenever you want to apply a server-generated operation. */
      applyOperation(operation) {
        this.document = operation.apply(this.document);
        this.operationBuffer.push(operation);
        this.clearOperations();
      }
    };
    exports.Server = Server;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/SerialQueue.js
var require_SerialQueue = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/SerialQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialQueue = void 0;
    var SerialQueue3 = class {
      name;
      debug;
      items = [];
      isProcessing = false;
      constructor(name, debug4 = false) {
        this.name = name;
        this.debug = debug4;
      }
      async processQueue() {
        if (this.isProcessing)
          return;
        const item = this.items.shift();
        if (item) {
          if (this.debug) {
            console.log(`Running queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.isProcessing = true;
          try {
            const result = await item.callback();
            for (const resolve of item.resolves) {
              try {
                resolve(result);
              } catch (err) {
              }
            }
          } catch (err) {
            for (const reject of item.rejects) {
              try {
                reject(err);
              } catch (err2) {
              }
            }
          }
          this.isProcessing = false;
          if (this.debug) {
            console.log(`Processed queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.processQueue();
        }
      }
      /**
       * Add a new promise callback to the queue
       *
       * in case you provide a key it will be used to de-duplicate against existing items in the queue
       * if there is an existing item, the callback of that item will be used and this function will
       * return the result of that callback instead
       */
      add(callback, key) {
        if (this.debug) {
          console.log(`Adding item ${this.name}#${key ?? "unknown"} to the queue`);
        }
        return new Promise((resolve, reject) => {
          let shouldAdd = true;
          let item = {
            key,
            callback,
            resolves: [],
            rejects: []
          };
          if (key) {
            const foundItem = this.items.find((i4) => i4.key === key);
            if (foundItem) {
              item = foundItem;
              shouldAdd = false;
            }
          }
          item.resolves.push(resolve);
          item.rejects.push(reject);
          if (shouldAdd) {
            this.items.push(item);
          }
          this.processQueue().catch(console.error);
        });
      }
    };
    exports.SerialQueue = SerialQueue3;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/AsyncDocument.js
var require_AsyncDocument = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/AsyncDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncDocument = void 0;
    var TextOperation_1 = require_TextOperation();
    var SerialQueue_1 = require_SerialQueue();
    var APPLY_SERVER_OPERATION_MAX_TRIES = 5;
    var AsyncDocument2 = class {
      queue = new SerialQueue_1.SerialQueue("async-document-server-operations");
      bufferedDocument;
      pendingServerOperations = [];
      constructor(document2) {
        this.bufferedDocument = document2;
      }
      get document() {
        return this.bufferedDocument;
      }
      get hasPendingServerOperations() {
        return Boolean(this.pendingServerOperations.length);
      }
      /**
       * Applies the operation to the buffered document and returns the transformed
       * operation to be applied to the OT Client
       */
      applyClientOperation(operation) {
        const prevBufferedDocument = this.bufferedDocument;
        this.bufferedDocument = operation.apply(prevBufferedDocument);
        const pendingServerOperation = this.pendingServerOperations[0];
        if (pendingServerOperation) {
          const { operation: currentServerOperation } = pendingServerOperation;
          if (this.bufferedDocument === currentServerOperation.apply(prevBufferedDocument)) {
            this.pendingServerOperations.shift();
            return;
          }
        }
        let transformedOp = operation;
        for (let x3 = 0; x3 < this.pendingServerOperations.length; x3++) {
          const { operation: currentServerOperation } = this.pendingServerOperations[x3];
          const [a3, b] = TextOperation_1.TextOperation.transform(transformedOp, currentServerOperation);
          transformedOp = a3;
          this.pendingServerOperations[x3].operation = b;
        }
        return transformedOp;
      }
      /**
       * Adds the operation to the queue and calls the callback with the current
       * buffered document and the transformed operation to be applied to the
       * code editor. The callback should throw an error when applying the operation
       * to the code editor fails. The promise returned will reject after X retries
       */
      applyServerOperation(operation, cb) {
        const operationReference = { operation };
        this.pendingServerOperations.push(operationReference);
        return this.queue.add(() => {
          const applyOperation = async (currentTryCount) => {
            try {
              await cb(this.bufferedDocument, operationReference.operation);
            } catch (error) {
              if (currentTryCount > APPLY_SERVER_OPERATION_MAX_TRIES) {
                throw new Error(`Not able to apply incoming operation after ${APPLY_SERVER_OPERATION_MAX_TRIES} tries: ${String(error)}`);
              }
              return applyOperation(++currentTryCount);
            }
          };
          return applyOperation(1);
        });
      }
    };
    exports.AsyncDocument = AsyncDocument2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/index.js
var require_operational_transforms = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDiffTextOperation = void 0;
    __exportStar(require_Client(), exports);
    __exportStar(require_Server(), exports);
    __exportStar(require_TextOperation(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_AsyncDocument(), exports);
    var utils_1 = require_utils2();
    Object.defineProperty(exports, "createDiffTextOperation", { enumerable: true, get: function() {
      return utils_1.createDiffTextOperation;
    } });
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i4 = 0; i4 < this._errors.length; i4++) {
        var error = this._errors[i4];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i4 = 0; i4 < opts.retries; i4++) {
        timeouts.push(this.createTimeout(i4, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i4, opts));
      }
      timeouts.sort(function(a3, b) {
        return a3 - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i4 = 0; i4 < methods.length; i4++) {
        var method = methods[i4];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/@codesandbox/pitcher-common/dist/p-retry.js
var require_p_retry = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/p-retry.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.run = exports.AbortError = void 0;
    var retry_1 = __importDefault(require_retry2());
    var AbortError = class extends Error {
      originalError;
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    exports.AbortError = AbortError;
    function decorateErrorWithCounts(error, attemptNumber, retries) {
      const retriesLeft = retries - (attemptNumber - 1);
      const decoratedError = error;
      decoratedError.attemptNumber = attemptNumber;
      decoratedError.retriesLeft = retriesLeft;
      return decoratedError;
    }
    function run(input, options = {}) {
      return new Promise((resolve, reject) => {
        const retries = options.retries ?? 10;
        const operation = retry_1.default.operation({
          retries,
          factor: options.factor ?? 2,
          minTimeout: options.minTimeout ?? 1e3,
          maxTimeout: options.maxTimeout ?? 1e4,
          randomize: options.randomize ?? true
        });
        operation.attempt(async (attemptNumber) => {
          try {
            resolve(await input(attemptNumber));
          } catch (error) {
            if (!(error instanceof Error)) {
              reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
              return;
            }
            const isAbortError = error instanceof AbortError;
            decorateErrorWithCounts(error, attemptNumber, retries);
            try {
              if (options.onFailedAttempt) {
                await options.onFailedAttempt(error);
              }
            } catch (error2) {
              reject(error2);
              return;
            }
            if (isAbortError) {
              reject(error);
              operation.stop();
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        });
      });
    }
    exports.run = run;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F2() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F2.prototype = __global__;
      return new F2();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
        var support = {
          searchParams: "URLSearchParams" in global3,
          iterable: "Symbol" in global3 && "iterator" in Symbol,
          blob: "FileReader" in global3 && "Blob" in global3 && function() {
            try {
              new Blob();
              return true;
            } catch (e3) {
              return false;
            }
          }(),
          formData: "FormData" in global3,
          arrayBuffer: "ArrayBuffer" in global3
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i4 = 0; i4 < view.length; i4++) {
            chars[i4] = String.fromCharCode(view[i4]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global3.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global3.location.href ? global3.location.href : url;
              } catch (e3) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2)) {
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!global3.fetch) {
          global3.fetch = fetch2;
          global3.Headers = Headers2;
          global3.Request = Request2;
          global3.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/fetch.js
var require_fetch = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/fetch.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetch = exports.retryFetch = void 0;
    var index_1 = require_dist3();
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var ERROR_CODES_TO_RETRY = /* @__PURE__ */ new Set([
      408,
      429,
      424,
      499,
      444,
      502,
      503,
      504,
      599
    ]);
    function isRetryableStatus(errorcode) {
      return ERROR_CODES_TO_RETRY.has(errorcode);
    }
    function retryFetch(input, init, retryOptions = {}) {
      const tryFetch = async () => {
        const response = await (0, cross_fetch_1.default)(input, init);
        if (!response.ok && isRetryableStatus(response.status)) {
          throw new index_1.pRetry.AbortError(`[${response.status}]: ${response.statusText}`);
        }
        return response;
      };
      return index_1.pRetry.run(tryFetch, retryOptions);
    }
    exports.retryFetch = retryFetch;
    var cross_fetch_2 = require_browser_ponyfill();
    Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
      return cross_fetch_2.fetch;
    } });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/timeout.js
var require_timeout = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeout = void 0;
    var sleep_1 = require_sleep();
    async function timeout(promise, timeoutMs) {
      const timeout2 = (0, sleep_1.sleep)(timeoutMs).then(() => "timeout-exceeded");
      const result = await Promise.race([promise, timeout2]);
      if (result === "timeout-exceeded") {
        return { type: "timeout-exceeded", timeoutMs };
      }
      return { type: "ok", result };
    }
    exports.timeout = timeout;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/nullthrows.js
var require_nullthrows = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/nullthrows.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nullthrows = void 0;
    function nullthrows(value, message) {
      if (value == null) {
        throw new Error(message || "Value is nullish");
      }
      return value;
    }
    exports.nullthrows = nullthrows;
  }
});

// node_modules/@emotion/hash/dist/hash.browser.cjs.js
var require_hash_browser_cjs = __commonJS({
  "node_modules/@emotion/hash/dist/hash.browser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function murmur2(str) {
      var h3 = 0;
      var k4, i4 = 0, len = str.length;
      for (; len >= 4; ++i4, len -= 4) {
        k4 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
        k4 = /* Math.imul(k, m): */
        (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16);
        k4 ^= /* k >>> r: */
        k4 >>> 24;
        h3 = /* Math.imul(k, m): */
        (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h3 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
        case 2:
          h3 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
        case 1:
          h3 ^= str.charCodeAt(i4) & 255;
          h3 = /* Math.imul(h, m): */
          (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      }
      h3 ^= h3 >>> 13;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
    }
    exports.default = murmur2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/murmur.js
var require_murmur = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/murmur.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.murmur = void 0;
    var hash_1 = __importDefault(require_hash_browser_cjs());
    function murmur2(s3) {
      return (0, hash_1.default)(s3);
    }
    exports.murmur = murmur2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Aborter.js
var require_Aborter = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Aborter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Aborter = void 0;
    var Aborter = class {
      isAborted = false;
      abort() {
        this.isAborted = true;
      }
    };
    exports.Aborter = Aborter;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Debouncer.js
var require_Debouncer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Debouncer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Debouncer = void 0;
    var Debouncer2 = class {
      debounceTime;
      maxDebounceTime;
      lastExecutionAt;
      timeoutRef = null;
      callback;
      constructor(debounceTime, maxDebounceTime, callback) {
        this.debounceTime = debounceTime;
        this.maxDebounceTime = maxDebounceTime;
        this.lastExecutionAt = 0;
        this.callback = callback;
      }
      shouldDebounce() {
        if (!this.maxDebounceTime) {
          return true;
        }
        const timeSinceLastExecution = Date.now() - this.lastExecutionAt;
        return timeSinceLastExecution < this.maxDebounceTime;
      }
      debounce(...args) {
        const shouldDebounce = !this.timeoutRef || this.shouldDebounce();
        this.clear();
        if (!shouldDebounce) {
          this.fire(...args);
        } else {
          this.timeoutRef = setTimeout(() => {
            this.fire(...args);
          }, this.debounceTime);
        }
      }
      fire(...args) {
        this.clear();
        this.lastExecutionAt = Date.now();
        this.callback(...args);
      }
      flush(...args) {
        this.fire(...args);
      }
      clear() {
        if (this.timeoutRef) {
          clearTimeout(this.timeoutRef);
          this.timeoutRef = null;
        }
      }
    };
    exports.Debouncer = Debouncer2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BidirectionalMap.js
var require_BidirectionalMap = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BidirectionalMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BidirectionalMap = void 0;
    var BidirectionalMap3 = class {
      keyToValue = /* @__PURE__ */ new Map();
      valueToKey = /* @__PURE__ */ new Map();
      deleteEntry(key, value) {
        this.keyToValue.delete(key);
        this.valueToKey.delete(value);
      }
      get size() {
        return this.keyToValue.size;
      }
      deleteByValue(value) {
        const key = this.getKey(value);
        if (key !== void 0) {
          this.deleteEntry(key, value);
        }
      }
      deleteByKey(key) {
        const value = this.getValue(key);
        if (value !== void 0) {
          this.deleteEntry(key, value);
        }
      }
      set(key, value) {
        this.keyToValue.set(key, value);
        this.valueToKey.set(value, key);
      }
      getKey(value) {
        return this.valueToKey.get(value);
      }
      getValue(key) {
        return this.keyToValue.get(key);
      }
      keys() {
        return this.keyToValue.keys();
      }
      values() {
        return this.keyToValue.values();
      }
      entries() {
        return this.keyToValue.entries();
      }
    };
    exports.BidirectionalMap = BidirectionalMap3;
  }
});

// node_modules/ts-mixer/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Mixin: () => Mixin,
  decorate: () => decorate,
  hasMixin: () => hasMixin,
  mix: () => mix,
  settings: () => settings
});
function Mixin(...constructors) {
  var _a2, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a2 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a2 !== void 0 ? _a2 : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
var init_esm = __esm({
  "node_modules/ts-mixer/dist/esm/index.js"() {
    copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return protoChain(proto, [...currentChain, proto]);
    };
    nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => protoChain(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a2;
      const base = (_a2 = nearestCommonProto(...ingredients)) !== null && _a2 !== void 0 ? _a2 : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = protoChain(base);
      for (let prototype of ingredients) {
        let protos = protoChain(prototype);
        for (let i4 = protos.length - 1; i4 >= 0; i4--) {
          let newProto = protos[i4];
          if (visitedProtos.indexOf(newProto) === -1) {
            copyProps(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    unique = (arr) => arr.filter((e3, i4) => arr.indexOf(e3) == i4);
    getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i4 = ingredients.length - 1; i4 >= 0; i4--) {
          const searchTarget = protoChains[i4][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i4][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_3, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_3, prop) {
        return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_3, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
      },
      set(_3, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
    settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
    mixins = /* @__PURE__ */ new WeakMap();
    getMixinsForClass = (clazz) => mixins.get(clazz);
    registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a2;
          const itemConstituents = (_a2 = mixins.get(item)) !== null && _a2 !== void 0 ? _a2 : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    mergeObjectsOfDecorators = (o1, o2) => {
      var _a2, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = unique([...(_a2 = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a2, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a2 = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a2 !== void 0 ? _a2 : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    mergeDecorators = (d1, d2) => {
      var _a2, _b, _c, _d, _e, _f;
      return {
        class: unique([...(_a2 = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    decorators = /* @__PURE__ */ new Map();
    findAllConstituentClasses = (...classes) => {
      var _a2;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a2 = getMixinsForClass(clazz)) !== null && _a2 !== void 0 ? _a2 : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c3) => !allClasses.has(c3));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a2, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = getDecoratorsForClass(clazz);
      const decoratorsForTargetType = (_a2 = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a2 !== void 0 ? _a2 : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/errors.js
var require_errors2 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nodeExists = exports.OutOfSyncError = void 0;
    var OutOfSyncError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "OutOfSyncError";
      }
    };
    exports.OutOfSyncError = OutOfSyncError;
    function nodeExists(node, errorMessage) {
      if (node)
        return;
      throw new OutOfSyncError(errorMessage);
    }
    exports.nodeExists = nodeExists;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/Tree.js
var require_Tree = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/Tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tree = exports.ROOT_ID = void 0;
    var TreeNode_1 = require_TreeNode();
    var BidirectionalMap_1 = require_BidirectionalMap();
    var errors_1 = require_errors2();
    exports.ROOT_ID = "0";
    var Tree = class _Tree {
      /** Tree nodes indexed by id. */
      nodes = /* @__PURE__ */ new Map();
      /**
       * Parent id to child id index.
       * Allows lookups of children by name or child id.
       */
      children = /* @__PURE__ */ new Map();
      constructor() {
        this.createRootNode();
      }
      /** Create a new root node. */
      createRootNode() {
        const root = new TreeNode_1.ImmutableDirectory({ id: exports.ROOT_ID, type: TreeNode_1.NodeType.Directory }, this);
        this.nodes.set(exports.ROOT_ID, root);
      }
      /** The workspace's root directory. */
      get root() {
        return this.nodes.get(exports.ROOT_ID);
      }
      /** Get a node by its id. */
      getNodeById(id) {
        return this.nodes.get(id);
      }
      /** Get a node's id with the given path. */
      getIdFromPath(path) {
        const parts = path.split("/");
        if (!parts[0]) {
          parts.shift();
        }
        const baseName = parts.pop();
        if (!baseName && parts.length === 0)
          return this.root.id;
        if (!baseName)
          return void 0;
        let node = this.root;
        for (const part of parts) {
          if (!node.isDirNode()) {
            return void 0;
          }
          node = node.getChildByName(part);
          if (!node) {
            return void 0;
          }
        }
        if (!node.isDirNode()) {
          return void 0;
        }
        return node.getChildByName(baseName)?.id;
      }
      /** Get a node with the given path. */
      getNodeFromPath(path) {
        const id = this.getIdFromPath(path);
        if (id) {
          return this.getNodeById(id);
        }
      }
      /** Move the provided node id to the given parent id. */
      moveNode(id, parentId, name) {
        const node = this.nodes.get(id);
        (0, errors_1.nodeExists)(node, `Attempting to move non-existent node: ${id}.`);
        this._removeChild(node);
        node.parentId = parentId;
        node.name = name ?? node.name;
        this._addChild(node, parentId);
        return node;
      }
      /** Delete the node with the given id. */
      deleteNode(id) {
        const node = this.nodes.get(id);
        (0, errors_1.nodeExists)(node, `Attempting to delete non-existent node: ${id}.`);
        this._removeNode(node);
      }
      /** Add a node to the tree. */
      _addNode(node) {
        const parentNode = node.parent;
        if (parentNode && parentNode.getChildByName(node.name)) {
          throw new Error(`${node.name} already exists in directory ${parentNode.name ?? "/"}.`);
        }
        this.nodes.set(node.id, node);
        if (node.isImmutableDirectory())
          return;
        this._addChild(node, node.parentId);
      }
      /** Add JSON Nodes to the tree. */
      _addJSONNodes(nodes) {
        for (const node of nodes) {
          this._addJSONNode(node);
        }
      }
      /** Add a node to the tree. */
      _addJSONNode(node) {
        this._addNode((0, TreeNode_1.createNode)(node, this));
      }
      /** Add a parent-child relation to the tree. */
      _addChild(node, parentId) {
        if (node.isImmutableDirectory())
          return;
        let childrenMap = this.children.get(parentId);
        if (!childrenMap) {
          childrenMap = new BidirectionalMap_1.BidirectionalMap();
          this.children.set(parentId, childrenMap);
        }
        childrenMap.set(node.id, node.name);
      }
      /** Recursively remove a node and all its children. */
      _removeNode(node) {
        if (node.isImmutableDirectory()) {
          throw new Error("Cannot remove the root node");
        }
        if (node.isDirNode()) {
          node.children.forEach((child) => this._removeNode(child));
        }
        this.nodes.delete(node.id);
        this._removeChild(node);
      }
      /** Remove a node's parent-child relation from the tree. */
      _removeChild(node) {
        if (node.isImmutableDirectory())
          return;
        const children = this.children.get(node.parentId);
        if (!children)
          return;
        children.deleteByKey(node.id);
        if (children.size === 0)
          this.children.delete(node.parentId);
      }
      /** Serialize a Tree to JSON. */
      toJSON() {
        const res = [];
        for (const node of this.nodes.values()) {
          res.push({
            id: node.id,
            type: node.type,
            name: node.name,
            parentId: node.parentId
          });
        }
        return res;
      }
      /** Deserialize a Tree from JSON. */
      static fromJSON(nodes) {
        const tree = new _Tree();
        tree._addJSONNodes(nodes);
        return tree;
      }
    };
    exports.Tree = Tree;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/TreeNode.js
var require_TreeNode = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/TreeNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImmutableDirectory = exports.Directory = exports.File = exports.DirNode = exports.MutableNode = exports.BaseNode = exports.createNode = exports.NodeType = void 0;
    var ts_mixer_1 = (init_esm(), __toCommonJS(esm_exports));
    var Id_1 = require_Id();
    var Tree_1 = require_Tree();
    var errors_1 = require_errors2();
    var NodeType2;
    (function(NodeType3) {
      NodeType3[NodeType3["File"] = 0] = "File";
      NodeType3[NodeType3["Directory"] = 1] = "Directory";
    })(NodeType2 || (exports.NodeType = NodeType2 = {}));
    function createNode(opts, tree) {
      if (opts.type === NodeType2.File) {
        return new File2(opts, tree);
      }
      if (opts.parentId) {
        return new Directory(opts, tree);
      }
      return new ImmutableDirectory(opts, tree);
    }
    exports.createNode = createNode;
    var BaseNode = class {
      /** Unique id of the node. */
      id;
      /** Type of the node. */
      type;
      /** Parent id of the node. */
      parentId;
      /** Name of the FS entry. */
      name;
      /** A reference to the tree. */
      tree;
      constructor(opts, tree) {
        this.id = opts.id;
        this.type = opts.type;
        this.name = opts.name ?? void 0;
        this.parentId = opts.parentId ?? void 0;
        this.tree = tree;
      }
      get parent() {
        if (!this.parentId) {
          return void 0;
        } else {
          const directory = this.tree.nodes.get(this.parentId);
          if (directory?.isDirNode()) {
            return directory;
          }
          return void 0;
        }
      }
      get path() {
        if (!this.parentId)
          return "/";
        if (this.parentId === Tree_1.ROOT_ID)
          return `/${this.name}`;
        return this.parent.path.concat(`/${this.name}`);
      }
      /** Returns whether this node is a {@link File}. */
      isFile() {
        return (0, ts_mixer_1.hasMixin)(this, File2);
      }
      /**
       * Returns whether this node is a {@link DirNode}.
       */
      isDirNode() {
        return (0, ts_mixer_1.hasMixin)(this, DirNode);
      }
      /**
       * Returns whether this node is a {@link Directory}.
       *
       * This does *not* include immutable directories like {@link ROOT}.
       * To identify {@link Directory} or {@link ImmutableDirectory}, use {@link isDirNode}.
       */
      isDirectory() {
        return (0, ts_mixer_1.hasMixin)(this, Directory);
      }
      /** Returns whether this node is a {@link MutableNode}. */
      isMutable() {
        return (0, ts_mixer_1.hasMixin)(this, MutableNode);
      }
      /** Returns whether this node is an {@link ImmutableDirectory}. */
      isImmutableDirectory() {
        return (0, ts_mixer_1.hasMixin)(this, ImmutableDirectory);
      }
    };
    exports.BaseNode = BaseNode;
    var MutableNode = class extends BaseNode {
      /** This node's parent node. */
      get parent() {
        return super.parent;
      }
      /** Move this node to the provided directory node. */
      move(parent, name) {
        this.tree.moveNode(this.id, parent.id, name);
      }
      /**
       * Rename this node to the provided name.
       * Optionally, move it to the provided parent directory node.
       */
      rename(name) {
        this.tree.moveNode(this.id, this.parentId, name);
      }
      /** Delete this node. */
      delete() {
        this.tree.deleteNode(this.id);
      }
    };
    exports.MutableNode = MutableNode;
    var DirNode = class extends BaseNode {
      /** Returns an array of a node's children. */
      get children() {
        const children = [];
        const childMap = this.tree.children.get(this.id);
        if (!childMap)
          return children;
        for (const childId of childMap.keys()) {
          const child = this.tree.nodes.get(childId);
          (0, errors_1.nodeExists)(child, `Attempting to get non-existent child of ${this}.`);
          children.push(child);
        }
        return children;
      }
      /** Find a child node by name */
      getChildByName(name) {
        const childMap = this.tree.children.get(this.id);
        if (!childMap)
          return void 0;
        const childId = childMap.getKey(name);
        if (!childId)
          return void 0;
        return this.tree.nodes.get(childId);
      }
      /** Create a file within this directory. */
      createFileWithId(id, name) {
        const node = createNode({ id, type: NodeType2.File, name, parentId: this.id }, this.tree);
        this.tree._addNode(node);
        return this.tree.nodes.get(id);
      }
      createFile(name) {
        const id = (0, Id_1.newId)();
        return this.createFileWithId(id, name);
      }
      /** Create a directory within this directory. */
      createDirectoryWithId(id, name) {
        const node = createNode({ id, type: NodeType2.Directory, name, parentId: this.id }, this.tree);
        this.tree._addNode(node);
        return this.tree.nodes.get(id);
      }
      /** Create a directory within this directory. */
      createDirectory(name) {
        const id = (0, Id_1.newId)();
        return this.createDirectoryWithId(id, name);
      }
    };
    exports.DirNode = DirNode;
    var File2 = class extends MutableNode {
    };
    exports.File = File2;
    var Directory = class extends (0, ts_mixer_1.Mixin)(MutableNode, DirNode) {
    };
    exports.Directory = Directory;
    var ImmutableDirectory = class extends DirNode {
      get parent() {
        return super.parent;
      }
    };
    exports.ImmutableDirectory = ImmutableDirectory;
  }
});

// node_modules/oo-ascii-tree/lib/ascii-tree.js
var require_ascii_tree = __commonJS({
  "node_modules/oo-ascii-tree/lib/ascii-tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsciiTree = void 0;
    var AsciiTree = class {
      /**
       * Creates a node.
       * @param text The node's text content
       * @param children Children of this node (can also be added via "add")
       */
      constructor(text, ...children) {
        this.text = text;
        this._children = new Array();
        for (const child of children) {
          this.add(child);
        }
      }
      /**
       * Prints the tree to an output stream.
       */
      printTree(output = process.stdout) {
        let ancestorsPrefix = "";
        for (const parent of this.ancestors) {
          if (parent.level <= 0) {
            continue;
          }
          if (parent.last) {
            ancestorsPrefix += "  ";
          } else {
            ancestorsPrefix += " \u2502";
          }
        }
        let myPrefix = "";
        let multilinePrefix = "";
        if (this.level > 0) {
          if (this.last) {
            if (!this.empty) {
              myPrefix += " \u2514\u2500\u252C ";
              multilinePrefix += " \u2514\u2500\u252C ";
            } else {
              myPrefix += " \u2514\u2500\u2500 ";
              multilinePrefix = "     ";
            }
          } else {
            if (!this.empty) {
              myPrefix += " \u251C\u2500\u252C ";
              multilinePrefix += " \u2502 \u2502 ";
            } else {
              myPrefix += " \u251C\u2500\u2500 ";
              multilinePrefix += " \u2502   ";
            }
          }
        }
        if (this.text) {
          output.write(ancestorsPrefix);
          output.write(myPrefix);
          const lines = this.text.split("\n");
          output.write(lines[0]);
          output.write("\n");
          for (const line of lines.splice(1)) {
            output.write(ancestorsPrefix);
            output.write(multilinePrefix);
            output.write(line);
            output.write("\n");
          }
        }
        for (const child of this._children) {
          child.printTree(output);
        }
      }
      /**
       * Returns a string representation of the tree.
       */
      toString() {
        let out = "";
        const printer = {
          write: (data) => {
            out += data;
            return true;
          }
        };
        this.printTree(printer);
        return out;
      }
      /**
       * Adds children to the node.
       */
      add(...children) {
        for (const child of children) {
          child.parent = this;
          this._children.push(child);
        }
      }
      /**
       * Returns a copy of the children array.
       */
      get children() {
        return this._children.map((x3) => x3);
      }
      /**
       * @returns true if this is the root node
       */
      get root() {
        return !this.parent;
      }
      /**
       * @returns true if this is the last child
       */
      get last() {
        if (!this.parent) {
          return true;
        }
        return this.parent.children.indexOf(this) === this.parent.children.length - 1;
      }
      /**
       * @returns the node level (0 is the root node)
       */
      get level() {
        if (!this.parent) {
          return this.text ? 0 : -1;
        }
        return this.parent.level + 1;
      }
      /**
       * @returns true if this node does not have any children
       */
      get empty() {
        return this.children.length === 0;
      }
      /**
       * @returns an array of parent nodes (from the root to this node, exclusive)
       */
      get ancestors() {
        if (!this.parent) {
          return [];
        }
        return [...this.parent.ancestors, this.parent];
      }
    };
    exports.AsciiTree = AsciiTree;
  }
});

// node_modules/oo-ascii-tree/lib/index.js
var require_lib = __commonJS({
  "node_modules/oo-ascii-tree/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ascii_tree(), exports);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/serializer.js
var require_serializer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treeAsString = void 0;
    var index_1 = require_dist3();
    var oo_ascii_tree_1 = require_lib();
    function treeAsString(fsTree) {
      const asciiTree = new oo_ascii_tree_1.AsciiTree("root");
      function populateBranch(branch, id) {
        const children = fsTree.children.get(id);
        if (!children)
          return;
        const childBranches = [...children.keys()].map((id2) => {
          const node = fsTree.getNodeById(id2);
          const typeEmoji = node?.type === index_1.bedrockFS.NodeType.File ? "\u{1F4C4}" : "\u{1F4C1}";
          const fileName = node?.name;
          const asciiNode = new oo_ascii_tree_1.AsciiTree(`${typeEmoji} ${fileName}`);
          populateBranch(asciiNode, id2);
          return asciiNode;
        }).sort((a3, b) => {
          if (a3.text === b.text) {
            return a3.children.length > b.children.length ? 1 : -1;
          }
          return a3.text > b.text ? 1 : -1;
        });
        branch.add(...childBranches);
        return branch;
      }
      populateBranch(asciiTree, fsTree.root.id);
      return asciiTree.toString();
    }
    exports.treeAsString = treeAsString;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/index.js
var require_BedrockFS = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TreeNode(), exports);
    __exportStar(require_Tree(), exports);
    __exportStar(require_serializer(), exports);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/shell-escape.js
var require_shell_escape = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/shell-escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shellescape = void 0;
    function shellescape(a3) {
      const ret = [];
      a3.forEach(function(s3) {
        if (/[^A-Za-z0-9_/:=-]/.test(s3)) {
          s3 = "'" + s3.replace(/'/g, "'\\''") + "'";
          s3 = s3.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
        }
        ret.push(s3);
      });
      return ret.join(" ");
    }
    exports.shellescape = shellescape;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/object.js
var require_object = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get = void 0;
    function get2(obj, path, seperator = ".") {
      if (obj == null) {
        return void 0;
      }
      const pathParts = path.split(seperator);
      for (const key of pathParts) {
        if (typeof obj !== "object" || obj == null) {
          return void 0;
        }
        obj = obj[key];
      }
      return obj;
    }
    exports.get = get2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/mutex.js
var require_mutex = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMutex = void 0;
    var createMutex2 = () => {
      let token = true;
      return (f3, g) => {
        if (token) {
          token = false;
          try {
            f3();
          } finally {
            token = true;
          }
        } else if (g !== void 0) {
          g();
        }
      };
    };
    exports.createMutex = createMutex2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames2() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee = new Array(l3); i4 < l3; i4++) {
        ee[i4] = handlers[i4].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a22);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn || once && !listeners[i4].once || context2 && listeners[i4].context !== context2) {
            events.push(listeners[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module) {
    "use strict";
    module.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports, module) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module.exports = pTimeout;
    module.exports.default = pTimeout;
    module.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a3, b) => b.priority - a3.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventEmitter2 = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter2 {
      constructor(options) {
        var _a2, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a2 = options.intervalCap) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports.default = PQueue;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _3 in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range2 = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max2 = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e3) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a3, b) {
      var arr = [];
      for (var i4 = 0; i4 < a3.length; i4 += 1) {
        arr[i4] = a3[i4];
      }
      for (var j3 = 0; j3 < b.length; j3 += 1) {
        arr[j3 + a3.length] = b[j3];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i4 = offset || 0, j3 = 0; i4 < arrLike.length; i4 += 1, j3 += 1) {
        arr[j3] = arrLike[i4];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i4 = 0; i4 < arr.length; i4 += 1) {
        str += arr[i4];
        if (i4 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i4 = 0; i4 < boundLength; i4++) {
        boundArgs[i4] = "$" + i4;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor = (
      /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype
    );
    var desc = hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range2();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max2();
    var min = require_min();
    var pow = require_pow();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getDunderProto = require_get();
    var getProto = typeof Reflect === "function" && Reflect.getPrototypeOf || $Object.getPrototypeOf || getDunderProto;
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow
    };
    if (getProto) {
      try {
        null.error;
      } catch (e3) {
        errorProto = getProto(getProto(e3));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i4 = 1, isOwn = true; i4 < parts.length; i4 += 1) {
        var part = parts[i4];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i4 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e3) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf2 = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e3) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_3) {
        if (_3 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e3) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e3) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e3) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e3) {
        if (e3 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i4 = 0, len = array.length; i4 < len; i4++) {
        if (hasOwnProperty.call(array, i4)) {
          if (receiver == null) {
            iterator(array[i4], i4, array);
          } else {
            iterator.call(receiver, array[i4], i4, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i4 = 0, len = string.length; i4 < len; i4++) {
        if (receiver == null) {
          iterator(string.charAt(i4), i4, string);
        } else {
          iterator.call(receiver, string.charAt(i4), i4, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k4 in object) {
        if (hasOwnProperty.call(object, k4)) {
          if (receiver == null) {
            iterator(object[k4], k4, object);
          } else {
            iterator.call(receiver, object[k4], k4, object);
          }
        }
      }
    };
    var forEach2 = function forEach3(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach2;
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i4 = 0; i4 < possibleNames.length; i4++) {
        if (typeof g[possibleNames[i4]] === "function") {
          out[out.length] = possibleNames[i4];
        }
      }
      return out;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf2 = callBound("Array.prototype.indexOf", true) || function indexOf2(array, value) {
      for (var i4 = 0; i4 < array.length; i4 += 1) {
        if (array[i4] === value) {
          return i4;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach2(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e3) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach2(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e3) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf2(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types2 = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f3) {
      return f3.call.bind(f3);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e3) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i4 = 0; i4 < keys.length; i4++) {
        descriptors[keys[i4]] = Object.getOwnPropertyDescriptor(obj, keys[i4]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f3) {
      if (!isString(f3)) {
        var objects = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          objects.push(inspect(arguments[i4]));
        }
        return objects.join(" ");
      }
      var i4 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f3).replace(formatRegExp, function(x4) {
        if (x4 === "%%") return "%";
        if (i4 >= len) return x4;
        switch (x4) {
          case "%s":
            return String(args[i4++]);
          case "%d":
            return Number(args[i4++]);
          case "%j":
            try {
              return JSON.stringify(args[i4++]);
            } catch (_3) {
              return "[Circular]";
            }
          default:
            return x4;
        }
      });
      for (var x3 = args[i4]; i4 < len; x3 = args[++i4]) {
        if (isNull(x3) || !isObject2(x3)) {
          str += " " + x3;
        } else {
          str += " " + inspect(x3);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set2) {
      set2 = set2.toUpperCase();
      if (!debugs[set2]) {
        if (debugEnvRegex.test(set2)) {
          var pid = process.pid;
          debugs[set2] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set2, pid, msg);
          };
        } else {
          debugs[set2] = function() {
          };
        }
      }
      return debugs[set2];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base = " [Function" + n2 + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i4 = 0, l3 = value.length; i4 < l3; ++i4) {
        if (hasOwnProperty(value, String(i4))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i4),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types2();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject2(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject2;
    function isDate(d2) {
      return isObject2(d2) && objectToString(d2) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e3) {
      return isObject2(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o2) {
      return Object.prototype.toString.call(o2);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d2 = /* @__PURE__ */ new Date();
      var time = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds())
      ].join(":");
      return [d2.getDate(), months[d2.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys = Object.keys(add);
      var i4 = keys.length;
      while (i4--) {
        origin[keys[i4]] = add[keys[i4]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args.push(arguments[i4]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args.push(arguments[i4]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n2 = 0, type) => {
      const node = block.nodes[n2];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i4 = 0; i4 < arr.length; i4++) {
          const ele = arr[i4];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    module.exports = (ast, options = {}) => {
      const stringify = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a3 = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a3 - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a: a3, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a3 < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a3), state, opts);
        a3 = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a3, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare2);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i4 = 0; i4 < digits; i4++) {
        let [startDigit, stopDigit] = zipped[i4];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i4 = 0; i4 < ranges.length; i4++) {
        let max2 = ranges[i4];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a3, b) {
      let arr = [];
      for (let i4 = 0; i4 < a3.length; i4++) arr.push([a3[i4], b[i4]]);
      return arr;
    }
    function compare2(a3, b) {
      return a3 > b ? 1 : b > a3 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a3, b, options) {
      return `[${a3}${b - a3 === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var toRegexRange = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-") value = value.slice(1);
      if (value === "0") return false;
      while (value[++index] === "0") ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a3, b) => a3 < b ? -1 : a3 > b ? 1 : 0);
      parts.positives.sort((a3, b) => a3 < b ? -1 : a3 > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v3) => toMaxLen(String(v3), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v3) => toMaxLen(String(v3), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a3, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a3, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a3);
      if (a3 === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a3 = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a3) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a3 === 0) a3 = 0;
      if (b === 0) b = 0;
      let descending = a3 > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a3 >= b : a3 <= b) {
        if (options.toRegex === true && step > 1) {
          push(a3);
        } else {
          range.push(pad(format(a3, index), maxLen, toNumber));
        }
        a3 = descending ? a3 - step : a3 + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a3 = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a3 > b;
      let min = Math.min(a3, b);
      let max = Math.max(a3, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a3 >= b : a3 <= b) {
        range.push(format(a3, index));
        a3 = descending ? a3 - step : a3 + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject2(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject2(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils3();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify2();
    var utils = require_utils3();
    var append2 = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append2(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append2(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p2 = parent;
        let q2 = parent.queue;
        while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
          p2 = p2.parent;
          q2 = p2.queue;
        }
        if (node.invalid || node.dollar) {
          q2.push(append2(q2.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q2.push(append2(q2.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q2.push(append2(q2.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i4 = 0; i4 < node.nodes.length; i4++) {
          const child = node.nodes[i4];
          if (child.type === "comma" && node.type === "brace") {
            if (i4 === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q2.push(append2(q2.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append2(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify2();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i4 = 0; i4 <= path.length; ++i4) {
        if (i4 < path.length)
          code = path.charCodeAt(i4);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i4 - 1 || dots === 1) {
          } else if (lastSlash !== i4 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i4;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i4;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i4);
            else
              res = path.slice(lastSlash + 1, i4);
            lastSegmentLength = i4 - lastSlash - 1;
          }
          lastSlash = i4;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i4 = arguments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--) {
          var path;
          if (i4 >= 0)
            path = arguments[i4];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i4 = 0; i4 < arguments.length; ++i4) {
          var arg = arguments[i4];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i4 = 0;
        for (; i4 <= length; ++i4) {
          if (i4 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i4) === 47) {
                return to.slice(toStart + i4 + 1);
              } else if (i4 === 0) {
                return to.slice(toStart + i4);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i4) === 47) {
                lastCommonSep = i4;
              } else if (i4 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i4);
          var toCode = to.charCodeAt(toStart + i4);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i4;
        }
        var out = "";
        for (i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4) {
          if (i4 === fromEnd || from.charCodeAt(i4) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i4 = path.length - 1; i4 >= 1; --i4) {
          code = path.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              end = i4;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i4;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i4 = path.length - 1; i4 >= 0; --i4) {
            var code = path.charCodeAt(i4);
            if (code === 47) {
              if (!matchedSlash) {
                start = i4 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i4 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i4;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i4 = path.length - 1; i4 >= 0; --i4) {
            if (path.charCodeAt(i4) === 47) {
              if (!matchedSlash) {
                start = i4 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i4 + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i4 = path.length - 1; i4 >= 0; --i4) {
          var code = path.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i4 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i4;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i4 = path.length - 1;
        var preDotState = 0;
        for (; i4 >= start; --i4) {
          code = path.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i4 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path = require_path_browserify();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require_path_browserify();
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend2 = options.contains ? "" : "^";
      const append2 = options.contains ? "" : "$";
      let output = `${prepend2}(?:${input})${append2}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i4 = slashes[idx];
          const value = input.slice(n2, i4);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i4;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils4();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v3) => utils.escapeRegex(v3)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m3;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i4 = arr.length - 1; i4 >= 0; i4--) {
              tokens.pop();
              if (arr[i4].type === "brace") {
                break;
              }
              if (arr[i4].type !== "dots") {
                range.unshift(arr[i4].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t3 of toks) {
              state.output += t3.output || t3.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create4 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create4(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create4(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path = require_path_browserify();
    var scan = require_scan();
    var parse = require_parse3();
    var utils = require_utils4();
    var constants = require_constants2();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p2) => picomatch.parse(p2, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend2 = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend2}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils4();
    var isEmptyString = (v3) => v3 === "" || v3 === "./";
    var hasBraces = (v3) => {
      const index = v3.indexOf("{");
      return index > -1 && v3.indexOf("}", index) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult3 = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i4 = 0; i4 < patterns.length; i4++) {
        let isMatch = picomatch(String(patterns[i4]), { ...options, onResult: onResult3 }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p2) => p2.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult3 = (state) => {
        if (options.onResult) options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult: onResult3 }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p2) => micromatch.contains(str, p2, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p2) => picomatch(p2, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v3) => v3 === void 0 ? "" : v3);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module.exports = micromatch;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/glob.js
var require_glob = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/glob.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GlobCache = void 0;
    var micromatch_1 = __importDefault(require_micromatch());
    var GlobCache2 = class {
      _cache = /* @__PURE__ */ new Map();
      get(pattern) {
        let re = this._cache.get(pattern);
        if (!re) {
          re = micromatch_1.default.makeRe(pattern, { dot: true });
          this._cache.set(pattern, re);
        }
        return re;
      }
      clear() {
        this._cache = /* @__PURE__ */ new Map();
      }
    };
    exports.GlobCache = GlobCache2;
  }
});

// node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/strip-json-comments/index.js"(exports, module) {
    "use strict";
    var singleComment = Symbol("singleComment");
    var multiComment = Symbol("multiComment");
    var stripWithoutWhitespace = () => "";
    var stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
    var isEscaped = (jsonString, quotePosition) => {
      let index = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index] === "\\") {
        index -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    };
    module.exports = (jsonString, options = {}) => {
      if (typeof jsonString !== "string") {
        throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
      }
      const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      let insideString = false;
      let insideComment = false;
      let offset = 0;
      let result = "";
      for (let i4 = 0; i4 < jsonString.length; i4++) {
        const currentCharacter = jsonString[i4];
        const nextCharacter = jsonString[i4 + 1];
        if (!insideComment && currentCharacter === '"') {
          const escaped = isEscaped(jsonString, i4);
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentCharacter + nextCharacter === "//") {
          result += jsonString.slice(offset, i4);
          offset = i4;
          insideComment = singleComment;
          i4++;
        } else if (insideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
          i4++;
          insideComment = false;
          result += strip(jsonString, offset, i4);
          offset = i4;
          continue;
        } else if (insideComment === singleComment && currentCharacter === "\n") {
          insideComment = false;
          result += strip(jsonString, offset, i4);
          offset = i4;
        } else if (!insideComment && currentCharacter + nextCharacter === "/*") {
          result += jsonString.slice(offset, i4);
          offset = i4;
          insideComment = multiComment;
          i4++;
          continue;
        } else if (insideComment === multiComment && currentCharacter + nextCharacter === "*/") {
          i4++;
          insideComment = false;
          result += strip(jsonString, offset, i4 + 1);
          offset = i4 + 1;
          continue;
        }
      }
      return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
    };
  }
});

// node_modules/@codesandbox/pitcher-common/dist/jsonc.js
var require_jsonc = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/jsonc.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var strip_json_comments_1 = __importDefault(require_strip_json_comments());
    function parse(text) {
      const withoutComments = (0, strip_json_comments_1.default)(text);
      return JSON.parse(withoutComments);
    }
    exports.parse = parse;
    function stringify(json) {
      return JSON.stringify(json);
    }
    exports.stringify = stringify;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/WorkerMessageBus.js
var require_WorkerMessageBus = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/WorkerMessageBus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkerMessageBus = void 0;
    var Disposable_1 = require_Disposable();
    var WorkerMessageBus = class extends Disposable_1.Disposable {
      endpoint;
      handleRequest;
      handleNotification;
      handleError;
      channel;
      timeoutMs;
      pendingRequests = /* @__PURE__ */ new Map();
      _messageId = 0;
      constructor(opts) {
        super();
        this.channel = opts.channel;
        this.endpoint = opts.endpoint;
        this.handleRequest = opts.handleRequest;
        this.handleNotification = opts.handleNotification;
        this.handleError = opts.handleError;
        this.timeoutMs = opts.timeoutMs;
        const disposeMessageListener = this.endpoint.onMessage(async (data) => {
          if (data.channel !== this.channel) {
            return;
          }
          const messageId = data.id;
          if (data.method) {
            if (messageId == null) {
              this.handleNotification(data.method, data.data);
            } else if (data.method && data.params) {
              try {
                const result = await this.handleRequest(data.method, data.params);
                this.endpoint.send({
                  id: messageId,
                  channel: this.channel,
                  result
                });
              } catch (err) {
                this.endpoint.send({
                  id: messageId,
                  channel: this.channel,
                  error: String(err)
                });
              }
            }
          } else if (messageId != null) {
            const pendingRequest = this.pendingRequests.get(messageId);
            if (!pendingRequest) {
              return;
            }
            if (data.error !== void 0) {
              pendingRequest.reject(data.error);
            } else {
              pendingRequest.resolve(data.result);
            }
          }
        });
        this.toDispose.push(disposeMessageListener);
        const disposeErrorListener = this.endpoint.onError((err) => {
          this.handleError(err);
        });
        this.toDispose.push(disposeErrorListener);
      }
      nextMessageId() {
        this._messageId++;
        return this._messageId;
      }
      request(method, params) {
        const messageId = this.nextMessageId();
        const message = {
          channel: this.channel,
          id: messageId,
          method,
          params
        };
        const promise = new Promise((resolve, reject) => {
          const timeoutRef = setTimeout(() => {
            this.pendingRequests.delete(messageId);
            reject(new Error(`Request on channel ${this.channel} timed out`));
          }, this.timeoutMs);
          this.pendingRequests.set(messageId, {
            resolve: (data) => {
              clearTimeout(timeoutRef);
              resolve(data);
            },
            reject: (err) => {
              clearTimeout(timeoutRef);
              reject(err);
            }
          });
        });
        this.endpoint.send(message);
        return promise;
      }
    };
    exports.WorkerMessageBus = WorkerMessageBus;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/PromiseQueue.js
var require_PromiseQueue = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/PromiseQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseQueue = void 0;
    var Id_1 = require_Id();
    var PromiseQueue = class {
      items = [];
      runningTasks = /* @__PURE__ */ new Map();
      name;
      debug;
      concurrency;
      constructor(options) {
        const { name, debug: debug4 = false, concurrency = 25 } = options;
        this.name = name;
        this.debug = debug4;
        this.concurrency = concurrency;
      }
      async processQueue() {
        if (this.runningTasks.size >= this.concurrency)
          return;
        const item = this.items.shift();
        if (item) {
          const key = item.key;
          if (this.runningTasks.has(key)) {
            this.items.push(item);
            return;
          }
          if (this.debug) {
            console.log(`Running queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.runningTasks.set(key, item);
          try {
            const result = await item.callback();
            for (const resolve of item.resolves) {
              try {
                resolve(result);
              } catch (err) {
              }
            }
          } catch (err) {
            for (const reject of item.rejects) {
              try {
                reject(err);
              } catch (err2) {
              }
            }
          }
          this.runningTasks.delete(key);
          if (this.debug) {
            console.log(`Processed queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.processQueue();
        }
      }
      /**
       * Add a new promise callback to the queue
       *
       * in case you provide a key it will be used to de-duplicate against existing items in the queue
       * if there is an existing item, the callback of that item will be used and this function will
       * return the result of that callback instead
       */
      add(callback, key) {
        if (this.debug) {
          console.log(`Adding item ${this.name}#${key ?? "unknown"} to the queue`);
        }
        return new Promise((resolve, reject) => {
          let shouldAdd = true;
          let item = {
            key: key ?? (0, Id_1.newId)(),
            callback,
            resolves: [],
            rejects: []
          };
          if (key) {
            const foundItem = this.items.find((i4) => i4.key === key);
            if (foundItem) {
              item = foundItem;
              item.callback = callback;
              shouldAdd = false;
            }
          }
          item.resolves.push(resolve);
          item.rejects.push(reject);
          if (shouldAdd) {
            this.items.push(item);
          }
          this.processQueue().catch(console.error);
        });
      }
    };
    exports.PromiseQueue = PromiseQueue;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/ContextualError.js
var require_ContextualError = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/ContextualError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextualError = void 0;
    var ContextualError = class extends Error {
      code;
      /** Parent operation context. */
      context;
      error;
      publicMessage;
      constructor(options) {
        super(options.publicMessage);
        this.name = "ContextualError";
        this.code = options.code;
        this.error = options.error;
        this.stack = options.error.stack;
        this.publicMessage = options.publicMessage;
        if (!options.code) {
          throw new Error(`Failed to create a contextual "${this.name}" without an error code.`);
        }
      }
      /**
       * Extend this error with a parental context.
       * @param context Parental context.
       * @example
       * const error = new ContextualError({
       *   code: 'GIT_PULL_REJECTED',
       *   details,
       * })
       * error.setContext('GIT_COMMIT')
       */
      setContext(context2) {
        this.context = context2;
        return this;
      }
    };
    exports.ContextualError = ContextualError;
  }
});

// node_modules/lru_map/dist/lru.js
var require_lru = __commonJS({
  "node_modules/lru_map/dist/lru.js"(exports, module) {
    !function(g, c3) {
      typeof exports == "object" && typeof module != "undefined" ? c3(exports) : typeof define == "function" && define.amd ? define(["exports"], c3) : c3((g = g || self).lru_map = g.lru_map || {});
    }(exports, function(g) {
      const c3 = Symbol("newer"), e3 = Symbol("older");
      class n2 {
        constructor(a3, b) {
          typeof a3 !== "number" && (b = a3, a3 = 0), this.size = 0, this.limit = a3, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a3 < 1 && (this.limit = this.size));
        }
        _markEntryAsUsed(a3) {
          if (a3 === this.newest) return;
          a3[c3] && (a3 === this.oldest && (this.oldest = a3[c3]), a3[c3][e3] = a3[e3]), a3[e3] && (a3[e3][c3] = a3[c3]), a3[c3] = void 0, a3[e3] = this.newest, this.newest && (this.newest[c3] = a3), this.newest = a3;
        }
        assign(a3) {
          let b, d2 = this.limit || Number.MAX_VALUE;
          this._keymap.clear();
          let m3 = a3[Symbol.iterator]();
          for (let h3 = m3.next(); !h3.done; h3 = m3.next()) {
            let f3 = new l3(h3.value[0], h3.value[1]);
            this._keymap.set(f3.key, f3), b ? (b[c3] = f3, f3[e3] = b) : this.oldest = f3, b = f3;
            if (d2-- == 0) throw new Error("overflow");
          }
          this.newest = b, this.size = this._keymap.size;
        }
        get(a3) {
          var b = this._keymap.get(a3);
          return b ? (this._markEntryAsUsed(b), b.value) : void 0;
        }
        set(a3, b) {
          var d2 = this._keymap.get(a3);
          return d2 ? (d2.value = b, this._markEntryAsUsed(d2), this) : (this._keymap.set(a3, d2 = new l3(a3, b)), this.newest ? (this.newest[c3] = d2, d2[e3] = this.newest) : this.oldest = d2, this.newest = d2, ++this.size, this.size > this.limit && this.shift(), this);
        }
        shift() {
          var a3 = this.oldest;
          if (a3) return this.oldest[c3] ? (this.oldest = this.oldest[c3], this.oldest[e3] = void 0) : (this.oldest = void 0, this.newest = void 0), a3[c3] = a3[e3] = void 0, this._keymap.delete(a3.key), --this.size, [a3.key, a3.value];
        }
        find(a3) {
          let b = this._keymap.get(a3);
          return b ? b.value : void 0;
        }
        has(a3) {
          return this._keymap.has(a3);
        }
        delete(a3) {
          var b = this._keymap.get(a3);
          return b ? (this._keymap.delete(b.key), b[c3] && b[e3] ? (b[e3][c3] = b[c3], b[c3][e3] = b[e3]) : b[c3] ? (b[c3][e3] = void 0, this.oldest = b[c3]) : b[e3] ? (b[e3][c3] = void 0, this.newest = b[e3]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
        }
        clear() {
          this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
        }
        keys() {
          return new j3(this.oldest);
        }
        values() {
          return new k4(this.oldest);
        }
        entries() {
          return this;
        }
        [Symbol.iterator]() {
          return new i4(this.oldest);
        }
        forEach(a3, b) {
          typeof b !== "object" && (b = this);
          let d2 = this.oldest;
          for (; d2; ) a3.call(b, d2.value, d2.key, this), d2 = d2[c3];
        }
        toJSON() {
          for (var a3 = new Array(this.size), b = 0, d2 = this.oldest; d2; ) a3[b++] = { key: d2.key, value: d2.value }, d2 = d2[c3];
          return a3;
        }
        toString() {
          for (var a3 = "", b = this.oldest; b; ) a3 += String(b.key) + ":" + b.value, b = b[c3], b && (a3 += " < ");
          return a3;
        }
      }
      g.LRUMap = n2;
      function l3(a3, b) {
        this.key = a3, this.value = b, this[c3] = void 0, this[e3] = void 0;
      }
      function i4(a3) {
        this.entry = a3;
      }
      i4.prototype[Symbol.iterator] = function() {
        return this;
      }, i4.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: [a3.key, a3.value] }) : { done: true, value: void 0 };
      };
      function j3(a3) {
        this.entry = a3;
      }
      j3.prototype[Symbol.iterator] = function() {
        return this;
      }, j3.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: a3.key }) : { done: true, value: void 0 };
      };
      function k4(a3) {
        this.entry = a3;
      }
      k4.prototype[Symbol.iterator] = function() {
        return this;
      }, k4.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: a3.value }) : { done: true, value: void 0 };
      };
    });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Throttle.js
var require_Throttle = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Throttle = void 0;
    var Throttle = class {
      lastExecution = 0;
      timeoutRef = null;
      ms;
      callback;
      constructor(callback, ms) {
        this.ms = ms;
        this.callback = callback;
        this.lastExecution = 0;
        this.timeoutRef = null;
      }
      execute() {
        if (Date.now() - this.lastExecution >= this.ms) {
          this.callback();
          this.lastExecution = Date.now();
        } else if (!this.timeoutRef) {
          this.timeoutRef = setTimeout(() => {
            this.lastExecution = Date.now();
            this.timeoutRef = null;
            this.callback();
          }, this.ms - (Date.now() - this.lastExecution));
        }
      }
      clear() {
        if (this.timeoutRef) {
          clearTimeout(this.timeoutRef);
          this.timeoutRef = null;
        }
        this.lastExecution = Date.now();
      }
    };
    exports.Throttle = Throttle;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/template-literals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.undent = void 0;
    function undent(strings, ...interps) {
      let string = "";
      for (let i4 = 0; i4 < strings.length; i4++) {
        string += `${strings[i4] || ""}${interps[i4] || ""}`;
      }
      string = string.replace(/^[\r\n]+/, "").replace(/\s+$/, "");
      const dents = string.match(/^([ \t])*/gm);
      if (!dents || dents.length == 0) {
        return string;
      }
      dents.sort((dent1, dent2) => dent1.length - dent2.length);
      const minDent = dents[0];
      if (!minDent) {
        return string;
      }
      const dedented = string.replace(new RegExp(`^${minDent}`, "gm"), "");
      return dedented;
    }
    exports.undent = undent;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/color.js
var require_color = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRandomColor = void 0;
    function hslToHex(h3, s3, l3) {
      h3 /= 360;
      s3 /= 100;
      l3 /= 100;
      let r3, g, b;
      if (s3 === 0) {
        r3 = g = b = l3;
      } else {
        const hue2rgb = (p3, q3, t3) => {
          if (t3 < 0)
            t3 += 1;
          if (t3 > 1)
            t3 -= 1;
          if (t3 < 1 / 6)
            return p3 + (q3 - p3) * 6 * t3;
          if (t3 < 1 / 2)
            return q3;
          if (t3 < 2 / 3)
            return p3 + (q3 - p3) * (2 / 3 - t3) * 6;
          return p3;
        };
        const q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
        const p2 = 2 * l3 - q2;
        r3 = hue2rgb(p2, q2, h3 + 1 / 3);
        g = hue2rgb(p2, q2, h3);
        b = hue2rgb(p2, q2, h3 - 1 / 3);
      }
      const toHex = (c3) => {
        const hex = Math.round(c3 * 255).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      };
      const hexR = toHex(r3);
      const hexG = toHex(g);
      const hexB = toHex(b);
      return `#${hexR}${hexG}${hexB}`;
    }
    function getRandomColor() {
      const hue = Math.floor(Math.random() * 360);
      const saturation = Math.floor(Math.random() * 25) + 75;
      const lightness = Math.floor(Math.random() * 25) + 75;
      return hslToHex(hue, saturation, lightness);
    }
    exports.getRandomColor = getRandomColor;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4)) __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRandomColor = exports.undent = exports.Throttle = exports.LRUMap = exports.DeduplicatingPromiseQueue = exports.SliceList = exports.WorkerMessageBus = exports.jsonc = exports.micromatch = exports.GlobCache = exports.SerialQueue = exports.PromiseQueue = exports.createMutex = exports.object = exports.shellescape = exports.bedrockFS = exports.BidirectionalMap = exports.Debouncer = exports.Aborter = exports.murmur = exports.nullthrows = exports.timeout = exports.sleep = exports.pRetry = exports.ot = exports.AsyncEmitter = exports.listenOnce = exports.Emitter = exports.EventEmitter = exports.DisposableStore = exports.Disposable = exports.newId = exports.ClosableBarrier = exports.Barrier = void 0;
    var Barrier_1 = require_Barrier();
    Object.defineProperty(exports, "Barrier", { enumerable: true, get: function() {
      return Barrier_1.Barrier;
    } });
    Object.defineProperty(exports, "ClosableBarrier", { enumerable: true, get: function() {
      return Barrier_1.ClosableBarrier;
    } });
    var Id_1 = require_Id();
    Object.defineProperty(exports, "newId", { enumerable: true, get: function() {
      return Id_1.newId;
    } });
    var Disposable_1 = require_Disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return Disposable_1.Disposable;
    } });
    Object.defineProperty(exports, "DisposableStore", { enumerable: true, get: function() {
      return Disposable_1.DisposableStore;
    } });
    var EventEmitter_1 = require_EventEmitter();
    Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function() {
      return EventEmitter_1.EventEmitter;
    } });
    var event_1 = require_event();
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return event_1.Emitter;
    } });
    Object.defineProperty(exports, "listenOnce", { enumerable: true, get: function() {
      return event_1.listenOnce;
    } });
    Object.defineProperty(exports, "AsyncEmitter", { enumerable: true, get: function() {
      return event_1.AsyncEmitter;
    } });
    exports.ot = __importStar(require_operational_transforms());
    exports.pRetry = __importStar(require_p_retry());
    __exportStar(require_fetch(), exports);
    var sleep_1 = require_sleep();
    Object.defineProperty(exports, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var nullthrows_1 = require_nullthrows();
    Object.defineProperty(exports, "nullthrows", { enumerable: true, get: function() {
      return nullthrows_1.nullthrows;
    } });
    var murmur_1 = require_murmur();
    Object.defineProperty(exports, "murmur", { enumerable: true, get: function() {
      return murmur_1.murmur;
    } });
    var Aborter_1 = require_Aborter();
    Object.defineProperty(exports, "Aborter", { enumerable: true, get: function() {
      return Aborter_1.Aborter;
    } });
    var Debouncer_1 = require_Debouncer();
    Object.defineProperty(exports, "Debouncer", { enumerable: true, get: function() {
      return Debouncer_1.Debouncer;
    } });
    var BidirectionalMap_1 = require_BidirectionalMap();
    Object.defineProperty(exports, "BidirectionalMap", { enumerable: true, get: function() {
      return BidirectionalMap_1.BidirectionalMap;
    } });
    exports.bedrockFS = __importStar(require_BedrockFS());
    var shell_escape_1 = require_shell_escape();
    Object.defineProperty(exports, "shellescape", { enumerable: true, get: function() {
      return shell_escape_1.shellescape;
    } });
    exports.object = __importStar(require_object());
    var mutex_1 = require_mutex();
    Object.defineProperty(exports, "createMutex", { enumerable: true, get: function() {
      return mutex_1.createMutex;
    } });
    var p_queue_1 = require_dist2();
    Object.defineProperty(exports, "PromiseQueue", { enumerable: true, get: function() {
      return __importDefault(p_queue_1).default;
    } });
    var SerialQueue_1 = require_SerialQueue();
    Object.defineProperty(exports, "SerialQueue", { enumerable: true, get: function() {
      return SerialQueue_1.SerialQueue;
    } });
    var glob_1 = require_glob();
    Object.defineProperty(exports, "GlobCache", { enumerable: true, get: function() {
      return glob_1.GlobCache;
    } });
    var micromatch_1 = require_micromatch();
    Object.defineProperty(exports, "micromatch", { enumerable: true, get: function() {
      return __importDefault(micromatch_1).default;
    } });
    exports.jsonc = __importStar(require_jsonc());
    var WorkerMessageBus_1 = require_WorkerMessageBus();
    Object.defineProperty(exports, "WorkerMessageBus", { enumerable: true, get: function() {
      return WorkerMessageBus_1.WorkerMessageBus;
    } });
    var SliceList_1 = require_SliceList();
    Object.defineProperty(exports, "SliceList", { enumerable: true, get: function() {
      return SliceList_1.SliceList;
    } });
    var PromiseQueue_1 = require_PromiseQueue();
    Object.defineProperty(exports, "DeduplicatingPromiseQueue", { enumerable: true, get: function() {
      return PromiseQueue_1.PromiseQueue;
    } });
    __exportStar(require_ContextualError(), exports);
    var lru_map_1 = require_lru();
    Object.defineProperty(exports, "LRUMap", { enumerable: true, get: function() {
      return lru_map_1.LRUMap;
    } });
    var Throttle_1 = require_Throttle();
    Object.defineProperty(exports, "Throttle", { enumerable: true, get: function() {
      return Throttle_1.Throttle;
    } });
    var template_literals_1 = require_template_literals();
    Object.defineProperty(exports, "undent", { enumerable: true, get: function() {
      return template_literals_1.undent;
    } });
    var color_1 = require_color();
    Object.defineProperty(exports, "getRandomColor", { enumerable: true, get: function() {
      return color_1.getRandomColor;
    } });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/protocol.js
var require_protocol = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PitcherResponseStatus = void 0;
    var PitcherResponseStatus4;
    (function(PitcherResponseStatus5) {
      PitcherResponseStatus5[PitcherResponseStatus5["RESOLVED"] = 0] = "RESOLVED";
      PitcherResponseStatus5[PitcherResponseStatus5["REJECTED"] = 1] = "REJECTED";
    })(PitcherResponseStatus4 || (exports.PitcherResponseStatus = PitcherResponseStatus4 = {}));
  }
});

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint64 = exports.getInt64 = exports.setInt64 = exports.setUint64 = exports.UINT32_MAX = void 0;
    exports.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports) {
    "use strict";
    var _a2;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8DecodeTD = exports.TEXT_DECODER_THRESHOLD = exports.utf8DecodeJs = exports.utf8EncodeTE = exports.TEXT_ENCODER_THRESHOLD = exports.utf8EncodeJs = exports.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a2 = process === null || process === void 0 ? void 0 : process.env) === null || _a2 === void 0 ? void 0 : _a2["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecodeError = void 0;
    var DecodeError = class _DecodeError extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(_DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: _DecodeError.name
        });
      }
    };
    exports.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampExtension = exports.decodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimestampExtension = exports.encodeDateToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports.decodeTimestampExtension = decodeTimestampExtension;
    exports.timestampExtension = {
      type: exports.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context2) {
        for (let i4 = 0; i4 < this.builtInEncoders.length; i4++) {
          const encodeExt = this.builtInEncoders[i4];
          if (encodeExt != null) {
            const data = encodeExt(object, context2);
            if (data != null) {
              const type = -1 - i4;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i4 = 0; i4 < this.encoders.length; i4++) {
          const encodeExt = this.encoders[i4];
          if (encodeExt != null) {
            const data = encodeExt(object, context2);
            if (data != null) {
              const type = i4;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context2) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context2);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.DEFAULT_INITIAL_BUFFER_SIZE = exports.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports.DEFAULT_MAX_DEPTH = 100;
    exports.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context2 = void 0, maxDepth = exports.DEFAULT_MAX_DEPTH, initialBufferSize = exports.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context2;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i4 = 0; i4 < this.maxKeyLength; i4++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK: for (const record of records) {
          const recordBytes = record.bytes;
          for (let j3 = 0; j3 < byteLength; j3++) {
            if (recordBytes[j3] !== bytes[inputOffset + j3]) {
              continue FIND_CHUNK;
            }
          }
          return record.str;
        }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e3) {
        return e3.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context2 = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context2;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e3) {
            if (!(e3 instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e3;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e3) {
            if (!(e3 instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e3;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE: while (true) {
          const headByte = this.readHeadByte();
          let object;
          if (headByte >= 224) {
            object = headByte - 256;
          } else if (headByte < 192) {
            if (headByte < 128) {
              object = headByte;
            } else if (headByte < 144) {
              const size = headByte - 128;
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte < 160) {
              const size = headByte - 144;
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else {
              const byteLength = headByte - 160;
              object = this.decodeUtf8String(byteLength, 0);
            }
          } else if (headByte === 192) {
            object = null;
          } else if (headByte === 194) {
            object = false;
          } else if (headByte === 195) {
            object = true;
          } else if (headByte === 202) {
            object = this.readF32();
          } else if (headByte === 203) {
            object = this.readF64();
          } else if (headByte === 204) {
            object = this.readU8();
          } else if (headByte === 205) {
            object = this.readU16();
          } else if (headByte === 206) {
            object = this.readU32();
          } else if (headByte === 207) {
            object = this.readU64();
          } else if (headByte === 208) {
            object = this.readI8();
          } else if (headByte === 209) {
            object = this.readI16();
          } else if (headByte === 210) {
            object = this.readI32();
          } else if (headByte === 211) {
            object = this.readI64();
          } else if (headByte === 217) {
            const byteLength = this.lookU8();
            object = this.decodeUtf8String(byteLength, 1);
          } else if (headByte === 218) {
            const byteLength = this.lookU16();
            object = this.decodeUtf8String(byteLength, 2);
          } else if (headByte === 219) {
            const byteLength = this.lookU32();
            object = this.decodeUtf8String(byteLength, 4);
          } else if (headByte === 220) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 221) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 222) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 223) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 196) {
            const size = this.lookU8();
            object = this.decodeBinary(size, 1);
          } else if (headByte === 197) {
            const size = this.lookU16();
            object = this.decodeBinary(size, 2);
          } else if (headByte === 198) {
            const size = this.lookU32();
            object = this.decodeBinary(size, 4);
          } else if (headByte === 212) {
            object = this.decodeExtension(1, 0);
          } else if (headByte === 213) {
            object = this.decodeExtension(2, 0);
          } else if (headByte === 214) {
            object = this.decodeExtension(4, 0);
          } else if (headByte === 215) {
            object = this.decodeExtension(8, 0);
          } else if (headByte === 216) {
            object = this.decodeExtension(16, 0);
          } else if (headByte === 199) {
            const size = this.lookU8();
            object = this.decodeExtension(size, 1);
          } else if (headByte === 200) {
            const size = this.lookU16();
            object = this.decodeExtension(size, 2);
          } else if (headByte === 201) {
            const size = this.lookU32();
            object = this.decodeExtension(size, 4);
          } else {
            throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
          }
          this.complete();
          const stack = this.stack;
          while (stack.length > 0) {
            const state = stack[stack.length - 1];
            if (state.type === 0) {
              state.array[state.position] = object;
              state.position++;
              if (state.position === state.size) {
                stack.pop();
                object = state.array;
              } else {
                continue DECODE;
              }
            } else if (state.type === 1) {
              if (!isValidMapKeyType(object)) {
                throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
              }
              if (object === "__proto__") {
                throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
              }
              state.key = object;
              state.type = 2;
              continue DECODE;
            } else {
              state.map[state.key] = object;
              state.readCount++;
              if (state.readCount === state.size) {
                stack.pop();
                object = state.map;
              } else {
                state.key = null;
                state.type = 1;
                continue DECODE;
              }
            }
          }
          return object;
        }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a2;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a2 = this.keyDecoder) === null || _a2 === void 0 ? void 0 : _a2.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMulti = exports.decode = exports.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports.defaultDecodeOptions = {};
    function decode(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports.decode = decode;
    function decodeMulti(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAsyncIterable = exports.asyncIterableFromStream = exports.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream();
    var decode_1 = require_decode();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTimestampExtension = exports.encodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.encodeDateToTimeSpec = exports.EXT_TIMESTAMP = exports.ExtData = exports.ExtensionCodec = exports.Encoder = exports.DataViewIndexOutOfBoundsError = exports.DecodeError = exports.Decoder = exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = exports.decodeMulti = exports.decode = exports.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/message.js
var require_message = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createResponsePayload = exports.createRequestPayload = exports.createNotificationPayload = exports.isResultPayload = exports.isErrorPayload = exports.isNotificationPayload = exports.decodeMessage = exports.encodeMessage = void 0;
    var msgpack_1 = require_dist4();
    function encodeMessage(message) {
      return (0, msgpack_1.encode)(message);
    }
    exports.encodeMessage = encodeMessage;
    function decodeMessage2(blob) {
      return (0, msgpack_1.decode)(blob);
    }
    exports.decodeMessage = decodeMessage2;
    function isNotificationPayload2(payload) {
      return !("id" in payload) && "params" in payload;
    }
    exports.isNotificationPayload = isNotificationPayload2;
    function isErrorPayload2(payload) {
      return "error" in payload;
    }
    exports.isErrorPayload = isErrorPayload2;
    function isResultPayload3(payload) {
      return "result" in payload;
    }
    exports.isResultPayload = isResultPayload3;
    function createNotificationPayload(payload) {
      return encodeMessage(payload);
    }
    exports.createNotificationPayload = createNotificationPayload;
    function createRequestPayload2(payload) {
      return encodeMessage(payload);
    }
    exports.createRequestPayload = createRequestPayload2;
    function createResponsePayload(payload) {
      return encodeMessage(payload);
    }
    exports.createResponsePayload = createResponsePayload;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/package.json
var require_package = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/package.json"(exports, module) {
    module.exports = {
      name: "@codesandbox/pitcher-protocol",
      version: "0.360.2",
      repository: {
        type: "git",
        url: "ssh://git@github.com/codesandbox/pitcher.git",
        directory: "packages/pitcher-protocol"
      },
      license: "GPL-3.0",
      main: "dist/src/index.js",
      types: "dist/src/index.d.ts",
      files: [
        "dist"
      ],
      scripts: {
        build: "yarn clean && yarn compile",
        clean: "rm -fr ./dist",
        compile: "tsc -b tsconfig.build.json",
        test: "jest"
      },
      dependencies: {
        "@codesandbox/pitcher-common": "*",
        "@msgpack/msgpack": "^2.7.1"
      }
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/errors.js
var require_errors3 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PitcherErrorCode = void 0;
    var PitcherErrorCode2;
    (function(PitcherErrorCode3) {
      PitcherErrorCode3[PitcherErrorCode3["CRITICAL_ERROR"] = 0] = "CRITICAL_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["FEATURE_UNAVAILABLE"] = 1] = "FEATURE_UNAVAILABLE";
      PitcherErrorCode3[PitcherErrorCode3["NO_ACCESS"] = 2] = "NO_ACCESS";
      PitcherErrorCode3[PitcherErrorCode3["RATE_LIMIT"] = 3] = "RATE_LIMIT";
      PitcherErrorCode3[PitcherErrorCode3["INVALID_ID"] = 100] = "INVALID_ID";
      PitcherErrorCode3[PitcherErrorCode3["INVALID_PATH"] = 101] = "INVALID_PATH";
      PitcherErrorCode3[PitcherErrorCode3["RAWFS_ERROR"] = 102] = "RAWFS_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_NOT_ACCESSIBLE"] = 200] = "SHELL_NOT_ACCESSIBLE";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_CLOSED"] = 201] = "SHELL_CLOSED";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_NOT_FOUND"] = 204] = "SHELL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["MODEL_NOT_FOUND"] = 300] = "MODEL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["GIT_OPERATION_IN_PROGRESS"] = 400] = "GIT_OPERATION_IN_PROGRESS";
      PitcherErrorCode3[PitcherErrorCode3["GIT_REMOTE_FILE_NOT_FOUND"] = 404] = "GIT_REMOTE_FILE_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["GIT_FETCH_FAIL"] = 410] = "GIT_FETCH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PULL_CONFLICT"] = 420] = "GIT_PULL_CONFLICT";
      PitcherErrorCode3[PitcherErrorCode3["GIT_RESET_LOCAL_REMOTE_ERROR"] = 430] = "GIT_RESET_LOCAL_REMOTE_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PUSH_FAIL"] = 440] = "GIT_PUSH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_RESET_CHECKOUT_INITIAL_BRANCH_FAIL"] = 450] = "GIT_RESET_CHECKOUT_INITIAL_BRANCH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PULL_FAIL"] = 460] = "GIT_PULL_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_TRANSPOSE_LINES_FAIL"] = 470] = "GIT_TRANSPOSE_LINES_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["CHANNEL_NOT_FOUND"] = 500] = "CHANNEL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["CONFIG_FILE_ALREADY_EXISTS"] = 600] = "CONFIG_FILE_ALREADY_EXISTS";
      PitcherErrorCode3[PitcherErrorCode3["TASK_NOT_FOUND"] = 601] = "TASK_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["COMMAND_ALREADY_CONFIGURED"] = 602] = "COMMAND_ALREADY_CONFIGURED";
      PitcherErrorCode3[PitcherErrorCode3["COMMAND_NOT_FOUND"] = 704] = "COMMAND_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["AI_NOT_AVAILABLE"] = 800] = "AI_NOT_AVAILABLE";
      PitcherErrorCode3[PitcherErrorCode3["PROMPT_TOO_BIG"] = 801] = "PROMPT_TOO_BIG";
      PitcherErrorCode3[PitcherErrorCode3["FAILED_TO_RESPOND"] = 802] = "FAILED_TO_RESPOND";
      PitcherErrorCode3[PitcherErrorCode3["AI_TOO_FREQUENT_REQUESTS"] = 803] = "AI_TOO_FREQUENT_REQUESTS";
      PitcherErrorCode3[PitcherErrorCode3["AI_CHAT_NOT_FOUND"] = 814] = "AI_CHAT_NOT_FOUND";
    })(PitcherErrorCode2 || (exports.PitcherErrorCode = PitcherErrorCode2 = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/client.js
var require_client = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientDisposeReason = exports.ClientAuthorization = void 0;
    var ClientAuthorization;
    (function(ClientAuthorization2) {
      ClientAuthorization2["READ"] = "Read";
      ClientAuthorization2["WRITE"] = "Write";
      ClientAuthorization2["OWNER"] = "Owner";
    })(ClientAuthorization || (exports.ClientAuthorization = ClientAuthorization = {}));
    var ClientDisposeReason;
    (function(ClientDisposeReason2) {
      ClientDisposeReason2["AUTHORIZATION_CHANGED"] = "AuthorizationChanged";
      ClientDisposeReason2["DISCONNECT"] = "Disconnect";
      ClientDisposeReason2["PITCHER_SHUTDOWN"] = "PitcherShutdown";
    })(ClientDisposeReason || (exports.ClientDisposeReason = ClientDisposeReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/ai.js
var require_ai = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/ai.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/port.js
var require_port = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/port.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/language.js
var require_language = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/language.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/git.js
var require_git = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/git.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GitStatusShortFormat = void 0;
    var GitStatusShortFormat;
    (function(GitStatusShortFormat2) {
      GitStatusShortFormat2["UnModified"] = "";
      GitStatusShortFormat2["Modified"] = "M";
      GitStatusShortFormat2["Added"] = "A";
      GitStatusShortFormat2["Deleted"] = "D";
      GitStatusShortFormat2["Renamed"] = "R";
      GitStatusShortFormat2["Copied"] = "C";
      GitStatusShortFormat2["Updated"] = "U";
      GitStatusShortFormat2["Untracked"] = "?";
    })(GitStatusShortFormat || (exports.GitStatusShortFormat = GitStatusShortFormat = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/setup.js
var require_setup = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/setup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/fs.js
var require_fs = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FSOperationResponseCode = void 0;
    var FSOperationResponseCode;
    (function(FSOperationResponseCode2) {
      FSOperationResponseCode2[FSOperationResponseCode2["Success"] = 0] = "Success";
      FSOperationResponseCode2[FSOperationResponseCode2["Ignored"] = 1] = "Ignored";
    })(FSOperationResponseCode || (exports.FSOperationResponseCode = FSOperationResponseCode = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/channel.js
var require_channel = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/channel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/task.js
var require_task = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/task.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/file.js
var require_file = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionsUpdateReason = void 0;
    var SelectionsUpdateReason;
    (function(SelectionsUpdateReason2) {
      SelectionsUpdateReason2[SelectionsUpdateReason2["CONTENT_CHANGE"] = 0] = "CONTENT_CHANGE";
      SelectionsUpdateReason2[SelectionsUpdateReason2["SELECTION"] = 1] = "SELECTION";
      SelectionsUpdateReason2[SelectionsUpdateReason2["CLIENT_LEFT"] = 2] = "CLIENT_LEFT";
    })(SelectionsUpdateReason || (exports.SelectionsUpdateReason = SelectionsUpdateReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/system.js
var require_system = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/shell.js
var require_shell = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/shell.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/command.js
var require_command = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/notification.js
var require_notification = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m3, p2);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4)) __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notification = exports.command = exports.shell = exports.system = exports.file = exports.task = exports.channel = exports.client = exports.fs = exports.setup = exports.git = exports.language = exports.port = exports.ai = exports.ClientDisposeReason = exports.ClientAuthorization = exports.PitcherErrorCode = exports.version = void 0;
    __exportStar(require_protocol(), exports);
    __exportStar(require_message(), exports);
    var package_json_1 = require_package();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return package_json_1.version;
    } });
    var errors_1 = require_errors3();
    Object.defineProperty(exports, "PitcherErrorCode", { enumerable: true, get: function() {
      return errors_1.PitcherErrorCode;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports, "ClientAuthorization", { enumerable: true, get: function() {
      return client_1.ClientAuthorization;
    } });
    Object.defineProperty(exports, "ClientDisposeReason", { enumerable: true, get: function() {
      return client_1.ClientDisposeReason;
    } });
    exports.ai = __importStar(require_ai());
    exports.port = __importStar(require_port());
    exports.language = __importStar(require_language());
    exports.git = __importStar(require_git());
    exports.setup = __importStar(require_setup());
    exports.fs = __importStar(require_fs());
    exports.client = __importStar(require_client());
    exports.channel = __importStar(require_channel());
    exports.task = __importStar(require_task());
    exports.file = __importStar(require_file());
    exports.system = __importStar(require_system());
    exports.shell = __importStar(require_shell());
    exports.command = __importStar(require_command());
    exports.notification = __importStar(require_notification());
  }
});

// node_modules/core-js/modules/_global.js
var require_global = __commonJS({
  "node_modules/core-js/modules/_global.js"(exports, module) {
    var global3 = module.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number") __g = global3;
  }
});

// node_modules/core-js/modules/_core.js
var require_core = __commonJS({
  "node_modules/core-js/modules/_core.js"(exports, module) {
    var core = module.exports = { version: "2.6.0" };
    if (typeof __e == "number") __e = core;
  }
});

// node_modules/core-js/modules/_is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/modules/_is-object.js"(exports, module) {
    module.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/modules/_an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/modules/_an-object.js"(exports, module) {
    var isObject2 = require_is_object();
    module.exports = function(it) {
      if (!isObject2(it)) throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_fails.js
var require_fails = __commonJS({
  "node_modules/core-js/modules/_fails.js"(exports, module) {
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (e3) {
        return true;
      }
    };
  }
});

// node_modules/core-js/modules/_descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/modules/_descriptors.js"(exports, module) {
    module.exports = !require_fails()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_dom-create.js
var require_dom_create = __commonJS({
  "node_modules/core-js/modules/_dom-create.js"(exports, module) {
    var isObject2 = require_is_object();
    var document2 = require_global().document;
    var is2 = isObject2(document2) && isObject2(document2.createElement);
    module.exports = function(it) {
      return is2 ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/modules/_ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/modules/_ie8-dom-define.js"(exports, module) {
    module.exports = !require_descriptors() && !require_fails()(function() {
      return Object.defineProperty(require_dom_create()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/modules/_to-primitive.js"(exports, module) {
    var isObject2 = require_is_object();
    module.exports = function(it, S3) {
      if (!isObject2(it)) return it;
      var fn, val;
      if (S3 && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it))) return val;
      if (!S3 && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/modules/_object-dp.js
var require_object_dp = __commonJS({
  "node_modules/core-js/modules/_object-dp.js"(exports) {
    var anObject2 = require_an_object();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var toPrimitive = require_to_primitive();
    var dP2 = Object.defineProperty;
    exports.f = require_descriptors() ? Object.defineProperty : function defineProperty(O3, P3, Attributes) {
      anObject2(O3);
      P3 = toPrimitive(P3, true);
      anObject2(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP2(O3, P3, Attributes);
      } catch (e3) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O3[P3] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/modules/_property-desc.js
var require_property_desc = __commonJS({
  "node_modules/core-js/modules/_property-desc.js"(exports, module) {
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/modules/_hide.js
var require_hide = __commonJS({
  "node_modules/core-js/modules/_hide.js"(exports, module) {
    var dP2 = require_object_dp();
    var createDesc = require_property_desc();
    module.exports = require_descriptors() ? function(object, key, value) {
      return dP2.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/modules/_has.js
var require_has = __commonJS({
  "node_modules/core-js/modules/_has.js"(exports, module) {
    var hasOwnProperty = {}.hasOwnProperty;
    module.exports = function(it, key) {
      return hasOwnProperty.call(it, key);
    };
  }
});

// node_modules/core-js/modules/_uid.js
var require_uid = __commonJS({
  "node_modules/core-js/modules/_uid.js"(exports, module) {
    var id = 0;
    var px = Math.random();
    module.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/modules/_redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/modules/_redefine.js"(exports, module) {
    var global3 = require_global();
    var hide2 = require_hide();
    var has = require_has();
    var SRC = require_uid()("src");
    var TO_STRING = "toString";
    var $toString = Function[TO_STRING];
    var TPL = ("" + $toString).split(TO_STRING);
    require_core().inspectSource = function(it) {
      return $toString.call(it);
    };
    (module.exports = function(O3, key, val, safe) {
      var isFunction = typeof val == "function";
      if (isFunction) has(val, "name") || hide2(val, "name", key);
      if (O3[key] === val) return;
      if (isFunction) has(val, SRC) || hide2(val, SRC, O3[key] ? "" + O3[key] : TPL.join(String(key)));
      if (O3 === global3) {
        O3[key] = val;
      } else if (!safe) {
        delete O3[key];
        hide2(O3, key, val);
      } else if (O3[key]) {
        O3[key] = val;
      } else {
        hide2(O3, key, val);
      }
    })(Function.prototype, TO_STRING, function toString() {
      return typeof this == "function" && this[SRC] || $toString.call(this);
    });
  }
});

// node_modules/core-js/modules/_a-function.js
var require_a_function = __commonJS({
  "node_modules/core-js/modules/_a-function.js"(exports, module) {
    module.exports = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_ctx.js
var require_ctx = __commonJS({
  "node_modules/core-js/modules/_ctx.js"(exports, module) {
    var aFunction = require_a_function();
    module.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a3) {
            return fn.call(that, a3);
          };
        case 2:
          return function(a3, b) {
            return fn.call(that, a3, b);
          };
        case 3:
          return function(a3, b, c3) {
            return fn.call(that, a3, b, c3);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/modules/_export.js
var require_export = __commonJS({
  "node_modules/core-js/modules/_export.js"(exports, module) {
    var global3 = require_global();
    var core = require_core();
    var hide2 = require_hide();
    var redefine2 = require_redefine();
    var ctx = require_ctx();
    var PROTOTYPE = "prototype";
    var $export10 = function(type, name, source) {
      var IS_FORCED = type & $export10.F;
      var IS_GLOBAL = type & $export10.G;
      var IS_STATIC = type & $export10.S;
      var IS_PROTO = type & $export10.P;
      var IS_BIND = type & $export10.B;
      var target = IS_GLOBAL ? global3 : IS_STATIC ? global3[name] || (global3[name] = {}) : (global3[name] || {})[PROTOTYPE];
      var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
      var key, own, out, exp;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        out = (own ? target : source)[key];
        exp = IS_BIND && own ? ctx(out, global3) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (target) redefine2(target, key, out, type & $export10.U);
        if (exports2[key] != out) hide2(exports2, key, exp);
        if (IS_PROTO && expProto[key] != out) expProto[key] = out;
      }
    };
    global3.core = core;
    $export10.F = 1;
    $export10.G = 2;
    $export10.S = 4;
    $export10.P = 8;
    $export10.B = 16;
    $export10.W = 32;
    $export10.U = 64;
    $export10.R = 128;
    module.exports = $export10;
  }
});

// node_modules/core-js/modules/_cof.js
var require_cof = __commonJS({
  "node_modules/core-js/modules/_cof.js"(exports, module) {
    var toString = {}.toString;
    module.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/modules/_iobject.js
var require_iobject = __commonJS({
  "node_modules/core-js/modules/_iobject.js"(exports, module) {
    var cof = require_cof();
    module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/modules/_defined.js
var require_defined = __commonJS({
  "node_modules/core-js/modules/_defined.js"(exports, module) {
    module.exports = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/modules/_to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/modules/_to-object.js"(exports, module) {
    var defined = require_defined();
    module.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/modules/_to-integer.js
var require_to_integer = __commonJS({
  "node_modules/core-js/modules/_to-integer.js"(exports, module) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/modules/_to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/modules/_to-length.js"(exports, module) {
    var toInteger = require_to_integer();
    var min = Math.min;
    module.exports = function(it) {
      return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/modules/_is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/modules/_is-array.js"(exports, module) {
    var cof = require_cof();
    module.exports = Array.isArray || function isArray(arg) {
      return cof(arg) == "Array";
    };
  }
});

// node_modules/core-js/modules/_library.js
var require_library = __commonJS({
  "node_modules/core-js/modules/_library.js"(exports, module) {
    module.exports = false;
  }
});

// node_modules/core-js/modules/_shared.js
var require_shared = __commonJS({
  "node_modules/core-js/modules/_shared.js"(exports, module) {
    var core = require_core();
    var global3 = require_global();
    var SHARED = "__core-js_shared__";
    var store = global3[SHARED] || (global3[SHARED] = {});
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library() ? "pure" : "global",
      copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/modules/_wks.js
var require_wks = __commonJS({
  "node_modules/core-js/modules/_wks.js"(exports, module) {
    var store = require_shared()("wks");
    var uid = require_uid();
    var Symbol2 = require_global().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/modules/_array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/modules/_array-species-constructor.js"(exports, module) {
    var isObject2 = require_is_object();
    var isArray = require_is_array();
    var SPECIES = require_wks()("species");
    module.exports = function(original) {
      var C3;
      if (isArray(original)) {
        C3 = original.constructor;
        if (typeof C3 == "function" && (C3 === Array || isArray(C3.prototype))) C3 = void 0;
        if (isObject2(C3)) {
          C3 = C3[SPECIES];
          if (C3 === null) C3 = void 0;
        }
      }
      return C3 === void 0 ? Array : C3;
    };
  }
});

// node_modules/core-js/modules/_array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/modules/_array-species-create.js"(exports, module) {
    var speciesConstructor = require_array_species_constructor();
    module.exports = function(original, length) {
      return new (speciesConstructor(original))(length);
    };
  }
});

// node_modules/core-js/modules/_array-methods.js
var require_array_methods = __commonJS({
  "node_modules/core-js/modules/_array-methods.js"(exports, module) {
    var ctx = require_ctx();
    var IObject = require_iobject();
    var toObject = require_to_object();
    var toLength2 = require_to_length();
    var asc = require_array_species_create();
    module.exports = function(TYPE, $create) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      var create4 = $create || asc;
      return function($this, callbackfn, that) {
        var O3 = toObject($this);
        var self2 = IObject(O3);
        var f3 = ctx(callbackfn, that, 3);
        var length = toLength2(self2.length);
        var index = 0;
        var result = IS_MAP ? create4($this, length) : IS_FILTER ? create4($this, 0) : void 0;
        var val, res;
        for (; length > index; index++) if (NO_HOLES || index in self2) {
          val = self2[index];
          res = f3(val, index, O3);
          if (TYPE) {
            if (IS_MAP) result[index] = res;
            else if (res) switch (TYPE) {
              case 3:
                return true;
              // some
              case 5:
                return val;
              // find
              case 6:
                return index;
              // findIndex
              case 2:
                result.push(val);
            }
            else if (IS_EVERY) return false;
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
      };
    };
  }
});

// node_modules/core-js/modules/_add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/modules/_add-to-unscopables.js"(exports, module) {
    var UNSCOPABLES = require_wks()("unscopables");
    var ArrayProto = Array.prototype;
    if (ArrayProto[UNSCOPABLES] == void 0) require_hide()(ArrayProto, UNSCOPABLES, {});
    module.exports = function(key) {
      ArrayProto[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/babel-runtime/helpers/newArrowCheck.js
var require_newArrowCheck = __commonJS({
  "node_modules/babel-runtime/helpers/newArrowCheck.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    };
  }
});

// node_modules/@jumpn/utils-composite/node_modules/flow-static-land/lib/Fun.js
var require_Fun = __commonJS({
  "node_modules/@jumpn/utils-composite/node_modules/flow-static-land/lib/Fun.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.flip = flip;
    exports.constant = constant;
    exports.on = on;
    exports.compose = compose;
    exports.pipe = pipe;
    exports.curry = curry3;
    function flip(f3) {
      return function(b, a3) {
        return f3(a3, b);
      };
    }
    function constant(a3) {
      return function() {
        return a3;
      };
    }
    function on(o2, f3) {
      return function(x3, y3) {
        return o2(f3(x3), f3(y3));
      };
    }
    function compose() {
      var _this5 = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i = len; _i > -1; _i--) {
          y3 = fns[_i].call(_this5, y3);
        }
        return y3;
      };
    }
    function pipe() {
      var _this22 = this;
      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i2 = 0; _i2 <= len; _i2++) {
          y3 = fns[_i2].call(_this22, y3);
        }
        return y3;
      };
    }
    function curried(f3, length, acc) {
      return function() {
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f3.apply(this, combined) : curried(f3, length, combined);
      };
    }
    function curry3(f3) {
      return curried(f3, f3.length, []);
    }
  }
});

// node_modules/core-js/library/modules/_to-integer.js
var require_to_integer2 = __commonJS({
  "node_modules/core-js/library/modules/_to-integer.js"(exports, module) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/library/modules/_defined.js
var require_defined2 = __commonJS({
  "node_modules/core-js/library/modules/_defined.js"(exports, module) {
    module.exports = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_string-at.js
var require_string_at = __commonJS({
  "node_modules/core-js/library/modules/_string-at.js"(exports, module) {
    var toInteger = require_to_integer2();
    var defined = require_defined2();
    module.exports = function(TO_STRING) {
      return function(that, pos) {
        var s3 = String(defined(that));
        var i4 = toInteger(pos);
        var l3 = s3.length;
        var a3, b;
        if (i4 < 0 || i4 >= l3) return TO_STRING ? "" : void 0;
        a3 = s3.charCodeAt(i4);
        return a3 < 55296 || a3 > 56319 || i4 + 1 === l3 || (b = s3.charCodeAt(i4 + 1)) < 56320 || b > 57343 ? TO_STRING ? s3.charAt(i4) : a3 : TO_STRING ? s3.slice(i4, i4 + 2) : (a3 - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/library/modules/_library.js
var require_library2 = __commonJS({
  "node_modules/core-js/library/modules/_library.js"(exports, module) {
    module.exports = true;
  }
});

// node_modules/core-js/library/modules/_global.js
var require_global2 = __commonJS({
  "node_modules/core-js/library/modules/_global.js"(exports, module) {
    var global3 = module.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number") __g = global3;
  }
});

// node_modules/core-js/library/modules/_core.js
var require_core2 = __commonJS({
  "node_modules/core-js/library/modules/_core.js"(exports, module) {
    var core = module.exports = { version: "2.6.0" };
    if (typeof __e == "number") __e = core;
  }
});

// node_modules/core-js/library/modules/_a-function.js
var require_a_function2 = __commonJS({
  "node_modules/core-js/library/modules/_a-function.js"(exports, module) {
    module.exports = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_ctx.js
var require_ctx2 = __commonJS({
  "node_modules/core-js/library/modules/_ctx.js"(exports, module) {
    var aFunction = require_a_function2();
    module.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a3) {
            return fn.call(that, a3);
          };
        case 2:
          return function(a3, b) {
            return fn.call(that, a3, b);
          };
        case 3:
          return function(a3, b, c3) {
            return fn.call(that, a3, b, c3);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/library/modules/_is-object.js
var require_is_object2 = __commonJS({
  "node_modules/core-js/library/modules/_is-object.js"(exports, module) {
    module.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/library/modules/_an-object.js
var require_an_object2 = __commonJS({
  "node_modules/core-js/library/modules/_an-object.js"(exports, module) {
    var isObject2 = require_is_object2();
    module.exports = function(it) {
      if (!isObject2(it)) throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_fails.js
var require_fails2 = __commonJS({
  "node_modules/core-js/library/modules/_fails.js"(exports, module) {
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (e3) {
        return true;
      }
    };
  }
});

// node_modules/core-js/library/modules/_descriptors.js
var require_descriptors2 = __commonJS({
  "node_modules/core-js/library/modules/_descriptors.js"(exports, module) {
    module.exports = !require_fails2()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_dom-create.js
var require_dom_create2 = __commonJS({
  "node_modules/core-js/library/modules/_dom-create.js"(exports, module) {
    var isObject2 = require_is_object2();
    var document2 = require_global2().document;
    var is2 = isObject2(document2) && isObject2(document2.createElement);
    module.exports = function(it) {
      return is2 ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/library/modules/_ie8-dom-define.js
var require_ie8_dom_define2 = __commonJS({
  "node_modules/core-js/library/modules/_ie8-dom-define.js"(exports, module) {
    module.exports = !require_descriptors2() && !require_fails2()(function() {
      return Object.defineProperty(require_dom_create2()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_to-primitive.js
var require_to_primitive2 = __commonJS({
  "node_modules/core-js/library/modules/_to-primitive.js"(exports, module) {
    var isObject2 = require_is_object2();
    module.exports = function(it, S3) {
      if (!isObject2(it)) return it;
      var fn, val;
      if (S3 && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it))) return val;
      if (!S3 && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/library/modules/_object-dp.js
var require_object_dp2 = __commonJS({
  "node_modules/core-js/library/modules/_object-dp.js"(exports) {
    var anObject2 = require_an_object2();
    var IE8_DOM_DEFINE = require_ie8_dom_define2();
    var toPrimitive = require_to_primitive2();
    var dP2 = Object.defineProperty;
    exports.f = require_descriptors2() ? Object.defineProperty : function defineProperty(O3, P3, Attributes) {
      anObject2(O3);
      P3 = toPrimitive(P3, true);
      anObject2(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP2(O3, P3, Attributes);
      } catch (e3) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O3[P3] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/library/modules/_property-desc.js
var require_property_desc2 = __commonJS({
  "node_modules/core-js/library/modules/_property-desc.js"(exports, module) {
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/library/modules/_hide.js
var require_hide2 = __commonJS({
  "node_modules/core-js/library/modules/_hide.js"(exports, module) {
    var dP2 = require_object_dp2();
    var createDesc = require_property_desc2();
    module.exports = require_descriptors2() ? function(object, key, value) {
      return dP2.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/library/modules/_has.js
var require_has2 = __commonJS({
  "node_modules/core-js/library/modules/_has.js"(exports, module) {
    var hasOwnProperty = {}.hasOwnProperty;
    module.exports = function(it, key) {
      return hasOwnProperty.call(it, key);
    };
  }
});

// node_modules/core-js/library/modules/_export.js
var require_export2 = __commonJS({
  "node_modules/core-js/library/modules/_export.js"(exports, module) {
    var global3 = require_global2();
    var core = require_core2();
    var ctx = require_ctx2();
    var hide2 = require_hide2();
    var has = require_has2();
    var PROTOTYPE = "prototype";
    var $export10 = function(type, name, source) {
      var IS_FORCED = type & $export10.F;
      var IS_GLOBAL = type & $export10.G;
      var IS_STATIC = type & $export10.S;
      var IS_PROTO = type & $export10.P;
      var IS_BIND = type & $export10.B;
      var IS_WRAP = type & $export10.W;
      var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports2[PROTOTYPE];
      var target = IS_GLOBAL ? global3 : IS_STATIC ? global3[name] : (global3[name] || {})[PROTOTYPE];
      var key, own, out;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        if (own && has(exports2, key)) continue;
        out = own ? target[key] : source[key];
        exports2[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global3) : IS_WRAP && target[key] == out ? function(C3) {
          var F2 = function(a3, b, c3) {
            if (this instanceof C3) {
              switch (arguments.length) {
                case 0:
                  return new C3();
                case 1:
                  return new C3(a3);
                case 2:
                  return new C3(a3, b);
              }
              return new C3(a3, b, c3);
            }
            return C3.apply(this, arguments);
          };
          F2[PROTOTYPE] = C3[PROTOTYPE];
          return F2;
        }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (IS_PROTO) {
          (exports2.virtual || (exports2.virtual = {}))[key] = out;
          if (type & $export10.R && expProto && !expProto[key]) hide2(expProto, key, out);
        }
      }
    };
    $export10.F = 1;
    $export10.G = 2;
    $export10.S = 4;
    $export10.P = 8;
    $export10.B = 16;
    $export10.W = 32;
    $export10.U = 64;
    $export10.R = 128;
    module.exports = $export10;
  }
});

// node_modules/core-js/library/modules/_redefine.js
var require_redefine2 = __commonJS({
  "node_modules/core-js/library/modules/_redefine.js"(exports, module) {
    module.exports = require_hide2();
  }
});

// node_modules/core-js/library/modules/_iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/library/modules/_iterators.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/core-js/library/modules/_cof.js
var require_cof2 = __commonJS({
  "node_modules/core-js/library/modules/_cof.js"(exports, module) {
    var toString = {}.toString;
    module.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/library/modules/_iobject.js
var require_iobject2 = __commonJS({
  "node_modules/core-js/library/modules/_iobject.js"(exports, module) {
    var cof = require_cof2();
    module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/library/modules/_to-iobject.js
var require_to_iobject = __commonJS({
  "node_modules/core-js/library/modules/_to-iobject.js"(exports, module) {
    var IObject = require_iobject2();
    var defined = require_defined2();
    module.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_to-length.js
var require_to_length2 = __commonJS({
  "node_modules/core-js/library/modules/_to-length.js"(exports, module) {
    var toInteger = require_to_integer2();
    var min = Math.min;
    module.exports = function(it) {
      return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/library/modules/_to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/library/modules/_to-absolute-index.js"(exports, module) {
    var toInteger = require_to_integer2();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }
});

// node_modules/core-js/library/modules/_array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/library/modules/_array-includes.js"(exports, module) {
    var toIObject = require_to_iobject();
    var toLength2 = require_to_length2();
    var toAbsoluteIndex = require_to_absolute_index();
    module.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIObject($this);
        var length = toLength2(O3.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O3[index++];
          if (value != value) return true;
        }
        else for (; length > index; index++) if (IS_INCLUDES || index in O3) {
          if (O3[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/library/modules/_shared.js
var require_shared2 = __commonJS({
  "node_modules/core-js/library/modules/_shared.js"(exports, module) {
    var core = require_core2();
    var global3 = require_global2();
    var SHARED = "__core-js_shared__";
    var store = global3[SHARED] || (global3[SHARED] = {});
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library2() ? "pure" : "global",
      copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/library/modules/_uid.js
var require_uid2 = __commonJS({
  "node_modules/core-js/library/modules/_uid.js"(exports, module) {
    var id = 0;
    var px = Math.random();
    module.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/library/modules/_shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/library/modules/_shared-key.js"(exports, module) {
    var shared = require_shared2()("keys");
    var uid = require_uid2();
    module.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/library/modules/_object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/library/modules/_object-keys-internal.js"(exports, module) {
    var has = require_has2();
    var toIObject = require_to_iobject();
    var arrayIndexOf = require_array_includes()(false);
    var IE_PROTO = require_shared_key()("IE_PROTO");
    module.exports = function(object, names) {
      var O3 = toIObject(object);
      var i4 = 0;
      var result = [];
      var key;
      for (key in O3) if (key != IE_PROTO) has(O3, key) && result.push(key);
      while (names.length > i4) if (has(O3, key = names[i4++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-bug-keys.js"(exports, module) {
    module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/library/modules/_object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/library/modules/_object-keys.js"(exports, module) {
    var $keys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O3) {
      return $keys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/library/modules/_object-dps.js
var require_object_dps = __commonJS({
  "node_modules/core-js/library/modules/_object-dps.js"(exports, module) {
    var dP2 = require_object_dp2();
    var anObject2 = require_an_object2();
    var getKeys3 = require_object_keys();
    module.exports = require_descriptors2() ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject2(O3);
      var keys = getKeys3(Properties);
      var length = keys.length;
      var i4 = 0;
      var P3;
      while (length > i4) dP2.f(O3, P3 = keys[i4++], Properties[P3]);
      return O3;
    };
  }
});

// node_modules/core-js/library/modules/_html.js
var require_html = __commonJS({
  "node_modules/core-js/library/modules/_html.js"(exports, module) {
    var document2 = require_global2().document;
    module.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/library/modules/_object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/library/modules/_object-create.js"(exports, module) {
    var anObject2 = require_an_object2();
    var dPs = require_object_dps();
    var enumBugKeys = require_enum_bug_keys();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var Empty = function() {
    };
    var PROTOTYPE = "prototype";
    var createDict = function() {
      var iframe = require_dom_create2()("iframe");
      var i4 = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i4--) delete createDict[PROTOTYPE][enumBugKeys[i4]];
      return createDict();
    };
    module.exports = Object.create || function create4(O3, Properties) {
      var result;
      if (O3 !== null) {
        Empty[PROTOTYPE] = anObject2(O3);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    };
  }
});

// node_modules/core-js/library/modules/_wks.js
var require_wks2 = __commonJS({
  "node_modules/core-js/library/modules/_wks.js"(exports, module) {
    var store = require_shared2()("wks");
    var uid = require_uid2();
    var Symbol2 = require_global2().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/library/modules/_set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/library/modules/_set-to-string-tag.js"(exports, module) {
    var def = require_object_dp2().f;
    var has = require_has2();
    var TAG = require_wks2()("toStringTag");
    module.exports = function(it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/library/modules/_iter-create.js
var require_iter_create = __commonJS({
  "node_modules/core-js/library/modules/_iter-create.js"(exports, module) {
    "use strict";
    var create4 = require_object_create();
    var descriptor = require_property_desc2();
    var setToStringTag = require_set_to_string_tag();
    var IteratorPrototype = {};
    require_hide2()(IteratorPrototype, require_wks2()("iterator"), function() {
      return this;
    });
    module.exports = function(Constructor, NAME2, next) {
      Constructor.prototype = create4(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME2 + " Iterator");
    };
  }
});

// node_modules/core-js/library/modules/_to-object.js
var require_to_object2 = __commonJS({
  "node_modules/core-js/library/modules/_to-object.js"(exports, module) {
    var defined = require_defined2();
    module.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_object-gpo.js
var require_object_gpo = __commonJS({
  "node_modules/core-js/library/modules/_object-gpo.js"(exports, module) {
    var has = require_has2();
    var toObject = require_to_object2();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module.exports = Object.getPrototypeOf || function(O3) {
      O3 = toObject(O3);
      if (has(O3, IE_PROTO)) return O3[IE_PROTO];
      if (typeof O3.constructor == "function" && O3 instanceof O3.constructor) {
        return O3.constructor.prototype;
      }
      return O3 instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/library/modules/_iter-define.js
var require_iter_define = __commonJS({
  "node_modules/core-js/library/modules/_iter-define.js"(exports, module) {
    "use strict";
    var LIBRARY = require_library2();
    var $export10 = require_export2();
    var redefine2 = require_redefine2();
    var hide2 = require_hide2();
    var Iterators2 = require_iterators();
    var $iterCreate = require_iter_create();
    var setToStringTag = require_set_to_string_tag();
    var getPrototypeOf = require_object_gpo();
    var ITERATOR2 = require_wks2()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Base, NAME2, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME2, next);
      var getMethod = function(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch (kind) {
          case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }
        return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME2 + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto = Base.prototype;
      var $native2 = proto[ITERATOR2] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
      var $default = $native2 || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME2 == "Array" ? proto.entries || $native2 : $native2;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR2] != "function") hide2(IteratorPrototype, ITERATOR2, returnThis);
        }
      }
      if (DEF_VALUES && $native2 && $native2.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native2.call(this);
        };
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR2])) {
        hide2(proto, ITERATOR2, $default);
      }
      Iterators2[NAME2] = $default;
      Iterators2[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto)) redefine2(proto, key, methods[key]);
        }
        else $export10($export10.P + $export10.F * (BUGGY || VALUES_BUG), NAME2, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/library/modules/es6.string.iterator.js
var require_es6_string_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.string.iterator.js"() {
    "use strict";
    var $at = require_string_at()(true);
    require_iter_define()(String, "String", function(iterated) {
      this._t = String(iterated);
      this._i = 0;
    }, function() {
      var O3 = this._t;
      var index = this._i;
      var point;
      if (index >= O3.length) return { value: void 0, done: true };
      point = $at(O3, index);
      this._i += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/library/modules/_add-to-unscopables.js
var require_add_to_unscopables2 = __commonJS({
  "node_modules/core-js/library/modules/_add-to-unscopables.js"(exports, module) {
    module.exports = function() {
    };
  }
});

// node_modules/core-js/library/modules/_iter-step.js
var require_iter_step = __commonJS({
  "node_modules/core-js/library/modules/_iter-step.js"(exports, module) {
    module.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/library/modules/es6.array.iterator.js
var require_es6_array_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.array.iterator.js"(exports, module) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables2();
    var step = require_iter_step();
    var Iterators2 = require_iterators();
    var toIObject = require_to_iobject();
    module.exports = require_iter_define()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O3 = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O3 || index >= O3.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys") return step(0, index);
      if (kind == "values") return step(0, O3[index]);
      return step(0, [index, O3[index]]);
    }, "values");
    Iterators2.Arguments = Iterators2.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/library/modules/web.dom.iterable.js
var require_web_dom_iterable = __commonJS({
  "node_modules/core-js/library/modules/web.dom.iterable.js"() {
    require_es6_array_iterator();
    var global3 = require_global2();
    var hide2 = require_hide2();
    var Iterators2 = require_iterators();
    var TO_STRING_TAG2 = require_wks2()("toStringTag");
    var DOMIterables2 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
    for (i4 = 0; i4 < DOMIterables2.length; i4++) {
      NAME2 = DOMIterables2[i4];
      Collection = global3[NAME2];
      proto = Collection && Collection.prototype;
      if (proto && !proto[TO_STRING_TAG2]) hide2(proto, TO_STRING_TAG2, NAME2);
      Iterators2[NAME2] = Iterators2.Array;
    }
    var NAME2;
    var Collection;
    var proto;
    var i4;
  }
});

// node_modules/core-js/library/modules/_wks-ext.js
var require_wks_ext = __commonJS({
  "node_modules/core-js/library/modules/_wks-ext.js"(exports) {
    exports.f = require_wks2();
  }
});

// node_modules/core-js/library/fn/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/core-js/library/fn/symbol/iterator.js"(exports, module) {
    require_es6_string_iterator();
    require_web_dom_iterable();
    module.exports = require_wks_ext().f("iterator");
  }
});

// node_modules/babel-runtime/core-js/symbol/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol/iterator.js"(exports, module) {
    module.exports = { "default": require_iterator(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_meta.js
var require_meta = __commonJS({
  "node_modules/core-js/library/modules/_meta.js"(exports, module) {
    var META = require_uid2()("meta");
    var isObject2 = require_is_object2();
    var has = require_has2();
    var setDesc = require_object_dp2().f;
    var id = 0;
    var isExtensible = Object.isExtensible || function() {
      return true;
    };
    var FREEZE = !require_fails2()(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var setMeta = function(it) {
      setDesc(it, META, { value: {
        i: "O" + ++id,
        // object ID
        w: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create4) {
      if (!isObject2(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!has(it, META)) {
        if (!isExtensible(it)) return "F";
        if (!create4) return "E";
        setMeta(it);
      }
      return it[META].i;
    };
    var getWeak = function(it, create4) {
      if (!has(it, META)) {
        if (!isExtensible(it)) return true;
        if (!create4) return false;
        setMeta(it);
      }
      return it[META].w;
    };
    var onFreeze = function(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
      return it;
    };
    var meta = module.exports = {
      KEY: META,
      NEED: false,
      fastKey,
      getWeak,
      onFreeze
    };
  }
});

// node_modules/core-js/library/modules/_wks-define.js
var require_wks_define = __commonJS({
  "node_modules/core-js/library/modules/_wks-define.js"(exports, module) {
    var global3 = require_global2();
    var core = require_core2();
    var LIBRARY = require_library2();
    var wksExt = require_wks_ext();
    var defineProperty = require_object_dp2().f;
    module.exports = function(name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global3.Symbol || {});
      if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
    };
  }
});

// node_modules/core-js/library/modules/_object-gops.js
var require_object_gops = __commonJS({
  "node_modules/core-js/library/modules/_object-gops.js"(exports) {
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/library/modules/_object-pie.js
var require_object_pie = __commonJS({
  "node_modules/core-js/library/modules/_object-pie.js"(exports) {
    exports.f = {}.propertyIsEnumerable;
  }
});

// node_modules/core-js/library/modules/_enum-keys.js
var require_enum_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-keys.js"(exports, module) {
    var getKeys3 = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    module.exports = function(it) {
      var result = getKeys3(it);
      var getSymbols = gOPS.f;
      if (getSymbols) {
        var symbols = getSymbols(it);
        var isEnum = pIE.f;
        var i4 = 0;
        var key;
        while (symbols.length > i4) if (isEnum.call(it, key = symbols[i4++])) result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_is-array.js
var require_is_array2 = __commonJS({
  "node_modules/core-js/library/modules/_is-array.js"(exports, module) {
    var cof = require_cof2();
    module.exports = Array.isArray || function isArray(arg) {
      return cof(arg) == "Array";
    };
  }
});

// node_modules/core-js/library/modules/_object-gopn.js
var require_object_gopn = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn.js"(exports) {
    var $keys = require_object_keys_internal();
    var hiddenKeys = require_enum_bug_keys().concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O3) {
      return $keys(O3, hiddenKeys);
    };
  }
});

// node_modules/core-js/library/modules/_object-gopn-ext.js
var require_object_gopn_ext = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn-ext.js"(exports, module) {
    var toIObject = require_to_iobject();
    var gOPN = require_object_gopn().f;
    var toString = {}.toString;
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return gOPN(it);
      } catch (e3) {
        return windowNames.slice();
      }
    };
    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
    };
  }
});

// node_modules/core-js/library/modules/_object-gopd.js
var require_object_gopd = __commonJS({
  "node_modules/core-js/library/modules/_object-gopd.js"(exports) {
    var pIE = require_object_pie();
    var createDesc = require_property_desc2();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive2();
    var has = require_has2();
    var IE8_DOM_DEFINE = require_ie8_dom_define2();
    var gOPD = Object.getOwnPropertyDescriptor;
    exports.f = require_descriptors2() ? gOPD : function getOwnPropertyDescriptor(O3, P3) {
      O3 = toIObject(O3);
      P3 = toPrimitive(P3, true);
      if (IE8_DOM_DEFINE) try {
        return gOPD(O3, P3);
      } catch (e3) {
      }
      if (has(O3, P3)) return createDesc(!pIE.f.call(O3, P3), O3[P3]);
    };
  }
});

// node_modules/core-js/library/modules/es6.symbol.js
var require_es6_symbol = __commonJS({
  "node_modules/core-js/library/modules/es6.symbol.js"() {
    "use strict";
    var global3 = require_global2();
    var has = require_has2();
    var DESCRIPTORS = require_descriptors2();
    var $export10 = require_export2();
    var redefine2 = require_redefine2();
    var META = require_meta().KEY;
    var $fails = require_fails2();
    var shared = require_shared2();
    var setToStringTag = require_set_to_string_tag();
    var uid = require_uid2();
    var wks2 = require_wks2();
    var wksExt = require_wks_ext();
    var wksDefine = require_wks_define();
    var enumKeys = require_enum_keys();
    var isArray = require_is_array2();
    var anObject2 = require_an_object2();
    var isObject2 = require_is_object2();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive2();
    var createDesc = require_property_desc2();
    var _create = require_object_create();
    var gOPNExt = require_object_gopn_ext();
    var $GOPD = require_object_gopd();
    var $DP = require_object_dp2();
    var $keys = require_object_keys();
    var gOPD = $GOPD.f;
    var dP2 = $DP.f;
    var gOPN = gOPNExt.f;
    var $Symbol = global3.Symbol;
    var $JSON = global3.JSON;
    var _stringify = $JSON && $JSON.stringify;
    var PROTOTYPE = "prototype";
    var HIDDEN = wks2("_hidden");
    var TO_PRIMITIVE = wks2("toPrimitive");
    var isEnum = {}.propertyIsEnumerable;
    var SymbolRegistry = shared("symbol-registry");
    var AllSymbols = shared("symbols");
    var OPSymbols = shared("op-symbols");
    var ObjectProto = Object[PROTOTYPE];
    var USE_NATIVE = typeof $Symbol == "function";
    var QObject = global3.QObject;
    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDesc = DESCRIPTORS && $fails(function() {
      return _create(dP2({}, "a", {
        get: function() {
          return dP2(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(it, key, D3) {
      var protoDesc = gOPD(ObjectProto, key);
      if (protoDesc) delete ObjectProto[key];
      dP2(it, key, D3);
      if (protoDesc && it !== ObjectProto) dP2(ObjectProto, key, protoDesc);
    } : dP2;
    var wrap = function(tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
      sym._k = tag;
      return sym;
    };
    var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      return it instanceof $Symbol;
    };
    var $defineProperty = function defineProperty(it, key, D3) {
      if (it === ObjectProto) $defineProperty(OPSymbols, key, D3);
      anObject2(it);
      key = toPrimitive(key, true);
      anObject2(D3);
      if (has(AllSymbols, key)) {
        if (!D3.enumerable) {
          if (!has(it, HIDDEN)) dP2(it, HIDDEN, createDesc(1, {}));
          it[HIDDEN][key] = true;
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
          D3 = _create(D3, { enumerable: createDesc(0, false) });
        }
        return setSymbolDesc(it, key, D3);
      }
      return dP2(it, key, D3);
    };
    var $defineProperties = function defineProperties(it, P3) {
      anObject2(it);
      var keys = enumKeys(P3 = toIObject(P3));
      var i4 = 0;
      var l3 = keys.length;
      var key;
      while (l3 > i4) $defineProperty(it, key = keys[i4++], P3[key]);
      return it;
    };
    var $create = function create4(it, P3) {
      return P3 === void 0 ? _create(it) : $defineProperties(_create(it), P3);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(key) {
      var E2 = isEnum.call(this, key = toPrimitive(key, true));
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
      return E2 || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E2 : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
      it = toIObject(it);
      key = toPrimitive(key, true);
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
      var D3 = gOPD(it, key);
      if (D3 && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D3.enumerable = true;
      return D3;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(it) {
      var names = gOPN(toIObject(it));
      var result = [];
      var i4 = 0;
      var key;
      while (names.length > i4) {
        if (!has(AllSymbols, key = names[i4++]) && key != HIDDEN && key != META) result.push(key);
      }
      return result;
    };
    var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
      var IS_OP = it === ObjectProto;
      var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
      var result = [];
      var i4 = 0;
      var key;
      while (names.length > i4) {
        if (has(AllSymbols, key = names[i4++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
      }
      return result;
    };
    if (!USE_NATIVE) {
      $Symbol = function Symbol2() {
        if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
        var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
        var $set = function(value) {
          if (this === ObjectProto) $set.call(OPSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDesc(this, tag, createDesc(1, value));
        };
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
        return wrap(tag);
      };
      redefine2($Symbol[PROTOTYPE], "toString", function toString() {
        return this._k;
      });
      $GOPD.f = $getOwnPropertyDescriptor;
      $DP.f = $defineProperty;
      require_object_gopn().f = gOPNExt.f = $getOwnPropertyNames;
      require_object_pie().f = $propertyIsEnumerable;
      require_object_gops().f = $getOwnPropertySymbols;
      if (DESCRIPTORS && !require_library2()) {
        redefine2(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
      }
      wksExt.f = function(name) {
        return wrap(wks2(name));
      };
    }
    $export10($export10.G + $export10.W + $export10.F * !USE_NATIVE, { Symbol: $Symbol });
    for (es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j3 = 0; es6Symbols.length > j3; ) wks2(es6Symbols[j3++]);
    var es6Symbols;
    var j3;
    for (wellKnownSymbols = $keys(wks2.store), k4 = 0; wellKnownSymbols.length > k4; ) wksDefine(wellKnownSymbols[k4++]);
    var wellKnownSymbols;
    var k4;
    $export10($export10.S + $export10.F * !USE_NATIVE, "Symbol", {
      // 19.4.2.1 Symbol.for(key)
      "for": function(key) {
        return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
      },
      // 19.4.2.5 Symbol.keyFor(sym)
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
        for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
      },
      useSetter: function() {
        setter = true;
      },
      useSimple: function() {
        setter = false;
      }
    });
    $export10($export10.S + $export10.F * !USE_NATIVE, "Object", {
      // 19.1.2.2 Object.create(O [, Properties])
      create: $create,
      // 19.1.2.4 Object.defineProperty(O, P, Attributes)
      defineProperty: $defineProperty,
      // 19.1.2.3 Object.defineProperties(O, Properties)
      defineProperties: $defineProperties,
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
      // 19.1.2.7 Object.getOwnPropertyNames(O)
      getOwnPropertyNames: $getOwnPropertyNames,
      // 19.1.2.8 Object.getOwnPropertySymbols(O)
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    $JSON && $export10($export10.S + $export10.F * (!USE_NATIVE || $fails(function() {
      var S3 = $Symbol();
      return _stringify([S3]) != "[null]" || _stringify({ a: S3 }) != "{}" || _stringify(Object(S3)) != "{}";
    })), "JSON", {
      stringify: function stringify(it) {
        var args = [it];
        var i4 = 1;
        var replacer, $replacer;
        while (arguments.length > i4) args.push(arguments[i4++]);
        $replacer = replacer = args[1];
        if (!isObject2(replacer) && it === void 0 || isSymbol(it)) return;
        if (!isArray(replacer)) replacer = function(key, value) {
          if (typeof $replacer == "function") value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return _stringify.apply($JSON, args);
      }
    });
    $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide2()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
    setToStringTag($Symbol, "Symbol");
    setToStringTag(Math, "Math", true);
    setToStringTag(global3.JSON, "JSON", true);
  }
});

// node_modules/core-js/library/modules/es6.object.to-string.js
var require_es6_object_to_string = __commonJS({
  "node_modules/core-js/library/modules/es6.object.to-string.js"() {
  }
});

// node_modules/core-js/library/modules/es7.symbol.async-iterator.js
var require_es7_symbol_async_iterator = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.async-iterator.js"() {
    require_wks_define()("asyncIterator");
  }
});

// node_modules/core-js/library/modules/es7.symbol.observable.js
var require_es7_symbol_observable = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.observable.js"() {
    require_wks_define()("observable");
  }
});

// node_modules/core-js/library/fn/symbol/index.js
var require_symbol = __commonJS({
  "node_modules/core-js/library/fn/symbol/index.js"(exports, module) {
    require_es6_symbol();
    require_es6_object_to_string();
    require_es7_symbol_async_iterator();
    require_es7_symbol_observable();
    module.exports = require_core2().Symbol;
  }
});

// node_modules/babel-runtime/core-js/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol.js"(exports, module) {
    module.exports = { "default": require_symbol(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/babel-runtime/helpers/typeof.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _iterator = require_iterator2();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _symbol = require_symbol2();
    var _symbol2 = _interopRequireDefault(_symbol);
    var _typeof2 = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = typeof _symbol2.default === "function" && _typeof2(_iterator2.default) === "symbol" ? function(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }
});

// node_modules/core-js/library/modules/_iter-call.js
var require_iter_call = __commonJS({
  "node_modules/core-js/library/modules/_iter-call.js"(exports, module) {
    var anObject2 = require_an_object2();
    module.exports = function(iterator, fn, value, entries) {
      try {
        return entries ? fn(anObject2(value)[0], value[1]) : fn(value);
      } catch (e3) {
        var ret = iterator["return"];
        if (ret !== void 0) anObject2(ret.call(iterator));
        throw e3;
      }
    };
  }
});

// node_modules/core-js/library/modules/_is-array-iter.js
var require_is_array_iter = __commonJS({
  "node_modules/core-js/library/modules/_is-array-iter.js"(exports, module) {
    var Iterators2 = require_iterators();
    var ITERATOR2 = require_wks2()("iterator");
    var ArrayProto = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators2.Array === it || ArrayProto[ITERATOR2] === it);
    };
  }
});

// node_modules/core-js/library/modules/_create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/library/modules/_create-property.js"(exports, module) {
    "use strict";
    var $defineProperty = require_object_dp2();
    var createDesc = require_property_desc2();
    module.exports = function(object, index, value) {
      if (index in object) $defineProperty.f(object, index, createDesc(0, value));
      else object[index] = value;
    };
  }
});

// node_modules/core-js/library/modules/_classof.js
var require_classof = __commonJS({
  "node_modules/core-js/library/modules/_classof.js"(exports, module) {
    var cof = require_cof2();
    var TAG = require_wks2()("toStringTag");
    var ARG = cof(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (e3) {
      }
    };
    module.exports = function(it) {
      var O3, T2, B4;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T2 = tryGet(O3 = Object(it), TAG)) == "string" ? T2 : ARG ? cof(O3) : (B4 = cof(O3)) == "Object" && typeof O3.callee == "function" ? "Arguments" : B4;
    };
  }
});

// node_modules/core-js/library/modules/core.get-iterator-method.js
var require_core_get_iterator_method = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator-method.js"(exports, module) {
    var classof = require_classof();
    var ITERATOR2 = require_wks2()("iterator");
    var Iterators2 = require_iterators();
    module.exports = require_core2().getIteratorMethod = function(it) {
      if (it != void 0) return it[ITERATOR2] || it["@@iterator"] || Iterators2[classof(it)];
    };
  }
});

// node_modules/core-js/library/modules/_iter-detect.js
var require_iter_detect = __commonJS({
  "node_modules/core-js/library/modules/_iter-detect.js"(exports, module) {
    var ITERATOR2 = require_wks2()("iterator");
    var SAFE_CLOSING = false;
    try {
      riter = [7][ITERATOR2]();
      riter["return"] = function() {
        SAFE_CLOSING = true;
      };
      Array.from(riter, function() {
        throw 2;
      });
    } catch (e3) {
    }
    var riter;
    module.exports = function(exec, skipClosing) {
      if (!skipClosing && !SAFE_CLOSING) return false;
      var safe = false;
      try {
        var arr = [7];
        var iter = arr[ITERATOR2]();
        iter.next = function() {
          return { done: safe = true };
        };
        arr[ITERATOR2] = function() {
          return iter;
        };
        exec(arr);
      } catch (e3) {
      }
      return safe;
    };
  }
});

// node_modules/core-js/library/modules/es6.array.from.js
var require_es6_array_from = __commonJS({
  "node_modules/core-js/library/modules/es6.array.from.js"() {
    "use strict";
    var ctx = require_ctx2();
    var $export10 = require_export2();
    var toObject = require_to_object2();
    var call = require_iter_call();
    var isArrayIter = require_is_array_iter();
    var toLength2 = require_to_length2();
    var createProperty = require_create_property();
    var getIterFn = require_core_get_iterator_method();
    $export10($export10.S + $export10.F * !require_iter_detect()(function(iter) {
      Array.from(iter);
    }), "Array", {
      // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
      from: function from(arrayLike) {
        var O3 = toObject(arrayLike);
        var C3 = typeof this == "function" ? this : Array;
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var index = 0;
        var iterFn = getIterFn(O3);
        var length, result, step, iterator;
        if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
        if (iterFn != void 0 && !(C3 == Array && isArrayIter(iterFn))) {
          for (iterator = iterFn.call(O3), result = new C3(); !(step = iterator.next()).done; index++) {
            createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
          }
        } else {
          length = toLength2(O3.length);
          for (result = new C3(length); length > index; index++) {
            createProperty(result, index, mapping ? mapfn(O3[index], index) : O3[index]);
          }
        }
        result.length = index;
        return result;
      }
    });
  }
});

// node_modules/core-js/library/fn/array/from.js
var require_from = __commonJS({
  "node_modules/core-js/library/fn/array/from.js"(exports, module) {
    require_es6_string_iterator();
    require_es6_array_from();
    module.exports = require_core2().Array.from;
  }
});

// node_modules/babel-runtime/core-js/array/from.js
var require_from2 = __commonJS({
  "node_modules/babel-runtime/core-js/array/from.js"(exports, module) {
    module.exports = { "default": require_from(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/babel-runtime/helpers/toConsumableArray.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _from = require_from2();
    var _from2 = _interopRequireDefault(_from);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = function(arr) {
      if (Array.isArray(arr)) {
        for (var i4 = 0, arr2 = Array(arr.length); i4 < arr.length; i4++) {
          arr2[i4] = arr[i4];
        }
        return arr2;
      } else {
        return (0, _from2.default)(arr);
      }
    };
  }
});

// node_modules/flow-static-land/lib/Fun.js
var require_Fun2 = __commonJS({
  "node_modules/flow-static-land/lib/Fun.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.flip = flip;
    exports.constant = constant;
    exports.on = on;
    exports.compose = compose;
    exports.pipe = pipe;
    exports.curry = curry3;
    function flip(f3) {
      return function(b, a3) {
        return f3(a3, b);
      };
    }
    function constant(a3) {
      return function() {
        return a3;
      };
    }
    function on(o2, f3) {
      return function(x3, y3) {
        return o2(f3(x3), f3(y3));
      };
    }
    function compose() {
      var _this5 = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i = len; _i > -1; _i--) {
          y3 = fns[_i].call(_this5, y3);
        }
        return y3;
      };
    }
    function pipe() {
      var _this22 = this;
      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i2 = 0; _i2 <= len; _i2++) {
          y3 = fns[_i2].call(_this22, y3);
        }
        return y3;
      };
    }
    function curried(f3, length, acc) {
      return function() {
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f3.apply(this, combined) : curried(f3, length, combined);
      };
    }
    function curry3(f3) {
      return curried(f3, f3.length, []);
    }
  }
});

// node_modules/core-js/library/modules/_object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/library/modules/_object-assign.js"(exports, module) {
    "use strict";
    var getKeys3 = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    var toObject = require_to_object2();
    var IObject = require_iobject2();
    var $assign = Object.assign;
    module.exports = !$assign || require_fails2()(function() {
      var A3 = {};
      var B4 = {};
      var S3 = Symbol();
      var K = "abcdefghijklmnopqrst";
      A3[S3] = 7;
      K.split("").forEach(function(k4) {
        B4[k4] = k4;
      });
      return $assign({}, A3)[S3] != 7 || Object.keys($assign({}, B4)).join("") != K;
    }) ? function assign(target, source) {
      var T2 = toObject(target);
      var aLen = arguments.length;
      var index = 1;
      var getSymbols = gOPS.f;
      var isEnum = pIE.f;
      while (aLen > index) {
        var S3 = IObject(arguments[index++]);
        var keys = getSymbols ? getKeys3(S3).concat(getSymbols(S3)) : getKeys3(S3);
        var length = keys.length;
        var j3 = 0;
        var key;
        while (length > j3) if (isEnum.call(S3, key = keys[j3++])) T2[key] = S3[key];
      }
      return T2;
    } : $assign;
  }
});

// node_modules/core-js/library/modules/es6.object.assign.js
var require_es6_object_assign = __commonJS({
  "node_modules/core-js/library/modules/es6.object.assign.js"() {
    var $export10 = require_export2();
    $export10($export10.S + $export10.F, "Object", { assign: require_object_assign() });
  }
});

// node_modules/core-js/library/fn/object/assign.js
var require_assign = __commonJS({
  "node_modules/core-js/library/fn/object/assign.js"(exports, module) {
    require_es6_object_assign();
    module.exports = require_core2().Object.assign;
  }
});

// node_modules/babel-runtime/core-js/object/assign.js
var require_assign2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/assign.js"(exports, module) {
    module.exports = { "default": require_assign(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/babel-runtime/helpers/extends.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _assign = require_assign2();
    var _assign2 = _interopRequireDefault(_assign);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = _assign2.default || function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
  }
});

// node_modules/core-js/library/modules/_object-sap.js
var require_object_sap = __commonJS({
  "node_modules/core-js/library/modules/_object-sap.js"(exports, module) {
    var $export10 = require_export2();
    var core = require_core2();
    var fails = require_fails2();
    module.exports = function(KEY3, exec) {
      var fn = (core.Object || {})[KEY3] || Object[KEY3];
      var exp = {};
      exp[KEY3] = exec(fn);
      $export10($export10.S + $export10.F * fails(function() {
        fn(1);
      }), "Object", exp);
    };
  }
});

// node_modules/core-js/library/modules/es6.object.keys.js
var require_es6_object_keys = __commonJS({
  "node_modules/core-js/library/modules/es6.object.keys.js"() {
    var toObject = require_to_object2();
    var $keys = require_object_keys();
    require_object_sap()("keys", function() {
      return function keys(it) {
        return $keys(toObject(it));
      };
    });
  }
});

// node_modules/core-js/library/fn/object/keys.js
var require_keys = __commonJS({
  "node_modules/core-js/library/fn/object/keys.js"(exports, module) {
    require_es6_object_keys();
    module.exports = require_core2().Object.keys;
  }
});

// node_modules/babel-runtime/core-js/object/keys.js
var require_keys2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/keys.js"(exports, module) {
    module.exports = { "default": require_keys(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_is-integer.js
var require_is_integer = __commonJS({
  "node_modules/core-js/library/modules/_is-integer.js"(exports, module) {
    var isObject2 = require_is_object2();
    var floor = Math.floor;
    module.exports = function isInteger(it) {
      return !isObject2(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js/library/modules/es6.number.is-integer.js
var require_es6_number_is_integer = __commonJS({
  "node_modules/core-js/library/modules/es6.number.is-integer.js"() {
    var $export10 = require_export2();
    $export10($export10.S, "Number", { isInteger: require_is_integer() });
  }
});

// node_modules/core-js/library/fn/number/is-integer.js
var require_is_integer2 = __commonJS({
  "node_modules/core-js/library/fn/number/is-integer.js"(exports, module) {
    require_es6_number_is_integer();
    module.exports = require_core2().Number.isInteger;
  }
});

// node_modules/babel-runtime/core-js/number/is-integer.js
var require_is_integer3 = __commonJS({
  "node_modules/babel-runtime/core-js/number/is-integer.js"(exports, module) {
    module.exports = { "default": require_is_integer2(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/babel-runtime/helpers/objectWithoutProperties.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(obj, keys) {
      var target = {};
      for (var i4 in obj) {
        if (keys.indexOf(i4) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i4)) continue;
        target[i4] = obj[i4];
      }
      return target;
    };
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a3, b) {
      if (a3 === b) return true;
      var arrA = Array.isArray(a3), arrB = Array.isArray(b), i4;
      if (arrA && arrB) {
        if (a3.length != b.length) return false;
        for (i4 = 0; i4 < a3.length; i4++)
          if (!equal(a3[i4], b[i4])) return false;
        return true;
      }
      if (arrA != arrB) return false;
      if (a3 && b && typeof a3 === "object" && typeof b === "object") {
        var keys = Object.keys(a3);
        if (keys.length !== Object.keys(b).length) return false;
        var dateA = a3 instanceof Date, dateB = b instanceof Date;
        if (dateA && dateB) return a3.getTime() == b.getTime();
        if (dateA != dateB) return false;
        var regexpA = a3 instanceof RegExp, regexpB = b instanceof RegExp;
        if (regexpA && regexpB) return a3.toString() == b.toString();
        if (regexpA != regexpB) return false;
        for (i4 = 0; i4 < keys.length; i4++)
          if (!Object.prototype.hasOwnProperty.call(b, keys[i4])) return false;
        for (i4 = 0; i4 < keys.length; i4++)
          if (!equal(a3[keys[i4]], b[keys[i4]])) return false;
        return true;
      }
      return false;
    };
  }
});

// node_modules/core-js/library/modules/es6.object.define-property.js
var require_es6_object_define_property = __commonJS({
  "node_modules/core-js/library/modules/es6.object.define-property.js"() {
    var $export10 = require_export2();
    $export10($export10.S + $export10.F * !require_descriptors2(), "Object", { defineProperty: require_object_dp2().f });
  }
});

// node_modules/core-js/library/fn/object/define-property.js
var require_define_property = __commonJS({
  "node_modules/core-js/library/fn/object/define-property.js"(exports, module) {
    require_es6_object_define_property();
    var $Object = require_core2().Object;
    module.exports = function defineProperty(it, key, desc) {
      return $Object.defineProperty(it, key, desc);
    };
  }
});

// node_modules/babel-runtime/core-js/object/define-property.js
var require_define_property2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/define-property.js"(exports, module) {
    module.exports = { "default": require_define_property(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/babel-runtime/helpers/defineProperty.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _defineProperty2 = require_define_property2();
    var _defineProperty22 = _interopRequireDefault(_defineProperty2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = function(obj, key, value) {
      if (key in obj) {
        (0, _defineProperty22.default)(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
  }
});

// node_modules/core-js/library/modules/core.is-iterable.js
var require_core_is_iterable = __commonJS({
  "node_modules/core-js/library/modules/core.is-iterable.js"(exports, module) {
    var classof = require_classof();
    var ITERATOR2 = require_wks2()("iterator");
    var Iterators2 = require_iterators();
    module.exports = require_core2().isIterable = function(it) {
      var O3 = Object(it);
      return O3[ITERATOR2] !== void 0 || "@@iterator" in O3 || Iterators2.hasOwnProperty(classof(O3));
    };
  }
});

// node_modules/core-js/library/fn/is-iterable.js
var require_is_iterable = __commonJS({
  "node_modules/core-js/library/fn/is-iterable.js"(exports, module) {
    require_web_dom_iterable();
    require_es6_string_iterator();
    module.exports = require_core_is_iterable();
  }
});

// node_modules/babel-runtime/core-js/is-iterable.js
var require_is_iterable2 = __commonJS({
  "node_modules/babel-runtime/core-js/is-iterable.js"(exports, module) {
    module.exports = { "default": require_is_iterable(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/core.get-iterator.js
var require_core_get_iterator = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator.js"(exports, module) {
    var anObject2 = require_an_object2();
    var get2 = require_core_get_iterator_method();
    module.exports = require_core2().getIterator = function(it) {
      var iterFn = get2(it);
      if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
      return anObject2(iterFn.call(it));
    };
  }
});

// node_modules/core-js/library/fn/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/library/fn/get-iterator.js"(exports, module) {
    require_web_dom_iterable();
    require_es6_string_iterator();
    module.exports = require_core_get_iterator();
  }
});

// node_modules/babel-runtime/core-js/get-iterator.js
var require_get_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/get-iterator.js"(exports, module) {
    module.exports = { "default": require_get_iterator(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/babel-runtime/helpers/slicedToArray.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _isIterable2 = require_is_iterable2();
    var _isIterable3 = _interopRequireDefault(_isIterable2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = /* @__PURE__ */ function() {
      function sliceIterator(arr, i4) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i4 && _arr.length === i4) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i4) {
        if (Array.isArray(arr)) {
          return arr;
        } else if ((0, _isIterable3.default)(Object(arr))) {
          return sliceIterator(arr, i4);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
  }
});

// node_modules/core-js/library/modules/_object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js/library/modules/_object-to-array.js"(exports, module) {
    var getKeys3 = require_object_keys();
    var toIObject = require_to_iobject();
    var isEnum = require_object_pie().f;
    module.exports = function(isEntries) {
      return function(it) {
        var O3 = toIObject(it);
        var keys = getKeys3(O3);
        var length = keys.length;
        var i4 = 0;
        var result = [];
        var key;
        while (length > i4) if (isEnum.call(O3, key = keys[i4++])) {
          result.push(isEntries ? [key, O3[key]] : O3[key]);
        }
        return result;
      };
    };
  }
});

// node_modules/core-js/library/modules/es7.object.entries.js
var require_es7_object_entries = __commonJS({
  "node_modules/core-js/library/modules/es7.object.entries.js"() {
    var $export10 = require_export2();
    var $entries = require_object_to_array()(true);
    $export10($export10.S, "Object", {
      entries: function entries(it) {
        return $entries(it);
      }
    });
  }
});

// node_modules/core-js/library/fn/object/entries.js
var require_entries = __commonJS({
  "node_modules/core-js/library/fn/object/entries.js"(exports, module) {
    require_es7_object_entries();
    module.exports = require_core2().Object.entries;
  }
});

// node_modules/babel-runtime/core-js/object/entries.js
var require_entries2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/entries.js"(exports, module) {
    module.exports = { "default": require_entries(), __esModule: true };
  }
});

// node_modules/core-js/modules/_iter-step.js
var require_iter_step2 = __commonJS({
  "node_modules/core-js/modules/_iter-step.js"(exports, module) {
    module.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/modules/_iterators.js
var require_iterators2 = __commonJS({
  "node_modules/core-js/modules/_iterators.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/core-js/modules/_to-iobject.js
var require_to_iobject2 = __commonJS({
  "node_modules/core-js/modules/_to-iobject.js"(exports, module) {
    var IObject = require_iobject();
    var defined = require_defined();
    module.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/modules/_to-absolute-index.js
var require_to_absolute_index2 = __commonJS({
  "node_modules/core-js/modules/_to-absolute-index.js"(exports, module) {
    var toInteger = require_to_integer();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }
});

// node_modules/core-js/modules/_array-includes.js
var require_array_includes2 = __commonJS({
  "node_modules/core-js/modules/_array-includes.js"(exports, module) {
    var toIObject = require_to_iobject2();
    var toLength2 = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index2();
    module.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIObject($this);
        var length = toLength2(O3.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O3[index++];
          if (value != value) return true;
        }
        else for (; length > index; index++) if (IS_INCLUDES || index in O3) {
          if (O3[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/modules/_shared-key.js
var require_shared_key2 = __commonJS({
  "node_modules/core-js/modules/_shared-key.js"(exports, module) {
    var shared = require_shared()("keys");
    var uid = require_uid();
    module.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/modules/_object-keys-internal.js
var require_object_keys_internal2 = __commonJS({
  "node_modules/core-js/modules/_object-keys-internal.js"(exports, module) {
    var has = require_has();
    var toIObject = require_to_iobject2();
    var arrayIndexOf = require_array_includes2()(false);
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    module.exports = function(object, names) {
      var O3 = toIObject(object);
      var i4 = 0;
      var result = [];
      var key;
      for (key in O3) if (key != IE_PROTO) has(O3, key) && result.push(key);
      while (names.length > i4) if (has(O3, key = names[i4++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/modules/_enum-bug-keys.js
var require_enum_bug_keys2 = __commonJS({
  "node_modules/core-js/modules/_enum-bug-keys.js"(exports, module) {
    module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/modules/_object-keys.js
var require_object_keys2 = __commonJS({
  "node_modules/core-js/modules/_object-keys.js"(exports, module) {
    var $keys = require_object_keys_internal2();
    var enumBugKeys = require_enum_bug_keys2();
    module.exports = Object.keys || function keys(O3) {
      return $keys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/modules/_object-dps.js
var require_object_dps2 = __commonJS({
  "node_modules/core-js/modules/_object-dps.js"(exports, module) {
    var dP2 = require_object_dp();
    var anObject2 = require_an_object();
    var getKeys3 = require_object_keys2();
    module.exports = require_descriptors() ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject2(O3);
      var keys = getKeys3(Properties);
      var length = keys.length;
      var i4 = 0;
      var P3;
      while (length > i4) dP2.f(O3, P3 = keys[i4++], Properties[P3]);
      return O3;
    };
  }
});

// node_modules/core-js/modules/_html.js
var require_html2 = __commonJS({
  "node_modules/core-js/modules/_html.js"(exports, module) {
    var document2 = require_global().document;
    module.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/modules/_object-create.js
var require_object_create2 = __commonJS({
  "node_modules/core-js/modules/_object-create.js"(exports, module) {
    var anObject2 = require_an_object();
    var dPs = require_object_dps2();
    var enumBugKeys = require_enum_bug_keys2();
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    var Empty = function() {
    };
    var PROTOTYPE = "prototype";
    var createDict = function() {
      var iframe = require_dom_create()("iframe");
      var i4 = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html2().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i4--) delete createDict[PROTOTYPE][enumBugKeys[i4]];
      return createDict();
    };
    module.exports = Object.create || function create4(O3, Properties) {
      var result;
      if (O3 !== null) {
        Empty[PROTOTYPE] = anObject2(O3);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    };
  }
});

// node_modules/core-js/modules/_set-to-string-tag.js
var require_set_to_string_tag2 = __commonJS({
  "node_modules/core-js/modules/_set-to-string-tag.js"(exports, module) {
    var def = require_object_dp().f;
    var has = require_has();
    var TAG = require_wks()("toStringTag");
    module.exports = function(it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/modules/_iter-create.js
var require_iter_create2 = __commonJS({
  "node_modules/core-js/modules/_iter-create.js"(exports, module) {
    "use strict";
    var create4 = require_object_create2();
    var descriptor = require_property_desc();
    var setToStringTag = require_set_to_string_tag2();
    var IteratorPrototype = {};
    require_hide()(IteratorPrototype, require_wks()("iterator"), function() {
      return this;
    });
    module.exports = function(Constructor, NAME2, next) {
      Constructor.prototype = create4(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME2 + " Iterator");
    };
  }
});

// node_modules/core-js/modules/_object-gpo.js
var require_object_gpo2 = __commonJS({
  "node_modules/core-js/modules/_object-gpo.js"(exports, module) {
    var has = require_has();
    var toObject = require_to_object();
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module.exports = Object.getPrototypeOf || function(O3) {
      O3 = toObject(O3);
      if (has(O3, IE_PROTO)) return O3[IE_PROTO];
      if (typeof O3.constructor == "function" && O3 instanceof O3.constructor) {
        return O3.constructor.prototype;
      }
      return O3 instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/modules/_iter-define.js
var require_iter_define2 = __commonJS({
  "node_modules/core-js/modules/_iter-define.js"(exports, module) {
    "use strict";
    var LIBRARY = require_library();
    var $export10 = require_export();
    var redefine2 = require_redefine();
    var hide2 = require_hide();
    var Iterators2 = require_iterators2();
    var $iterCreate = require_iter_create2();
    var setToStringTag = require_set_to_string_tag2();
    var getPrototypeOf = require_object_gpo2();
    var ITERATOR2 = require_wks()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Base, NAME2, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME2, next);
      var getMethod = function(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch (kind) {
          case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }
        return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME2 + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto = Base.prototype;
      var $native2 = proto[ITERATOR2] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
      var $default = $native2 || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME2 == "Array" ? proto.entries || $native2 : $native2;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR2] != "function") hide2(IteratorPrototype, ITERATOR2, returnThis);
        }
      }
      if (DEF_VALUES && $native2 && $native2.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native2.call(this);
        };
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR2])) {
        hide2(proto, ITERATOR2, $default);
      }
      Iterators2[NAME2] = $default;
      Iterators2[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto)) redefine2(proto, key, methods[key]);
        }
        else $export10($export10.P + $export10.F * (BUGGY || VALUES_BUG), NAME2, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/modules/es6.array.iterator.js
var require_es6_array_iterator2 = __commonJS({
  "node_modules/core-js/modules/es6.array.iterator.js"(exports, module) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    var step = require_iter_step2();
    var Iterators2 = require_iterators2();
    var toIObject = require_to_iobject2();
    module.exports = require_iter_define2()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O3 = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O3 || index >= O3.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys") return step(0, index);
      if (kind == "values") return step(0, O3[index]);
      return step(0, [index, O3[index]]);
    }, "values");
    Iterators2.Arguments = Iterators2.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/modules/_strict-method.js
var require_strict_method = __commonJS({
  "node_modules/core-js/modules/_strict-method.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = function(method, arg) {
      return !!method && fails(function() {
        arg ? method.call(null, function() {
        }, 1) : method.call(null);
      });
    };
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i4 = 0, arr2 = new Array(arr.length); i4 < arr.length; i4++) {
          arr2[i4] = arr[i4];
        }
        return arr2;
      }
    }
    module.exports = _arrayWithoutHoles;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    module.exports = _iterableToArray;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    module.exports = _nonIterableSpread;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray2 = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray4(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
    }
    module.exports = _toConsumableArray4;
  }
});

// node_modules/core-js/modules/_string-at.js
var require_string_at2 = __commonJS({
  "node_modules/core-js/modules/_string-at.js"(exports, module) {
    var toInteger = require_to_integer();
    var defined = require_defined();
    module.exports = function(TO_STRING) {
      return function(that, pos) {
        var s3 = String(defined(that));
        var i4 = toInteger(pos);
        var l3 = s3.length;
        var a3, b;
        if (i4 < 0 || i4 >= l3) return TO_STRING ? "" : void 0;
        a3 = s3.charCodeAt(i4);
        return a3 < 55296 || a3 > 56319 || i4 + 1 === l3 || (b = s3.charCodeAt(i4 + 1)) < 56320 || b > 57343 ? TO_STRING ? s3.charAt(i4) : a3 : TO_STRING ? s3.slice(i4, i4 + 2) : (a3 - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/modules/_advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/modules/_advance-string-index.js"(exports, module) {
    "use strict";
    var at = require_string_at2()(true);
    module.exports = function(S3, index, unicode) {
      return index + (unicode ? at(S3, index).length : 1);
    };
  }
});

// node_modules/core-js/modules/_classof.js
var require_classof2 = __commonJS({
  "node_modules/core-js/modules/_classof.js"(exports, module) {
    var cof = require_cof();
    var TAG = require_wks()("toStringTag");
    var ARG = cof(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (e3) {
      }
    };
    module.exports = function(it) {
      var O3, T2, B4;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T2 = tryGet(O3 = Object(it), TAG)) == "string" ? T2 : ARG ? cof(O3) : (B4 = cof(O3)) == "Object" && typeof O3.callee == "function" ? "Arguments" : B4;
    };
  }
});

// node_modules/core-js/modules/_regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/modules/_regexp-exec-abstract.js"(exports, module) {
    "use strict";
    var classof = require_classof2();
    var builtinExec = RegExp.prototype.exec;
    module.exports = function(R2, S3) {
      var exec = R2.exec;
      if (typeof exec === "function") {
        var result = exec.call(R2, S3);
        if (typeof result !== "object") {
          throw new TypeError("RegExp exec method returned something other than an Object or null");
        }
        return result;
      }
      if (classof(R2) !== "RegExp") {
        throw new TypeError("RegExp#exec called on incompatible receiver");
      }
      return builtinExec.call(R2, S3);
    };
  }
});

// node_modules/core-js/modules/_flags.js
var require_flags = __commonJS({
  "node_modules/core-js/modules/_flags.js"(exports, module) {
    "use strict";
    var anObject2 = require_an_object();
    module.exports = function() {
      var that = anObject2(this);
      var result = "";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.unicode) result += "u";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// node_modules/core-js/modules/_regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/modules/_regexp-exec.js"(exports, module) {
    "use strict";
    var regexpFlags = require_flags();
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = String.prototype.replace;
    var patchedExec = nativeExec;
    var LAST_INDEX = "lastIndex";
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/, re2 = /b*/g;
      nativeExec.call(re1, "a");
      nativeExec.call(re2, "a");
      return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
    }();
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match, i4;
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + re.source + "$(?!\\s)", regexpFlags.call(re));
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
        match = nativeExec.call(re, str);
        if (UPDATES_LAST_INDEX_WRONG && match) {
          re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          nativeReplace.call(match[0], reCopy, function() {
            for (i4 = 1; i4 < arguments.length - 2; i4++) {
              if (arguments[i4] === void 0) match[i4] = void 0;
            }
          });
        }
        return match;
      };
    }
    module.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es6.regexp.exec.js
var require_es6_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es6.regexp.exec.js"() {
    "use strict";
    var regexpExec = require_regexp_exec();
    require_export()({
      target: "RegExp",
      proto: true,
      forced: regexpExec !== /./.exec
    }, {
      exec: regexpExec
    });
  }
});

// node_modules/core-js/modules/_fix-re-wks.js
var require_fix_re_wks = __commonJS({
  "node_modules/core-js/modules/_fix-re-wks.js"(exports, module) {
    "use strict";
    require_es6_regexp_exec();
    var redefine2 = require_redefine();
    var hide2 = require_hide();
    var fails = require_fails();
    var defined = require_defined();
    var wks2 = require_wks();
    var regexpExec = require_regexp_exec();
    var SPECIES = wks2("species");
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length === 2 && result[0] === "a" && result[1] === "b";
    }();
    module.exports = function(KEY3, length, exec) {
      var SYMBOL = wks2(KEY3);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O3 = {};
        O3[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY3](O3) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
        var execCalled = false;
        var re = /a/;
        re.exec = function() {
          execCalled = true;
          return null;
        };
        if (KEY3 === "split") {
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
        }
        re[SYMBOL]("");
        return !execCalled;
      }) : void 0;
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY3 === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY3 === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var fns = exec(
          defined,
          SYMBOL,
          ""[KEY3],
          function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
            if (regexp.exec === regexpExec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
              }
              return { done: true, value: nativeMethod.call(str, regexp, arg2) };
            }
            return { done: false };
          }
        );
        var strfn = fns[0];
        var rxfn = fns[1];
        redefine2(String.prototype, KEY3, strfn);
        hide2(
          RegExp.prototype,
          SYMBOL,
          length == 2 ? function(string, arg) {
            return rxfn.call(string, this, arg);
          } : function(string) {
            return rxfn.call(string, this);
          }
        );
      }
    };
  }
});

// node_modules/core-js/modules/_invoke.js
var require_invoke = __commonJS({
  "node_modules/core-js/modules/_invoke.js"(exports, module) {
    module.exports = function(fn, args, that) {
      var un = that === void 0;
      switch (args.length) {
        case 0:
          return un ? fn() : fn.call(that);
        case 1:
          return un ? fn(args[0]) : fn.call(that, args[0]);
        case 2:
          return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
        case 3:
          return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
        case 4:
          return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
      }
      return fn.apply(that, args);
    };
  }
});

// node_modules/core-js/modules/_bind.js
var require_bind = __commonJS({
  "node_modules/core-js/modules/_bind.js"(exports, module) {
    "use strict";
    var aFunction = require_a_function();
    var isObject2 = require_is_object();
    var invoke = require_invoke();
    var arraySlice = [].slice;
    var factories = {};
    var construct = function(F2, len, args) {
      if (!(len in factories)) {
        for (var n2 = [], i4 = 0; i4 < len; i4++) n2[i4] = "a[" + i4 + "]";
        factories[len] = Function("F,a", "return new F(" + n2.join(",") + ")");
      }
      return factories[len](F2, args);
    };
    module.exports = Function.bind || function bind(that) {
      var fn = aFunction(this);
      var partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject2(fn.prototype)) bound.prototype = fn.prototype;
      return bound;
    };
  }
});

// node_modules/@babel/runtime/helpers/newArrowCheck.js
var require_newArrowCheck2 = __commonJS({
  "node_modules/@babel/runtime/helpers/newArrowCheck.js"(exports, module) {
    function _newArrowCheck5(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    }
    module.exports = _newArrowCheck5;
  }
});

// node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS({
  "node_modules/zen-observable/lib/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i4 = 0; i4 < props.length; i4++) {
          var descriptor = props[i4];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var hasSymbols = function() {
      return typeof Symbol === "function";
    };
    var hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    var SymbolIterator = getSymbol("iterator");
    var SymbolObservable = getSymbol("observable");
    var SymbolSpecies = getSymbol("species");
    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null) return void 0;
      if (typeof value !== "function") throw new TypeError(value + " is not a function");
      return value;
    }
    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== void 0) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = void 0;
        }
      }
      return ctor !== void 0 ? ctor : Observable2;
    }
    function isObservable(x3) {
      return x3 instanceof Observable2;
    }
    function hostReportError(e3) {
      if (hostReportError.log) {
        hostReportError.log(e3);
      } else {
        setTimeout(function() {
          throw e3;
        });
      }
    }
    function enqueue(fn) {
      Promise.resolve().then(function() {
        try {
          fn();
        } catch (e3) {
          hostReportError(e3);
        }
      });
    }
    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === void 0) return;
      subscription._cleanup = void 0;
      if (!cleanup) {
        return;
      }
      try {
        if (typeof cleanup === "function") {
          cleanup();
        } else {
          var unsubscribe3 = getMethod(cleanup, "unsubscribe");
          if (unsubscribe3) {
            unsubscribe3.call(cleanup);
          }
        }
      } catch (e3) {
        hostReportError(e3);
      }
    }
    function closeSubscription(subscription) {
      subscription._observer = void 0;
      subscription._queue = void 0;
      subscription._state = "closed";
    }
    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = void 0;
      subscription._state = "ready";
      for (var i4 = 0; i4 < queue.length; ++i4) {
        notifySubscription(subscription, queue[i4].type, queue[i4].value);
        if (subscription._state === "closed") break;
      }
    }
    function notifySubscription(subscription, type, value) {
      subscription._state = "running";
      var observer = subscription._observer;
      try {
        var m3 = getMethod(observer, type);
        switch (type) {
          case "next":
            if (m3) m3.call(observer, value);
            break;
          case "error":
            closeSubscription(subscription);
            if (m3) m3.call(observer, value);
            else throw value;
            break;
          case "complete":
            closeSubscription(subscription);
            if (m3) m3.call(observer);
            break;
        }
      } catch (e3) {
        hostReportError(e3);
      }
      if (subscription._state === "closed") cleanupSubscription(subscription);
      else if (subscription._state === "running") subscription._state = "ready";
    }
    function onNotify(subscription, type, value) {
      if (subscription._state === "closed") return;
      if (subscription._state === "buffering") {
        subscription._queue.push({ type, value });
        return;
      }
      if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [{ type, value }];
        enqueue(function() {
          return flushSubscription(subscription);
        });
        return;
      }
      notifySubscription(subscription, type, value);
    }
    var Subscription = function() {
      function Subscription2(observer, subscriber) {
        _classCallCheck(this, Subscription2);
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e3) {
          subscriptionObserver.error(e3);
        }
        if (this._state === "initializing") this._state = "ready";
      }
      _createClass(Subscription2, [{
        key: "unsubscribe",
        value: function unsubscribe3() {
          if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    var SubscriptionObserver = function() {
      function SubscriptionObserver2(subscription) {
        _classCallCheck(this, SubscriptionObserver2);
        this._subscription = subscription;
      }
      _createClass(SubscriptionObserver2, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, "next", value);
        }
      }, {
        key: "error",
        value: function error(value) {
          onNotify(this._subscription, "error", value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, "complete");
        }
      }, {
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    var Observable2 = exports.Observable = function() {
      function Observable3(subscriber) {
        _classCallCheck(this, Observable3);
        if (!(this instanceof Observable3)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      _createClass(Observable3, [{
        key: "subscribe",
        value: function subscribe3(observer) {
          if (typeof observer !== "object" || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach2(fn) {
          var _this5 = this;
          return new Promise(function(resolve, reject) {
            if (typeof fn !== "function") {
              reject(new TypeError(fn + " is not a function"));
              return;
            }
            function done() {
              subscription.unsubscribe();
              resolve();
            }
            var subscription = _this5.subscribe({
              next: function(value) {
                try {
                  fn(value, done);
                } catch (e3) {
                  reject(e3);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      }, {
        key: "map",
        value: function map3(fn) {
          var _this22 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            return _this22.subscribe({
              next: function(value) {
                try {
                  value = fn(value);
                } catch (e3) {
                  return observer.error(e3);
                }
                observer.next(value);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this32 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            return _this32.subscribe({
              next: function(value) {
                try {
                  if (!fn(value)) return;
                } catch (e3) {
                  return observer.error(e3);
                }
                observer.next(value);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this42 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C3(function(observer) {
            return _this42.subscribe({
              next: function(value) {
                var first = !hasValue;
                hasValue = true;
                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e3) {
                    return observer.error(e3);
                  }
                } else {
                  acc = value;
                }
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat() {
          var _this5 = this;
          for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            var subscription = void 0;
            var index = 0;
            function startNext(next) {
              subscription = next.subscribe({
                next: function(v3) {
                  observer.next(v3);
                },
                error: function(e3) {
                  observer.error(e3);
                },
                complete: function() {
                  if (index === sources.length) {
                    subscription = void 0;
                    observer.complete();
                  } else {
                    startNext(C3.from(sources[index++]));
                  }
                }
              });
            }
            startNext(_this5);
            return function() {
              if (subscription) {
                subscription.unsubscribe();
                subscription = void 0;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
              next: function(value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e3) {
                    return observer.error(e3);
                  }
                }
                var inner = C3.from(value).subscribe({
                  next: function(value2) {
                    observer.next(value2);
                  },
                  error: function(e3) {
                    observer.error(e3);
                  },
                  complete: function() {
                    var i4 = subscriptions.indexOf(inner);
                    if (i4 >= 0) subscriptions.splice(i4, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                completeIfDone();
              }
            });
            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0) observer.complete();
            }
            return function() {
              subscriptions.forEach(function(s3) {
                return s3.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function() {
          return this;
        }
      }], [{
        key: "from",
        value: function from(x3) {
          var C3 = typeof this === "function" ? this : Observable3;
          if (x3 == null) throw new TypeError(x3 + " is not an object");
          var method = getMethod(x3, SymbolObservable);
          if (method) {
            var observable = method.call(x3);
            if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C3) return observable;
            return new C3(function(observer) {
              return observable.subscribe(observer);
            });
          }
          if (hasSymbol("iterator")) {
            method = getMethod(x3, SymbolIterator);
            if (method) {
              return new C3(function(observer) {
                enqueue(function() {
                  if (observer.closed) return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = method.call(x3)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var item = _step.value;
                      observer.next(item);
                      if (observer.closed) return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  observer.complete();
                });
              });
            }
          }
          if (Array.isArray(x3)) {
            return new C3(function(observer) {
              enqueue(function() {
                if (observer.closed) return;
                for (var i4 = 0; i4 < x3.length; ++i4) {
                  observer.next(x3[i4]);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }
          throw new TypeError(x3 + " is not observable");
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }
          var C3 = typeof this === "function" ? this : Observable3;
          return new C3(function(observer) {
            enqueue(function() {
              if (observer.closed) return;
              for (var i4 = 0; i4 < items.length; ++i4) {
                observer.next(items[i4]);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable3;
    }();
    if (hasSymbols()) {
      Object.defineProperty(Observable2, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// node_modules/zen-observable/index.js
var require_zen_observable = __commonJS({
  "node_modules/zen-observable/index.js"(exports, module) {
    module.exports = require_Observable().Observable;
  }
});

// node_modules/core-js/modules/_is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/modules/_is-regexp.js"(exports, module) {
    var isObject2 = require_is_object();
    var cof = require_cof();
    var MATCH = require_wks()("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : cof(it) == "RegExp");
    };
  }
});

// node_modules/core-js/modules/_string-context.js
var require_string_context = __commonJS({
  "node_modules/core-js/modules/_string-context.js"(exports, module) {
    var isRegExp = require_is_regexp();
    var defined = require_defined();
    module.exports = function(that, searchString, NAME2) {
      if (isRegExp(searchString)) throw TypeError("String#" + NAME2 + " doesn't accept regex!");
      return String(defined(that));
    };
  }
});

// node_modules/core-js/modules/_fails-is-regexp.js
var require_fails_is_regexp = __commonJS({
  "node_modules/core-js/modules/_fails-is-regexp.js"(exports, module) {
    var MATCH = require_wks()("match");
    module.exports = function(KEY3) {
      var re = /./;
      try {
        "/./"[KEY3](re);
      } catch (e3) {
        try {
          re[MATCH] = false;
          return !"/./"[KEY3](re);
        } catch (f3) {
        }
      }
      return true;
    };
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty2 = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty2;
  }
});

// node_modules/@babel/runtime/helpers/objectSpread.js
var require_objectSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/objectSpread.js"(exports, module) {
    var defineProperty = require_defineProperty2();
    function _objectSpread2(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    module.exports = _objectSpread2;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i4;
      for (i4 = 0; i4 < sourceKeys.length; i4++) {
        key = sourceKeys[i4];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    module.exports = _objectWithoutPropertiesLoose;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties2 = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties4(source, excluded) {
      if (source == null) return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i4;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
          key = sourceSymbolKeys[i4];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module.exports = _objectWithoutProperties4;
  }
});

// node_modules/@codesandbox/api/node_modules/class-states/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@codesandbox/api/node_modules/class-states/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.States = void 0;
    var States5 = class {
      constructor(initialState) {
        this._listeners = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        this._state = initialState;
        this.onTransition = this.onTransition.bind(this);
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get() {
        return this._state;
      }
      match(...args) {
        const matches = args[1] || args[0];
        const state = args.length === 2 ? args[0] : this._state;
        return matches[state.state] ? matches[state.state](state) : matches._();
      }
      set(state) {
        if (this._isDisposed) {
          return;
        }
        const prevState = this._state;
        this._state = state;
        this._listeners.forEach((listener) => listener(state, prevState));
        return state;
      }
      is(state) {
        return this._state.state === state;
      }
      onTransition(...args) {
        if (this._isDisposed) {
          return;
        }
        let listener;
        if (typeof args[0] === "string" && typeof args[1] === "function") {
          const state = args[0];
          listener = (currentState, prevState) => {
            if (currentState.state === state) {
              args[1](currentState, prevState);
            }
          };
        } else if (typeof args[0] === "function") {
          listener = args[0];
        } else {
          throw new Error("You are giving the wrong arguments");
        }
        this._listeners.add(listener);
        return () => {
          this._listeners.delete(listener);
        };
      }
      dispose() {
        this._listeners.clear();
        this._isDisposed = true;
      }
    };
    exports.States = States5;
  }
});

// node_modules/humps/humps.js
var require_humps = __commonJS({
  "node_modules/humps/humps.js"(exports, module) {
    (function(global3) {
      var _processKeys = function(convert, obj, options) {
        if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
          return obj;
        }
        var output, i4 = 0, l3 = 0;
        if (_isArray(obj)) {
          output = [];
          for (l3 = obj.length; i4 < l3; i4++) {
            output.push(_processKeys(convert, obj[i4], options));
          }
        } else {
          output = {};
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              output[convert(key, options)] = _processKeys(convert, obj[key], options);
            }
          }
        }
        return output;
      };
      var separateWords = function(string, options) {
        options = options || {};
        var separator = options.separator || "_";
        var split = options.split || /(?=[A-Z])/;
        return string.split(split).join(separator);
      };
      var camelize2 = function(string) {
        if (_isNumerical(string)) {
          return string;
        }
        string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
          return chr ? chr.toUpperCase() : "";
        });
        return string.substr(0, 1).toLowerCase() + string.substr(1);
      };
      var pascalize = function(string) {
        var camelized = camelize2(string);
        return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
      };
      var decamelize = function(string, options) {
        return separateWords(string, options).toLowerCase();
      };
      var toString = Object.prototype.toString;
      var _isFunction = function(obj) {
        return typeof obj === "function";
      };
      var _isObject = function(obj) {
        return obj === Object(obj);
      };
      var _isArray = function(obj) {
        return toString.call(obj) == "[object Array]";
      };
      var _isDate = function(obj) {
        return toString.call(obj) == "[object Date]";
      };
      var _isRegExp = function(obj) {
        return toString.call(obj) == "[object RegExp]";
      };
      var _isBoolean = function(obj) {
        return toString.call(obj) == "[object Boolean]";
      };
      var _isNumerical = function(obj) {
        obj = obj - 0;
        return obj === obj;
      };
      var _processor = function(convert, options) {
        var callback = options && "process" in options ? options.process : options;
        if (typeof callback !== "function") {
          return convert;
        }
        return function(string, options2) {
          return callback(string, convert, options2);
        };
      };
      var humps2 = {
        camelize: camelize2,
        decamelize,
        pascalize,
        depascalize: decamelize,
        camelizeKeys: function(object, options) {
          return _processKeys(_processor(camelize2, options), object);
        },
        decamelizeKeys: function(object, options) {
          return _processKeys(_processor(decamelize, options), object, options);
        },
        pascalizeKeys: function(object, options) {
          return _processKeys(_processor(pascalize, options), object);
        },
        depascalizeKeys: function() {
          return this.decamelizeKeys.apply(this, arguments);
        }
      };
      if (typeof define === "function" && define.amd) {
        define(humps2);
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = humps2;
      } else {
        global3.humps = humps2;
      }
    })(exports);
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module.exports = exports = globalObject.fetch;
    if (globalObject.fetch) {
      exports.default = globalObject.fetch.bind(globalObject);
    }
    exports.Headers = globalObject.Headers;
    exports.Request = globalObject.Request;
    exports.Response = globalObject.Response;
  }
});

// node_modules/class-states/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/class-states/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.States = void 0;
    var States5 = class {
      constructor(initialState) {
        this._listeners = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        this._state = initialState;
        this.onTransition = this.onTransition.bind(this);
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get() {
        return this._state;
      }
      match(...args) {
        const matches = args[1] || args[0];
        const state = args.length === 2 ? args[0] : this._state;
        return matches[state.state] ? matches[state.state](state) : matches._();
      }
      set(state) {
        if (this._isDisposed) {
          return;
        }
        const prevState = this._state;
        this._state = state;
        this._listeners.forEach((listener) => listener(state, prevState));
        return state;
      }
      is(state) {
        return this._state.state === state;
      }
      onTransition(...args) {
        if (this._isDisposed) {
          return;
        }
        let listener;
        if (typeof args[0] === "string" && typeof args[1] === "function") {
          const state = args[0];
          listener = (currentState, prevState) => {
            if (currentState.state === state) {
              args[1](currentState, prevState);
            }
          };
        } else if (typeof args[0] === "function") {
          listener = args[0];
        } else {
          throw new Error("You are giving the wrong arguments");
        }
        this._listeners.add(listener);
        return () => {
          this._listeners.delete(listener);
        };
      }
      dispose() {
        this._listeners.clear();
        this._isDisposed = true;
      }
    };
    exports.States = States5;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s3 = 1e3;
    var m3 = s3 * 60;
    var h3 = m3 * 60;
    var d2 = h3 * 24;
    var w4 = d2 * 7;
    var y3 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y3;
        case "weeks":
        case "week":
        case "w":
          return n2 * w4;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms, msAbs, s3, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i4);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v3) => {
            enableOverride = v3;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m3;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r3;
      try {
        r3 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v3) {
      try {
        return JSON.stringify(v3);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/constants.js
var require_constants3 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/debug.js"(exports, module) {
    var debug4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug4;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants3();
    var debug4 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t3 = exports.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R2++;
      debug4(name, index, value);
      t3[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NUMERICIDENTIFIER]}|${src[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NUMERICIDENTIFIERLOOSE]}|${src[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
    createToken("FULL", `^${src[t3.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
    createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?(?:${src[t3.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t3.COERCE], true);
    createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})\\s+-\\s+(${src[t3.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t3.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a3, b) => {
      const anum = numeric.test(a3);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a3 = +a3;
        b = +b;
      }
      return a3 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a3, b) => compareIdentifiers(b, a3);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/semver.js"(exports, module) {
    var debug4 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants3();
    var { safeRe: re, t: t3 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug4("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m3 = version.trim().match(options.loose ? re[t3.LOOSE] : re[t3.FULL]);
        if (!m3) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m3[1];
        this.minor = +m3[2];
        this.patch = +m3[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m3[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m3[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m3[5] ? m3[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug4("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i4 = 0;
        do {
          const a3 = this.prerelease[i4];
          const b = other.prerelease[i4];
          debug4("prerelease compare", i4, a3, b);
          if (a3 === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b) {
            continue;
          } else {
            return compareIdentifiers(a3, b);
          }
        } while (++i4);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i4 = 0;
        do {
          const a3 = this.build[i4];
          const b = other.build[i4];
          debug4("build compare", i4, a3, b);
          if (a3 === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b) {
            continue;
          } else {
            return compareIdentifiers(a3, b);
          }
        } while (++i4);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i4 = this.prerelease.length;
              while (--i4 >= 0) {
                if (typeof this.prerelease[i4] === "number") {
                  this.prerelease[i4]++;
                  i4 = -2;
                }
              }
              if (i4 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/parse.js
var require_parse4 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse4();
    var valid = (version, options) => {
      const v3 = parse(version, options);
      return v3 ? v3.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse4();
    var clean = (version, options) => {
      const s3 = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s3 ? s3.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse4();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v22 = parse(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a3, loose) => new SemVer(a3, loose).major;
    module.exports = major;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a3, loose) => new SemVer(a3, loose).minor;
    module.exports = minor;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a3, loose) => new SemVer(a3, loose).patch;
    module.exports = patch;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse4();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare2 = (a3, b, loose) => new SemVer(a3, loose).compare(new SemVer(b, loose));
    module.exports = compare2;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare2 = require_compare();
    var rcompare = (a3, b, loose) => compare2(b, a3, loose);
    module.exports = rcompare;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare2 = require_compare();
    var compareLoose = (a3, b) => compare2(a3, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a3, b, loose) => {
      const versionA = new SemVer(a3, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a3, b) => compareBuild(a3, b, loose));
    module.exports = sort;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a3, b) => compareBuild(b, a3, loose));
    module.exports = rsort;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gt.js"(exports, module) {
    var compare2 = require_compare();
    var gt = (a3, b, loose) => compare2(a3, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lt.js"(exports, module) {
    var compare2 = require_compare();
    var lt = (a3, b, loose) => compare2(a3, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/eq.js"(exports, module) {
    var compare2 = require_compare();
    var eq = (a3, b, loose) => compare2(a3, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/neq.js"(exports, module) {
    var compare2 = require_compare();
    var neq = (a3, b, loose) => compare2(a3, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gte.js"(exports, module) {
    var compare2 = require_compare();
    var gte = (a3, b, loose) => compare2(a3, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lte.js"(exports, module) {
    var compare2 = require_compare();
    var lte = (a3, b, loose) => compare2(a3, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a3, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a3 === b;
        case "!==":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a3 !== b;
        case "":
        case "=":
        case "==":
          return eq(a3, b, loose);
        case "!=":
          return neq(a3, b, loose);
        case ">":
          return gt(a3, b, loose);
        case ">=":
          return gte(a3, b, loose);
        case "<":
          return lt(a3, b, loose);
        case "<=":
          return lte(a3, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse4();
    var { safeRe: re, t: t3 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t3.COERCEFULL] : re[t3.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t3.COERCERTLFULL] : re[t3.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/range.js
var require_range3 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/range.js"(exports, module) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c3) => c3.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c3) => !isNullSet(c3[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c3 of this.set) {
              if (c3.length === 1 && isAny(c3[0])) {
                this.set = [c3];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i4 = 0; i4 < this.set.length; i4++) {
            if (i4 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i4];
            for (let k4 = 0; k4 < comps.length; k4++) {
              if (k4 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k4].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t3.HYPHENRANGELOOSE] : re[t3.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug4("hyphen replace", range);
        range = range.replace(re[t3.COMPARATORTRIM], comparatorTrimReplace);
        debug4("comparator trim", range);
        range = range.replace(re[t3.TILDETRIM], tildeTrimReplace);
        debug4("tilde trim", range);
        range = range.replace(re[t3.CARETTRIM], caretTrimReplace);
        debug4("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug4("loose invalid filter", comp, this.options);
            return !!comp.match(re[t3.COMPARATORLOOSE]);
          });
        }
        debug4("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i4 = 0; i4 < this.set.length; i4++) {
          if (testSet(this.set[i4], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t3,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants3();
    var isNullSet = (c3) => c3.value === "<0.0.0-0";
    var isAny = (c3) => c3.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceTilde(c3, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r3 = options.loose ? re[t3.TILDELOOSE] : re[t3.TILDE];
      return comp.replace(r3, (_3, M2, m3, p2, pr) => {
        debug4("tilde", comp, _3, M2, m3, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M2}.${m3}.0 <${M2}.${+m3 + 1}.0-0`;
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m3}.${p2} <${M2}.${+m3 + 1}.0-0`;
        }
        debug4("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceCaret(c3, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug4("caret", comp, options);
      const r3 = options.loose ? re[t3.CARETLOOSE] : re[t3.CARET];
      const z4 = options.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_3, M2, m3, p2, pr) => {
        debug4("caret", comp, _3, M2, m3, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M2}.0.0${z4} <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M2 === "0") {
            ret = `>=${M2}.${m3}.0${z4} <${M2}.${+m3 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m3}.0${z4} <${+M2 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M2 === "0") {
            if (m3 === "0") {
              ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${m3}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m3}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
          }
        } else {
          debug4("no pr");
          if (M2 === "0") {
            if (m3 === "0") {
              ret = `>=${M2}.${m3}.${p2}${z4} <${M2}.${m3}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m3}.${p2}${z4} <${M2}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m3}.${p2} <${+M2 + 1}.0.0-0`;
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c3) => replaceXRange(c3, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r3 = options.loose ? re[t3.XRANGELOOSE] : re[t3.XRANGE];
      return comp.replace(r3, (ret, gtlt, M2, m3, p2, pr) => {
        debug4("xRange", comp, ret, gtlt, M2, m3, p2, pr);
        const xM = isX(M2);
        const xm = xM || isX(m3);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M2 = +M2 + 1;
              m3 = 0;
              p2 = 0;
            } else {
              m3 = +m3 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M2 = +M2 + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M2}.${m3}.${p2}${pr}`;
        } else if (xm) {
          ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M2}.${m3}.0${pr} <${M2}.${+m3 + 1}.0-0`;
        }
        debug4("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(re[t3.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug4("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version, options) => {
      for (let i4 = 0; i4 < set2.length; i4++) {
        if (!set2[i4].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i4 = 0; i4 < set2.length; i4++) {
          debug4(set2[i4].semver);
          if (set2[i4].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i4].semver.prerelease.length > 0) {
            const allowed = set2[i4].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug4("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug4("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re[t3.COMPARATORLOOSE] : re[t3.COMPARATOR];
        const m3 = comp.match(r3);
        if (!m3) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m3[1] !== void 0 ? m3[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m3[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m3[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug4("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t3 } = require_re();
    var cmp = require_cmp();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var Range = require_range3();
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range3();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range3();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c3) => c3.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range3();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v3) => {
        if (rangeObj.test(v3)) {
          if (!max || maxSV.compare(v3) === -1) {
            max = v3;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range3();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v3) => {
        if (rangeObj.test(v3)) {
          if (!min || minSV.compare(v3) === 1) {
            min = v3;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range3();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range3();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range3();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range3();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v3 = versions.sort((a3, b) => compare2(a3, b, options));
      for (const version of v3) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v3[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v3[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range3();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c3 of sub) {
        if (c3.operator === ">" || c3.operator === ">=") {
          gt = higherGT(gt, c3, options);
        } else if (c3.operator === "<" || c3.operator === "<=") {
          lt = lowerLT(lt, c3, options);
        } else {
          eqSet.add(c3.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c3 of dom) {
          if (!satisfies(eq, String(c3), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c3 of dom) {
        hasDomGT = hasDomGT || c3.operator === ">" || c3.operator === ">=";
        hasDomLT = hasDomLT || c3.operator === "<" || c3.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomGTPre.major && c3.semver.minor === needDomGTPre.minor && c3.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c3.operator === ">" || c3.operator === ">=") {
            higher = higherGT(gt, c3, options);
            if (higher === c3 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c3), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomLTPre.major && c3.semver.minor === needDomLTPre.minor && c3.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c3.operator === "<" || c3.operator === "<=") {
            lower = lowerLT(lt, c3, options);
            if (lower === c3 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c3), options)) {
            return false;
          }
        }
        if (!c3.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a3, b, options) => {
      if (!a3) {
        return b;
      }
      const comp = compare2(a3.semver, b.semver, options);
      return comp > 0 ? a3 : comp < 0 ? b : b.operator === ">" && a3.operator === ">=" ? b : a3;
    };
    var lowerLT = (a3, b, options) => {
      if (!a3) {
        return b;
      }
      const comp = compare2(a3.semver, b.semver, options);
      return comp < 0 ? a3 : comp > 0 ? b : b.operator === "<" && a3.operator === "<=" ? b : a3;
    };
    module.exports = subset;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants3();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse4();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff2();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range3();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@hey-api/client-fetch/dist/index.js
var U = /\{[^{}]+\}/g;
var S = ({ allowReserved: n2, name: t3, value: r3 }) => {
  if (r3 == null) return "";
  if (typeof r3 == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
  return `${t3}=${n2 ? r3 : encodeURIComponent(r3)}`;
};
var $ = (n2) => {
  switch (n2) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var D = (n2) => {
  switch (n2) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var _ = (n2) => {
  switch (n2) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var C = ({ allowReserved: n2, explode: t3, name: r3, style: o2, value: a3 }) => {
  if (!t3) {
    let e3 = (n2 ? a3 : a3.map((s3) => encodeURIComponent(s3))).join(D(o2));
    switch (o2) {
      case "label":
        return `.${e3}`;
      case "matrix":
        return `;${r3}=${e3}`;
      case "simple":
        return e3;
      default:
        return `${r3}=${e3}`;
    }
  }
  let c3 = $(o2), i4 = a3.map((e3) => o2 === "label" || o2 === "simple" ? n2 ? e3 : encodeURIComponent(e3) : S({ allowReserved: n2, name: r3, value: e3 })).join(c3);
  return o2 === "label" || o2 === "matrix" ? c3 + i4 : i4;
};
var A = ({ allowReserved: n2, explode: t3, name: r3, style: o2, value: a3 }) => {
  if (a3 instanceof Date) return `${r3}=${a3.toISOString()}`;
  if (o2 !== "deepObject" && !t3) {
    let e3 = [];
    Object.entries(a3).forEach(([u4, g]) => {
      e3 = [...e3, u4, n2 ? g : encodeURIComponent(g)];
    });
    let s3 = e3.join(",");
    switch (o2) {
      case "form":
        return `${r3}=${s3}`;
      case "label":
        return `.${s3}`;
      case "matrix":
        return `;${r3}=${s3}`;
      default:
        return s3;
    }
  }
  let c3 = _(o2), i4 = Object.entries(a3).map(([e3, s3]) => S({ allowReserved: n2, name: o2 === "deepObject" ? `${r3}[${e3}]` : e3, value: s3 })).join(c3);
  return o2 === "label" || o2 === "matrix" ? c3 + i4 : i4;
};
var k = ({ path: n2, url: t3 }) => {
  let r3 = t3, o2 = t3.match(U);
  if (o2) for (let a3 of o2) {
    let c3 = false, i4 = a3.substring(1, a3.length - 1), e3 = "simple";
    i4.endsWith("*") && (c3 = true, i4 = i4.substring(0, i4.length - 1)), i4.startsWith(".") ? (i4 = i4.substring(1), e3 = "label") : i4.startsWith(";") && (i4 = i4.substring(1), e3 = "matrix");
    let s3 = n2[i4];
    if (s3 == null) continue;
    if (Array.isArray(s3)) {
      r3 = r3.replace(a3, C({ explode: c3, name: i4, style: e3, value: s3 }));
      continue;
    }
    if (typeof s3 == "object") {
      r3 = r3.replace(a3, A({ explode: c3, name: i4, style: e3, value: s3 }));
      continue;
    }
    if (e3 === "matrix") {
      r3 = r3.replace(a3, `;${S({ name: i4, value: s3 })}`);
      continue;
    }
    let u4 = encodeURIComponent(e3 === "label" ? `.${s3}` : s3);
    r3 = r3.replace(a3, u4);
  }
  return r3;
};
var R = ({ allowReserved: n2, array: t3, object: r3 } = {}) => (a3) => {
  let c3 = [];
  if (a3 && typeof a3 == "object") for (let i4 in a3) {
    let e3 = a3[i4];
    if (e3 != null) {
      if (Array.isArray(e3)) {
        c3 = [...c3, C({ allowReserved: n2, explode: true, name: i4, style: "form", value: e3, ...t3 })];
        continue;
      }
      if (typeof e3 == "object") {
        c3 = [...c3, A({ allowReserved: n2, explode: true, name: i4, style: "deepObject", value: e3, ...r3 })];
        continue;
      }
      c3 = [...c3, S({ allowReserved: n2, name: i4, value: e3 })];
    }
  }
  return c3.join("&");
};
var w = (n2) => {
  if (!n2) return;
  let t3 = n2.split(";")[0].trim();
  if (t3.startsWith("application/json") || t3.endsWith("+json")) return "json";
  if (t3 === "multipart/form-data") return "formData";
  if (["application/", "audio/", "image/", "video/"].some((r3) => t3.startsWith(r3))) return "blob";
  if (t3.startsWith("text/")) return "text";
};
var P = ({ baseUrl: n2, path: t3, query: r3, querySerializer: o2, url: a3 }) => {
  let c3 = a3.startsWith("/") ? a3 : `/${a3}`, i4 = n2 + c3;
  t3 && (i4 = k({ path: t3, url: i4 }));
  let e3 = r3 ? o2(r3) : "";
  return e3.startsWith("?") && (e3 = e3.substring(1)), e3 && (i4 += `?${e3}`), i4;
};
var O = (n2, t3) => {
  let r3 = { ...n2, ...t3 };
  return r3.baseUrl?.endsWith("/") && (r3.baseUrl = r3.baseUrl.substring(0, r3.baseUrl.length - 1)), r3.headers = x(n2.headers, t3.headers), r3;
};
var x = (...n2) => {
  let t3 = new Headers();
  for (let r3 of n2) {
    if (!r3 || typeof r3 != "object") continue;
    let o2 = r3 instanceof Headers ? r3.entries() : Object.entries(r3);
    for (let [a3, c3] of o2) if (c3 === null) t3.delete(a3);
    else if (Array.isArray(c3)) for (let i4 of c3) t3.append(a3, i4);
    else c3 !== void 0 && t3.set(a3, typeof c3 == "object" ? JSON.stringify(c3) : c3);
  }
  return t3;
};
var y = class {
  _fns;
  constructor() {
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(t3) {
    return this._fns.indexOf(t3) !== -1;
  }
  eject(t3) {
    let r3 = this._fns.indexOf(t3);
    r3 !== -1 && (this._fns = [...this._fns.slice(0, r3), ...this._fns.slice(r3 + 1)]);
  }
  use(t3) {
    this._fns = [...this._fns, t3];
  }
};
var E = () => ({ error: new y(), request: new y(), response: new y() });
var I = { bodySerializer: (n2) => JSON.stringify(n2) };
var N = R({ allowReserved: false, array: { explode: true, style: "form" }, object: { explode: true, style: "deepObject" } });
var B = { "Content-Type": "application/json" };
var z = (n2 = {}) => ({ ...I, baseUrl: "", headers: B, parseAs: "auto", querySerializer: N, ...n2 });
var L = (n2 = {}) => {
  let t3 = O(z(), n2), r3 = () => ({ ...t3 }), o2 = (e3) => (t3 = O(t3, e3), r3()), a3 = (e3) => P({ baseUrl: e3.baseUrl ?? "", path: e3.path, query: e3.query, querySerializer: typeof e3.querySerializer == "function" ? e3.querySerializer : R(e3.querySerializer), url: e3.url }), c3 = E(), i4 = async (e3) => {
    let s3 = { ...t3, ...e3, fetch: e3.fetch ?? t3.fetch ?? globalThis.fetch, headers: x(t3.headers, e3.headers) };
    s3.body && s3.bodySerializer && (s3.body = s3.bodySerializer(s3.body)), s3.body || s3.headers.delete("Content-Type");
    let u4 = a3(s3), g = { redirect: "follow", ...s3 }, f3 = new Request(u4, g);
    for (let p2 of c3.request._fns) f3 = await p2(f3, s3);
    let T2 = s3.fetch, l3 = await T2(f3);
    for (let p2 of c3.response._fns) l3 = await p2(l3, f3, s3);
    let m3 = { request: f3, response: l3 };
    if (l3.ok) {
      if (l3.status === 204 || l3.headers.get("Content-Length") === "0") return { data: {}, ...m3 };
      if (s3.parseAs === "stream") return { data: l3.body, ...m3 };
      let p2 = (s3.parseAs === "auto" ? w(l3.headers.get("Content-Type")) : s3.parseAs) ?? "json", b = await l3[p2]();
      return p2 === "json" && s3.responseTransformer && (b = await s3.responseTransformer(b)), { data: b, ...m3 };
    }
    let h3 = await l3.text();
    try {
      h3 = JSON.parse(h3);
    } catch {
    }
    let d2 = h3;
    for (let p2 of c3.error._fns) d2 = await p2(h3, l3, f3, s3);
    if (d2 = d2 || {}, s3.throwOnError) throw d2;
    return { error: d2, ...m3 };
  };
  return { buildUrl: a3, connect: (e3) => i4({ ...e3, method: "CONNECT" }), delete: (e3) => i4({ ...e3, method: "DELETE" }), get: (e3) => i4({ ...e3, method: "GET" }), getConfig: r3, head: (e3) => i4({ ...e3, method: "HEAD" }), interceptors: c3, options: (e3) => i4({ ...e3, method: "OPTIONS" }), patch: (e3) => i4({ ...e3, method: "PATCH" }), post: (e3) => i4({ ...e3, method: "POST" }), put: (e3) => i4({ ...e3, method: "PUT" }), request: i4, setConfig: o2, trace: (e3) => i4({ ...e3, method: "TRACE" }) };
};

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var import_pitcher_common32 = __toESM(require_dist3());
var protocol = __toESM(require_src());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/MemoryFS.js
var import_pitcher_common = __toESM(require_dist3());
var MemoryFS = class {
  constructor() {
    this.pendingOperations = /* @__PURE__ */ new Map();
    this.revertOperations = /* @__PURE__ */ new Map();
    this.messageId = 0;
    this.incomingOperations = /* @__PURE__ */ new Set();
    this.remoteClock = 0;
    this.tree = new import_pitcher_common.bedrockFS.Tree();
  }
  populateTreeFromJSON(payload) {
    this.remoteClock = payload.clock;
    this.tree = import_pitcher_common.bedrockFS.Tree.fromJSON(payload.treeNodes);
    this.syncFSTree([]);
  }
  /** Applies an operation and returns the inverse operation */
  applyOperation(op) {
    switch (op.type) {
      case "create": {
        const parentNode = this.tree.getNodeById(op.parentId);
        if (!parentNode?.isDirNode())
          return false;
        switch (op.newEntry.type) {
          case import_pitcher_common.bedrockFS.NodeType.File:
            parentNode.createFileWithId(op.newEntry.id, op.newEntry.name);
            break;
          case import_pitcher_common.bedrockFS.NodeType.Directory:
            parentNode.createDirectoryWithId(op.newEntry.id, op.newEntry.name);
            break;
        }
        return {
          type: "delete",
          id: op.newEntry.id
        };
      }
      case "delete": {
        const nodeToDelete = this.tree.getNodeById(op.id);
        if (!nodeToDelete?.parentId)
          return false;
        this.tree.deleteNode(op.id);
        return {
          type: "create",
          parentId: nodeToDelete.parentId,
          newEntry: {
            id: nodeToDelete.id,
            type: nodeToDelete.type,
            // Typescript complains otherwise... but this should be fine
            name: nodeToDelete.name ?? ""
          }
        };
      }
      case "move": {
        const nodeToMove = this.tree.getNodeById(op.id);
        if (!nodeToMove)
          return false;
        const reverseOp = {
          type: "move",
          id: op.id
        };
        reverseOp.parentId = nodeToMove.parentId;
        if (op.name) {
          reverseOp.name = nodeToMove.name;
        }
        const parentId = op.parentId ?? nodeToMove.parentId;
        if (!parentId) {
          throw new Error("Move requires a parentId");
        }
        this.tree.moveNode(op.id, parentId, op.name);
        return reverseOp;
      }
    }
  }
  /** Apply a client-side created operation, these get added to a queue and synced to pitcher */
  applyPendingOperation(op) {
    this.messageId++;
    this.pendingOperations.set(this.messageId, op);
    const reverseOp = this.applyOperation(op);
    if (!reverseOp) {
      this.pendingOperations.delete(this.messageId);
      return false;
    }
    this.revertOperations.set(this.messageId, reverseOp);
    return this.messageId;
  }
  /**
   * received an operation notification from the server
   *
   * This can be:
   * - Operation created by other client
   * - Confirmation for a pending operation this client created
   */
  receiveNotification(evt) {
    this.incomingOperations.add(evt);
  }
  /**
   * sync the fs tree, dropping operations that have been processed by the server
   * @param pendingOpsToDrop the list of operations that have been processed by the server
   * @returns the amount of operations that have been applied
   */
  syncFSTree(pendingOpsToDrop) {
    let opCount = 0;
    const sortedEvents = [...this.incomingOperations].sort((a3, b) => a3.clock - b.clock);
    for (const op of this.revertOperations.values()) {
      this.applyOperation(op);
    }
    let nextClock = this.remoteClock + 1;
    for (const fsEvent of sortedEvents) {
      if (fsEvent.clock < nextClock) {
        this.incomingOperations.delete(fsEvent);
      } else if (fsEvent.clock === nextClock) {
        this.applyOperation(fsEvent.operation);
        this.incomingOperations.delete(fsEvent);
        this.remoteClock = fsEvent.clock;
        opCount++;
      }
      nextClock++;
    }
    for (const msgIdx of pendingOpsToDrop) {
      this.pendingOperations.delete(msgIdx);
      this.revertOperations.delete(msgIdx);
    }
    for (const msgId of this.pendingOperations.keys()) {
      const op = this.pendingOperations.get(msgId);
      if (op) {
        const reverseOp = this.applyOperation(op);
        if (!reverseOp) {
          this.revertOperations.delete(msgId);
          this.pendingOperations.delete(msgId);
        } else {
          this.revertOperations.set(msgId, reverseOp);
          opCount++;
        }
      }
    }
    return opCount;
  }
  getPathFromId(id) {
    const node = this.tree.getNodeById(id);
    if (node) {
      return node.path;
    }
  }
  getIdFromPath(path) {
    return this.tree.getIdFromPath(path);
  }
  getNodeById(id) {
    return this.tree.getNodeById(id);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/common/PendingPitcherMessage.js
var import_pitcher_common2 = __toESM(require_dist3());
var import_pitcher_protocol = __toESM(require_src());
var PITCHER_MESSAGE_TIMEOUT_MS = 9e4;
var PitcherMessageError = class _PitcherMessageError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  static match(error) {
    return error instanceof _PitcherMessageError;
  }
  static matchCode(error, code) {
    return error instanceof _PitcherMessageError && error.code === code;
  }
};
var PendingPitcherMessage = class extends import_pitcher_common2.Disposable {
  constructor(id, request, timeoutMs = PITCHER_MESSAGE_TIMEOUT_MS) {
    super();
    this._hasResolved = false;
    this.id = id;
    const data = {
      ...request,
      id
    };
    this.method = request.method;
    this.message = (0, import_pitcher_protocol.createRequestPayload)(data);
    this.timeoutRef = setTimeout(() => this.dispose(`Pitcher message ${this.method} timed out`), timeoutMs);
    this.onWillDispose(() => {
      if (this.timeoutRef) {
        clearTimeout(this.timeoutRef);
        this.timeoutRef = void 0;
      }
    });
    this.promise = new Promise((_resolve, _reject) => {
      this._resolve = _resolve;
      this._reject = _reject;
    }).then((response) => {
      if (response.status === import_pitcher_protocol.PitcherResponseStatus.RESOLVED) {
        return response.result;
      }
      const err = new PitcherMessageError(response.error.message, response.error.code);
      err.data = response.error.data;
      throw err;
    });
  }
  resolve(response) {
    if (!this.isDisposed && this._resolve) {
      this._resolve(response);
      this._hasResolved = true;
    }
    this.dispose();
  }
  reject(error) {
    if (!this.isDisposed && this._reject) {
      this._reject(error);
      this._hasResolved = true;
    }
    this.dispose();
  }
  unwrap() {
    return this.promise;
  }
  dispose(message) {
    if (!this._hasResolved && this._reject) {
      this._reject(new Error(message ?? `Pitcher message ${this.method} has been disposed`));
    }
    super.dispose();
    if (this.timeoutRef) {
      clearTimeout(this.timeoutRef);
      this.timeoutRef = void 0;
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/common/Rc.js
var import_pitcher_common3 = __toESM(require_dist3());
var RcRef = class extends import_pitcher_common3.Disposable {
  constructor(rc, onDrop) {
    super();
    this.rc = rc;
    this.onWillDispose(() => {
      if (!this.isDisposed) {
        onDrop();
      }
    });
  }
  get object() {
    return this.rc.object;
  }
};
var shouldTrace = false;
try {
  shouldTrace = typeof window !== "undefined" && localStorage.getItem("CSB_RC_DEBUG") === "ENABLED";
} catch {
}
if (shouldTrace) {
  window.RC_DEBUG = {
    traceLog: [],
    counters: /* @__PURE__ */ new Map()
  };
}
var nextRefId = 0;
var Rc = class _Rc extends import_pitcher_common3.Disposable {
  static trace(event, ref) {
    if (!shouldTrace) {
      return;
    }
    try {
      throw new Error("RC_TRACE");
    } catch (error) {
      if (error instanceof Error) {
        const stack = (error.stack || "").split("\n").filter((entry) => !entry.includes("node_modules") && !entry.includes("Rc.js") && !entry.includes("RC_TRACE") && entry.match(/[a-zA-Z0-9_-]+/));
        const location2 = stack[0] || "";
        const debug4 = window.RC_DEBUG;
        const logItem = {
          id: ref instanceof _Rc ? ref.id : null,
          event,
          ref: ref instanceof _Rc ? ref.object : ref,
          count: ref instanceof _Rc ? ref.count : 0,
          location: "..." + location2.substring(location2.length - 50),
          stack
        };
        debug4.traceLog.push(logItem);
        if (!(ref instanceof _Rc)) {
          return;
        }
        const counter = debug4.counters.get(ref.object);
        if (counter) {
          counter.push(logItem);
        } else {
          debug4.counters.set(ref.object, [logItem]);
        }
      }
    }
  }
  constructor(object, handleDispose) {
    super();
    this.object = object;
    this.count = 0;
    this.id = `REF-` + nextRefId++;
    this.onWillDispose(handleDispose);
    _Rc.trace("rc.create", this);
  }
  acquire() {
    if (this.isDisposed) {
      throw new Error("Cannot re-acquire a destroyed Rc");
    }
    this.count += 1;
    _Rc.trace("rc.acquire", this);
    return new RcRef(this, () => {
      this.count -= 1;
      _Rc.trace("rc.drop", this);
      if (this.count === 0) {
        _Rc.trace("rc.dispose", this);
        return super.dispose();
      }
    });
  }
  dispose() {
    throw new Error("Cannot call dispose directly, need to use the RcRef");
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/browser/clients/port/Sandpack.js
var import_pitcher_common4 = __toESM(require_dist3());
var import_BedrockFS = __toESM(require_BedrockFS());

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var import_pitcher_common33 = __toESM(require_dist3());

// node_modules/core-js/modules/es6.array.find-index.js
var $export = require_export();
var $find = require_array_methods()(6);
var KEY = "findIndex";
var forced = true;
if (KEY in []) Array(1)[KEY](function() {
  forced = false;
});
$export($export.P + $export.F * forced, "Array", {
  findIndex: function findIndex(callbackfn) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
require_add_to_unscopables()(KEY);

// node_modules/core-js/modules/es6.array.find.js
var $export2 = require_export();
var $find2 = require_array_methods()(5);
var KEY2 = "find";
var forced2 = true;
if (KEY2 in []) Array(1)[KEY2](function() {
  forced2 = false;
});
$export2($export2.P + $export2.F * forced2, "Array", {
  find: function find(callbackfn) {
    return $find2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
require_add_to_unscopables()(KEY2);

// node_modules/core-js/modules/es6.function.name.js
var dP = require_object_dp().f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = "name";
NAME in FProto || require_descriptors() && dP(FProto, NAME, {
  configurable: true,
  get: function() {
    try {
      return ("" + this).match(nameRE)[1];
    } catch (e3) {
      return "";
    }
  }
});

// node_modules/@jumpn/utils-composite/dist/index.js
var import_newArrowCheck2 = __toESM(require_newArrowCheck());
var import_Fun2 = __toESM(require_Fun());
var import_typeof = __toESM(require_typeof());

// node_modules/@jumpn/utils-array/dist/index.js
var import_toConsumableArray = __toESM(require_toConsumableArray());
var import_newArrowCheck = __toESM(require_newArrowCheck());
var import_Fun = __toESM(require_Fun2());
var import_extends = __toESM(require_extends());
var import_from = __toESM(require_from2());
var import_keys = __toESM(require_keys2());
var import_is_integer = __toESM(require_is_integer3());
var import_objectWithoutProperties = __toESM(require_objectWithoutProperties());
var _this = void 0;
var append = function(elements, array) {
  (0, import_newArrowCheck.default)(this, _this);
  return [].concat((0, import_toConsumableArray.default)(array), (0, import_toConsumableArray.default)(elements));
}.bind(void 0);
var append$1 = (0, import_Fun.curry)(append);
var _this$1 = void 0;
var convertIfNot = function(input) {
  (0, import_newArrowCheck.default)(this, _this$1);
  return Array.isArray(input) ? input : [input];
}.bind(void 0);
var _this$3 = void 0;
var isLastIndex = function(array, index) {
  (0, import_newArrowCheck.default)(this, _this$3);
  return index === array.length - 1;
}.bind(void 0);
var isLastIndex$1 = (0, import_Fun.curry)(isLastIndex);
var _this$2 = void 0;
var cycleNext = function(array, currentIndex) {
  (0, import_newArrowCheck.default)(this, _this$2);
  return isLastIndex$1(array, currentIndex) ? 0 : currentIndex + 1;
}.bind(void 0);
var cycleNext$1 = (0, import_Fun.curry)(cycleNext);
var _this$4 = void 0;
var getObjectLength = function(object) {
  (0, import_newArrowCheck.default)(this, _this$4);
  return Math.max.apply(Math, (0, import_toConsumableArray.default)((0, import_keys.default)(object))) + 1;
}.bind(void 0);
var fromObject = function(object) {
  (0, import_newArrowCheck.default)(this, _this$4);
  return (0, import_from.default)("length" in object ? object : (0, import_extends.default)({}, object, { length: getObjectLength(object) }));
}.bind(void 0);
var _this$5 = void 0;
var insert = function(index, elements, array) {
  (0, import_newArrowCheck.default)(this, _this$5);
  return [].concat((0, import_toConsumableArray.default)(array.slice(0, index)), (0, import_toConsumableArray.default)(elements), (0, import_toConsumableArray.default)(array.slice(index + 1)));
}.bind(void 0);
var insert$1 = (0, import_Fun.curry)(insert);
var _this$6 = void 0;
var isIntGreaterThan = function(number, other) {
  (0, import_newArrowCheck.default)(this, _this$6);
  return (0, import_is_integer.default)(number) && number >= other;
}.bind(void 0);
var isKey = function(string) {
  (0, import_newArrowCheck.default)(this, _this$6);
  return isIntGreaterThan(Number(string), 0);
}.bind(void 0);
var _this$7 = void 0;
var isPossibleFromObject = function(_ref) {
  var length = _ref.length, rest = (0, import_objectWithoutProperties.default)(_ref, ["length"]);
  (0, import_newArrowCheck.default)(this, _this$7);
  return (0, import_keys.default)(rest).every(isKey);
}.bind(void 0);
var _this$8 = void 0;
var prepend = function(elements, array) {
  (0, import_newArrowCheck.default)(this, _this$8);
  return [].concat((0, import_toConsumableArray.default)(elements), (0, import_toConsumableArray.default)(array));
}.bind(void 0);
var prepend$1 = (0, import_Fun.curry)(prepend);
var _this$9 = void 0;
var reduceIf = function(filter, reduce, resultInitial, array) {
  (0, import_newArrowCheck.default)(this, _this$9);
  return array.reduce(function(result, element, index) {
    (0, import_newArrowCheck.default)(this, _this$9);
    return filter(element, index, result) ? reduce(result, element, index) : result;
  }.bind(this), resultInitial);
}.bind(void 0);
var reduceIf$1 = (0, import_Fun.curry)(reduceIf);
var _this$10 = void 0;
var reduceWhile = function(shouldProceed, reduce, resultInitial, array) {
  (0, import_newArrowCheck.default)(this, _this$10);
  var result = resultInitial;
  array.every(function(element, index) {
    (0, import_newArrowCheck.default)(this, _this$10);
    var proceed = shouldProceed(element, index, result);
    if (proceed) {
      result = reduce(result, element, index);
    }
    return proceed;
  }.bind(this));
  return result;
}.bind(void 0);
var reduceWhile$1 = (0, import_Fun.curry)(reduceWhile);
var _this$11 = void 0;
var remove = function(index, count, array) {
  (0, import_newArrowCheck.default)(this, _this$11);
  return [].concat((0, import_toConsumableArray.default)(array.slice(0, index)), (0, import_toConsumableArray.default)(array.slice(index + count)));
}.bind(void 0);
var remove$1 = (0, import_Fun.curry)(remove);
var _this$12 = void 0;
var repeat = function(count, element) {
  (0, import_newArrowCheck.default)(this, _this$12);
  return [].concat((0, import_toConsumableArray.default)(Array(count))).map(function() {
    (0, import_newArrowCheck.default)(this, _this$12);
    return element;
  }.bind(this));
}.bind(void 0);
var repeat$1 = (0, import_Fun.curry)(repeat);
var _this$13 = void 0;
var replace = function(index, elements, array) {
  (0, import_newArrowCheck.default)(this, _this$13);
  return [].concat((0, import_toConsumableArray.default)(array.slice(0, index)), (0, import_toConsumableArray.default)(elements), (0, import_toConsumableArray.default)(array.slice(index + elements.length)));
}.bind(void 0);
var replace$1 = (0, import_Fun.curry)(replace);
var _this$14 = void 0;
var resolveIndex = function(array, relativeIndex) {
  (0, import_newArrowCheck.default)(this, _this$14);
  return relativeIndex < 0 ? array.length - relativeIndex : relativeIndex;
}.bind(void 0);
var resolveIndex$1 = (0, import_Fun.curry)(resolveIndex);

// node_modules/@jumpn/utils-composite/dist/index.js
var import_keys2 = __toESM(require_keys2());
var import_toConsumableArray2 = __toESM(require_toConsumableArray());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_defineProperty = __toESM(require_defineProperty());
var import_extends2 = __toESM(require_extends());
var import_slicedToArray = __toESM(require_slicedToArray());
var import_entries = __toESM(require_entries2());
var import_objectWithoutProperties2 = __toESM(require_objectWithoutProperties());
var import_symbol = __toESM(require_symbol2());
var _this2 = void 0;
var get = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this2), r3[e3];
}.bind(void 0);
var get$1 = (0, import_Fun2.curry)(get);
var _this$22 = void 0;
var isObject = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$22), null !== e3 && "object" === (void 0 === e3 ? "undefined" : (0, import_typeof.default)(e3));
}.bind(void 0);
var is = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$22), Array.isArray(e3) || isObject(e3);
}.bind(void 0);
var _this$15 = void 0;
var getInIfNeeded = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$15), isLastIndex$1(r3, e3) ? t3 : getInRecur(e3 + 1, r3, t3);
}.bind(void 0);
var getNotCompositeErrorMessage = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$15), "Expected to find a composite at [" + String(r3.join(", ")) + "][" + String(e3) + "], but instead got: " + (void 0 === t3 ? "undefined" : (0, import_typeof.default)(t3));
}.bind(void 0);
var ensureIsComposite = function(e3, r3, t3) {
  if ((0, import_newArrowCheck2.default)(this, _this$15), is(t3)) return t3;
  throw new Error(getNotCompositeErrorMessage(e3, r3, t3));
}.bind(void 0);
var getInRecur = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$15), void 0 === t3 ? void 0 : getInIfNeeded(e3, r3, get$1(r3[e3], ensureIsComposite(e3, r3, t3)));
}.bind(void 0);
var getIn = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$15), 0 === e3.length ? void 0 : getInRecur(0, e3, r3);
}.bind(void 0);
var getIn$1 = (0, import_Fun2.curry)(getIn);
var _this$32 = void 0;
var getKeys = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$32), Array.isArray(e3) ? [].concat((0, import_toConsumableArray2.default)(e3.keys())) : (0, import_keys2.default)(e3);
}.bind(void 0);
var _this$42 = void 0;
var hasIn = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$42), (0, import_fast_deep_equal.default)(getIn$1(e3, t3), r3);
}.bind(void 0);
var hasIn$1 = (0, import_Fun2.curry)(hasIn);
var _this$52 = void 0;
var hasKey = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$52), Object.prototype.hasOwnProperty.call(r3, e3);
}.bind(void 0);
var hasKey$1 = (0, import_Fun2.curry)(hasKey);
var _this$62 = void 0;
var haveSameProps = function(e3, r3) {
  (0, import_newArrowCheck2.default)(this, _this$62);
  var t3 = getKeys(e3);
  return t3.length === getKeys(r3).length && t3.every(function(t4) {
    return (0, import_newArrowCheck2.default)(this, _this$62), hasKey$1(t4, r3) && get$1(t4, e3) === get$1(t4, r3);
  }.bind(this));
}.bind(void 0);
var haveSameProps$1 = (0, import_Fun2.curry)(haveSameProps);
var _this$72 = void 0;
var isEmpty = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$72), 0 === getKeys(e3).length;
}.bind(void 0);
var _this$82 = void 0;
var mapObject = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$82), (0, import_entries.default)(r3).reduce(function(t3, i4) {
    var n2 = (0, import_slicedToArray.default)(i4, 2), o2 = n2[0], s3 = n2[1];
    return (0, import_newArrowCheck2.default)(this, _this$82), (0, import_extends2.default)({}, t3, (0, import_defineProperty.default)({}, o2, e3(s3, o2, r3)));
  }.bind(this), {});
}.bind(void 0);
var map = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$82), Array.isArray(r3) ? r3.map(e3) : mapObject(e3, r3);
}.bind(void 0);
var map$1 = (0, import_Fun2.curry)(map);
var _this$92 = void 0;
var objectRemove = function(e3, r3) {
  r3[e3];
  var t3 = (0, import_objectWithoutProperties2.default)(r3, [e3]);
  return (0, import_newArrowCheck2.default)(this, _this$92), t3;
}.bind(void 0);
var remove$12 = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$92), Array.isArray(r3) ? remove$1(e3, 1, r3) : objectRemove(e3, r3);
}.bind(void 0);
var remove$2 = (0, import_Fun2.curry)(remove$12);
var _this$122 = void 0;
var shallowCopy = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$122), Array.isArray(e3) ? [].concat((0, import_toConsumableArray2.default)(e3)) : (0, import_extends2.default)({}, e3);
}.bind(void 0);
var _this$112 = void 0;
var createReduceContext = function(e3) {
  (0, import_newArrowCheck2.default)(this, _this$112);
  var r3 = shallowCopy(e3);
  return { origin: r3, current: r3, previous: void 0 };
}.bind(void 0);
var set = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$112), t3[e3] = r3, get$1(e3, t3);
}.bind(void 0);
var updateSet = function(e3, r3, t3, i4) {
  return (0, import_newArrowCheck2.default)(this, _this$112), (0, import_extends2.default)({}, i4, { current: set(e3[r3], t3, i4.current), previous: i4.current });
}.bind(void 0);
var updateRemove = function(e3, r3, t3) {
  (0, import_newArrowCheck2.default)(this, _this$112);
  var i4 = remove$2(e3[r3], t3.current);
  return 0 === r3 ? (0, import_extends2.default)({}, t3, { current: i4, origin: i4 }) : (0, import_extends2.default)({}, t3, { previous: set(e3[r3 - 1], i4, t3.previous) });
}.bind(void 0);
var removeAction = (0, import_symbol.default)("composite.updateIn.removeAction");
var update = function(e3, r3, t3, i4) {
  return (0, import_newArrowCheck2.default)(this, _this$112), t3 === removeAction ? updateRemove(e3, r3, i4) : updateSet(e3, r3, t3, i4);
}.bind(void 0);
var createSupporting = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$112), "number" == typeof e3 ? [] : {};
}.bind(void 0);
var copyOrCreate = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$112), hasKey$1(e3, t3) ? shallowCopy(get$1(e3, t3)) : createSupporting(r3);
}.bind(void 0);
var getNext = function(e3, r3, t3, i4) {
  return (0, import_newArrowCheck2.default)(this, _this$112), isLastIndex$1(e3, t3) ? r3(get$1(e3[t3], i4)) : copyOrCreate(e3[t3], e3[t3 + 1], i4);
}.bind(void 0);
var getReducer = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$112), function(t3, i4, n2) {
    return (0, import_newArrowCheck2.default)(this, _this$112), update(e3, n2, getNext(e3, r3, n2, t3.current), t3);
  }.bind(this);
}.bind(void 0);
var updateIn = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$112), 0 === e3.length ? t3 : e3.reduce(getReducer(e3, r3), createReduceContext(t3)).origin;
}.bind(void 0);
var updateInCurried = (0, import_Fun2.curry)(updateIn);
updateInCurried.remove = removeAction;
var _this$102 = void 0;
var remove$3 = function() {
  return (0, import_newArrowCheck2.default)(this, _this$102), updateInCurried.remove;
}.bind(void 0);
var removeIn = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$102), updateInCurried(e3, remove$3, r3);
}.bind(void 0);
var removeIn$1 = (0, import_Fun2.curry)(removeIn);
var _this$132 = void 0;
var set$1 = function(e3, r3, t3) {
  (0, import_newArrowCheck2.default)(this, _this$132);
  var i4 = shallowCopy(t3);
  return i4[e3] = r3, i4;
}.bind(void 0);
var set$2 = (0, import_Fun2.curry)(set$1);
var _this$142 = void 0;
var setIn = function(e3, r3, t3) {
  return (0, import_newArrowCheck2.default)(this, _this$142), updateInCurried(e3, function() {
    return (0, import_newArrowCheck2.default)(this, _this$142), r3;
  }.bind(this), t3);
}.bind(void 0);
var setIn$1 = (0, import_Fun2.curry)(setIn);
var _this$152 = void 0;
var xor = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$152), Boolean(Number(e3) ^ Number(r3));
}.bind(void 0);
var shallowEqual = function(e3, r3) {
  return (0, import_newArrowCheck2.default)(this, _this$152), e3 === r3 || !xor(Array.isArray(e3), Array.isArray(r3)) && haveSameProps$1(e3, r3);
}.bind(void 0);
var shallowEqual$1 = (0, import_Fun2.curry)(shallowEqual);
var _this$16 = void 0;
var toUndefinedIfEmpty = function(e3) {
  return (0, import_newArrowCheck2.default)(this, _this$16), isEmpty(e3) ? void 0 : e3;
}.bind(void 0);

// node_modules/core-js/modules/web.dom.iterable.js
var $iterators = require_es6_array_iterator2();
var getKeys2 = require_object_keys2();
var redefine = require_redefine();
var global2 = require_global();
var hide = require_hide();
var Iterators = require_iterators2();
var wks = require_wks();
var ITERATOR = wks("iterator");
var TO_STRING_TAG = wks("toStringTag");
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};
for (collections = getKeys2(DOMIterables), i4 = 0; i4 < collections.length; i4++) {
  NAME2 = collections[i4];
  explicit = DOMIterables[NAME2];
  Collection = global2[NAME2];
  proto = Collection && Collection.prototype;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME2);
    Iterators[NAME2] = ArrayValues;
    if (explicit) {
      for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}
var NAME2;
var explicit;
var Collection;
var proto;
var key;
var collections;
var i4;

// node_modules/core-js/modules/es6.array.for-each.js
var $export3 = require_export();
var $forEach = require_array_methods()(0);
var STRICT = require_strict_method()([].forEach, true);
$export3($export3.P + $export3.F * !STRICT, "Array", {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

// node_modules/@absinthe/socket/dist/index.js
var import_toConsumableArray3 = __toESM(require_toConsumableArray2());

// node_modules/core-js/modules/es6.array.map.js
var $export4 = require_export();
var $map = require_array_methods()(1);
$export4($export4.P + $export4.F * !require_strict_method()([].map, true), "Array", {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map2(callbackfn) {
    return $map(this, callbackfn, arguments[1]);
  }
});

// node_modules/core-js/modules/es6.regexp.match.js
var anObject = require_an_object();
var toLength = require_to_length();
var advanceStringIndex = require_advance_string_index();
var regExpExec = require_regexp_exec_abstract();
require_fix_re_wks()("match", 1, function(defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O3 = defined(this);
      var fn = regexp == void 0 ? void 0 : regexp[MATCH];
      return fn !== void 0 ? fn.call(regexp, O3) : new RegExp(regexp)[MATCH](String(O3));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function(regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S3 = String(this);
      if (!rx.global) return regExpExec(rx, S3);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A3 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec(rx, S3)) !== null) {
        var matchStr = String(result[0]);
        A3[n2] = matchStr;
        if (matchStr === "") rx.lastIndex = advanceStringIndex(S3, toLength(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A3;
    }
  ];
});

// node_modules/core-js/modules/es6.array.some.js
var $export5 = require_export();
var $some = require_array_methods()(3);
$export5($export5.P + $export5.F * !require_strict_method()([].some, true), "Array", {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn) {
    return $some(this, callbackfn, arguments[1]);
  }
});

// node_modules/core-js/modules/es6.function.bind.js
var $export6 = require_export();
$export6($export6.P, "Function", { bind: require_bind() });

// node_modules/@jumpn/utils-graphql/dist/index.js
var import_newArrowCheck3 = __toESM(require_newArrowCheck2());
var _this3 = void 0;
var locationsToString = function locationsToString2(locations) {
  var _this22 = this;
  (0, import_newArrowCheck3.default)(this, _this3);
  return locations.map(function(_ref) {
    var column = _ref.column, line = _ref.line;
    (0, import_newArrowCheck3.default)(this, _this22);
    return "".concat(line, ":").concat(column);
  }.bind(this)).join("; ");
}.bind(void 0);
var errorToString = function errorToString2(_ref2) {
  var message = _ref2.message, locations = _ref2.locations;
  (0, import_newArrowCheck3.default)(this, _this3);
  return message + (locations ? " (".concat(locationsToString(locations), ")") : "");
}.bind(void 0);
var errorsToString = function errorsToString2(gqlErrors) {
  (0, import_newArrowCheck3.default)(this, _this3);
  return gqlErrors.map(errorToString).join("\n");
}.bind(void 0);
var _this$17 = void 0;
var operationTypeRe = /^\s*(query|mutation|subscription|\{)/;
var getOperationTypeFromMatched = function getOperationTypeFromMatched2(matched) {
  (0, import_newArrowCheck3.default)(this, _this$17);
  return matched === "{" ? "query" : matched;
}.bind(void 0);
var getOperationType = function getOperationType2(operation) {
  (0, import_newArrowCheck3.default)(this, _this$17);
  var result = operation.match(operationTypeRe);
  if (!result) {
    throw new TypeError("Invalid operation:\n".concat(operation));
  }
  return getOperationTypeFromMatched(result[1]);
}.bind(void 0);
var _this$23 = void 0;
var isSubscription = function isSubscription2(definition) {
  (0, import_newArrowCheck3.default)(this, _this$23);
  return definition.kind === "OperationDefinition" && definition.operation === "subscription";
}.bind(void 0);
var hasSubscription = function hasSubscription2(documentNode) {
  (0, import_newArrowCheck3.default)(this, _this$23);
  return documentNode.definitions.some(isSubscription);
}.bind(void 0);
var _this$33 = void 0;
var requestFromCompat = function requestFromCompat2(_ref) {
  var operation = _ref.query, variables = _ref.variables;
  (0, import_newArrowCheck3.default)(this, _this$33);
  return variables ? {
    operation,
    variables
  } : {
    operation
  };
}.bind(void 0);
var _this$43 = void 0;
var requestToCompat = function requestToCompat2(_ref) {
  var query = _ref.operation, variables = _ref.variables;
  (0, import_newArrowCheck3.default)(this, _this$43);
  return variables ? {
    query,
    variables
  } : {
    query
  };
}.bind(void 0);

// node_modules/@absinthe/socket/dist/index.js
var import_zen_observable = __toESM(require_zen_observable());

// node_modules/core-js/modules/es7.array.includes.js
var $export7 = require_export();
var $includes = require_array_includes2()(true);
$export7($export7.P, "Array", {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
require_add_to_unscopables()("includes");

// node_modules/core-js/modules/es6.string.includes.js
var $export8 = require_export();
var context = require_string_context();
var INCLUDES = "includes";
$export8($export8.P + $export8.F * require_fails_is_regexp()(INCLUDES), "String", {
  includes: function includes2(searchString) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
  }
});

// node_modules/@absinthe/socket/dist/index.js
var import_objectSpread = __toESM(require_objectSpread());
var import_objectWithoutProperties3 = __toESM(require_objectWithoutProperties2());

// node_modules/core-js/modules/es6.array.index-of.js
var $export9 = require_export();
var $indexOf = require_array_includes2()(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export9($export9.P + $export9.F * (NEGATIVE_ZERO || !require_strict_method()($native)), "Array", {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement) {
    return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

// node_modules/@absinthe/socket/dist/index.js
var import_newArrowCheck4 = __toESM(require_newArrowCheck2());
var _this4 = void 0;
var cancel = function cancel2(_ref) {
  var activeObservers = _ref.activeObservers, canceledObservers = _ref.canceledObservers, rest = (0, import_objectWithoutProperties3.default)(_ref, ["activeObservers", "canceledObservers"]);
  (0, import_newArrowCheck4.default)(this, _this4);
  return (0, import_objectSpread.default)({}, rest, {
    isActive: false,
    activeObservers: [],
    canceledObservers: (0, import_toConsumableArray3.default)(activeObservers).concat((0, import_toConsumableArray3.default)(canceledObservers))
  });
}.bind(void 0);
var _this$18 = void 0;
var getNotifier = function getNotifier2(handlerName, payload) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$18);
  return function(observer) {
    (0, import_newArrowCheck4.default)(this, _this22);
    return observer[handlerName] && observer[handlerName](payload);
  }.bind(this);
}.bind(void 0);
var getHandlerName = function getHandlerName2(_ref) {
  var name = _ref.name;
  (0, import_newArrowCheck4.default)(this, _this$18);
  return "on".concat(name);
}.bind(void 0);
var notifyAll = function notifyAll2(observers, event) {
  (0, import_newArrowCheck4.default)(this, _this$18);
  return observers.forEach(getNotifier(getHandlerName(event), event.payload));
}.bind(void 0);
var _this$24 = void 0;
var notifyCanceled = function notifyCanceled2(notifier, event) {
  (0, import_newArrowCheck4.default)(this, _this$24);
  notifyAll(notifier.canceledObservers, event);
  return notifier;
}.bind(void 0);
var eventNames = {
  abort: "Abort",
  cancel: "Cancel",
  error: "Error",
  result: "Result",
  start: "Start"
};
var _this$34 = void 0;
var createStartEvent = function createStartEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$34);
  return {
    payload,
    name: eventNames.start
  };
}.bind(void 0);
var createResultEvent = function createResultEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$34);
  return {
    payload,
    name: eventNames.result
  };
}.bind(void 0);
var createErrorEvent = function createErrorEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$34);
  return {
    payload,
    name: eventNames.error
  };
}.bind(void 0);
var createCancelEvent = function createCancelEvent2() {
  (0, import_newArrowCheck4.default)(this, _this$34);
  return {
    name: eventNames.cancel,
    payload: void 0
  };
}.bind(void 0);
var createAbortEvent = function createAbortEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$34);
  return {
    payload,
    name: eventNames.abort
  };
}.bind(void 0);
var _this$44 = void 0;
var clearCanceled = function clearCanceled2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$44);
  return (0, import_objectSpread.default)({}, notifier, {
    canceledObservers: []
  });
}.bind(void 0);
var flushCanceled = function flushCanceled2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$44);
  return notifier.canceledObservers.length > 0 ? clearCanceled(notifyCanceled(notifier, createCancelEvent())) : notifier;
}.bind(void 0);
var _this$53 = void 0;
var findIndex2 = function findIndex3(notifiers, key, value) {
  (0, import_newArrowCheck4.default)(this, _this$53);
  return notifiers.findIndex(hasIn$1([key], value));
}.bind(void 0);
var _this$63 = void 0;
var refresh = function refresh2(notifier) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$63);
  return function(notifiers) {
    (0, import_newArrowCheck4.default)(this, _this22);
    return replace$1(findIndex2(notifiers, "request", notifier.request), [notifier], notifiers);
  }.bind(this);
}.bind(void 0);
var _this$73 = void 0;
var remove$13 = function remove$$1(notifier) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$73);
  return function(notifiers) {
    (0, import_newArrowCheck4.default)(this, _this22);
    return remove$1(findIndex2(notifiers, "request", notifier.request), 1, notifiers);
  }.bind(this);
}.bind(void 0);
var _this$83 = void 0;
var updateNotifiers = function updateNotifiers2(absintheSocket, updater) {
  (0, import_newArrowCheck4.default)(this, _this$83);
  absintheSocket.notifiers = updater(absintheSocket.notifiers);
  return absintheSocket;
}.bind(void 0);
var _this$93 = void 0;
var refreshNotifier = function refreshNotifier2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$93);
  updateNotifiers(absintheSocket, refresh(notifier));
  return notifier;
}.bind(void 0);
var requestStatuses = {
  canceled: "canceled",
  canceling: "canceling",
  pending: "pending",
  sent: "sent",
  sending: "sending"
};
var _this$a = void 0;
var getObservers = function getObservers2(_ref) {
  var activeObservers = _ref.activeObservers, canceledObservers = _ref.canceledObservers;
  (0, import_newArrowCheck4.default)(this, _this$a);
  return (0, import_toConsumableArray3.default)(activeObservers).concat((0, import_toConsumableArray3.default)(canceledObservers));
}.bind(void 0);
var notify = function notify2(notifier, event) {
  (0, import_newArrowCheck4.default)(this, _this$a);
  notifyAll(getObservers(notifier), event);
  return notifier;
}.bind(void 0);
var _this$b = void 0;
var abortNotifier = function abortNotifier2(absintheSocket, notifier, error) {
  (0, import_newArrowCheck4.default)(this, _this$b);
  return updateNotifiers(absintheSocket, remove$13(notify(notifier, createAbortEvent(error))));
}.bind(void 0);
var _this$c = void 0;
var find2 = function find3(notifiers, key, value) {
  (0, import_newArrowCheck4.default)(this, _this$c);
  return notifiers.find(hasIn$1([key], value));
}.bind(void 0);
var _this$d = void 0;
var notifyActive = function notifyActive2(notifier, event) {
  (0, import_newArrowCheck4.default)(this, _this$d);
  notifyAll(notifier.activeObservers, event);
  return notifier;
}.bind(void 0);
var _this$e = void 0;
var notifyResultEvent = function notifyResultEvent2(notifier, result) {
  (0, import_newArrowCheck4.default)(this, _this$e);
  return notifyActive(notifier, createResultEvent(result));
}.bind(void 0);
var _this$f = void 0;
var notifyStartEvent = function notifyStartEvent2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$f);
  return notifyActive(notifier, createStartEvent(notifier));
}.bind(void 0);
var _this$g = void 0;
var reset = function reset2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$g);
  return flushCanceled((0, import_objectSpread.default)({}, notifier, {
    isActive: true,
    requestStatus: requestStatuses.pending,
    subscriptionId: void 0
  }));
}.bind(void 0);
var _this$h = void 0;
var handlePush = function handlePush2(push, handler) {
  (0, import_newArrowCheck4.default)(this, _this$h);
  return push.receive("ok", handler.onSucceed).receive("error", handler.onError).receive("timeout", handler.onTimeout);
}.bind(void 0);
var _this$i = void 0;
var getPushHandlerMethodGetter = function getPushHandlerMethodGetter2(absintheSocket, request) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$i);
  return function(handle) {
    var _this32 = this;
    (0, import_newArrowCheck4.default)(this, _this22);
    return function() {
      (0, import_newArrowCheck4.default)(this, _this32);
      var notifier = find2(absintheSocket.notifiers, "request", request);
      if (notifier) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handle.apply(void 0, [absintheSocket, notifier].concat(args));
      }
    }.bind(this);
  }.bind(this);
}.bind(void 0);
var getPushHandler = function getPushHandler2(absintheSocket, request, notifierPushHandler) {
  (0, import_newArrowCheck4.default)(this, _this$i);
  return map$1(getPushHandlerMethodGetter(absintheSocket, request), notifierPushHandler);
}.bind(void 0);
var pushAbsintheEvent = function pushAbsintheEvent2(absintheSocket, request, notifierPushHandler, absintheEvent) {
  (0, import_newArrowCheck4.default)(this, _this$i);
  handlePush(absintheSocket.channel.push(absintheEvent.name, absintheEvent.payload), getPushHandler(absintheSocket, request, notifierPushHandler));
  return absintheSocket;
}.bind(void 0);
var absintheEventNames = {
  doc: "doc",
  unsubscribe: "unsubscribe"
};
var _this$j = void 0;
var createAbsintheUnsubscribeEvent = function createAbsintheUnsubscribeEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$j);
  return {
    payload,
    name: absintheEventNames.unsubscribe
  };
}.bind(void 0);
var createAbsintheDocEvent = function createAbsintheDocEvent2(payload) {
  (0, import_newArrowCheck4.default)(this, _this$j);
  return {
    payload,
    name: absintheEventNames.doc
  };
}.bind(void 0);
var _this$k = void 0;
var pushAbsintheDocEvent = function pushAbsintheDocEvent2(absintheSocket, _ref, notifierPushHandler) {
  var request = _ref.request;
  (0, import_newArrowCheck4.default)(this, _this$k);
  return pushAbsintheEvent(absintheSocket, request, notifierPushHandler, createAbsintheDocEvent(requestToCompat(request)));
}.bind(void 0);
var setNotifierRequestStatusSending = function setNotifierRequestStatusSending2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return refreshNotifier(absintheSocket, (0, import_objectSpread.default)({}, notifier, {
    requestStatus: requestStatuses.sending
  }));
}.bind(void 0);
var createRequestError = function createRequestError2(message) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return new Error("request: ".concat(message));
}.bind(void 0);
var onTimeout = function onTimeout2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return notifyActive(notifier, createErrorEvent(createRequestError("timeout")));
}.bind(void 0);
var onError = function onError2(absintheSocket, notifier, errorMessage) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return abortNotifier(absintheSocket, notifier, createRequestError(errorMessage));
}.bind(void 0);
var getNotifierPushHandler = function getNotifierPushHandler2(onSucceed2) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return {
    onError,
    onSucceed: onSucceed2,
    onTimeout
  };
}.bind(void 0);
var pushRequestUsing = function pushRequestUsing2(absintheSocket, notifier, onSucceed2) {
  (0, import_newArrowCheck4.default)(this, _this$k);
  return pushAbsintheDocEvent(absintheSocket, setNotifierRequestStatusSending(absintheSocket, notifier), getNotifierPushHandler(onSucceed2));
}.bind(void 0);
var _this$l = void 0;
var onUnsubscribeSucceedCanceled = function onUnsubscribeSucceedCanceled2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return updateNotifiers(absintheSocket, remove$13(flushCanceled(notifier)));
}.bind(void 0);
var onUnsubscribeSucceedActive = function onUnsubscribeSucceedActive2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return subscribe(absintheSocket, refreshNotifier(absintheSocket, reset(notifier)));
}.bind(void 0);
var createUnsubscribeError = function createUnsubscribeError2(message) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return new Error("unsubscribe: ".concat(message));
}.bind(void 0);
var unsubscribeHandler = {
  onError: function onError$$1(absintheSocket, notifier, errorMessage) {
    (0, import_newArrowCheck4.default)(this, _this$l);
    return abortNotifier(absintheSocket, notifier, createUnsubscribeError(errorMessage));
  }.bind(void 0),
  onTimeout: function onTimeout3(absintheSocket, notifier) {
    (0, import_newArrowCheck4.default)(this, _this$l);
    return notifyCanceled(notifier, createErrorEvent(createUnsubscribeError("timeout")));
  }.bind(void 0),
  onSucceed: function onSucceed(absintheSocket, notifier) {
    (0, import_newArrowCheck4.default)(this, _this$l);
    if (notifier.isActive) {
      onUnsubscribeSucceedActive(absintheSocket, notifier);
    } else {
      onUnsubscribeSucceedCanceled(absintheSocket, notifier);
    }
  }.bind(void 0)
};
var pushAbsintheUnsubscribeEvent = function pushAbsintheUnsubscribeEvent2(absintheSocket, _ref) {
  var request = _ref.request, subscriptionId = _ref.subscriptionId;
  (0, import_newArrowCheck4.default)(this, _this$l);
  return pushAbsintheEvent(absintheSocket, request, unsubscribeHandler, createAbsintheUnsubscribeEvent({
    subscriptionId
  }));
}.bind(void 0);
var unsubscribe = function unsubscribe2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return pushAbsintheUnsubscribeEvent(absintheSocket, refreshNotifier(absintheSocket, (0, import_objectSpread.default)({}, notifier, {
    requestStatus: requestStatuses.canceling
  })));
}.bind(void 0);
var onSubscribeSucceed = function onSubscribeSucceed2(absintheSocket, notifier, _ref2) {
  var subscriptionId = _ref2.subscriptionId;
  (0, import_newArrowCheck4.default)(this, _this$l);
  var subscribedNotifier = refreshNotifier(absintheSocket, (0, import_objectSpread.default)({}, notifier, {
    subscriptionId,
    requestStatus: requestStatuses.sent
  }));
  if (subscribedNotifier.isActive) {
    notifyStartEvent(subscribedNotifier);
  } else {
    unsubscribe(absintheSocket, subscribedNotifier);
  }
}.bind(void 0);
var onSubscribe = function onSubscribe2(absintheSocket, notifier, response) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  if (response.errors) {
    onError(absintheSocket, notifier, errorsToString(response.errors));
  } else {
    onSubscribeSucceed(absintheSocket, notifier, response);
  }
}.bind(void 0);
var subscribe = function subscribe2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return pushRequestUsing(absintheSocket, notifier, onSubscribe);
}.bind(void 0);
var onDataMessage = function onDataMessage2(absintheSocket, _ref3) {
  var payload = _ref3.payload;
  (0, import_newArrowCheck4.default)(this, _this$l);
  var notifier = find2(absintheSocket.notifiers, "subscriptionId", payload.subscriptionId);
  if (notifier) {
    notifyResultEvent(notifier, payload.result);
  }
}.bind(void 0);
var dataMessageEventName = "subscription:data";
var isDataMessage = function isDataMessage2(message) {
  (0, import_newArrowCheck4.default)(this, _this$l);
  return message.event === dataMessageEventName;
}.bind(void 0);
var _this$m = void 0;
var cancelQueryOrMutationSending = function cancelQueryOrMutationSending2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return updateNotifiers(absintheSocket, refresh(flushCanceled(cancel(notifier))));
}.bind(void 0);
var cancelQueryOrMutationIfSending = function cancelQueryOrMutationIfSending2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.requestStatus === requestStatuses.sending ? cancelQueryOrMutationSending(absintheSocket, notifier) : absintheSocket;
}.bind(void 0);
var cancelPending = function cancelPending2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return updateNotifiers(absintheSocket, remove$13(flushCanceled(cancel(notifier))));
}.bind(void 0);
var cancelQueryOrMutation = function cancelQueryOrMutation2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.requestStatus === requestStatuses.pending ? cancelPending(absintheSocket, notifier) : cancelQueryOrMutationIfSending(absintheSocket, notifier);
}.bind(void 0);
var unsubscribeIfNeeded = function unsubscribeIfNeeded2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.requestStatus === requestStatuses.sent ? unsubscribe(absintheSocket, notifier) : absintheSocket;
}.bind(void 0);
var cancelNonPendingSubscription = function cancelNonPendingSubscription2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return unsubscribeIfNeeded(absintheSocket, refreshNotifier(absintheSocket, cancel(notifier)));
}.bind(void 0);
var cancelSubscription = function cancelSubscription2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.requestStatus === requestStatuses.pending ? cancelPending(absintheSocket, notifier) : cancelNonPendingSubscription(absintheSocket, notifier);
}.bind(void 0);
var cancelActive = function cancelActive2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.operationType === "subscription" ? cancelSubscription(absintheSocket, notifier) : cancelQueryOrMutation(absintheSocket, notifier);
}.bind(void 0);
var cancel$1 = function cancel$$1(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$m);
  return notifier.isActive ? cancelActive(absintheSocket, notifier) : absintheSocket;
}.bind(void 0);
var _this$n = void 0;
var setNotifierRequestStatusSent = function setNotifierRequestStatusSent2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$n);
  return refreshNotifier(absintheSocket, (0, import_objectSpread.default)({}, notifier, {
    requestStatus: requestStatuses.sent
  }));
}.bind(void 0);
var onQueryOrMutationSucceed = function onQueryOrMutationSucceed2(absintheSocket, notifier, response) {
  (0, import_newArrowCheck4.default)(this, _this$n);
  return updateNotifiers(absintheSocket, remove$13(notifyResultEvent(setNotifierRequestStatusSent(absintheSocket, notifier), response)));
}.bind(void 0);
var pushQueryOrMutation = function pushQueryOrMutation2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$n);
  return pushRequestUsing(absintheSocket, notifyStartEvent(notifier), onQueryOrMutationSucceed);
}.bind(void 0);
var pushRequest = function pushRequest2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$n);
  if (notifier.operationType === "subscription") {
    subscribe(absintheSocket, notifier);
  } else {
    pushQueryOrMutation(absintheSocket, notifier);
  }
}.bind(void 0);
var _this$o = void 0;
var createChannelJoinError = function createChannelJoinError2(message) {
  (0, import_newArrowCheck4.default)(this, _this$o);
  return new Error("channel join: ".concat(message));
}.bind(void 0);
var notifyErrorToAllActive = function notifyErrorToAllActive2(absintheSocket, errorMessage) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$o);
  return absintheSocket.notifiers.forEach(function(notifier) {
    (0, import_newArrowCheck4.default)(this, _this22);
    return notifyActive(notifier, createErrorEvent(createChannelJoinError(errorMessage)));
  }.bind(this));
}.bind(void 0);
var createChannelJoinHandler = function createChannelJoinHandler2(absintheSocket) {
  var _this32 = this;
  (0, import_newArrowCheck4.default)(this, _this$o);
  return {
    onError: function onError3(errorMessage) {
      (0, import_newArrowCheck4.default)(this, _this32);
      return notifyErrorToAllActive(absintheSocket, errorMessage);
    }.bind(this),
    onSucceed: function onSucceed2() {
      var _this42 = this;
      (0, import_newArrowCheck4.default)(this, _this32);
      return absintheSocket.notifiers.forEach(function(notifier) {
        (0, import_newArrowCheck4.default)(this, _this42);
        return pushRequest(absintheSocket, notifier);
      }.bind(this));
    }.bind(this),
    onTimeout: function onTimeout4() {
      (0, import_newArrowCheck4.default)(this, _this32);
      return notifyErrorToAllActive(absintheSocket, "timeout");
    }.bind(this)
  };
}.bind(void 0);
var joinChannel = function joinChannel2(absintheSocket) {
  (0, import_newArrowCheck4.default)(this, _this$o);
  handlePush(absintheSocket.channel.join(), createChannelJoinHandler(absintheSocket));
  absintheSocket.channelJoinCreated = true;
  return absintheSocket;
}.bind(void 0);
var _this$p = void 0;
var onMessage = function onMessage2(absintheSocket) {
  var _this22 = this;
  (0, import_newArrowCheck4.default)(this, _this$p);
  return function(message) {
    (0, import_newArrowCheck4.default)(this, _this22);
    if (isDataMessage(message)) {
      onDataMessage(absintheSocket, message);
    }
  }.bind(this);
}.bind(void 0);
var createConnectionCloseError = function createConnectionCloseError2() {
  (0, import_newArrowCheck4.default)(this, _this$p);
  return new Error("connection: close");
}.bind(void 0);
var notifyConnectionCloseError = function notifyConnectionCloseError2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$p);
  return notify(notifier, createErrorEvent(createConnectionCloseError()));
}.bind(void 0);
var notifierOnConnectionCloseCanceled = function notifierOnConnectionCloseCanceled2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$p);
  return updateNotifiers(absintheSocket, remove$13(notifyConnectionCloseError(notifier)));
}.bind(void 0);
var notifierOnConnectionCloseActive = function notifierOnConnectionCloseActive2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$p);
  if (notifier.operationType === "mutation") {
    abortNotifier(absintheSocket, notifier, createConnectionCloseError());
  } else {
    refreshNotifier(absintheSocket, reset(notifyConnectionCloseError(notifier)));
  }
}.bind(void 0);
var notifierOnConnectionClose = function notifierOnConnectionClose2(absintheSocket) {
  var _this32 = this;
  (0, import_newArrowCheck4.default)(this, _this$p);
  return function(notifier) {
    (0, import_newArrowCheck4.default)(this, _this32);
    if (notifier.isActive) {
      notifierOnConnectionCloseActive(absintheSocket, notifier);
    } else {
      notifierOnConnectionCloseCanceled(absintheSocket, notifier);
    }
  }.bind(this);
}.bind(void 0);
var onConnectionClose = function onConnectionClose2(absintheSocket) {
  var _this42 = this;
  (0, import_newArrowCheck4.default)(this, _this$p);
  return function() {
    (0, import_newArrowCheck4.default)(this, _this42);
    return absintheSocket.notifiers.forEach(notifierOnConnectionClose(absintheSocket));
  }.bind(this);
}.bind(void 0);
var shouldJoinChannel = function shouldJoinChannel2(absintheSocket) {
  (0, import_newArrowCheck4.default)(this, _this$p);
  return !absintheSocket.channelJoinCreated && absintheSocket.notifiers.length > 0;
}.bind(void 0);
var onConnectionOpen = function onConnectionOpen2(absintheSocket) {
  var _this5 = this;
  (0, import_newArrowCheck4.default)(this, _this$p);
  return function() {
    (0, import_newArrowCheck4.default)(this, _this5);
    if (shouldJoinChannel(absintheSocket)) {
      joinChannel(absintheSocket);
    }
  }.bind(this);
}.bind(void 0);
var absintheChannelName = "__absinthe__:control";
var create = function create2(phoenixSocket) {
  (0, import_newArrowCheck4.default)(this, _this$p);
  var absintheSocket = {
    phoenixSocket,
    channel: phoenixSocket.channel(absintheChannelName),
    channelJoinCreated: false,
    notifiers: []
  };
  phoenixSocket.onOpen(onConnectionOpen(absintheSocket));
  phoenixSocket.onClose(onConnectionClose(absintheSocket));
  phoenixSocket.onMessage(onMessage(absintheSocket));
  return absintheSocket;
}.bind(void 0);
var _this$q = void 0;
var observe = function observe2(_ref, observer) {
  var activeObservers = _ref.activeObservers, rest = (0, import_objectWithoutProperties3.default)(_ref, ["activeObservers"]);
  (0, import_newArrowCheck4.default)(this, _this$q);
  return (0, import_objectSpread.default)({}, rest, {
    activeObservers: (0, import_toConsumableArray3.default)(activeObservers).concat([observer]),
    isActive: true
  });
}.bind(void 0);
var _this$r = void 0;
var observe$1 = function observe$$1(absintheSocket, notifier, observer) {
  (0, import_newArrowCheck4.default)(this, _this$r);
  return refreshNotifier(absintheSocket, observe(notifier, observer));
}.bind(void 0);
var _this$s = void 0;
var createUsing = function createUsing2(request, operationType) {
  (0, import_newArrowCheck4.default)(this, _this$s);
  return {
    operationType,
    request,
    activeObservers: [],
    canceledObservers: [],
    isActive: true,
    requestStatus: requestStatuses.pending,
    subscriptionId: void 0
  };
}.bind(void 0);
var create$1 = function create3(request) {
  (0, import_newArrowCheck4.default)(this, _this$s);
  return createUsing(request, getOperationType(request.operation));
}.bind(void 0);
var _this$t = void 0;
var reactivate = function reactivate2(notifier) {
  (0, import_newArrowCheck4.default)(this, _this$t);
  return notifier.isActive ? notifier : (0, import_objectSpread.default)({}, notifier, {
    isActive: true
  });
}.bind(void 0);
var _this$u = void 0;
var connectOrJoinChannel = function connectOrJoinChannel2(absintheSocket) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  if (absintheSocket.phoenixSocket.isConnected()) {
    joinChannel(absintheSocket);
  } else {
    absintheSocket.phoenixSocket.connect();
  }
}.bind(void 0);
var sendNew = function sendNew2(absintheSocket, request) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  var notifier = create$1(request);
  updateNotifiers(absintheSocket, append$1([notifier]));
  if (absintheSocket.channelJoinCreated) {
    pushRequest(absintheSocket, notifier);
  } else {
    connectOrJoinChannel(absintheSocket);
  }
  return notifier;
}.bind(void 0);
var updateCanceledReactivate = function updateCanceledReactivate2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  return refreshNotifier(absintheSocket, reactivate(notifier));
}.bind(void 0);
var updateCanceled = function updateCanceled2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  return notifier.requestStatus === requestStatuses.sending ? updateCanceledReactivate(absintheSocket, flushCanceled(notifier)) : updateCanceledReactivate(absintheSocket, notifier);
}.bind(void 0);
var updateIfCanceled = function updateIfCanceled2(absintheSocket, notifier) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  return notifier.isActive ? notifier : updateCanceled(absintheSocket, notifier);
}.bind(void 0);
var getExistentIfAny = function getExistentIfAny2(absintheSocket, request) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  var notifier = find2(absintheSocket.notifiers, "request", request);
  return notifier && updateIfCanceled(absintheSocket, notifier);
}.bind(void 0);
var send = function send2(absintheSocket, request) {
  (0, import_newArrowCheck4.default)(this, _this$u);
  return getExistentIfAny(absintheSocket, request) || sendNew(absintheSocket, request);
}.bind(void 0);
var _this$v = void 0;
var getUnsubscriber = function getUnsubscriber2(absintheSocket, _ref, observer, unsubscribe3) {
  var _this22 = this;
  var request = _ref.request;
  (0, import_newArrowCheck4.default)(this, _this$v);
  return function() {
    (0, import_newArrowCheck4.default)(this, _this22);
    var notifier = find2(absintheSocket.notifiers, "request", request);
    unsubscribe3(absintheSocket, notifier, notifier ? observer : void 0);
  }.bind(this);
}.bind(void 0);
var onResult = function onResult2(_ref2, observableObserver) {
  var _this32 = this;
  var operationType = _ref2.operationType;
  (0, import_newArrowCheck4.default)(this, _this$v);
  return function(result) {
    (0, import_newArrowCheck4.default)(this, _this32);
    observableObserver.next(result);
    if (operationType !== "subscription") {
      observableObserver.complete();
    }
  }.bind(this);
}.bind(void 0);
var createObserver = function createObserver2(notifier, handlers, observableObserver) {
  (0, import_newArrowCheck4.default)(this, _this$v);
  return (0, import_objectSpread.default)({}, handlers, {
    onAbort: observableObserver.error.bind(observableObserver),
    onResult: onResult(notifier, observableObserver)
  });
}.bind(void 0);
var toObservable = function toObservable2(absintheSocket, notifier) {
  var _this42 = this;
  var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, unsubscribe3 = _ref3.unsubscribe, handlers = (0, import_objectWithoutProperties3.default)(_ref3, ["unsubscribe"]);
  (0, import_newArrowCheck4.default)(this, _this$v);
  return new import_zen_observable.default(function(observableObserver) {
    (0, import_newArrowCheck4.default)(this, _this42);
    var observer = createObserver(notifier, handlers, observableObserver);
    observe$1(absintheSocket, notifier, observer);
    return unsubscribe3 && getUnsubscriber(absintheSocket, notifier, observer, unsubscribe3);
  }.bind(this));
}.bind(void 0);
var _this$w = void 0;
var removeObserver = function removeObserver2(observers, observer) {
  (0, import_newArrowCheck4.default)(this, _this$w);
  return remove$1(observers.indexOf(observer), 1, observers);
}.bind(void 0);
var unobserve = function unobserve2(_ref, observer) {
  var activeObservers = _ref.activeObservers, rest = (0, import_objectWithoutProperties3.default)(_ref, ["activeObservers"]);
  (0, import_newArrowCheck4.default)(this, _this$w);
  return (0, import_objectSpread.default)({}, rest, {
    activeObservers: removeObserver(activeObservers, observer)
  });
}.bind(void 0);
var _this$x = void 0;
var ensureHasActiveObserver = function ensureHasActiveObserver2(notifier, observer) {
  (0, import_newArrowCheck4.default)(this, _this$x);
  if (notifier.activeObservers.includes(observer)) return notifier;
  throw new Error("Observer is not attached to notifier");
}.bind(void 0);
var unobserve$1 = function unobserve$$1(absintheSocket, notifier, observer) {
  (0, import_newArrowCheck4.default)(this, _this$x);
  return updateNotifiers(absintheSocket, refresh(unobserve(ensureHasActiveObserver(notifier, observer), observer)));
}.bind(void 0);
var _this$y = void 0;
var doUnobserveOrCancel = function doUnobserveOrCancel2(absintheSocket, notifier, observer) {
  (0, import_newArrowCheck4.default)(this, _this$y);
  return notifier.activeObservers.length === 1 ? cancel$1(absintheSocket, notifier) : unobserve$1(absintheSocket, notifier, observer);
}.bind(void 0);
var unobserveOrCancel = function unobserveOrCancel2(absintheSocket, notifier, observer) {
  (0, import_newArrowCheck4.default)(this, _this$y);
  return notifier.isActive ? doUnobserveOrCancel(absintheSocket, notifier, observer) : absintheSocket;
}.bind(void 0);

// node_modules/@codesandbox/create-gql-api/dist/esm/typeUtils.js
var InlineFragmentSymbol = Symbol("INLINE_FRAGMENT");

// node_modules/@codesandbox/create-gql-api/dist/esm/utils.js
var createQueryUtils = (enums2, argumentsByField) => {
  function createQueryArgumentsString(fieldKey, args, detectedVariableTypes, variables) {
    return `(${Object.keys(args).reduce((aggr, key) => {
      const val = args[key];
      const isVariable = typeof val === "string" && val[0] === "$";
      const isEnum = typeof val === "string" && enums2.includes(val);
      if (val === void 0) {
        return aggr;
      }
      if (isVariable) {
        detectedVariableTypes[val] = argumentsByField[fieldKey][key];
      }
      return isVariable && variables && variables[val.substring(1)] === void 0 ? aggr : aggr.concat(`${key}: ${isVariable || isEnum ? val : typeof val === "string" ? `"${val}"` : val}`);
    }, []).join(", ")})`;
  }
  function isObjectQueryDefinition(queryDefinition) {
    return Array.isArray(queryDefinition) && queryDefinition.length === 2;
  }
  function isFieldQueryDefinition(queryDefinition) {
    return Array.isArray(queryDefinition) && queryDefinition.length === 1;
  }
  function createQueryBodyString(queryDefinitions, detectedVariableTypes, includeTypeNames, variables, level = 1) {
    let string = " {\n";
    if (level > 1 && includeTypeNames) {
      string += "  ".repeat(level) + "__typename\n" + ("id" in queryDefinitions ? "" : "  ".repeat(level) + "id\n");
    }
    const topLevelUnionField = queryDefinitions[InlineFragmentSymbol];
    if (topLevelUnionField) {
      for (const key in queryDefinitions) {
        string += "  ".repeat(level) + `... on ${key}`;
        string += createQueryBodyString(
          // eslint-disable-next-line
          // @ts-ignore
          queryDefinitions[key],
          detectedVariableTypes,
          includeTypeNames,
          variables,
          level + 1
        );
      }
      string += "  ".repeat(level - 1) + "}\n";
      return string;
    }
    for (let field in queryDefinitions) {
      const value = queryDefinitions[field];
      if (value === false || value === void 0) {
        continue;
      }
      const aliasTuple = field.split(":");
      const aliasPrefix = aliasTuple[1] ? ":" + aliasTuple[1] : "";
      field = aliasTuple[0];
      string += "  ".repeat(level) + field;
      if (value === void 0) {
        throw new Error("Got an undefined, that should not be possible!");
      }
      if (value === true) {
        string += "\n";
      } else if (isFieldQueryDefinition(value)) {
        string += createQueryArgumentsString(aliasTuple[1] || aliasTuple[0], value[0], detectedVariableTypes, variables) + "\n";
      } else if (isObjectQueryDefinition(value)) {
        string += aliasPrefix + createQueryArgumentsString(aliasTuple[1] || aliasTuple[0], value[0], detectedVariableTypes, variables) + createQueryBodyString(value[1], detectedVariableTypes, includeTypeNames, variables, level + 1);
      } else {
        const unionFieldType = value[InlineFragmentSymbol];
        if (unionFieldType) {
          string += aliasPrefix + " {\n";
          for (const key in value) {
            string += "  ".repeat(level + 1) + `... on ${key}`;
            string += createQueryBodyString(
              // eslint-disable-next-line
              // @ts-ignore
              value[key],
              detectedVariableTypes,
              includeTypeNames,
              variables,
              level + 2
            );
          }
          string += "}\n";
        } else {
          string += aliasPrefix + createQueryBodyString(value, detectedVariableTypes, includeTypeNames, variables, level + 1);
        }
      }
    }
    string += "  ".repeat(level - 1) + "}\n";
    return string;
  }
  function createVariablesString(variables, detectedVariableTypes) {
    return Object.keys(variables).reduce((aggr, key) => {
      if (variables[key] === void 0) {
        return aggr;
      }
      const varKey = `$${key}`;
      const gqlType = detectedVariableTypes[varKey];
      if (!gqlType) {
        throw new Error(`Unable to detect variable type for key ${key}`);
      }
      return aggr.concat(`${varKey}: ${gqlType.isList ? "[" : ""}${gqlType.type}${gqlType.isNonNull ? "!" : ""}${gqlType.isList ? "]" : ""}`);
    }, []).join(", ");
  }
  function createQueryStringFactory(type) {
    return function createQueryString2(name, query, variables, includeTypeNames) {
      const detectedVariableTypes = {};
      const queryBodyString = createQueryBodyString(query, detectedVariableTypes, includeTypeNames, variables);
      return `${type} ${name} ${variables ? `(${createVariablesString(variables, detectedVariableTypes)})` : ""}${queryBodyString}`;
    };
  }
  const createQueryString = createQueryStringFactory("query");
  const createMutationString = createQueryStringFactory("mutation");
  const createSubscriptionString = createQueryStringFactory("subscription");
  return {
    createMutation: (name, cb) => (request, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? cb(Object.keys(variables || {}).reduce((aggr, key) => {
        aggr[key] = "$" + key;
        return aggr;
      }, {})) : (
        // eslint-disable-next-line
        cb
      );
      return request(createMutationString(name, query, variables ? variables : void 0, includeTypeNames), variables ? Object.keys(variables).reduce((aggr, key) => {
        aggr[key] = variables[key];
        return aggr;
      }, {}) : {});
    },
    createQuery: (name, cb) => (request, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? (
        // eslint-disable-next-line
        cb(Object.keys(variables || {}).reduce((aggr, key) => {
          aggr[key] = "$" + key;
          return aggr;
        }, {}))
      ) : (
        // eslint-disable-next-line
        cb
      );
      return request(createQueryString(name, query, variables ? variables : void 0, includeTypeNames), variables ? Object.keys(variables).reduce((aggr, key) => {
        aggr[key] = variables[key];
        return aggr;
      }, {}) : {});
    },
    createSubscription: (name, cb) => (subscribe3, onMessage3, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? cb(Object.keys(variables || {}).reduce((aggr, key) => {
        aggr[key] = "$" + key;
        return aggr;
      }, {})) : (
        // eslint-disable-next-line
        cb
      );
      return subscribe3(
        createSubscriptionString(name, query, variables ? variables : void 0, includeTypeNames),
        // eslint-disable-next-line
        onMessage3,
        variables ? Object.keys(variables).reduce((aggr, key) => {
          aggr[key] = variables[key];
          return aggr;
        }, {}) : {}
      );
    }
  };
};

// node_modules/@codesandbox/api/dist/esm/generated_gql.js
var enums = [
  "COMMENT",
  "NONE",
  "OWNER",
  "READ",
  "WRITE_CODE",
  "WRITE_PROJECT",
  "BASIC",
  "BEARER",
  "ASC",
  "DESC",
  "COLLABORATOR",
  "CONTRIBUTOR",
  "FIRST_TIMER",
  "FIRST_TIME_CONTRIBUTOR",
  "MANNEQUIN",
  "MEMBER",
  "ADMIN",
  "WRITE",
  "MERGE",
  "REBASE",
  "SQUASH",
  "APPROVE",
  "REQUEST_CHANGES",
  "LEFT",
  "RIGHT",
  "FILE",
  "LINE",
  "GITHUB",
  "CREATED",
  "JOINED",
  "SET_DEFAULT_PERMISSION",
  "SET_GUEST_PERMISSION",
  "STARTED",
  "STOPPED",
  "APPLE",
  "GOOGLE",
  "DELETED",
  "EDITED",
  "CLOSED",
  "CONVERTED_TO_DRAFT",
  "OPENED",
  "READY_FOR_REVIEW",
  "REVIEW_REQUEST_REMOVED",
  "REVIEW_REQUESTED",
  "DISMISSED",
  "SUBMITTED",
  "APPROVED",
  "CHANGES_REQUESTED",
  "COMMENTED",
  "CUSTOM",
  "NPM",
  "MONTHLY",
  "YEARLY",
  "LEGACY",
  "PATRON",
  "PILOT",
  "STRIPE",
  "ACTIVE",
  "CANCELLED",
  "INCOMPLETE",
  "INCOMPLETE_EXPIRED",
  "PAUSED",
  "TRIALING",
  "UNKNOWN",
  "UNPAID",
  "PERSONAL_PRO",
  "TEAM_PRO",
  "IMMEDIATELY",
  "NEXT_BILL_DATE",
  "PERSONAL",
  "TEAM",
  "ORGANIZATION_MEMBER",
  "FULL_NAME",
  "PUSHED",
  "UPDATED"
];
var Authorization = {
  COMMENT: enums[0],
  NONE: enums[1],
  OWNER: enums[2],
  READ: enums[3],
  WRITE_CODE: enums[4],
  WRITE_PROJECT: enums[5]
};
var AuthType = {
  BASIC: enums[6],
  BEARER: enums[7]
};
var Direction = {
  ASC: enums[8],
  DESC: enums[9]
};
var GitHubAuthorAssociation = {
  COLLABORATOR: enums[10],
  CONTRIBUTOR: enums[11],
  FIRST_TIMER: enums[12],
  FIRST_TIME_CONTRIBUTOR: enums[13],
  MANNEQUIN: enums[14],
  MEMBER: enums[15],
  NONE: enums[1],
  OWNER: enums[2]
};
var GithubPermission = {
  ADMIN: enums[16],
  NONE: enums[1],
  READ: enums[3],
  WRITE: enums[17]
};
var GitHubPullRequestMergeMethod = {
  MERGE: enums[18],
  REBASE: enums[19],
  SQUASH: enums[20]
};
var GitHubPullRequestReviewAction = {
  APPROVE: enums[21],
  COMMENT: enums[0],
  REQUEST_CHANGES: enums[22]
};
var GitHubPullRequestReviewCommentSide = {
  LEFT: enums[23],
  RIGHT: enums[24]
};
var GitHubPullRequestReviewCommentSubjectType = {
  FILE: enums[25],
  LINE: enums[26]
};
var GithubRepoAuthorization = {
  READ: enums[3],
  WRITE: enums[17]
};
var GitProvider = {
  GITHUB: enums[27]
};
var InstallationEventAction = {
  CREATED: enums[28]
};
var LiveSessionEventAction = {
  JOINED: enums[29],
  SET_DEFAULT_PERMISSION: enums[30],
  SET_GUEST_PERMISSION: enums[31],
  STARTED: enums[32],
  STOPPED: enums[33]
};
var LiveSessionPermission = {
  READ: enums[3],
  WRITE: enums[17]
};
var ProjectAuthorization = {
  ADMIN: enums[16],
  NONE: enums[1],
  READ: enums[3],
  WRITE: enums[17]
};
var ProviderName = {
  APPLE: enums[34],
  GITHUB: enums[27],
  GOOGLE: enums[35]
};
var PullRequestCommentEventAction = {
  CREATED: enums[28],
  DELETED: enums[36],
  EDITED: enums[37]
};
var PullRequestEventAction = {
  CLOSED: enums[38],
  CONVERTED_TO_DRAFT: enums[39],
  OPENED: enums[40],
  READY_FOR_REVIEW: enums[41],
  REVIEW_REQUEST_REMOVED: enums[42],
  REVIEW_REQUESTED: enums[43]
};
var PullRequestReviewCommentEventAction = {
  CREATED: enums[28],
  DELETED: enums[36],
  EDITED: enums[37]
};
var PullRequestReviewEventAction = {
  DISMISSED: enums[44],
  EDITED: enums[37],
  SUBMITTED: enums[45]
};
var PullRequestReviewState = {
  APPROVED: enums[46],
  CHANGES_REQUESTED: enums[47],
  COMMENTED: enums[48],
  DISMISSED: enums[44]
};
var RegistryType = {
  CUSTOM: enums[49],
  GITHUB: enums[27],
  NPM: enums[50]
};
var SubscriptionInterval = {
  MONTHLY: enums[51],
  YEARLY: enums[52]
};
var SubscriptionOrigin = {
  LEGACY: enums[53],
  PATRON: enums[54],
  PILOT: enums[55]
};
var SubscriptionPaymentProvider = {
  STRIPE: enums[56]
};
var SubscriptionStatus = {
  ACTIVE: enums[57],
  CANCELLED: enums[58],
  INCOMPLETE: enums[59],
  INCOMPLETE_EXPIRED: enums[60],
  PAUSED: enums[61],
  TRIALING: enums[62],
  UNKNOWN: enums[63],
  UNPAID: enums[64]
};
var SubscriptionType = {
  PERSONAL_PRO: enums[65],
  TEAM_PRO: enums[66]
};
var SubscriptionUpdateMoment = {
  IMMEDIATELY: enums[67],
  NEXT_BILL_DATE: enums[68]
};
var TeamMemberAuthorization = {
  ADMIN: enums[16],
  READ: enums[3],
  WRITE: enums[17]
};
var TeamType = {
  PERSONAL: enums[69],
  TEAM: enums[70]
};
var UserRepoAffiliation = {
  COLLABORATOR: enums[10],
  ORGANIZATION_MEMBER: enums[71],
  OWNER: enums[2]
};
var UserRepoSort = {
  CREATED: enums[28],
  FULL_NAME: enums[72],
  PUSHED: enums[73],
  UPDATED: enums[74]
};
var _a = createQueryUtils(enums, {
  "collection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "collections": {
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "githubRepos": {
    "affiliation": {
      "isNonNull": true,
      "type": "UserRepoAffiliation",
      "isList": true
    },
    "page": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "perPage": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sort": {
      "isNonNull": false,
      "type": "UserRepoSort",
      "isList": false
    }
  },
  "notifications": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    },
    "type": {
      "isNonNull": false,
      "type": "String",
      "isList": true
    }
  },
  "recentBranches": {
    "contribution": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "recentProjects": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    }
  },
  "recentlyAccessedSandboxes": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "recentlyUsedTemplates": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "sandboxes": {
    "hasOriginalGit": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    },
    "showDeleted": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "alwaysOn": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "authorId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "team": {
    "id": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "templates": {
    "showAll": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "baseGitSandboxes": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "originalGitSandboxes": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "branchByName": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "acceptTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "addCollaborator": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "addSandboxesToAlbum": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "addToCollection": {
    "collectionPath": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": false,
      "type": "ID",
      "isList": true
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "addToCollectionOrTeam": {
    "collectionPath": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": false,
      "type": "ID",
      "isList": true
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "archiveNotification": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "bookmarkTemplate": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "templateId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "changeCollaboratorAuthorization": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "changeSandboxInvitationAuthorization": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "invitationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "changeTeamMemberAuthorizations": {
    "memberAuthorizations": {
      "isNonNull": true,
      "type": "MemberAuthorization",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "convertToUsageBilling": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "createAlbum": {
    "description": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "title": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "createBranch": {
    "branch": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "from": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "createCodeComment": {
    "anchorReference": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": false
    },
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createCollection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "createComment": {
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createContributionBranch": {
    "from": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "createGithubPullRequestReview": {
    "body": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "comments": {
      "isNonNull": true,
      "type": "GithubPullRequestReviewCommentInput",
      "isList": true
    },
    "commitId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "event": {
      "isNonNull": true,
      "type": "GitHubPullRequestReviewAction",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "createOrUpdatePrivateNpmRegistry": {
    "authType": {
      "isNonNull": false,
      "type": "AuthType",
      "isList": false
    },
    "enabledScopes": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "limitToScopes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "proxyEnabled": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "registryAuthKey": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "registryType": {
      "isNonNull": true,
      "type": "RegistryType",
      "isList": false
    },
    "registryUrl": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "sandpackTrustedDomains": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "createPreviewComment": {
    "anchorReference": {
      "isNonNull": true,
      "type": "PreviewReference",
      "isList": false
    },
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createSandboxInvitation": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "email": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "createTeam": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pilot": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "deleteAlbum": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteBranch": {
    "id": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "deleteCollection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "deleteComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteCurrentUser": {
    "confirm": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "deleteGithubPullRequestReviewComment": {
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "deletePrivateNpmRegistry": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "deleteProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteProjectById": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteSandboxes": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "deleteWorkspace": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "dismissGithubPullRequestReview": {
    "message": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "pullRequestReviewId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "importBranch": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "importProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "importReadOnlyBranch": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "importReadOnlyProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "incrementSandboxVersion": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "inviteToTeam": {
    "authorization": {
      "isNonNull": false,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "inviteToTeamViaEmail": {
    "authorization": {
      "isNonNull": false,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "email": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "joinEligibleWorkspace": {
    "workspaceId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "joinLiveSession": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "joinUsageBillingBeta": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "leaveTeam": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "makeSandboxesTemplates": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "markNotificationAsRead": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "mergeGithubPullRequest": {
    "mergeMethod": {
      "isNonNull": false,
      "type": "GitHubPullRequestMergeMethod",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "permanentlyDeleteSandboxes": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "previewConvertToUsageBilling": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "previewUpdateSubscriptionBillingInterval": {
    "billingInterval": {
      "isNonNull": true,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "previewUpdateUsageSubscriptionPlan": {
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "reactivateSubscription": {
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "redeemSandboxInvitation": {
    "invitationToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "redeemTeamInviteToken": {
    "inviteToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "rejectTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "removeCollaborator": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "removeFromTeam": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "removeRequestedGithubPullRequestReviewers": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "reviewers": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    }
  },
  "removeSandboxesFromAlbum": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "renameCollection": {
    "newPath": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "newTeamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "renameSandbox": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "title": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "replyToGithubPullRequestReview": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "requestGithubPullRequestReviewers": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "reviewers": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    }
  },
  "requestTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "resolveComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "revokeSandboxInvitation": {
    "invitationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "revokeTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setBranchProtection": {
    "branchId": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "protected": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "setDefaultTeamMemberAuthorization": {
    "defaultAuthorization": {
      "isNonNull": true,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setLiveSessionDefaultPermission": {
    "permission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "setLiveSessionGuestPermission": {
    "permission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "setPreventSandboxesExport": {
    "preventSandboxExport": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setPreventSandboxesLeavingWorkspace": {
    "preventSandboxLeaving": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setPrimaryWorkspace": {
    "primaryWorkspaceId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setSandboxesFrozen": {
    "isFrozen": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setSandboxesPrivacy": {
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setTeamAiConsent": {
    "privateRepositories": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "privateSandboxes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "publicRepositories": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "publicSandboxes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamDescription": {
    "description": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamLimits": {
    "onDemandSpendingLimit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamMetadata": {
    "metadata": {
      "isNonNull": true,
      "type": "TeamMetadataInput",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamMinimumPrivacy": {
    "minimumPrivacy": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "updateDrafts": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "setTeamName": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setWorkspaceSandboxSettings": {
    "preventSandboxExport": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "preventSandboxLeaving": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "softCancelSubscription": {
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "startLiveSession": {
    "defaultPermission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "stopLiveSession": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "unbookmarkTemplate": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "templateId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "unmakeSandboxesTemplates": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "unresolveComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "updateAlbum": {
    "description": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "title": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    }
  },
  "updateComment": {
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "content": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "updateCurrentUser": {
    "bio": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "socialLinks": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "updateGithubPullRequestReview": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "pullRequestReviewId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "updateGithubPullRequestReviewComment": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "updateNotificationPreferences": {
    "emailCommentMention": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailCommentReply": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailMarketing": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailNewComment": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailSandboxInvite": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailTeamInvite": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailTeamRequest": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "inAppPrReviewReceived": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "inAppPrReviewRequest": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "updateNotificationReadStatus": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "read": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "updateProjectSettings": {
    "aiConsent": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "projectId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateProjectVmTier": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "projectId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "vmTier": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "updateSandboxSettings": {
    "aiConsent": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "updateSubscription": {
    "quantity": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateSubscriptionBillingInterval": {
    "billingInterval": {
      "isNonNull": true,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateUsageSubscription": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateUsageSubscriptionPlan": {
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "album": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "albums": {
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "branchById": {
    "id": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "getLiveSession": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "git": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "githubOrganizationRepos": {
    "organization": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "page": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "perPage": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sort": {
      "isNonNull": false,
      "type": "UserRepoSort",
      "isList": false
    }
  },
  "githubRepo": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "project": {
    "gitProvider": {
      "isNonNull": false,
      "type": "GitProvider",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "team": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "projects": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "syncData": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "recentTeamsByRepository": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "sandbox": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "sandboxEligibleWorkspace": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "teamByToken": {
    "inviteToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "branchEvents": {
    "branchName": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "collaboratorAdded": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "collaboratorChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "collaboratorRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentAdded": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "githubEvents": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "invitationChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "invitationCreated": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "invitationRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "liveSessionEvents": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "projectCommits": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectConnections": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectEvents": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectStatus": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "sandboxChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "teamEvents": {
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "comment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "drafts": {
    "authorId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    }
  },
  "subscription": {
    "includeCancelled": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  }
});
var createQuery = _a.createQuery;
var createMutation = _a.createMutation;
var createSubscription = _a.createSubscription;
var createFragment = function(fragment) {
  return fragment;
};
var fragments = new Proxy({}, {
  get: function() {
    return createFragment;
  }
});
var createInlineFragment = function(type, fragment) {
  var _a2;
  return Object.assign(fragment, (_a2 = {}, _a2[InlineFragmentSymbol] = type, _a2));
};
var inlineFragments = new Proxy({}, {
  get: function(target, prop) {
    return createInlineFragment.bind(target, prop);
  }
});

// node_modules/@codesandbox/api/dist/esm/constants.js
var DAY = 1e3 * 60 * 60 * 24;

// node_modules/@codesandbox/api/dist/esm/SessionApi.js
var import_class_states = __toESM(require_dist5());

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var r;
var o;
var e;
var f;
var c;
var s;
var a;
var h;
var p = {};
var v = [];
var y2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var d = Array.isArray;
function w2(n2, l3) {
  for (var u4 in l3) n2[u4] = l3[u4];
  return n2;
}
function _2(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function m(n2, t3, i4, r3, o2) {
  var e3 = { type: n2, props: t3, key: i4, ref: r3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o2 ? ++u : o2, __i: -1, __u: 0 };
  return null == o2 && null != l.vnode && l.vnode(e3), e3;
}
function k2(n2) {
  return n2.children;
}
function x2(n2, l3) {
  this.props = n2, this.context = l3;
}
function C2(n2, l3) {
  if (null == l3) return n2.__ ? C2(n2.__, n2.__i + 1) : null;
  for (var u4; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) return u4.__e;
  return "function" == typeof n2.type ? C2(n2) : null;
}
function S2(n2) {
  var l3, u4;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) {
      n2.__e = n2.__c.base = u4.__e;
      break;
    }
    return S2(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !P2.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(P2);
}
function P2() {
  var n2, u4, t3, r3, o2, f3, c3, s3;
  for (i.sort(e); n2 = i.shift(); ) n2.__d && (u4 = i.length, r3 = void 0, f3 = (o2 = (t3 = n2).__v).__e, c3 = [], s3 = [], t3.__P && ((r3 = w2({}, o2)).__v = o2.__v + 1, l.vnode && l.vnode(r3), j(t3.__P, r3, o2, t3.__n, t3.__P.namespaceURI, 32 & o2.__u ? [f3] : null, c3, null == f3 ? C2(o2) : f3, !!(32 & o2.__u), s3), r3.__v = o2.__v, r3.__.__k[r3.__i] = r3, z2(c3, r3, s3), r3.__e != f3 && S2(r3)), i.length > u4 && i.sort(e));
  P2.__r = 0;
}
function $2(n2, l3, u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, y3, d2, w4, _3, g = t3 && t3.__k || v, m3 = l3.length;
  for (f3 = I2(u4, l3, g, f3, m3), a3 = 0; a3 < m3; a3++) null != (y3 = u4.__k[a3]) && (h3 = -1 === y3.__i ? p : g[y3.__i] || p, y3.__i = a3, _3 = j(n2, y3, h3, i4, r3, o2, e3, f3, c3, s3), d2 = y3.__e, y3.ref && h3.ref != y3.ref && (h3.ref && V(h3.ref, null, y3), s3.push(y3.ref, y3.__c || d2, y3)), null == w4 && null != d2 && (w4 = d2), 4 & y3.__u || h3.__k === y3.__k ? f3 = A2(y3, f3, n2) : "function" == typeof y3.type && void 0 !== _3 ? f3 = _3 : d2 && (f3 = d2.nextSibling), y3.__u &= -7);
  return u4.__e = w4, f3;
}
function I2(n2, l3, u4, t3, i4) {
  var r3, o2, e3, f3, c3, s3 = u4.length, a3 = s3, h3 = 0;
  for (n2.__k = new Array(i4), r3 = 0; r3 < i4; r3++) null != (o2 = l3[r3]) && "boolean" != typeof o2 && "function" != typeof o2 ? (f3 = r3 + h3, (o2 = n2.__k[r3] = "string" == typeof o2 || "number" == typeof o2 || "bigint" == typeof o2 || o2.constructor == String ? m(null, o2, null, null, null) : d(o2) ? m(k2, { children: o2 }, null, null, null) : void 0 === o2.constructor && o2.__b > 0 ? m(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : o2).__ = n2, o2.__b = n2.__b + 1, e3 = null, -1 !== (c3 = o2.__i = L2(o2, u4, f3, a3)) && (a3--, (e3 = u4[c3]) && (e3.__u |= 2)), null == e3 || null === e3.__v ? (-1 == c3 && h3--, "function" != typeof o2.type && (o2.__u |= 4)) : c3 != f3 && (c3 == f3 - 1 ? h3-- : c3 == f3 + 1 ? h3++ : (c3 > f3 ? h3-- : h3++, o2.__u |= 4))) : n2.__k[r3] = null;
  if (a3) for (r3 = 0; r3 < s3; r3++) null != (e3 = u4[r3]) && 0 == (2 & e3.__u) && (e3.__e == t3 && (t3 = C2(e3)), q(e3, e3));
  return t3;
}
function A2(n2, l3, u4) {
  var t3, i4;
  if ("function" == typeof n2.type) {
    for (t3 = n2.__k, i4 = 0; t3 && i4 < t3.length; i4++) t3[i4] && (t3[i4].__ = n2, l3 = A2(t3[i4], l3, u4));
    return l3;
  }
  n2.__e != l3 && (l3 && n2.type && !u4.contains(l3) && (l3 = C2(n2)), u4.insertBefore(n2.__e, l3 || null), l3 = n2.__e);
  do {
    l3 = l3 && l3.nextSibling;
  } while (null != l3 && 8 == l3.nodeType);
  return l3;
}
function L2(n2, l3, u4, t3) {
  var i4, r3, o2 = n2.key, e3 = n2.type, f3 = l3[u4];
  if (null === f3 || f3 && o2 == f3.key && e3 === f3.type && 0 == (2 & f3.__u)) return u4;
  if (t3 > (null != f3 && 0 == (2 & f3.__u) ? 1 : 0)) for (i4 = u4 - 1, r3 = u4 + 1; i4 >= 0 || r3 < l3.length; ) {
    if (i4 >= 0) {
      if ((f3 = l3[i4]) && 0 == (2 & f3.__u) && o2 == f3.key && e3 === f3.type) return i4;
      i4--;
    }
    if (r3 < l3.length) {
      if ((f3 = l3[r3]) && 0 == (2 & f3.__u) && o2 == f3.key && e3 === f3.type) return r3;
      r3++;
    }
  }
  return -1;
}
function T(n2, l3, u4) {
  "-" == l3[0] ? n2.setProperty(l3, null == u4 ? "" : u4) : n2[l3] = null == u4 ? "" : "number" != typeof u4 || y2.test(l3) ? u4 : u4 + "px";
}
function F(n2, l3, u4, t3, i4) {
  var r3;
  n: if ("style" == l3) if ("string" == typeof u4) n2.style.cssText = u4;
  else {
    if ("string" == typeof t3 && (n2.style.cssText = t3 = ""), t3) for (l3 in t3) u4 && l3 in u4 || T(n2.style, l3, "");
    if (u4) for (l3 in u4) t3 && u4[l3] === t3[l3] || T(n2.style, l3, u4[l3]);
  }
  else if ("o" == l3[0] && "n" == l3[1]) r3 = l3 != (l3 = l3.replace(f, "$1")), l3 = l3.toLowerCase() in n2 || "onFocusOut" == l3 || "onFocusIn" == l3 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u4, u4 ? t3 ? u4.u = t3.u : (u4.u = c, n2.addEventListener(l3, r3 ? a : s, r3)) : n2.removeEventListener(l3, r3 ? a : s, r3);
  else {
    if ("http://www.w3.org/2000/svg" == i4) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l3 && "height" != l3 && "href" != l3 && "list" != l3 && "form" != l3 && "tabIndex" != l3 && "download" != l3 && "rowSpan" != l3 && "colSpan" != l3 && "role" != l3 && "popover" != l3 && l3 in n2) try {
      n2[l3] = null == u4 ? "" : u4;
      break n;
    } catch (n3) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && "-" != l3[4] ? n2.removeAttribute(l3) : n2.setAttribute(l3, "popover" == l3 && 1 == u4 ? "" : u4));
  }
}
function O2(n2) {
  return function(u4) {
    if (this.l) {
      var t3 = this.l[u4.type + n2];
      if (null == u4.t) u4.t = c++;
      else if (u4.t < t3.u) return;
      return t3(l.event ? l.event(u4) : u4);
    }
  };
}
function j(n2, u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, p2, v3, y3, g, m3, b, C3, S3, M2, P3, I3, A3, H, L3, T2, F2 = u4.type;
  if (void 0 !== u4.constructor) return null;
  128 & t3.__u && (c3 = !!(32 & t3.__u), o2 = [f3 = u4.__e = t3.__e]), (a3 = l.__b) && a3(u4);
  n: if ("function" == typeof F2) try {
    if (b = u4.props, C3 = "prototype" in F2 && F2.prototype.render, S3 = (a3 = F2.contextType) && i4[a3.__c], M2 = a3 ? S3 ? S3.props.value : a3.__ : i4, t3.__c ? m3 = (h3 = u4.__c = t3.__c).__ = h3.__E : (C3 ? u4.__c = h3 = new F2(b, M2) : (u4.__c = h3 = new x2(b, M2), h3.constructor = F2, h3.render = B2), S3 && S3.sub(h3), h3.props = b, h3.state || (h3.state = {}), h3.context = M2, h3.__n = i4, p2 = h3.__d = true, h3.__h = [], h3._sb = []), C3 && null == h3.__s && (h3.__s = h3.state), C3 && null != F2.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = w2({}, h3.__s)), w2(h3.__s, F2.getDerivedStateFromProps(b, h3.__s))), v3 = h3.props, y3 = h3.state, h3.__v = u4, p2) C3 && null == F2.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), C3 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
    else {
      if (C3 && null == F2.getDerivedStateFromProps && b !== v3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(b, M2), !h3.__e && (null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(b, h3.__s, M2) || u4.__v == t3.__v)) {
        for (u4.__v != t3.__v && (h3.props = b, h3.state = h3.__s, h3.__d = false), u4.__e = t3.__e, u4.__k = t3.__k, u4.__k.some(function(n3) {
          n3 && (n3.__ = u4);
        }), P3 = 0; P3 < h3._sb.length; P3++) h3.__h.push(h3._sb[P3]);
        h3._sb = [], h3.__h.length && e3.push(h3);
        break n;
      }
      null != h3.componentWillUpdate && h3.componentWillUpdate(b, h3.__s, M2), C3 && null != h3.componentDidUpdate && h3.__h.push(function() {
        h3.componentDidUpdate(v3, y3, g);
      });
    }
    if (h3.context = M2, h3.props = b, h3.__P = n2, h3.__e = false, I3 = l.__r, A3 = 0, C3) {
      for (h3.state = h3.__s, h3.__d = false, I3 && I3(u4), a3 = h3.render(h3.props, h3.state, h3.context), H = 0; H < h3._sb.length; H++) h3.__h.push(h3._sb[H]);
      h3._sb = [];
    } else do {
      h3.__d = false, I3 && I3(u4), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
    } while (h3.__d && ++A3 < 25);
    h3.state = h3.__s, null != h3.getChildContext && (i4 = w2(w2({}, i4), h3.getChildContext())), C3 && !p2 && null != h3.getSnapshotBeforeUpdate && (g = h3.getSnapshotBeforeUpdate(v3, y3)), f3 = $2(n2, d(L3 = null != a3 && a3.type === k2 && null == a3.key ? a3.props.children : a3) ? L3 : [L3], u4, t3, i4, r3, o2, e3, f3, c3, s3), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && e3.push(h3), m3 && (h3.__E = h3.__ = null);
  } catch (n3) {
    if (u4.__v = null, c3 || null != o2) if (n3.then) {
      for (u4.__u |= c3 ? 160 : 128; f3 && 8 == f3.nodeType && f3.nextSibling; ) f3 = f3.nextSibling;
      o2[o2.indexOf(f3)] = null, u4.__e = f3;
    } else for (T2 = o2.length; T2--; ) _2(o2[T2]);
    else u4.__e = t3.__e, u4.__k = t3.__k;
    l.__e(n3, u4, t3);
  }
  else null == o2 && u4.__v == t3.__v ? (u4.__k = t3.__k, u4.__e = t3.__e) : f3 = u4.__e = N2(t3.__e, u4, t3, i4, r3, o2, e3, c3, s3);
  return (a3 = l.diffed) && a3(u4), 128 & u4.__u ? void 0 : f3;
}
function z2(n2, u4, t3) {
  for (var i4 = 0; i4 < t3.length; i4++) V(t3[i4], t3[++i4], t3[++i4]);
  l.__c && l.__c(u4, n2), n2.some(function(u5) {
    try {
      n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
        n3.call(u5);
      });
    } catch (n3) {
      l.__e(n3, u5.__v);
    }
  });
}
function N2(u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, v3, y3, w4, g, m3, b = i4.props, k4 = t3.props, x3 = t3.type;
  if ("svg" == x3 ? o2 = "http://www.w3.org/2000/svg" : "math" == x3 ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), null != e3) {
    for (a3 = 0; a3 < e3.length; a3++) if ((w4 = e3[a3]) && "setAttribute" in w4 == !!x3 && (x3 ? w4.localName == x3 : 3 == w4.nodeType)) {
      u4 = w4, e3[a3] = null;
      break;
    }
  }
  if (null == u4) {
    if (null == x3) return document.createTextNode(k4);
    u4 = document.createElementNS(o2, x3, k4.is && k4), c3 && (l.__m && l.__m(t3, e3), c3 = false), e3 = null;
  }
  if (null === x3) b === k4 || c3 && u4.data === k4 || (u4.data = k4);
  else {
    if (e3 = e3 && n.call(u4.childNodes), b = i4.props || p, !c3 && null != e3) for (b = {}, a3 = 0; a3 < u4.attributes.length; a3++) b[(w4 = u4.attributes[a3]).name] = w4.value;
    for (a3 in b) if (w4 = b[a3], "children" == a3) ;
    else if ("dangerouslySetInnerHTML" == a3) v3 = w4;
    else if (!(a3 in k4)) {
      if ("value" == a3 && "defaultValue" in k4 || "checked" == a3 && "defaultChecked" in k4) continue;
      F(u4, a3, null, w4, o2);
    }
    for (a3 in k4) w4 = k4[a3], "children" == a3 ? y3 = w4 : "dangerouslySetInnerHTML" == a3 ? h3 = w4 : "value" == a3 ? g = w4 : "checked" == a3 ? m3 = w4 : c3 && "function" != typeof w4 || b[a3] === w4 || F(u4, a3, w4, b[a3], o2);
    if (h3) c3 || v3 && (h3.__html === v3.__html || h3.__html === u4.innerHTML) || (u4.innerHTML = h3.__html), t3.__k = [];
    else if (v3 && (u4.innerHTML = ""), $2(u4, d(y3) ? y3 : [y3], t3, i4, r3, "foreignObject" == x3 ? "http://www.w3.org/1999/xhtml" : o2, e3, f3, e3 ? e3[0] : i4.__k && C2(i4, 0), c3, s3), null != e3) for (a3 = e3.length; a3--; ) _2(e3[a3]);
    c3 || (a3 = "value", "progress" == x3 && null == g ? u4.removeAttribute("value") : void 0 !== g && (g !== u4[a3] || "progress" == x3 && !g || "option" == x3 && g !== b[a3]) && F(u4, a3, g, b[a3], o2), a3 = "checked", void 0 !== m3 && m3 !== u4[a3] && F(u4, a3, m3, b[a3], o2));
  }
  return u4;
}
function V(n2, u4, t3) {
  try {
    if ("function" == typeof n2) {
      var i4 = "function" == typeof n2.__u;
      i4 && n2.__u(), i4 && null == u4 || (n2.__u = n2(u4));
    } else n2.current = u4;
  } catch (n3) {
    l.__e(n3, t3);
  }
}
function q(n2, u4, t3) {
  var i4, r3;
  if (l.unmount && l.unmount(n2), (i4 = n2.ref) && (i4.current && i4.current !== n2.__e || V(i4, null, u4)), null != (i4 = n2.__c)) {
    if (i4.componentWillUnmount) try {
      i4.componentWillUnmount();
    } catch (n3) {
      l.__e(n3, u4);
    }
    i4.base = i4.__P = null;
  }
  if (i4 = n2.__k) for (r3 = 0; r3 < i4.length; r3++) i4[r3] && q(i4[r3], u4, t3 || "function" != typeof n2.type);
  t3 || _2(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function B2(n2, l3, u4) {
  return this.constructor(n2, u4);
}
n = v.slice, l = { __e: function(n2, l3, u4, t3) {
  for (var i4, r3, o2; l3 = l3.__; ) if ((i4 = l3.__c) && !i4.__) try {
    if ((r3 = i4.constructor) && null != r3.getDerivedStateFromError && (i4.setState(r3.getDerivedStateFromError(n2)), o2 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n2, t3 || {}), o2 = i4.__d), o2) return i4.__E = i4;
  } catch (l4) {
    n2 = l4;
  }
  throw n2;
} }, u = 0, t = function(n2) {
  return null != n2 && null == n2.constructor;
}, x2.prototype.setState = function(n2, l3) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = w2({}, this.state), "function" == typeof n2 && (n2 = n2(w2({}, u4), this.props)), n2 && w2(u4, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), M(this));
}, x2.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x2.prototype.render = k2, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l3) {
  return n2.__v.__b - l3.__v.__b;
}, P2.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = O2(false), a = O2(true), h = 0;

// node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var i2 = Array.isArray;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u3;
var i3;
var f2 = [];
var c2 = l;
var e2 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l2 = c2.__c;
var m2 = c2.unmount;
var s2 = c2.__;
function j2() {
  for (var n2; n2 = f2.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z3), n2.__H.__h.forEach(B3), n2.__H.__h = [];
  } catch (t3) {
    n2.__H.__h = [], c2.__e(t3, n2.__v);
  }
}
c2.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, c2.__ = function(n2, t3) {
  n2 && t3.__k && t3.__k.__m && (n2.__m = t3.__k.__m), s2 && s2(n2, t3);
}, c2.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i4 = (r2 = n2.__c).__H;
  i4 && (u3 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.i = n3.__N = void 0;
  })) : (i4.__h.forEach(z3), i4.__h.forEach(B3), i4.__h = [], t2 = 0)), u3 = r2;
}, c2.diffed = function(n2) {
  v2 && v2(n2);
  var t3 = n2.__c;
  t3 && t3.__H && (t3.__H.__h.length && (1 !== f2.push(t3) && i3 === c2.requestAnimationFrame || ((i3 = c2.requestAnimationFrame) || w3)(j2)), t3.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.i = void 0;
  })), u3 = r2 = null;
}, c2.__c = function(n2, t3) {
  t3.some(function(n3) {
    try {
      n3.__h.forEach(z3), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B3(n4);
      });
    } catch (r3) {
      t3.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t3 = [], c2.__e(r3, n3.__v);
    }
  }), l2 && l2(n2, t3);
}, c2.unmount = function(n2) {
  m2 && m2(n2);
  var t3, r3 = n2.__c;
  r3 && r3.__H && (r3.__H.__.forEach(function(n3) {
    try {
      z3(n3);
    } catch (n4) {
      t3 = n4;
    }
  }), r3.__H = void 0, t3 && c2.__e(t3, r3.__v));
};
var k3 = "function" == typeof requestAnimationFrame;
function w3(n2) {
  var t3, r3 = function() {
    clearTimeout(u4), k3 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u4 = setTimeout(r3, 100);
  k3 && (t3 = requestAnimationFrame(r3));
}
function z3(n2) {
  var t3 = r2, u4 = n2.__c;
  "function" == typeof u4 && (n2.__c = void 0, u4()), r2 = t3;
}
function B3(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@codesandbox/api/dist/esm/utils.js
var import_humps = __toESM(require_humps());
var import_node_fetch = __toESM(require_browser());
var { camelizeKeys, camelize } = import_humps.default;
var ApiResponseError = class extends Error {
  constructor(status, message, parsedErrorMessage) {
    super(`(${status}) ${message}`);
    this.type = "ERROR";
    this.parsedErrorMessage = parsedErrorMessage;
    if (status === 404 || message.toLowerCase().includes("not found")) {
      this.type = "NOT_FOUND";
    } else if (status === 402) {
      this.type = "WORKSPACE_FROZEN";
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/index.js
var import_pitcher_common31 = __toESM(require_dist3());
var import_pitcher_protocol5 = __toESM(require_src());
var import_class_states4 = __toESM(require_dist6());
var import_debug3 = __toESM(require_browser2());
var import_semver = __toESM(require_semver2());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/retryPromise.js
var import_pitcher_common5 = __toESM(require_dist3());
var import_event = __toESM(require_event());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/sleep.js
function sleep(ms) {
  let timeoutId = void 0;
  const promise = new Promise((resolve) => {
    timeoutId = setTimeout(resolve, ms);
  });
  promise.dispose = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };
  return promise;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/common/retryPromise.js
var CancellationToken = class extends import_pitcher_common5.Disposable {
  constructor() {
    super();
    this.onCancellationRequestedEmitter = this.addDisposable(new import_pitcher_common5.Emitter());
    this.onCancellationRequested = this.onCancellationRequestedEmitter.event;
    this.cancellationRequested = false;
    this.onWillDispose(() => {
      this.requestCancellation();
    });
  }
  isCancellationRequested() {
    return this.cancellationRequested;
  }
  requestCancellation() {
    this.cancellationRequested = true;
    this.onCancellationRequestedEmitter.fire();
  }
  throwErrorIfCancelled(cleanup) {
    if (this.cancellationRequested) {
      cleanup?.();
      throw new CancellationError();
    }
  }
};
var CancellationError = class extends Error {
  constructor(sourceError) {
    super("Cancelled");
    this.sourceError = sourceError;
  }
};
var TIMEOUT_SYMBOL = Symbol("TIMEOUT_SYMBOL");
async function retryPromise(cb, tries, delayMs, timeoutMs) {
  let cancellationToken;
  let result;
  for (let i4 = 0; i4 < tries; i4++) {
    cancellationToken = new CancellationToken();
    try {
      const sleepRef = sleep(timeoutMs);
      const raceResult = await Promise.race([
        cb(cancellationToken),
        // Since callbacks can return undefined, we need a recognizeable symbol to evaluate
        // if we hit the timeout
        sleepRef.then(() => TIMEOUT_SYMBOL),
        (0, import_event.listenOnce)(cancellationToken.onCancellationRequested)
      ]);
      sleepRef.dispose();
      if (cancellationToken.isCancellationRequested()) {
        throw new CancellationError();
      }
      if (raceResult === TIMEOUT_SYMBOL) {
        cancellationToken.requestCancellation();
        throw new Error("Timed out after " + timeoutMs + "ms");
      }
      result = raceResult;
      break;
    } catch (e3) {
      if (e3 instanceof CancellationError) {
        throw e3.sourceError || e3;
      }
      const isLastRetry = i4 === tries - 1;
      if (isLastRetry) {
        throw e3;
      }
      await sleep(delayMs);
    }
  }
  return result;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/common/versions.js
var PitcherFeatureToVersionMap = {
  GIT_BRANCH_OUT_OF_SYNC: "0.209.11",
  SANDBOX_TO_REPOSITORY: "0.209.9",
  VM_METRICS: "0.212.0",
  GIT_LOGS_ON_PROTECTED_BRANCHES: "0.233.0",
  REMOTE_BRANCH_PRESENCE_DETECTION: "0.242.0",
  SET_BRANCH_PROTECTION: "0.248.4",
  SHELL_RENAME: "0.254.0",
  SEARCH_CASE_SENSITIVITY: "0.308.6",
  SETUP_ENV_DEVTOOL: "0.313.0"
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/PitcherMessageHandler.js
var import_pitcher_common6 = __toESM(require_dist3());
var import_pitcher_protocol2 = __toESM(require_src());
var PitcherMessageHandler = class {
  constructor(onSendRequest, seamlessFork) {
    this.onSendRequest = onSendRequest;
    this.seamlessFork = seamlessFork;
    this.nextMessageId = 0;
    this.awaitReconnectQueue = [];
    this.pendingMessages = /* @__PURE__ */ new Map();
    this.isRequestingInstanceChange = false;
    this.onInstanceChangeRequiredEmitter = new import_pitcher_common6.Emitter();
    this.onInstanceChangeRequired = this.onInstanceChangeRequiredEmitter.event;
    this.notificationListeners = {};
    this.messageEmitter = new import_pitcher_common6.Emitter();
    this.onMessage = this.messageEmitter.event;
    this.errorEmitter = new import_pitcher_common6.Emitter();
    this.onError = this.errorEmitter.event;
  }
  toggleSeamlessFork(value) {
    this.seamlessFork = value;
  }
  onNotification(method, cb) {
    let listeners = this.notificationListeners[method];
    if (!listeners) {
      listeners = this.notificationListeners[method] = new import_pitcher_common6.SliceList();
    }
    const idx = listeners.add(cb);
    return () => {
      this.notificationListeners[method]?.remove(idx);
    };
  }
  receiveMessage(blob) {
    const payload = (0, import_pitcher_protocol2.decodeMessage)(blob);
    this.messageEmitter.fire(payload);
    const method = payload.method;
    if ((0, import_pitcher_protocol2.isNotificationPayload)(payload)) {
      const listeners = this.notificationListeners[method];
      if (listeners) {
        for (const cb of listeners.values()) {
          cb(payload.params);
        }
      }
      return;
    }
    let response;
    if ((0, import_pitcher_protocol2.isErrorPayload)(payload)) {
      response = {
        status: import_pitcher_protocol2.PitcherResponseStatus.REJECTED,
        error: {
          code: payload.error.code,
          data: payload.error.data,
          message: payload.error.message
        },
        method
      };
    } else if ((0, import_pitcher_protocol2.isResultPayload)(payload)) {
      response = {
        status: import_pitcher_protocol2.PitcherResponseStatus.RESOLVED,
        result: payload.result,
        method
      };
    } else {
      throw new Error("Unable to identify message type");
    }
    const messageToResolve = this.pendingMessages.get(payload.id);
    if (messageToResolve) {
      messageToResolve.resolve(response);
    }
  }
  /**
   * Replaces the current sending message handler with a new one, bound to a new connection. We do this instead of emitting an event
   * as we want to deal with any errors
   */
  setOnSendRequest(onSendRequest) {
    this.onSendRequest = onSendRequest;
  }
  request(pitcherRequest, options = {}) {
    const { timeoutMs, queueForReconnect = true, seamlessForkStrategy } = options;
    const request = this.createRequest(pitcherRequest, timeoutMs);
    if (this.seamlessFork && (seamlessForkStrategy === "queue" || seamlessForkStrategy === "dispose")) {
      if (seamlessForkStrategy === "queue") {
        this.awaitReconnectQueue.push(request);
      } else {
        request.dispose();
      }
      if (!this.isRequestingInstanceChange) {
        this.isRequestingInstanceChange = true;
        this.onInstanceChangeRequiredEmitter.fire(pitcherRequest.method);
      }
      return request.unwrap();
    }
    if (this.seamlessFork && this.isRequestingInstanceChange && seamlessForkStrategy === "queueDuringFork") {
      this.awaitReconnectQueue.push(request);
      return request.unwrap();
    }
    try {
      this.onSendRequest(request);
      return request.unwrap();
    } catch (error) {
      if (queueForReconnect) {
        this.awaitReconnectQueue.push(request);
        return request.unwrap();
      }
      this.errorEmitter.fire({
        message: error.message,
        extras: {
          source: "pitcher-message-handler",
          type: "send-request",
          request: pitcherRequest
        }
      });
      return Promise.reject(error);
    }
  }
  createRequest(request, timeoutMs) {
    const id = this.nextMessageId++;
    const pitcherMessage = new PendingPitcherMessage(id, request, timeoutMs);
    this.pendingMessages.set(id, pitcherMessage);
    pitcherMessage.onDidDispose(() => this.pendingMessages.delete(id));
    return pitcherMessage;
  }
  getPendingMessages() {
    return this.pendingMessages;
  }
  disposePendingMessages(exceptions) {
    this.pendingMessages.forEach((pendingMessage) => {
      if (!exceptions || !exceptions.includes(pendingMessage.message)) {
        pendingMessage.dispose();
      }
    });
  }
  disableSeamlessFork() {
    this.seamlessFork = false;
    this.isRequestingInstanceChange = false;
  }
  async flushReconnectQueue() {
    try {
      await Promise.all(this.awaitReconnectQueue.map((message) => this.onSendRequest(message)));
      this.awaitReconnectQueue.length = 0;
    } catch {
    }
  }
  dispose() {
    this.onSendRequest = () => {
    };
    this.disposePendingMessages();
    this.pendingMessages.clear();
    this.notificationListeners = {};
    this.errorEmitter.dispose();
    this.messageEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/WebSocketClient/index.js
var import_pitcher_common7 = __toESM(require_dist3());
var import_debug = __toESM(require_browser2());

// node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/WebSocketClient/index.js
var debug = (0, import_debug.default)("csb:vm:ws");
var WEBSOCKET_PING_OFFSET = 2e3;
var INIT_DETECT_PONG_TIMEOUT = 2e4;
var readyStateToString = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
if (typeof process !== "undefined" && false) {
  WEBSOCKET_PING_OFFSET = 20;
  INIT_DETECT_PONG_TIMEOUT = 200;
}
var WebSocketClient = class extends import_pitcher_common7.Disposable {
  // It receives a connected websocket connection
  constructor(ws2) {
    super();
    this.bufferQueue = new import_pitcher_common7.SerialQueue("websocket-buffer-queue");
    this.pongDetectionTimeout = INIT_DETECT_PONG_TIMEOUT;
    this.onMessageEmitter = new import_pitcher_common7.Emitter();
    this.onDisconnectedEmitter = new import_pitcher_common7.Emitter();
    this.onMessage = this.onMessageEmitter.event;
    this.onDisconnected = this.onDisconnectedEmitter.event;
    this.lastActivity = Date.now();
    if (ws2.readyState !== ws2.OPEN) {
      throw new Error("Requires an OPEN websocket connection");
    }
    debug("[websocket]: OPEN");
    this.ws = ws2;
    this.lastActivity = Date.now();
    const onHeartbeatInterval = () => {
      const timeSinceActivity = Date.now() - this.lastActivity;
      if (timeSinceActivity > this.pingTimeout) {
        this.ping();
      }
    };
    const heartbeatInterval = setInterval(onHeartbeatInterval, this.pingTimeout);
    const onMessageListener = (event) => {
      this.lastActivity = Date.now();
      const data = event.data;
      clearTimeout(this.detectDisconnectByPongTimeout);
      if (typeof window !== "undefined" && data instanceof window.Blob) {
        this.bufferQueue.add(async () => {
          this.emitMessage(new Uint8Array(await data.arrayBuffer()));
        });
        return;
      }
      if (typeof data !== "string") {
        this.emitMessage(data);
        return;
      }
    };
    const onErrorListener = () => {
      if (this.isClosingOrClosed()) {
        this.onDisconnectedEmitter.fire({
          code: -1,
          reason: "Error listener - " + readyStateToString[ws2.readyState],
          wasClean: false
        });
      }
    };
    const onCloseListener = ({ wasClean, code, reason }) => this.onDisconnectedEmitter.fire({
      wasClean,
      code,
      reason: "Close listener - " + reason
    });
    ws2.addEventListener("message", onMessageListener);
    ws2.addEventListener("close", onCloseListener);
    ws2.addEventListener("error", onErrorListener);
    this.onWillDispose(() => {
      clearInterval(heartbeatInterval);
      clearTimeout(this.pongDetectionTimeout);
      clearTimeout(this.detectDisconnectByPongTimeout);
      ws2.removeEventListener("close", onCloseListener);
      ws2.removeEventListener("message", onMessageListener);
      ws2.removeEventListener("error", onErrorListener);
      this.onMessageEmitter.dispose();
      this.onDisconnectedEmitter.dispose();
      this.ws.close();
    });
  }
  isClosingOrClosed() {
    return this.ws.readyState === this.ws.CLOSING || this.ws.readyState === this.ws.CLOSED;
  }
  emitMessage(message) {
    this.onMessageEmitter.fire(message);
  }
  get pingTimeout() {
    return this.pongDetectionTimeout + WEBSOCKET_PING_OFFSET;
  }
  setPongDetectionTimeout(ms) {
    this.pongDetectionTimeout = ms;
  }
  /**
   We use "PING" to both keep the session alive, but also detect disconnects. Certain interactions, like
   focusing the application should trigger an immediate "ping", which is why this is a public method. An optional
   pong timeout can be set. This is useful to detect disconnects faster for example when focusing the application
   */
  ping(pongTimeout) {
    clearTimeout(this.detectDisconnectByPongTimeout);
    this.detectDisconnectByPongTimeout = setTimeout(() => {
      this.onDisconnectedEmitter.fire({
        code: -1,
        reason: "Pong response not detected",
        wasClean: false
      });
    }, pongTimeout || this.pongDetectionTimeout);
    try {
      this.send("");
    } catch {
    }
  }
  send(data) {
    if (this.isClosingOrClosed()) {
      this.onDisconnectedEmitter.fire({
        code: -1,
        reason: "WebSocket not in an open state",
        wasClean: false
      });
      throw new Error("Could not send message in " + readyStateToString[this.ws.readyState] + " state");
    }
    this.ws.send(data);
  }
  /**
   * Closes the connection, triggering a disconnected event
   */
  close() {
    this.ws.close();
  }
  /**
   * Keep connection alive, but do not trigger any events. Used with seamless forking
   */
  silence() {
    this.onDisconnectedEmitter.dispose();
  }
  dispose(reason) {
    if (this.isDisposed) {
      return;
    }
    if (!reason) {
      reason = "DISPOSED";
    }
    debug("[websocket]: Disposed", readyStateToString[this.ws.readyState], reason);
    super.dispose();
  }
};
var createWebSocketClient = (url) => new Promise((resolve, reject) => {
  const ws2 = new browser_default(url);
  const openListener = () => {
    cleanInitialListeners();
    resolve(new WebSocketClient(ws2));
  };
  const errorListener = ({ message }) => {
    cleanInitialListeners();
    reject(new Error(message));
  };
  const closeListener = () => {
    cleanInitialListeners();
    reject(new Error("Connection closed before it was opened"));
  };
  const cleanInitialListeners = () => {
    ws2.removeEventListener("open", openListener);
    ws2.removeEventListener("error", errorListener);
    ws2.removeEventListener("close", closeListener);
  };
  ws2.addEventListener("open", openListener);
  ws2.addEventListener("error", errorListener);
  ws2.addEventListener("close", closeListener);
});

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/index.js
var import_pitcher_common10 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/AiChat.js
var import_pitcher_common8 = __toESM(require_dist3());
var AiChatMessageStream = class extends import_pitcher_common8.Disposable {
  constructor(id, role, username) {
    super();
    this.id = id;
    this.role = role;
    this.username = username;
    this.progressEmitter = new import_pitcher_common8.Emitter();
    this.onProgress = this.progressEmitter.event;
    this.doneEmitter = new import_pitcher_common8.Emitter();
    this.onDone = this.doneEmitter.event;
  }
  handleProgress(content) {
    this.progressEmitter.fire(content);
  }
  handleDone() {
    this.doneEmitter.fire();
  }
};
var AiChat = class extends import_pitcher_common8.Disposable {
  constructor(chatId, title, isUpToDate, messageHandler, aiClient) {
    super();
    this.messageHandler = messageHandler;
    this.aiClient = aiClient;
    this.historyPromise = null;
    this.entries = [];
    this.isStreamingReply = false;
    this.chatMessageEmitter = new import_pitcher_common8.Emitter();
    this.onChatMessage = this.chatMessageEmitter.event;
    this.chatMessageStartedEmitter = new import_pitcher_common8.Emitter();
    this.onChatMessageStarted = this.chatMessageStartedEmitter.event;
    this.chatTitleChangeEmitter = new import_pitcher_common8.Emitter();
    this.onChatTitleChange = this.chatTitleChangeEmitter.event;
    this.chatId = chatId;
    this.title = title;
    this.isUpToDate = isUpToDate;
    const disposeNotificationListener = this.messageHandler.onNotification("ai/chatMessage", (evt) => {
      if (evt.chatId === this.chatId) {
        const stream = new AiChatMessageStream(evt.messageId, evt.role, evt.username);
        this.chatMessageStartedEmitter.fire(stream);
        if (evt.isFinished || !evt.messageId) {
          this.addChatMessage(evt, true);
          this.chatMessageEmitter.fire(evt);
          stream.handleProgress(evt.message);
          stream.handleDone();
        } else {
          this.isStreamingReply = true;
          const disposable = this.aiClient.subscribeToMessage(evt.messageId, (newContent, isFinished) => {
            stream.handleProgress(newContent);
            if (isFinished) {
              const message = { ...evt, message: newContent };
              this.addChatMessage(message, true);
              this.isStreamingReply = false;
              this.chatMessageEmitter.fire(message);
              disposable.dispose();
              stream.handleDone();
            }
          });
        }
      }
    });
    this.onWillDispose(() => disposeNotificationListener());
  }
  addChatMessage(message, checkHistory) {
    if (checkHistory && this.entries.length) {
      const lastMsgIdx = this.entries[this.entries.length - 1]?.idx ?? 0;
      if (lastMsgIdx !== message.idx - 1) {
        console.warn("Chat message got lost", this, message);
        this.fetchHistory();
      }
    }
    this.entries.push({
      idx: message.idx,
      role: message.role,
      username: message.username,
      message: message.message,
      context: message.context
    });
  }
  fetchHistory() {
    if (!this.historyPromise) {
      this.historyPromise = this.messageHandler.request({
        method: "ai/chatHistory",
        params: {
          chatId: this.chatId
        }
      }).then((res) => {
        this.isUpToDate = true;
        this.entries = res.entries;
        return this.entries;
      }).catch((err) => {
        if (!err.message?.includes("not found")) {
          console.error(err);
        }
        return [];
      }).finally(() => {
        this.historyPromise = null;
      });
    }
    return this.historyPromise;
  }
  getHistory() {
    if (!this.isUpToDate) {
      return this.fetchHistory();
    } else {
      return Promise.resolve(this.entries);
    }
  }
  getHistorySync() {
    return this.entries;
  }
  async sendMessage(params) {
    if (this.isStreamingReply) {
      throw new Error("Cannot sent another request while we are waiting on a response");
    }
    const messageId = (0, import_pitcher_common8.newId)();
    const result = await this.messageHandler.request({
      method: "ai/chatMessage",
      params: {
        ...params,
        messageId,
        chatId: this.chatId
      }
    });
    if (result.title !== this.title) {
      this.title = result.title;
      this.chatTitleChangeEmitter.fire(this.title);
    }
    const chatMessage = {
      ...params,
      chatId: this.chatId,
      role: "user",
      idx: this.entries.length
    };
    this.addChatMessage(chatMessage, true);
  }
  async refresh() {
    await this.fetchHistory();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/MessageStream.js
var import_pitcher_common9 = __toESM(require_dist3());
var AiMessageStream = class extends import_pitcher_common9.Disposable {
  constructor(id, aiClient) {
    super();
    this.id = id;
    this.progressEmitter = new import_pitcher_common9.Emitter();
    this.onProgress = this.progressEmitter.event;
    this.doneEmitter = new import_pitcher_common9.Emitter();
    this.onDone = this.doneEmitter.event;
    const disposable = aiClient.subscribeToMessage(id, (newContent, isFinished) => {
      this.progressEmitter.fire(newContent);
      if (isFinished) {
        this.doneEmitter.fire();
      }
    });
    this.addDisposable(disposable);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/index.js
var AiClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.chats = /* @__PURE__ */ new Map();
    this.messageStates = /* @__PURE__ */ new Map();
    this.messageProgressEmitter = new import_pitcher_common10.Emitter();
    this.onMessageProgress = this.messageProgressEmitter.event;
    this.chatsUpdatedEmitter = new import_pitcher_common10.Emitter();
    this.onChatsUpdated = this.chatsUpdatedEmitter.event;
    this.chatsErrorEmitter = new import_pitcher_common10.Emitter();
    this.onChatsError = this.chatsErrorEmitter.event;
    this.chatCreatedEmitter = new import_pitcher_common10.Emitter();
    this.onChatCreated = this.chatCreatedEmitter.event;
    this.chatMessageEmitter = new import_pitcher_common10.Emitter();
    this.onChatMessage = this.chatMessageEmitter.event;
    messageHandler.onNotification("ai/messageProgress", ({ messageId, chunk, isFinished }) => {
      const state = this.messageStates.get(messageId) ?? {
        isFinished,
        content: ""
      };
      state.content += chunk;
      state.isFinished = isFinished;
      this.messageStates.set(messageId, state);
      this.messageProgressEmitter.fire(messageId);
    });
    messageHandler.onNotification("ai/chatCreated", (evt) => {
      const chat = new AiChat(evt.chatId, evt.title, true, messageHandler, this);
      chat.entries = evt.entries;
      this.chats.set(chat.chatId, chat);
      this.chatCreatedEmitter.fire(chat);
      this.chatsUpdatedEmitter.fire(this.chats);
    });
    messageHandler.onNotification("ai/chatMessage", (message) => {
      this.chatMessageEmitter.fire(message);
    });
  }
  subscribeToMessage(messageId, callback) {
    const disposable = this.onMessageProgress((evtId) => {
      if (evtId === messageId) {
        const state2 = this.messageStates.get(messageId);
        if (state2) {
          callback(state2.content, state2.isFinished);
        }
      }
    });
    const state = this.messageStates.get(messageId);
    if (state) {
      callback(state.content, state.isFinished);
    }
    return disposable;
  }
  fetchChats() {
    this.messageHandler.request({
      method: "ai/chats",
      params: {}
    }).then((v3) => {
      for (const c3 of v3.chats) {
        const existingChat = this.chats.get(c3.chatId);
        if (!existingChat) {
          const chatInstance = new AiChat(c3.chatId, c3.title, false, this.messageHandler, this);
          this.chats.set(c3.chatId, chatInstance);
          chatInstance.refresh();
        }
        this.chatsUpdatedEmitter.fire(this.chats);
      }
    }).catch((err) => {
      this.chatsErrorEmitter.fire(err.message);
    });
  }
  resync() {
    this.fetchChats();
  }
  suggestCommit(params) {
    if (!params.files.length) {
      throw new Error("Need to provide at least 1 file");
    }
    return this.messageHandler.request({
      method: "ai/suggestCommit",
      params
    });
  }
  raw(params) {
    return this.messageHandler.request({
      method: "ai/raw",
      params
    });
  }
  async stream(params) {
    const result = await this.messageHandler.request({
      method: "ai/stream",
      params
    });
    const stream = new AiMessageStream(result.messageId, this);
    return stream;
  }
  async getChat({ id = (0, import_pitcher_common10.newId)() }) {
    let chat = this.chats.get(id);
    if (chat) {
      return chat;
    }
    chat = new AiChat(id, "New chat", true, this.messageHandler, this);
    this.chats.set(chat.chatId, chat);
    this.chatsUpdatedEmitter.fire(this.chats);
    await chat.getHistory();
    return chat;
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/Channel.js
var import_pitcher_common11 = __toESM(require_dist3());
var Channel = class extends import_pitcher_common11.Disposable {
  constructor(name, messageHandler) {
    super();
    this.name = name;
    this.messageHandler = messageHandler;
    this.onErrorEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onJoinEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onLeaveEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onMessageEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.state = {
      hasSubscribed: false
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.onError = this.onErrorEmitter.event;
    this.onSubscribe = this.onJoinEmitter.event;
    this.onUnsubscribe = this.onLeaveEmitter.event;
    this.onMessage = this.onMessageEmitter.event;
    this.onWillDispose(() => {
      this.unsubscribe();
      this.subscribers = /* @__PURE__ */ new Set();
      if (this.state.hasSubscribed) {
        this.state.disposeNotificationListeners();
      }
    });
  }
  listenToNotifications() {
    const onMessageDisposer = this.messageHandler.onNotification("channel/message", (message) => {
      if (message.name === this.name) {
        this.onMessageEmitter.fire({
          clientId: message.clientId,
          data: message.data,
          isUser: message.isUser
        });
      }
    });
    const onSubscribedDisposer = this.messageHandler.onNotification("channel/subscribed", (message) => {
      if (message.name === this.name) {
        this.subscribers = new Set(message.subscribers);
        this.onJoinEmitter.fire(message.clientId);
      }
    });
    const onUnsubscribedDisposer = this.messageHandler.onNotification("channel/unsubscribed", (message) => {
      if (message.name === this.name) {
        this.subscribers = new Set(message.subscribers);
        this.onLeaveEmitter.fire(message.clientId);
      }
    });
    return () => {
      onMessageDisposer();
      onSubscribedDisposer();
      onUnsubscribedDisposer();
    };
  }
  async subscribe() {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.state.hasSubscribed === true) {
      return;
    }
    const disposeNotificationListeners = this.listenToNotifications();
    try {
      const result = await this.messageHandler.request({
        method: "channel/subscribe",
        params: {
          name: this.name
        }
      });
      this.subscribers = new Set(result.subscribers);
      this.state = {
        hasSubscribed: true,
        disposeNotificationListeners
      };
    } catch (err) {
      const error = err;
      disposeNotificationListeners();
      this.onErrorEmitter.fire({
        code: error.code,
        message: error.message
      });
      throw new Error(error.message);
    }
  }
  async unsubscribe() {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.state.hasSubscribed === false) {
      return;
    }
    this.state.disposeNotificationListeners();
    this.state = {
      hasSubscribed: false
    };
    try {
      await this.messageHandler.request({
        method: "channel/unsubscribe",
        params: {
          name: this.name
        }
      });
      this.subscribers = /* @__PURE__ */ new Set();
      this.state = {
        hasSubscribed: false
      };
    } catch (err) {
      const dispose = this.listenToNotifications();
      const error = err;
      this.state = {
        hasSubscribed: true,
        disposeNotificationListeners: dispose
      };
      this.onErrorEmitter.fire({
        code: error.code,
        message: error.message
      });
      throw new Error(error.message);
    }
  }
  sendAll(data) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.messageHandler.request({
      method: "channel/message",
      params: {
        data,
        name: this.name
      }
    });
  }
  send(subscribers, data) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.messageHandler.request({
      method: "channel/message",
      params: {
        data,
        name: this.name,
        clients: Array.from(subscribers)
      }
    });
  }
  resync() {
    if (this.state.hasSubscribed) {
      this.state.disposeNotificationListeners();
      this.state = {
        hasSubscribed: false
      };
      this.subscribe();
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/CommandChannel.js
var import_pitcher_common12 = __toESM(require_dist3());
var import_class_states2 = __toESM(require_dist6());
var CommandChannel = class extends import_pitcher_common12.Disposable {
  constructor({ name, currentClient, clientClient, messageHandler }) {
    super();
    this.state = new import_class_states2.States({
      state: "SOLO"
    });
    this.name = name;
    this.hostChannel = new Channel(`${name}-${currentClient.clientId}`, messageHandler);
    this.hostChannel.subscribe();
    this.messageHandler = messageHandler;
    this.currentClient = currentClient;
    this.addDisposable(clientClient.onClientsUpdated((clients) => this.updateChannels(clients)));
    this.updateChannels(clientClient.getClients());
    this.onWillDispose(() => {
      this.hostChannel.dispose();
      this.state.match({
        MULTIPLAYER: ({ channels }) => {
          for (const clientId in channels) {
            channels[clientId]?.dispose();
          }
        },
        SOLO: () => {
        }
      });
    });
  }
  updateChannels(clients) {
    const clientIdsOfUser = clients.filter((client2) => client2.clientId !== this.currentClient.clientId && client2.username && client2.username === this.currentClient.username).map((client2) => client2.clientId);
    const channels = this.state.match({
      SOLO: () => this.state.set({
        state: "MULTIPLAYER",
        channels: {}
      }).channels,
      MULTIPLAYER: ({ channels: channels2 }) => channels2
    });
    clientIdsOfUser.forEach((clientId) => {
      if (!channels[clientId]) {
        const channel = new Channel(`${this.name}-${clientId}`, this.messageHandler);
        channels[clientId] = channel;
        channel.subscribe();
      }
    });
    for (const clientId in channels) {
      const channel = channels[clientId];
      if (channel && !clientIdsOfUser.includes(clientId)) {
        channel.dispose();
        delete channels[clientId];
      }
    }
  }
  /**
   * Messages from your other clients
   */
  onMessage(cb) {
    return this.hostChannel.onMessage((message) => {
      if (message.isUser) {
        cb(message);
      }
    });
  }
  /**
   * Send to your other clients
   */
  send(message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    this.state.match({
      MULTIPLAYER: ({ channels }) => {
        const channelValues = Object.values(channels);
        channelValues.forEach((channel) => channel.sendAll(message));
      },
      SOLO: () => {
      }
    });
  }
  resync() {
    this.hostChannel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/FollowChannel.js
var import_pitcher_common13 = __toESM(require_dist3());
var import_class_states3 = __toESM(require_dist6());
var FollowChannel = class extends import_pitcher_common13.Disposable {
  constructor(name, messageHandler, currentClient) {
    super();
    this.name = name;
    this.messageHandler = messageHandler;
    this.currentClient = currentClient;
    this.onFollowMessageEmitter = this.addDisposable(new import_pitcher_common13.Emitter());
    this.onFollowMessage = this.onFollowMessageEmitter.event;
    this.onUnfollowMessageEmitter = this.addDisposable(new import_pitcher_common13.Emitter());
    this.onUnfollow = this.onUnfollowMessageEmitter.event;
    this.state = {
      following: new import_class_states3.States({
        state: "NOT_FOLLOWING"
      }),
      followers: new import_class_states3.States({
        state: "NO_FOLLOWERS"
      })
    };
    this.hostChannel = new Channel(`${name}-${currentClient.clientId}`, messageHandler);
    this.hostChannel.subscribe();
    this.onFollowerJoin = this.hostChannel.onSubscribe;
    this.onFollowerLeave = this.hostChannel.onUnsubscribe;
    this.hostChannel.onSubscribe((clientId) => {
      const followingState = this.state.following.get();
      if (followingState.state === "FOLLOWING" && followingState.clientId === clientId) {
        this.unfollow();
      }
      this.state.followers.match({
        FOLLOWERS: ({ clientIds }) => this.state.followers.set({
          state: "FOLLOWERS",
          clientIds: clientIds.concat(clientId)
        }),
        NO_FOLLOWERS: () => this.state.followers.set({
          state: "FOLLOWERS",
          clientIds: [clientId]
        })
      });
    });
    this.hostChannel.onUnsubscribe((clientId) => {
      this.state.followers.match({
        FOLLOWERS: ({ clientIds }) => {
          const updatedFollowers = clientIds.filter((currentClientId) => currentClientId !== clientId);
          if (updatedFollowers.length) {
            this.state.followers.set({
              state: "FOLLOWERS",
              clientIds: updatedFollowers
            });
          } else {
            this.state.followers.set({
              state: "NO_FOLLOWERS"
            });
          }
        },
        NO_FOLLOWERS: () => {
        }
      });
    });
    this.onWillDispose(() => {
      this.hostChannel.dispose();
      this.followChannel?.dispose();
    });
  }
  sendAllFollowers(message) {
    if (this.hostChannel.subscribers.size > 1) {
      return this.hostChannel.sendAll(message);
    }
  }
  sendFollower(clientId, message) {
    if (this.hostChannel.subscribers.has(clientId)) {
      return this.hostChannel.send(/* @__PURE__ */ new Set([clientId]), message);
    }
  }
  // We do not deal with the host leaving and joining, this is something the consuming client
  // can handle by subscribing to the client updates
  follow(clientId) {
    if (clientId === this.currentClient.clientId) {
      return;
    }
    if (this.followChannel) {
      this.followChannel.unsubscribe();
    }
    this.followChannel = new Channel(`${this.name}-${clientId}`, this.messageHandler);
    this.followChannel.subscribe();
    this.followChannel.onMessage((message) => {
      this.onFollowMessageEmitter.fire(message);
    });
    this.state.following.set({
      state: "FOLLOWING",
      clientId
    });
  }
  unfollow() {
    if (this.followChannel) {
      this.followChannel.dispose();
      delete this.followChannel;
      this.onUnfollowMessageEmitter.fire();
      this.state.following.set({
        state: "NOT_FOLLOWING"
      });
    }
  }
  resync() {
    this.followChannel?.resync();
    this.hostChannel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/SharedChannel.js
var import_pitcher_common14 = __toESM(require_dist3());
var SharedChannel = class extends import_pitcher_common14.Disposable {
  constructor(name, messageHandler) {
    super();
    this.channel = new Channel(name, messageHandler);
    this.channel.subscribe();
    this.onWillDispose(() => {
      this.channel.dispose();
    });
  }
  onJoin(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onSubscribe(cb);
  }
  onLeave(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onUnsubscribe(cb);
  }
  sendAll(message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.channel.subscribers.size > 1) {
      return this.channel.sendAll(message);
    }
  }
  send(clientId, message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.channel.subscribers.has(clientId)) {
      this.channel.send(/* @__PURE__ */ new Set([clientId]), message);
    }
  }
  onMessage(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onMessage(cb);
  }
  resync() {
    this.channel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/index.js
var ChannelClient = class {
  constructor({ messageHandler, currentClient, clientClient }) {
    this.channels = {
      raw: {},
      command: {},
      follow: {},
      shared: {}
    };
    this.currentClient = currentClient;
    this.messageHandler = messageHandler;
    this.clientClient = clientClient;
  }
  getChannel(name) {
    return this.channels.raw[name] = this.channels.raw[name] || new Channel(name, this.messageHandler);
  }
  getFollowChannel(name) {
    return this.channels.follow[name] = this.channels.follow[name] || new FollowChannel(name, this.messageHandler, this.currentClient);
  }
  getCommandChannel(name) {
    return this.channels.command[name] = this.channels.command[name] || new CommandChannel({
      name,
      clientClient: this.clientClient,
      currentClient: this.currentClient,
      messageHandler: this.messageHandler
    });
  }
  getSharedChannel(name) {
    return this.channels.shared[name] = this.channels.shared[name] || new SharedChannel(name, this.messageHandler);
  }
  resync() {
    for (const channels of Object.values(this.channels)) {
      for (const channelId in channels) {
        channels[channelId].resync();
      }
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ClientClient.js
var import_pitcher_common16 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/AsyncValueStore.js
var import_pitcher_common15 = __toESM(require_dist3());
var AsyncValueStore = class {
  constructor(initialValue, getValue, opts = {}) {
    this.changeEmitter = new import_pitcher_common15.Emitter();
    this.onChange = this.changeEmitter.event;
    this.errorEmitter = new import_pitcher_common15.Emitter();
    this.onError = this.errorEmitter.event;
    this.value = initialValue;
    this.getValue = getValue;
    if (opts.fetchEagerly) {
      this.get();
    }
  }
  get() {
    if (!this.initialValuePromise) {
      this.initialValuePromise = this.getValue().then((initialValue) => {
        this.value = initialValue;
        this.changeEmitter.fire({
          value: this.value,
          prevValue: this.value
        });
      }).catch((error) => {
        this.errorEmitter.fire(error.message);
      });
    }
    return this.value;
  }
  getInitPromise() {
    return this.initialValuePromise;
  }
  set(newValue) {
    const prevValue = this.value;
    this.value = newValue;
    this.changeEmitter.fire({
      value: this.value,
      prevValue
    });
    return this.value;
  }
  update(cb) {
    const prevValue = this.value;
    this.value = cb(this.value);
    this.changeEmitter.fire({
      value: this.value,
      prevValue
    });
    return this.value;
  }
  refresh() {
    this.getValue().then((value) => this.set(value));
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ClientClient.js
var ClientClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.clientConnectedEmitter = new import_pitcher_common16.Emitter();
    this.onClientConnected = this.clientConnectedEmitter.event;
    this.clientDisconnectedEmitter = new import_pitcher_common16.Emitter();
    this.onClientDisconnected = this.clientDisconnectedEmitter.event;
    this.clientUpdatedEmitter = new import_pitcher_common16.Emitter();
    this.onClientUpdated = this.clientUpdatedEmitter.event;
    this.clientPermissionsEmitter = new import_pitcher_common16.Emitter();
    this.onClientPermissionsUpdated = this.clientPermissionsEmitter.event;
    this.clientsUpdatedEmitter = new import_pitcher_common16.Emitter();
    this.onClientsUpdated = this.clientsUpdatedEmitter.event;
    this.clientsErrorEmitter = new import_pitcher_common16.Emitter();
    this.onClientsError = this.clientsErrorEmitter.event;
    this.clients = this.createClientsValue();
    messageHandler.onNotification("client/connected", (connectedClient) => {
      this.clients.update((existingValue) => {
        const existingClient = existingValue.find((client2) => client2.clientId === connectedClient.clientId);
        if (existingClient) {
          return existingValue.map((client2) => client2.clientId === connectedClient.clientId ? (
            // We might already have the client in the list, in that case we use the new connected client, but
            // we rather use the avatar url from the stale client as this is lazily resolved and we do not want flicker
            { ...connectedClient, avatarUrl: client2.avatarUrl }
          ) : client2);
        }
        return existingValue.concat(connectedClient);
      });
      this.clientConnectedEmitter.fire(connectedClient);
    });
    messageHandler.onNotification("client/disconnected", ({ clientId, reason }) => {
      if (clientId === this.currentClientId) {
        return;
      }
      this.clients.update((existingValue) => existingValue.filter((client2) => client2.clientId !== clientId));
      this.clientDisconnectedEmitter.fire({ clientId, reason });
    });
    messageHandler.onNotification("client/updated", (updatedClient) => {
      this.clients.update((existingValue) => existingValue.map((client2) => client2.clientId === updatedClient.clientId ? updatedClient : client2));
      this.clientUpdatedEmitter.fire(updatedClient);
    });
    messageHandler.onNotification("client/permissions", (updatedPermissions) => {
      this.clientPermissionsEmitter.fire(updatedPermissions);
    });
  }
  createClientsValue() {
    const clients = new AsyncValueStore([], () => this.messageHandler.request({
      method: "client/list",
      params: {}
    }));
    clients.onChange(({ value }) => this.clientsUpdatedEmitter.fire(value));
    clients.onError((error) => this.clientsErrorEmitter.fire(error));
    return clients;
  }
  async join(params) {
    const joinResult = await this.messageHandler.request({
      method: "client/join",
      params
    }, {
      // 1 hour timeout
      timeoutMs: 36e5,
      queueForReconnect: false
    });
    const joinedClient = joinResult.client;
    this.currentClientId = joinResult.client.clientId;
    this.clients.update((existingValue) => {
      const existingClient = existingValue.find((client2) => client2.clientId === joinedClient.clientId);
      if (existingClient) {
        return [{ ...joinedClient, avatarUrl: existingClient.avatarUrl }];
      }
      return [joinedClient];
    });
    return joinResult;
  }
  getClients() {
    return this.clients.get();
  }
  resync() {
    return this.clients.refresh();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/CommandClient.js
var import_pitcher_common17 = __toESM(require_dist3());
var CommandClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.commandsUpdatedEmitter = new import_pitcher_common17.Emitter();
    this.onCommandsUpdated = this.commandsUpdatedEmitter.event;
    this.commandsErrorEmitter = new import_pitcher_common17.Emitter();
    this.onCommandsError = this.commandsErrorEmitter.event;
    this.commands = this.createCommandsValue();
    messageHandler.onNotification("command/changed", ({ commands }) => {
      this.commands.set(commands);
    });
  }
  createCommandsValue() {
    const commands = new AsyncValueStore([], () => this.messageHandler.request({
      method: "command/list",
      params: {}
    }).then(({ commands: commands2 }) => {
      return commands2;
    }));
    commands.onChange(({ value }) => this.commandsUpdatedEmitter.fire(value));
    commands.onError((error) => this.commandsErrorEmitter.fire(error));
    return commands;
  }
  getCommands() {
    return this.commands.get();
  }
  resync() {
    return this.commands.refresh();
  }
  async executeCommand(commandId) {
    await this.messageHandler.request({
      method: "command/execute",
      params: { commandId }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ContainerClient.js
var import_pitcher_common18 = __toESM(require_dist3());
var ContainerClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.openDevToolEmitter = new import_pitcher_common18.Emitter();
    this.onOpenSetupDevTool = this.openDevToolEmitter.event;
    messageHandler.onNotification("container/openSetupDevtool", ({ dependencies }) => {
      this.openDevToolEmitter.fire({ dependencies });
    });
  }
  async runSetupContainer(params) {
    return await this.messageHandler.request({
      method: "container/setup",
      params
    }, { seamlessForkStrategy: "queue" });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FSClient/index.js
var import_path = __toESM(require_path_browserify());
var import_pitcher_common19 = __toESM(require_dist3());
var import_pitcher_protocol3 = __toESM(require_src());
var USER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/project\/home\/[a-zA-Z0-9 -_]+\/workspace/gm);
var DOCKER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/workspace/gm);
var PITCHER_HOST_WORKSPACE_PATH_REGEXP = new RegExp(/^\/project\/.*?\//gm);
var DEVCONTAINER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/workspaces\/.*?\//gm);
var workspacePaths = [
  DEVCONTAINER_WORKSPACE_PATH_REGEXP,
  DOCKER_WORKSPACE_PATH_REGEXP,
  USER_WORKSPACE_PATH_REGEXP,
  PITCHER_HOST_WORKSPACE_PATH_REGEXP
];
function removeWorkspacePath(path) {
  for (const relativeRegex of workspacePaths) {
    if (relativeRegex.test(path)) {
      return path.replace(relativeRegex, "");
    }
  }
  return path;
}
var FSClient = class {
  constructor(workspacePath, userWorkspacePath, messageHandler) {
    this.workspacePath = workspacePath;
    this.userWorkspacePath = userWorkspacePath;
    this.messageHandler = messageHandler;
    this.memoryFS = new MemoryFS();
    this.operationQueue = new import_pitcher_common19.SerialQueue("fs-client");
    this.onFSErrorEmitter = new import_pitcher_common19.Emitter();
    this.onFSError = this.onFSErrorEmitter.event;
    this.onFSSyncEmitter = new import_pitcher_common19.Emitter();
    this.onFSSync = this.onFSSyncEmitter.event;
    this.onPendingOperationsChangeEmitter = new import_pitcher_common19.Emitter();
    this.onPendingOperationsChange = this.onPendingOperationsChangeEmitter.event;
    this.getPathFromId = this.memoryFS.getPathFromId.bind(this.memoryFS);
    this.getIdFromPath = this.memoryFS.getIdFromPath.bind(this.memoryFS);
    messageHandler.onNotification("fs/operations", ({ operations }) => {
      for (const evt of operations) {
        this.memoryFS.receiveNotification(evt);
        const opCount = this.memoryFS.syncFSTree([]);
        this.onFSSyncEmitter.fire({
          opCount
        });
      }
    });
    this.readyPromise = this.readFs();
  }
  /**
   * When you have a path you know is relative, but you want to to ensure the correct format with
   * prefixed "/" and type safety
   */
  asRelativeWorkspacePath(path) {
    return (0, import_path.join)("/", path);
  }
  /**
   * When you know you have an absolute path, but want to ensure it to be this users workspace and have type safety
   */
  asAbsoluteWorkspacePath(path) {
    return (0, import_path.join)(this.workspacePath, removeWorkspacePath(path));
  }
  /**
   * When you have a type safe absolute path and want to make it relative
   */
  absoluteToRelativeWorkspacePath(path) {
    return (0, import_path.join)("/", removeWorkspacePath(path));
  }
  /**
   * When you have a tpe safe relative path and want to make it absolute to this users workspace path
   */
  relativeToAbsoluteWorkspacePath(path) {
    return (0, import_path.join)(this.workspacePath, path);
  }
  // When you are not sure about the path being relative or absolute, but you want a relative representation.
  // NOTE! This does a best guess as there is a risk the path passed is actually relative to the workspace, but
  // contains the path to the workspace itself, meaning it will be removed
  resolveRelativeWorkspacePath(path) {
    return (0, import_path.join)("/", removeWorkspacePath(path));
  }
  // When you are not sure about the path being relative or absolute, but you want an absolute representation for this
  // users workspace path.
  // NOTE! This does a best guess as there is a risk the path passed is actually relative to the workspace, but
  // contains the path to the workspace itself, meaning it will be removed
  resolveAbsoluteWorkspacePath(path) {
    return this.asAbsoluteWorkspacePath(path);
  }
  getPendingOperations() {
    return Array.from(this.memoryFS["pendingOperations"].values());
  }
  readFs() {
    return this.messageHandler.request({
      method: "fs/read",
      params: null
    }).then((result) => {
      return this.memoryFS.populateTreeFromJSON(result);
    });
  }
  async resync() {
    return this.readFs().catch(console.error);
  }
  applyFSOperation(operation) {
    const operationId = this.memoryFS.applyPendingOperation(operation);
    if (operationId === false) {
      return Promise.resolve();
    }
    this.onPendingOperationsChangeEmitter.fire(this.getPendingOperations());
    return this.operationQueue.add(() => {
      return this.messageHandler.request({
        method: "fs/operation",
        params: {
          operation
        }
      }, {
        seamlessForkStrategy: "queue"
      }).then((result) => {
        if (result.code === import_pitcher_protocol3.fs.FSOperationResponseCode.Success) {
          this.memoryFS.receiveNotification({
            clock: result.clock,
            operation
          });
        }
      }).catch((error) => {
        this.onFSErrorEmitter.fire({
          message: error.message
        });
      }).finally(() => {
        const opCount = this.memoryFS.syncFSTree([operationId]);
        this.onFSSyncEmitter.fire({
          opCount
        });
        this.onPendingOperationsChangeEmitter.fire(this.getPendingOperations());
      });
    });
  }
  createParentDirs(parts, parentId) {
    let previousNode = this.memoryFS.tree.getNodeById(parentId);
    if (!previousNode || !previousNode.isDirNode()) {
      throw new Error(previousNode ? `${previousNode.path} is not a directory` : "Parent directory not found");
    }
    for (const part of parts) {
      const foundDirectory = previousNode.children.find((c3) => c3.name === part);
      if (!foundDirectory) {
        const dirId = this.createNewDirectory(part, previousNode.id);
        previousNode = this.memoryFS.tree.getNodeById(dirId);
      } else {
        if (!foundDirectory.isDirNode()) {
          throw new Error(`${foundDirectory.path} already exists but is not a directory`);
        }
        previousNode = foundDirectory;
      }
    }
    return previousNode;
  }
  /**
   * Create a file with the provided name within the directory of the given
   * parent id.
   * */
  async createFile(name, parentId) {
    const parts = name.split("/").filter(Boolean);
    const filename = parts.pop();
    if (!filename) {
      throw new Error("File name is undefined");
    }
    const parentDirNode = this.createParentDirs(parts, parentId);
    const id = (0, import_pitcher_common19.newId)();
    await this.applyFSOperation({
      type: "create",
      parentId: parentDirNode.id,
      newEntry: {
        id,
        type: import_pitcher_common19.bedrockFS.NodeType.File,
        name: filename
      }
      // eslint-disable-next-line
    }).catch(console.error);
    return {
      id,
      filepath: this.getPathFromId(id)
    };
  }
  isFile(id) {
    const node = this.memoryFS.getNodeById(id);
    return node ? node.isFile() : false;
  }
  createNewDirectory(name, parentId) {
    const id = (0, import_pitcher_common19.newId)();
    this.applyFSOperation({
      type: "create",
      parentId,
      newEntry: {
        id,
        type: import_pitcher_common19.bedrockFS.NodeType.Directory,
        name
      }
      // eslint-disable-next-line
    }).catch(console.error);
    return id;
  }
  /**
   * Create a directory with the provided name within the directory of the
   * given parent id.
   * */
  createDirectory(name, parentId) {
    const parts = name.split("/").filter(Boolean);
    if (!parts.length) {
      throw new Error("Directory name is undefined");
    }
    const dirNode = this.createParentDirs(parts, parentId);
    return dirNode.id;
  }
  /**
   * delete a node from the FS
   * */
  deleteNode(id) {
    this.applyFSOperation({
      type: "delete",
      id
      // eslint-disable-next-line
    }).catch(console.error);
  }
  /**
   * rename a node from the FS
   * */
  move(id, opts) {
    const { newName, newParentId } = opts;
    this.applyFSOperation({
      type: "move",
      id,
      parentId: newParentId,
      name: newName
      // eslint-disable-next-line
    }).catch(console.error);
  }
  /**
   * Searches for a string literal within the files of a workspace.
   * Doesn't search the contents of gitignored files.
   */
  async search(params) {
    const result = await this.messageHandler.request({
      method: "fs/search",
      params
    });
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return result.map((result2) => {
      const originalMatches = result2.submatches;
      const newSubmatches = [];
      const lineText = result2.lines.text;
      if (originalMatches.length > 0) {
        const buffer = encoder.encode(lineText);
        for (const submatch of originalMatches) {
          const substring = decoder.decode(buffer.slice(0, submatch.start));
          const actualStart = substring.length;
          const actualEnd = actualStart + submatch.match.text.length;
          newSubmatches.push({
            ...submatch,
            start: actualStart,
            end: actualEnd
          });
        }
      } else {
        newSubmatches.push({
          start: 0,
          end: 1,
          match: { text: lineText[0] ?? "" }
        });
      }
      return { ...result2, submatches: newSubmatches };
    });
  }
  /**
   * Searches for a string literal within the files of a workspace.
   * Doesn't search the contents of gitignored files.
   */
  async streamingSearch(params, onMatches, abort) {
    const searchId = (0, import_pitcher_common19.newId)();
    let promiseResolver;
    let promiseRejector;
    const completionPromise = new Promise((resolve, reject) => {
      promiseResolver = resolve;
      promiseRejector = reject;
    });
    const disposables = [];
    const dispose = () => {
      for (const disposable of disposables) {
        disposable();
      }
    };
    const abortDisposable = abort.onDidDispose(() => {
      dispose();
      promiseResolver({ hitLimit: false });
      this.messageHandler.request({
        method: "fs/cancelStreamingSearch",
        params: {
          searchId
        }
      }).catch((err) => {
        promiseRejector(err);
      });
    });
    disposables.push(() => abortDisposable.dispose());
    const disposeSearchMatchesNotif = this.messageHandler.onNotification("fs/searchMatches", ({ searchId: notificationSearchId, matches }) => {
      if (searchId !== notificationSearchId) {
        return;
      }
      const encoder = new TextEncoder();
      const decoder = new TextDecoder();
      const remappedMatches = matches.map((result) => {
        const originalMatches = result.submatches;
        const newSubmatches = [];
        const lineText = result.lines.text;
        if (originalMatches.length > 0) {
          const buffer = encoder.encode(lineText);
          for (const submatch of originalMatches) {
            const substring = decoder.decode(buffer.slice(0, submatch.start));
            const actualStart = substring.length;
            const actualEnd = actualStart + submatch.match.text.length;
            newSubmatches.push({
              ...submatch,
              start: actualStart,
              end: actualEnd
            });
          }
        } else {
          newSubmatches.push({
            start: 0,
            end: 1,
            match: { text: lineText[0] ?? "" }
          });
        }
        return { ...result, submatches: newSubmatches };
      });
      onMatches(remappedMatches);
    });
    disposables.push(disposeSearchMatchesNotif);
    const disposeSearchCompletionNotif = this.messageHandler.onNotification("fs/searchFinished", ({ searchId: notificationSearchId, hitLimit }) => {
      if (searchId !== notificationSearchId) {
        return;
      }
      promiseResolver({ hitLimit });
    });
    disposables.push(disposeSearchCompletionNotif);
    await this.messageHandler.request({
      method: "fs/streamingSearch",
      params: {
        ...params,
        searchId
      }
    }).catch((err) => {
      dispose();
      promiseRejector(err);
    });
    return completionPromise.finally(() => dispose());
  }
  /**
   * Searches for a filepath within the project
   * Query can be a literal string or a unix-like pattern e.g. *.test.ts
   */
  pathSearch(params) {
    return this.messageHandler.request({
      method: "fs/pathSearch",
      params
    });
  }
  async uploadFile(name, content, parentId) {
    const parts = name.split("/").filter(Boolean);
    const filename = parts.pop();
    if (!filename) {
      throw new Error("File name is undefined");
    }
    const parentDirNode = this.createParentDirs(parts, parentId);
    const result = await this.messageHandler.request({
      method: "fs/upload",
      params: {
        parentId: parentDirNode.id,
        filename,
        content
      }
    }, {
      seamlessForkStrategy: "queue"
    });
    return {
      id: result.fileId,
      filepath: this.getPathFromId(result.fileId)
    };
  }
  async download(path) {
    const result = await this.messageHandler.request({
      method: "fs/download",
      params: {
        path: path || this.workspacePath
      }
    }, {});
    return {
      downloadUrl: result.downloadUrl
    };
  }
  isInWorkspacePath(path) {
    return path.startsWith(this.workspacePath + "/") || path.startsWith(this.userWorkspacePath + "/");
  }
  async readFile(path) {
    return this.handleRawFsResponse("fs/readFile", { path });
  }
  async readdir(path) {
    return this.handleRawFsResponse("fs/readdir", { path });
  }
  async writeFile(path, content, create4 = false, overwrite = false) {
    return this.handleRawFsResponse("fs/writeFile", {
      path,
      content,
      create: create4,
      overwrite
    }, !this.isInWorkspacePath(path));
  }
  async stat(path) {
    return this.handleRawFsResponse("fs/stat", { path });
  }
  async copy(from, to, recursive = false, overwrite = false) {
    return this.handleRawFsResponse("fs/copy", {
      from,
      to,
      recursive,
      overwrite
    }, !this.isInWorkspacePath(from) && !this.isInWorkspacePath(to));
  }
  async rename(from, to, overwrite = false) {
    return this.handleRawFsResponse("fs/rename", { from, to, overwrite }, !this.isInWorkspacePath(from) && !this.isInWorkspacePath(to));
  }
  async remove(path, recursive = false) {
    return this.handleRawFsResponse("fs/remove", { path, recursive }, !this.isInWorkspacePath(path));
  }
  async mkdir(path, recursive = false) {
    return this.handleRawFsResponse("fs/mkdir", { path, recursive }, !this.isInWorkspacePath(path));
  }
  async watch(path, options, onEvent) {
    const response = await this.handleRawFsResponse("fs/watch", {
      path,
      recursive: options.recursive,
      // @ts-expect-error angry about using readonly here
      excludes: options.excludes
    });
    if (response.type === "error") {
      return response;
    }
    const watchId = response.result.watchId;
    this.messageHandler.onNotification("fs/watchEvent", (params) => {
      if (params.watchId === watchId) {
        params.events.forEach(onEvent);
      }
    });
    return {
      type: "success",
      dispose: () => {
        this.handleRawFsResponse("fs/unwatch", { watchId });
      }
    };
  }
  async handleRawFsResponse(method, params, skipSeamlessFork = false) {
    try {
      const isModifyingRawOperation = method === "fs/copy" || method === "fs/mkdir" || method === "fs/writeFile" || method === "fs/remove" || method === "fs/rename";
      const result = await this.messageHandler.request({
        method,
        params
      }, isModifyingRawOperation && !skipSeamlessFork ? {
        seamlessForkStrategy: "queue",
        queueForReconnect: true
      } : {
        queueForReconnect: true
      });
      return { type: "ok", result };
    } catch (e3) {
      const err = e3;
      if ("code" in err) {
        if (err.code === import_pitcher_protocol3.PitcherErrorCode.RAWFS_ERROR) {
          return {
            type: "error",
            error: err.message,
            errno: err.data.errno
          };
        }
        return { type: "error", error: err.message, errno: null };
      }
      if (err instanceof Error) {
        return { type: "error", error: err.message, errno: null };
      }
      return { type: "error", error: "unknown error", errno: null };
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/index.js
var import_pitcher_common22 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/File.js
var import_pitcher_common21 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/Document.js
var import_pitcher_common20 = __toESM(require_dist3());
var import_pitcher_protocol4 = __toESM(require_src());
var Document = class {
  constructor(file, doc, messageHandler) {
    this.onIncomingOperationEmitter = new import_pitcher_common20.Emitter();
    this.onIncomingOperation = this.onIncomingOperationEmitter.event;
    this.onSendOperationEmitter = new import_pitcher_common20.Emitter();
    this.onSendOperation = this.onSendOperationEmitter.event;
    this.onOperationAckEmitter = new import_pitcher_common20.Emitter();
    this.onOperationAck = this.onOperationAckEmitter.event;
    this.onSelectionEmitter = new import_pitcher_common20.Emitter();
    this.onSelection = this.onSelectionEmitter.event;
    this.onErrorEmitter = new import_pitcher_common20.Emitter();
    this.onError = this.onErrorEmitter.event;
    this.onResyncEmitter = new import_pitcher_common20.Emitter();
    this.onResync = this.onResyncEmitter.event;
    this.clientSelections = /* @__PURE__ */ new Map();
    this.syncState = "SYNCED";
    this.file = file;
    this.messageHandler = messageHandler;
    this.clientSelections = new Map(Object.entries(doc.clients).map(([clientId, selection]) => {
      return [clientId, selection];
    }));
    this.file.onWillClientJoin(({ clientId }) => {
      this.clientSelections.set(clientId, null);
    });
    this.file.onWillClientLeave(({ clientId }) => {
      this.clientSelections.delete(clientId);
    });
    this.otClient = this.createOTClient(this.file.content, doc.revision);
    function isResolvedDocumentOperationResult(message) {
      return (0, import_pitcher_protocol4.isResultPayload)(message) && message.method === "file/documentOperation" && message.status === import_pitcher_protocol4.PitcherResponseStatus.RESOLVED;
    }
    messageHandler.onMessage((message) => {
      if (isResolvedDocumentOperationResult(message) && // This is for backwards compatability
      Boolean("id" in message.result ? message.result.id === this.file.id : true)) {
        this.otClient.serverAck();
      }
    });
    messageHandler.onNotification("file/documentOperation", ({ id, operation, revision, reason }) => {
      if (id !== this.file.id || this.syncState === "RESYNCING")
        return;
      try {
        const op = import_pitcher_common20.ot.TextOperation.fromJSON(operation);
        this.otClient.applyServerOperation(op, reason);
      } catch (err) {
        this.syncState = "RESYNCING";
        this.file.resync().catch((err2) => {
          this.onErrorEmitter.fire({
            error: err2.message,
            metadata: {
              type: "ot-resync-error"
            }
          });
        });
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-received-invalid-operation",
            operation: JSON.stringify(operation, null, 2),
            revision
          }
        });
      }
    });
    messageHandler.onNotification("file/documentSelection", ({ id, selections, reason }) => {
      if (id !== this.file.id)
        return;
      Object.entries(selections).forEach(([clientId, selection]) => {
        if (this.clientSelections.has(clientId)) {
          this.clientSelections.set(clientId, selection);
        }
      });
      this.onSelectionEmitter.fire({
        clientSelections: this.clientSelections,
        reason
      });
    });
  }
  createOTClient(content, revision) {
    const otClient = new import_pitcher_common20.ot.Client(content, revision, (revision2, operation) => {
      this.sendDocumentOperation(operation, revision2).catch((err) => {
        if (this.syncState === "RESYNCING" || !(err instanceof PitcherMessageError)) {
          return;
        }
        this.syncState = "RESYNCING";
        this.file.resync().catch((err2) => {
          this.onErrorEmitter.fire({
            error: err2.message,
            metadata: {
              type: "ot-resync-error"
            }
          });
        });
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-send-document-operation",
            operation: JSON.stringify(operation.toJSON(), null, 2),
            code: err.code,
            revision: revision2
          }
        });
      });
    }, async (revision2) => {
      try {
        await this.sendDocumentAck(revision2);
      } catch (err) {
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-send-document-ack",
            revision: revision2
          }
        });
      }
    });
    otClient.onDocumentChange(({ newContent }) => {
      this.file.updateContent(newContent);
    });
    otClient.onIncomingOperation((evt) => {
      this.onIncomingOperationEmitter.fire({
        revision: evt.revision,
        clientSelections: this.clientSelections,
        operation: evt.operation,
        reason: evt.reason
      });
    });
    otClient.onOperationAck(({ revision: revision2 }) => {
      this.onOperationAckEmitter.fire({
        clientSelections: this.clientSelections,
        revision: revision2
      });
    });
    return otClient;
  }
  /**
   * Resync is used when there is an internal issue with the OT Document, which means we can gracefully recover
   * changes made on the server with any pending/queued operations from the client
   */
  resync(content, revision) {
    const didChange = content !== this.file.content;
    this.otClient.syncServerDocument(content, revision);
    this.syncState = "SYNCED";
    this.onResyncEmitter.fire(didChange);
  }
  /**
   * In extreme cases we want to be able to reset the otClient to the server state. We do this when the code editor
   * is not able to apply its operations to the OT Document or it has problems applying server operations to the code editor. There
   * is not good way to recover from this and it should really never happen. But if it does happen we can completely reset the OTClient with
   * the current server document and its revision
   */
  reset(content, revision) {
    this.otClient.dispose();
    this.otClient = this.createOTClient(content, revision);
  }
  sendDocumentAck(revision) {
    return this.messageHandler.request({
      method: "file/documentAck",
      params: {
        id: this.file.id,
        revision
      }
    });
  }
  sendDocumentOperation(operation, revision) {
    this.onSendOperationEmitter.fire({ operation, revision });
    return this.messageHandler.request(
      {
        method: "file/documentOperation",
        params: {
          id: this.file.id,
          operation: operation.toJSON(),
          revision
        }
      },
      // OT Operations should never be queued. When they fail the OT Client will resend them on resync. On seamless
      // fork we just dispose of the message immediately as a resync happens after the fork is done
      {
        seamlessForkStrategy: "dispose",
        queueForReconnect: false
      }
    );
  }
  /**
   * Apply a text operation to the ot-client
   *
   * @param operation the operation to apply
   */
  applyClient(operation) {
    this.otClient.applyClientOperation(operation);
  }
  sendSelection(selection, reason) {
    return this.messageHandler.request(
      {
        method: "file/documentSelection",
        params: {
          id: this.file.id,
          selection,
          reason
        }
      },
      // Selections happens so often and are immutable, so we do not need to queue them
      {
        queueForReconnect: false
      }
    ).then(() => {
      return;
    }).catch(() => {
    });
  }
  dispose() {
    this.onIncomingOperationEmitter.dispose();
    this.onOperationAckEmitter.dispose();
    this.onErrorEmitter.dispose();
    this.onSelectionEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/File.js
var File = class extends import_pitcher_common21.Disposable {
  get isDirty() {
    return this.contentHash !== this.savedHash;
  }
  constructor(path, fileData, messageHandler) {
    super();
    this.onDidSaveEmitter = new import_pitcher_common21.Emitter();
    this.onDidSave = this.onDidSaveEmitter.event;
    this.onDidContentChangeEmitter = new import_pitcher_common21.Emitter();
    this.onDidContentChange = this.onDidContentChangeEmitter.event;
    this.onWillClientJoinEmitter = new import_pitcher_common21.Emitter();
    this.onWillClientJoin = this.onWillClientJoinEmitter.event;
    this.onDidClientJoinEmitter = new import_pitcher_common21.Emitter();
    this.onDidClientJoin = this.onDidClientJoinEmitter.event;
    this.onWillClientLeaveEmitter = new import_pitcher_common21.Emitter();
    this.onWillClientLeave = this.onWillClientLeaveEmitter.event;
    this.onDidClientLeaveEmitter = new import_pitcher_common21.Emitter();
    this.onDidClientLeave = this.onDidClientLeaveEmitter.event;
    this.onDidMoveEmitter = new import_pitcher_common21.Emitter();
    this.onDidMove = this.onDidMoveEmitter.event;
    this.clients = {};
    this.document = null;
    this.path = path;
    this.id = fileData.id;
    this.savedHash = fileData.savedHash;
    this.messageHandler = messageHandler;
    this.content = fileData.content;
    this.isBinary = fileData.isBinary;
    this.clients = fileData.clients;
    this.contentHash = typeof fileData.content === "string" ? (0, import_pitcher_common21.murmur)(fileData.content) : fileData.savedHash;
    if (fileData.document) {
      this.document = new Document(this, fileData.document, messageHandler);
    }
    messageHandler.onNotification("file/save", ({ id, savedHash }) => {
      if (id !== this.id) {
        return;
      }
      this.savedHash = savedHash;
      this.onDidSaveEmitter.fire({
        savedHash
      });
    });
    messageHandler.onNotification("file/join", ({ id, username, clientId }) => {
      if (id !== this.id) {
        return;
      }
      this.onWillClientJoinEmitter.fire({
        clientId,
        username
      });
      this.clients[clientId] = {
        username
      };
      this.onDidClientJoinEmitter.fire({
        clientId,
        username,
        clients: this.clients
      });
    });
    messageHandler.onNotification("file/leave", ({ id, clientId, username }) => {
      if (id !== this.id) {
        return;
      }
      this.onWillClientLeaveEmitter.fire({
        clientId,
        username
      });
      delete this.clients[clientId];
      this.onDidClientLeaveEmitter.fire({
        clientId,
        username,
        clients: this.clients
      });
    });
    this.onWillDispose(() => {
      this.onDidSaveEmitter.dispose();
      this.onDidContentChangeEmitter.dispose();
      this.onWillClientJoinEmitter.dispose();
      this.onDidClientJoinEmitter.dispose();
      this.onWillClientLeaveEmitter.dispose();
      this.onDidClientLeaveEmitter.dispose();
      this.document?.dispose();
    });
  }
  updatePath(newPath) {
    this.path = newPath;
    this.onDidMoveEmitter.fire(newPath);
  }
  async resync() {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // Resync is a result of reconnecting, so we do not queue here
      {
        queueForReconnect: false
      }
    );
    this.savedHash = readResult.savedHash;
    if (readResult.document && typeof readResult.content === "string") {
      this.document.resync(readResult.content, readResult.document.revision);
    }
  }
  /**
   * Will get the current content of the document in Pitcher and reset the otClient to that state.
   * It returns the current contents which should be updated in the code editor
   */
  async resetFromServer() {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // In this context we do not want any queuing as a failed resync would mean we would call this again
      {
        queueForReconnect: false
      }
    );
    if (readResult.document && typeof readResult.content === "string") {
      this.document.reset(readResult.content, readResult.document.revision);
      return readResult.content;
    }
  }
  /**
   * Will get the current content of the document in Pitcher, reset the otClient to that state and
   * apply the current editor contents as a diff operation on top
   */
  async resetFromClient(content) {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // In this context we do not want any queuing as a failed resync would mean we would call this again
      {
        queueForReconnect: false
      }
    );
    if (readResult.document && typeof readResult.content === "string") {
      this.document.reset(readResult.content, readResult.document.revision);
      this.document.otClient.applyClientDocument(content);
    }
  }
  updateContent(newContent) {
    this.content = newContent;
    this.contentHash = (0, import_pitcher_common21.murmur)(newContent);
    this.onDidContentChangeEmitter.fire({
      contentHash: this.contentHash,
      newContent: this.content
    });
  }
  async save(write = true) {
    const hasPendingOperations = () => this.document && (this.document.otClient.hasPendingOperation || this.document?.otClient.hasQueuedOperation);
    while (hasPendingOperations()) {
      await (0, import_pitcher_common21.sleep)(50);
    }
    return this.messageHandler.request({
      method: "file/save",
      params: {
        id: this.id,
        write
      }
    }, {
      seamlessForkStrategy: "queue"
    }).then(() => {
      return;
    });
  }
  /** Do not call this directly, should be called by the wrapping Rc */
  internalClose() {
    this.dispose();
    return this.messageHandler.request({
      method: "file/close",
      params: {
        id: this.id
      }
    }).then(() => {
      return;
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/index.js
var WAIT_TO_CLOSE_FILE_MS = 1e3;
var FileClient = class {
  constructor(messageHandler, fs, workspacePath) {
    this.messageHandler = messageHandler;
    this.fs = fs;
    this.workspacePath = workspacePath;
    this.onFileOpenEmitter = new import_pitcher_common22.Emitter();
    this.onFileOpen = this.onFileOpenEmitter.event;
    this.onFileJoinEmitter = new import_pitcher_common22.Emitter();
    this.onFileJoin = this.onFileJoinEmitter.event;
    this.onFileLeaveEmitter = new import_pitcher_common22.Emitter();
    this.onFileLeave = this.onFileLeaveEmitter.event;
    this.onFileSaveEmitter = new import_pitcher_common22.Emitter();
    this.onFileSave = this.onFileSaveEmitter.event;
    this.onFileMoveEmitter = new import_pitcher_common22.Emitter();
    this.onFileMove = this.onFileMoveEmitter.event;
    this.onFileDeleteEmitter = new import_pitcher_common22.Emitter();
    this.onFileDelete = this.onFileDeleteEmitter.event;
    this.openedPaths = new import_pitcher_common22.BidirectionalMap();
    this.openFiles = /* @__PURE__ */ new Map();
    this.pendingFiles = /* @__PURE__ */ new Map();
    messageHandler.onNotification("file/join", (data) => {
      this.onFileJoinEmitter.fire(data);
    });
    messageHandler.onNotification("file/save", (data) => {
      this.onFileSaveEmitter.fire({
        ...data,
        path: fs.getPathFromId(data.id)
      });
    });
    messageHandler.onNotification("file/leave", (data) => {
      this.onFileLeaveEmitter.fire(data);
    });
    fs.onFSSync(() => {
      for (const fileRc of this.openFiles.values()) {
        const file = fileRc.object;
        const fileId = file.id;
        if (this.openedPaths.getKey(fileId)) {
          continue;
        }
        const foundPath = fs.getPathFromId(fileId);
        if (!foundPath) {
          this.onFileDeleteEmitter.fire({
            id: fileId,
            path: file.path
          });
        } else if (file.path !== foundPath) {
          this.onFileMoveEmitter.fire({
            id: fileId,
            newPath: foundPath,
            oldPath: file.path
          });
          file.updatePath(foundPath);
        }
      }
    });
  }
  hasDirtyFiles() {
    for (const [, openFile] of this.openFiles) {
      if (openFile.object.isDirty) {
        return true;
      }
    }
    return false;
  }
  registerFile(path, result) {
    const id = result.id;
    const foundFile = this.openFiles.get(id);
    if (foundFile) {
      return foundFile;
    }
    const f3 = new File(path, result, this.messageHandler);
    const file = new Rc(f3, () => {
      this.openFiles.delete(fileId);
      this.openedPaths.deleteByValue(fileId);
      this.pendingFiles.set(f3.path, {
        state: "AWAITING_CLOSE",
        promise: (0, import_pitcher_common22.sleep)(WAIT_TO_CLOSE_FILE_MS).then(() => {
          if (this.pendingFiles.get(f3.path)?.state === "AWAITING_CLOSE")
            this.pendingFiles.set(f3.path, {
              state: "CLOSING",
              promise: f3["internalClose"]().finally(() => {
                this.pendingFiles.delete(f3.path);
              })
            });
        })
      });
    });
    const fileId = file.object.id;
    this.openFiles.set(fileId, file);
    this.onFileOpenEmitter.fire(file.object);
    return file;
  }
  getFileIdFromPath(filepath) {
    const fileId = this.fs.getIdFromPath(filepath);
    if (!fileId || !this.fs.isFile(fileId)) {
      return this.openedPaths.getValue(filepath);
    }
    return fileId;
  }
  getPathFromFileId(fileId) {
    return this.openedPaths.getKey(fileId) ?? this.fs.getPathFromId(fileId);
  }
  getOpenedFile(fileId) {
    const openFile = this.openFiles.get(fileId);
    if (openFile) {
      return openFile.object;
    }
  }
  getOpenFiles() {
    return Array.from(this.openFiles.values());
  }
  async openFile(fileId) {
    const openFile = this.openFiles.get(fileId);
    if (openFile) {
      return Promise.resolve(openFile.acquire());
    }
    const filePath = this.getPathFromFileId(fileId);
    const existingPendingFile = this.pendingFiles.get(filePath);
    let pendingFilePromise;
    if (existingPendingFile?.state === "CLOSING") {
      await existingPendingFile.promise;
    }
    if (existingPendingFile?.state === "OPENING") {
      pendingFilePromise = existingPendingFile.promise;
    } else {
      pendingFilePromise = this.messageHandler.request({
        method: "file/open",
        params: {
          id: fileId
        }
      }).then((result) => this.registerFile(this.getPathFromFileId(result.id), result)).finally(() => {
        this.pendingFiles.delete(filePath);
      });
      this.pendingFiles.set(filePath, {
        state: "OPENING",
        promise: pendingFilePromise
      });
    }
    return pendingFilePromise.then((rcFile) => rcFile.acquire());
  }
  async openFileByPath(filepath) {
    const fileId = this.getFileIdFromPath(filepath);
    if (fileId) {
      return this.openFile(fileId);
    }
    const existingPendingFile = this.pendingFiles.get(filepath);
    let pendingFilePromise;
    if (existingPendingFile?.state === "CLOSING") {
      await existingPendingFile.promise;
    }
    if (existingPendingFile?.state === "OPENING") {
      pendingFilePromise = existingPendingFile.promise;
    } else {
      pendingFilePromise = this.messageHandler.request({
        method: "file/openByPath",
        params: {
          path: filepath
        }
      }).then((result) => {
        this.openedPaths.set(filepath, result.id);
        return this.registerFile(filepath, result);
      }).finally(() => {
        this.pendingFiles.delete(filepath);
      });
      this.pendingFiles.set(filepath, {
        state: "OPENING",
        promise: pendingFilePromise
      });
    }
    return pendingFilePromise.then((f3) => f3.acquire());
  }
  createDocumentOperationFromDiff(originalText, modifiedText) {
    return import_pitcher_common22.ot.createDiffTextOperation(originalText, modifiedText);
  }
  async resync() {
    await Promise.all(Array.from(this.openFiles.values()).map((f3) => f3.object.resync()));
  }
  getIdFromWorkspaceUriString(uriString) {
    const absolutePath = this.fs.asAbsoluteWorkspacePath(uriString.replace(/^.*:\/\//, ""));
    return this.getFileIdFromPath(this.fs.absoluteToRelativeWorkspacePath(absolutePath));
  }
  dispose() {
    this.onFileJoinEmitter.dispose();
    this.onFileLeaveEmitter.dispose();
    this.onFileSaveEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/GitClient.js
var import_pitcher_common23 = __toESM(require_dist3());
var GitClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.statusUpdatedEmitter = new import_pitcher_common23.Emitter();
    this.onStatusUpdated = this.statusUpdatedEmitter.event;
    this.checkoutPreventedEmitter = new import_pitcher_common23.Emitter();
    this.onCheckoutPrevented = this.checkoutPreventedEmitter.event;
    this.remotesUpdatedEmitter = new import_pitcher_common23.Emitter();
    this.onRemotesUpdated = this.remotesUpdatedEmitter.event;
    this.remotesErrorEmitter = new import_pitcher_common23.Emitter();
    this.onRemotesError = this.remotesErrorEmitter.event;
    this.pullStartedEmitter = new import_pitcher_common23.Emitter();
    this.onPullStarted = this.pullStartedEmitter.event;
    this.pullFinishedEmitter = new import_pitcher_common23.Emitter();
    this.onPullFinished = this.pullFinishedEmitter.event;
    this.commitStartedEmitter = new import_pitcher_common23.Emitter();
    this.onCommitStarted = this.commitStartedEmitter.event;
    this.commitFinishedEmitter = new import_pitcher_common23.Emitter();
    this.onCommitFinished = this.commitFinishedEmitter.event;
    this.branchRenamedEmitter = new import_pitcher_common23.Emitter();
    this.onBranchRenamed = this.branchRenamedEmitter.event;
    messageHandler.onNotification("git/status", (gitStatus) => {
      this.cachedGitStatus = gitStatus;
      this.statusUpdatedEmitter.fire(gitStatus);
    });
    this.remotes = this.createRemotesValue();
    messageHandler.onNotification("git/checkoutPrevented", ({ branch }) => {
      this.checkoutPreventedEmitter.fire(branch);
    });
    messageHandler.onNotification("git/pullStarted", () => {
      this.pullStartedEmitter.fire();
    });
    messageHandler.onNotification("git/remotes", (remotes) => {
      this.remotes.set(remotes);
    });
    messageHandler.onNotification("git/pullFinished", () => {
      this.pullFinishedEmitter.fire();
    });
    messageHandler.onNotification("git/commitStarted", (notification) => {
      this.commitStartedEmitter.fire(notification);
    });
    messageHandler.onNotification("git/commitFinished", (notification) => {
      this.commitFinishedEmitter.fire(notification);
    });
    messageHandler.onNotification("git/renameBranch", (msg) => {
      this.branchRenamedEmitter.fire(msg);
    });
  }
  createRemotesValue() {
    const remotes = new AsyncValueStore(
      // TODO: Empty value, the initial state will be fetched later
      { origin: "", upstream: "" },
      () => this.messageHandler.request({
        method: "git/remotes",
        params: {}
      })
    );
    remotes.onChange(({ value }) => this.remotesUpdatedEmitter.fire(value));
    remotes.onError((error) => this.remotesErrorEmitter.fire(error));
    remotes.get();
    return remotes;
  }
  pushToRemote(url, branch, squashAllCommits = false) {
    return this.messageHandler.request({
      method: "git/pushToRemote",
      params: {
        url,
        branch,
        squashAllCommits
      }
    });
  }
  resetLocalWithRemote() {
    return this.messageHandler.request({
      method: "git/resetLocalWithRemote",
      params: {}
    });
  }
  getStatus() {
    if (this.cachedGitStatus) {
      return Promise.resolve(this.cachedGitStatus);
    }
    return this.messageHandler.request({
      method: "git/status",
      params: {}
    }).then((gitStatus) => {
      this.cachedGitStatus = gitStatus;
      return gitStatus;
    });
  }
  getRemotes() {
    return this.remotes.get();
  }
  getTargetDiffStatus(baseBranch) {
    return this.messageHandler.request({
      method: "git/diffStatus",
      params: {
        base: `origin/${baseBranch}`,
        head: "HEAD"
      }
    });
  }
  resync() {
    delete this.cachedGitStatus;
    this.remotes.refresh();
    return this.getStatus().then((updatedStatus) => {
      this.statusUpdatedEmitter.fire(updatedStatus);
    });
  }
  compare(branch) {
    return this.messageHandler.request({
      method: "git/targetDiff",
      params: {
        branch
      }
    });
  }
  pull(branch, force) {
    return this.messageHandler.request({
      method: "git/pull",
      params: {
        branch,
        force
      }
    });
  }
  commit(message, paths, push = true) {
    return this.messageHandler.request({
      method: "git/commit",
      params: {
        message,
        paths,
        push
      }
    });
  }
  push() {
    return this.messageHandler.request({ method: "git/push", params: null });
  }
  discard(paths) {
    return this.messageHandler.request({
      method: "git/discard",
      params: {
        paths
      }
    }).then(({ paths: paths2 }) => paths2);
  }
  renameBranch(oldBranch, newBranch) {
    return this.messageHandler.request({
      method: "git/renameBranch",
      params: {
        oldBranch,
        newBranch
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  remoteContent({ reference, filepath }) {
    return this.messageHandler.request({
      method: "git/remoteContent",
      params: {
        reference,
        path: filepath
      }
    });
  }
  checkoutInitialBranch() {
    return this.messageHandler.request({
      method: "git/checkoutInitialBranch",
      params: {}
    });
  }
  transposeLines(lines) {
    return this.messageHandler.request({
      // eslint-disable-next-line
      // @ts-ignore
      method: "git/transposeLines",
      params: lines
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/LanguageClient.js
var import_pitcher_common24 = __toESM(require_dist3());
var import_debug2 = __toESM(require_browser2());
var debug2 = (0, import_debug2.default)("pitcher:language-client");
var LanguageClient = class {
  constructor(messageHandler, fileClient) {
    this.messageHandler = messageHandler;
    this.fileClient = fileClient;
    this.globCache = new import_pitcher_common24.GlobCache();
    this.initializeMessages = {};
    this.lspNotificationEmitter = new import_pitcher_common24.Emitter();
    this.onLspNotification = this.lspNotificationEmitter.event;
    this.lspServerRequestEmitter = new import_pitcher_common24.Emitter();
    this.onLspServerRequest = this.lspServerRequestEmitter.event;
    this.languagesUpdatedEmitter = new import_pitcher_common24.Emitter();
    this.onLanguagesUpdated = this.languagesUpdatedEmitter.event;
    this.languagesErrorEmitter = new import_pitcher_common24.Emitter();
    this.onLanguagesError = this.languagesErrorEmitter.event;
    this.languages = this.createLanguagesValue();
    messageHandler.onNotification("language/lspNotification", (msg) => {
      this.lspNotificationEmitter.fire(msg);
    });
    messageHandler.onNotification("language/lspServerRequest", (msg) => {
      this.lspServerRequestEmitter.fire(msg);
    });
  }
  createLanguagesValue() {
    const languages = new AsyncValueStore([], () => this.messageHandler.request({
      method: "language/list",
      params: {}
    }).then(({ languages: languages2 }) => languages2));
    languages.onChange(({ value }) => {
      this.globCache.clear();
      this.languagesUpdatedEmitter.fire(value);
    });
    languages.onError((error) => this.languagesErrorEmitter.fire(error));
    return languages;
  }
  getLanguages() {
    return this.languages.get();
  }
  resync() {
    this.languages.refresh();
    for (const serverId in this.initializeMessages) {
      this.sendLSPRequest(this.initializeMessages[serverId]);
    }
  }
  // eslint-disable-next-line
  async sendLSPRequest(params) {
    const now = Date.now();
    const file = this.getLSPRelatedFile(params.message);
    if (params.message.method === "initialize") {
      this.initializeMessages[params.languageId] = params;
    }
    if (file?.document?.otClient.hasQueuedOperation) {
      const barrier = new import_pitcher_common24.Barrier();
      const disposable = file.document.onSendOperation(() => {
        if (!file?.document?.otClient.hasQueuedOperation) {
          disposable.dispose();
          barrier.open();
        }
      });
      await barrier.wait();
    }
    try {
      const result = await this.messageHandler.request({
        method: "language/lspRequest",
        params
      }, {
        queueForReconnect: params.message.method === "initialize",
        // We use a less aggressive timeout as LSPs can sometimes take very long to respond, and sometimes
        // we even need to wait for the container to be built before we get a response.
        timeoutMs: 10 * 60 * 1e3,
        seamlessForkStrategy: params.message.method === "textDocument/formatting" ? "queue" : "queueDuringFork"
      });
      debug2('LSP request "%s" took %dms', params.message.method, Date.now() - now);
      return {
        type: "ok",
        // @ts-expect-error unknown to any
        result
      };
    } catch (e3) {
      return { type: "error", error: e3 };
    }
  }
  sendLSPServerResponse(params) {
    return new Promise((resolve, reject) => {
      this.messageHandler.request({
        method: "language/lspServerResponse",
        params
      }).then(resolve).catch(reject);
    });
  }
  getLanguageId(filepath) {
    for (const language of this.languages.get()) {
      for (const pattern of language.globs) {
        const regex = this.globCache.get(pattern);
        if (filepath.match(regex)) {
          return language.id;
        }
      }
    }
    return "text";
  }
  isLSPDocumentMessage(message) {
    return Boolean(message.params && message.params.textDocument);
  }
  getLSPRelatedFile(message) {
    if (!this.isLSPDocumentMessage(message)) {
      return;
    }
    const id = this.fileClient.getIdFromWorkspaceUriString(message.params.textDocument.uri);
    if (!id) {
      return;
    }
    const file = this.fileClient.getOpenedFile(id);
    if (!file) {
      return;
    }
    return file;
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/NotificationClient.js
var import_pitcher_common25 = __toESM(require_dist3());
var NotificationClient = class extends import_pitcher_common25.Disposable {
  constructor(messageHandler) {
    super();
    this.onNotificationEmitter = new import_pitcher_common25.Emitter();
    this.onNotification = this.onNotificationEmitter.event;
    this.notifications = {};
    this.onDismissNotificationEmitter = new import_pitcher_common25.Emitter();
    this.onDismissNotification = this.onDismissNotificationEmitter.event;
    this.addDisposable(messageHandler.onMessage((message) => {
      if (message.method === "notification/notify") {
        const notification = new Notification(message.params);
        this.notifications[notification.id] = notification;
        this.addDisposable(notification.onNotificationResponse((response) => {
          delete this.notifications[notification.id];
          messageHandler.request({
            method: "notification/notifyResponse",
            params: {
              notificationId: notification.id,
              response
            }
          });
        }));
        this.onNotificationEmitter.fire(notification);
      } else if (message.method === "notification/dismiss") {
        const notification = this.notifications[message.params.notificationId];
        if (notification) {
          notification.dismiss();
          delete this.notifications[notification.id];
          this.onDismissNotificationEmitter.fire(message.params);
        }
      }
    }));
  }
};
var Notification = class extends import_pitcher_common25.Disposable {
  constructor(notification) {
    super();
    this.onNotificationResponseEmitter = this.addDisposable(new import_pitcher_common25.Emitter());
    this.onNotificationResponse = this.onNotificationResponseEmitter.event;
    this.onNotificationDismissEmitter = this.addDisposable(new import_pitcher_common25.Emitter());
    this.onNotificationDismiss = this.onNotificationDismissEmitter.event;
    this.id = notification.notificationId;
    this.type = notification.type;
    this.message = notification.message;
    this.actions = notification.actions;
  }
  /**
   * Called when Pitcher wants to dismiss the notification, this should not be used
   * by clients that implement the pitcher-client. To listen to dismiss events, use
   * the `onNotificationDismiss` event instead.
   */
  dismiss() {
    this.onNotificationDismissEmitter.fire();
  }
  respond(label) {
    this.onNotificationResponseEmitter.fire(label);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/PortClient.js
var import_pitcher_common26 = __toESM(require_dist3());
var PortClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.portsUpdatedEmitter = new import_pitcher_common26.Emitter();
    this.onPortsUpdated = this.portsUpdatedEmitter.event;
    this.portsErrorEmitter = new import_pitcher_common26.Emitter();
    this.onPortsError = this.portsErrorEmitter.event;
    this.ports = this.createPortsValue();
    this.readyPromise = this.ports.getInitPromise();
    messageHandler.onNotification("port/changed", ({ list }) => {
      this.ports.set(list);
    });
  }
  createPortsValue() {
    const ports = new AsyncValueStore([], () => this.messageHandler.request({
      method: "port/list",
      params: {}
    }).then(({ list }) => list), { fetchEagerly: true });
    ports.onChange(({ value }) => this.portsUpdatedEmitter.fire(value));
    ports.onError((error) => this.portsErrorEmitter.fire(error));
    return ports;
  }
  getPorts() {
    return this.ports.get();
  }
  resync() {
    return this.ports.refresh();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/SetupClient.js
var import_pitcher_common27 = __toESM(require_dist3());
var SetupClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.setupProgressUpdateEmitter = new import_pitcher_common27.Emitter();
    this.onSetupProgressUpdate = this.setupProgressUpdateEmitter.event;
    this.setupProgressErrorEmitter = new import_pitcher_common27.Emitter();
    this.onSetupProgressError = this.setupProgressErrorEmitter.event;
    this.setupProgress = this.createSetupProgressValue();
    this.readyPromise = this.setupProgress.getInitPromise();
    messageHandler.onNotification("setup/progress", (progress) => (
      // This will emit the progress event
      this.setupProgress.set(progress)
    ));
  }
  createSetupProgressValue() {
    const setupProgress = new AsyncValueStore({
      state: "IDLE",
      currentStepIndex: 0,
      steps: []
    }, () => this.messageHandler.request({
      method: "setup/get",
      params: {}
    }), { fetchEagerly: true });
    setupProgress.onChange(({ value }) => this.setupProgressUpdateEmitter.fire(value));
    setupProgress.onError((error) => this.setupProgressErrorEmitter.fire(error));
    return setupProgress;
  }
  getProgress() {
    return this.setupProgress.get();
  }
  resync() {
    return this.setupProgress.refresh();
  }
  /**
   * Skip the currently running step. We expect you to send the current step as a verification for Pitcher
   * to know whether you'd like to skip the current step.
   */
  skipStep(stepIndexToSkip) {
    return this.messageHandler.request({
      method: "setup/skip",
      params: {
        stepIndexToSkip
      }
    });
  }
  /**
   * Skip the entire remaining progress. Current step is finished as SKIPPED, rest of the steps are ignored
   */
  skipAll() {
    return this.messageHandler.request({
      method: "setup/skipAll",
      params: null
    });
  }
  /**
   * Sets the current step, allows you to go back in time again
   */
  setStep(stepIndex) {
    return this.messageHandler.request({
      method: "setup/setStep",
      params: {
        stepIndex
      }
    });
  }
  disable() {
    this.messageHandler.request({
      method: "setup/disable",
      params: null
    });
  }
  enable() {
    this.messageHandler.request({
      method: "setup/enable",
      params: null
    });
  }
  init() {
    return this.messageHandler.request({
      method: "setup/init",
      params: null
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ShellClient.js
var import_pitcher_common28 = __toESM(require_dist3());
var ShellClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.openShells = /* @__PURE__ */ new Map();
    this.shellCreatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellCreated = this.shellCreatedEmitter.event;
    this.shellRestartedEmitter = new import_pitcher_common28.Emitter();
    this.onShellRestarted = this.shellRestartedEmitter.event;
    this.shellTerminatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellTerminated = this.shellTerminatedEmitter.event;
    this.shellNameChangeEmitter = new import_pitcher_common28.Emitter();
    this.onShellNameChange = this.shellNameChangeEmitter.event;
    this.shellExitedEmitter = new import_pitcher_common28.Emitter();
    this.onShellExited = this.shellExitedEmitter.event;
    this.shellsUpdatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellsUpdated = this.shellsUpdatedEmitter.event;
    this.shellsErrorEmitter = new import_pitcher_common28.Emitter();
    this.onShellsError = this.shellsErrorEmitter.event;
    this.shellOutEmitter = new import_pitcher_common28.Emitter();
    this.onShellOut = this.shellOutEmitter.event;
    this.shells = this.createShellsValue();
    this.readyPromise = this.shells.getInitPromise();
    messageHandler.onNotification("shell/terminate", ({ shellId, author }) => {
      this.shellTerminatedEmitter.fire({ shellId, author });
      this.deleteShell(shellId);
    });
    messageHandler.onNotification("shell/exit", ({ shellId, shellType, exitCode }) => {
      this.shellExitedEmitter.fire({ shellId, exitCode });
      if (shellType === "TERMINAL") {
        this.deleteShell(shellId);
      }
    });
    messageHandler.onNotification("shell/create", (shell) => {
      this.shellCreatedEmitter.fire(shell);
      this.shells.update((shells) => shells.concat(shell));
    });
    messageHandler.onNotification("shell/restart", ({ shellId }) => this.shellRestartedEmitter.fire({ shellId }));
    messageHandler.onNotification("shell/out", (params) => this.shellOutEmitter.fire(params));
    messageHandler.onNotification("shell/rename", ({ shell }) => {
      this.shells.update((shells) => [
        ...shells.filter((item) => item.shellId !== shell.shellId),
        shell
      ]);
      this.shellNameChangeEmitter.fire({ shellId: shell.shellId });
    });
  }
  createShellsValue() {
    const shells = new AsyncValueStore([], () => this.messageHandler.request({
      method: "shell/list",
      params: {}
    }).then(({ shells: shells2 }) => shells2), { fetchEagerly: true });
    shells.onChange(({ value }) => this.shellsUpdatedEmitter.fire(value));
    shells.onError((error) => this.shellsErrorEmitter.fire(error));
    return shells;
  }
  closeShell(shellId) {
    this.openShells.delete(shellId);
  }
  deleteShell(shellId) {
    this.shells.update((shells) => shells.filter((shell) => shell.shellId !== shellId));
    this.closeShell(shellId);
  }
  getShells() {
    return this.shells.get();
  }
  getShellName(id) {
    const name = this.shells.get().find((shell) => shell.shellId === id)?.name || null;
    return name;
  }
  resync() {
    this.shells.refresh();
    Array.from(this.openShells.entries()).forEach(([shellId, shellSize]) => this.open(shellId, shellSize).catch(() => {
      this.shellTerminatedEmitter.fire({
        shellId,
        author: "connection loss"
      });
    }));
  }
  create(projectPath, size, command, type, isSystemShell) {
    return this.messageHandler.request({
      method: "shell/create",
      params: {
        projectPath,
        command,
        size,
        type,
        isSystemShell
      }
    }).then((response) => {
      this.openShells.set(response.shellId, size);
      return response;
    });
  }
  open(shellId, size) {
    return this.messageHandler.request({
      method: "shell/open",
      params: {
        shellId,
        size
      }
    }).then((response) => {
      this.openShells.set(response.shellId, size);
      return response;
    });
  }
  close(shellId) {
    return this.messageHandler.request({
      method: "shell/close",
      params: {
        shellId
      }
    }).then((response) => {
      this.closeShell(shellId);
      return response;
    });
  }
  restart(shellId) {
    return this.messageHandler.request({
      method: "shell/restart",
      params: {
        shellId
      }
    });
  }
  delete(shellId) {
    return this.messageHandler.request({
      method: "shell/terminate",
      params: {
        shellId
      }
    }).then((response) => {
      this.deleteShell(shellId);
      return response;
    });
  }
  send(shellId, input, size) {
    return this.messageHandler.request({
      method: "shell/in",
      params: {
        shellId,
        input,
        size
      }
    });
  }
  resize(shellId, size) {
    return this.messageHandler.request({
      method: "shell/resize",
      params: {
        shellId,
        size
      }
    }, {
      // This is immutable and can be triggered very often
      queueForReconnect: false
    }).then((response) => {
      this.openShells.set(shellId, size);
      return response;
    });
  }
  rename(shellId, name) {
    return this.messageHandler.request({
      method: "shell/rename",
      params: {
        shellId,
        name
      }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/SystemClient.js
var import_pitcher_common29 = __toESM(require_dist3());
var SystemClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.hibernateEmitter = new import_pitcher_common29.Emitter();
    this.onHibernate = this.hibernateEmitter.event;
    this.metricsEmitter = new import_pitcher_common29.Emitter();
    this.onMetricsUpdated = this.metricsEmitter.event;
    this.initStatusEmitter = new import_pitcher_common29.Emitter();
    this.onInitStatusUpdate = this.initStatusEmitter.event;
    this.metrics = this.createMetricsValue();
    messageHandler.onNotification("system/hibernate", () => {
      this.hibernateEmitter.fire({});
    });
    messageHandler.onNotification("system/metrics", (metrics) => {
      this.metrics.set(metrics);
    });
    messageHandler.onNotification("system/initStatus", (statusUpdate) => {
      this.initStatusEmitter.fire(statusUpdate);
    });
  }
  createMetricsValue() {
    const metrics = new AsyncValueStore(void 0, () => this.messageHandler.request({
      method: "system/metrics",
      params: {}
    }).then((metrics2) => metrics2));
    metrics.onChange(({ value }) => this.metricsEmitter.fire(value));
    return metrics;
  }
  getMetrics() {
    return this.metrics.get();
  }
  startMetricsPollingAtInterval(interval = 5e3) {
    const update2 = () => {
      this.messageHandler.request({
        method: "system/metrics",
        params: {}
      }, {
        // As this is an immutable request and it happens quite often we do not queue them
        queueForReconnect: false
      }).then((m3) => this.metrics.set(m3)).catch(() => {
      });
    };
    update2();
    const intervalRef = setInterval(update2, interval);
    return () => {
      clearInterval(intervalRef);
    };
  }
  resync() {
    return;
  }
  update() {
    return this.messageHandler.request({
      method: "system/update",
      params: {}
    });
  }
  hibernate() {
    return this.messageHandler.request({
      method: "system/hibernate",
      params: {}
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/TaskClient.js
var import_pitcher_common30 = __toESM(require_dist3());
var TaskClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.taskListUpdateEmitter = new import_pitcher_common30.Emitter();
    this.onTaskListUpdate = this.taskListUpdateEmitter.event;
    this.taskUpdateEmitter = new import_pitcher_common30.Emitter();
    this.onTaskUpdate = this.taskUpdateEmitter.event;
    this.taskPortOpenedEmitter = new import_pitcher_common30.Emitter();
    this.onTaskPortOpened = this.taskPortOpenedEmitter.event;
    this.taskStartedEmitter = new import_pitcher_common30.Emitter();
    this.onTaskStarted = this.taskStartedEmitter.event;
    this.unassignedPortOpenedEmitter = new import_pitcher_common30.Emitter();
    this.onUnassignedPortOpened = this.unassignedPortOpenedEmitter.event;
    this.unassignedPortClosedEmitter = new import_pitcher_common30.Emitter();
    this.onUnassignedPortClosed = this.unassignedPortClosedEmitter.event;
    this.configParseErrorEmitter = new import_pitcher_common30.Emitter();
    this.onConfigParseError = this.configParseErrorEmitter.event;
    this.tasksValue = this.createTasksValue();
    this.readyPromise = this.tasksValue.getInitPromise();
    messageHandler.onNotification("task/listUpdate", (value) => {
      this.tasksValue.set(value);
    });
    messageHandler.onNotification("task/update", (task) => {
      const taskId = task.id;
      const oldTask = this.tasksValue.get().tasks[taskId];
      this.tasksValue.update((crtValue) => ({
        ...crtValue,
        tasks: {
          ...crtValue.tasks,
          [taskId]: task
        }
      }));
      this.taskUpdateEmitter.fire(task);
      if (oldTask?.shell?.status !== "RUNNING" && task.shell?.status === "RUNNING") {
        this.taskStartedEmitter.fire({ taskId });
      }
      if (oldTask) {
        task.ports.forEach((p2) => {
          const portIsNew = !oldTask.ports.some((tp) => tp.port === p2.port);
          if (portIsNew) {
            this.taskPortOpenedEmitter.fire({ taskId, port: p2 });
          }
        });
      }
    });
    messageHandler.onNotification("shell/exit", ({ shellId, exitCode }) => {
      const tasks = this.tasksValue.get().tasks;
      const taskToUpdate = Object.values(tasks).find((t3) => t3.shell?.shellId === shellId);
      if (!taskToUpdate || taskToUpdate.shell === null) {
        return;
      }
      const updatedTask = {
        ...taskToUpdate,
        shell: {
          ...taskToUpdate.shell,
          status: exitCode > 0 ? "ERROR" : "FINISHED",
          exitCode
        }
      };
      this.tasksValue.update((crtValue) => ({
        ...crtValue,
        tasks: {
          ...crtValue.tasks,
          [updatedTask.id]: updatedTask
        }
      }));
      this.taskUpdateEmitter.fire(updatedTask);
    });
    messageHandler.onNotification("task/unassignedPortOpened", (value) => {
      this.unassignedPortOpenedEmitter.fire(value);
    });
    messageHandler.onNotification("task/unassignedPortClosed", (value) => {
      this.unassignedPortClosedEmitter.fire(value);
    });
    messageHandler.onNotification("task/configParseError", ({ error }) => {
      this.configParseErrorEmitter.fire(error);
    });
  }
  createTasksValue() {
    const value = new AsyncValueStore({
      tasks: {},
      setupTasks: [],
      validationErrors: []
    }, () => this.messageHandler.request({
      method: "task/list",
      params: {}
    }).then((value2) => {
      return value2;
    }), { fetchEagerly: true });
    value.onChange(({ value: value2 }) => {
      this.taskListUpdateEmitter.fire(value2);
    });
    return value;
  }
  getTasks() {
    return this.tasksValue.get();
  }
  getTask(taskId) {
    const tasks = this.tasksValue.get().tasks;
    return tasks[taskId];
  }
  resync() {
    return this.tasksValue.refresh();
  }
  runTask(taskId) {
    const task = this.tasksValue.get().tasks[taskId];
    if (task && task.shell?.status === "KILLED") {
      task.shell = null;
    }
    return this.messageHandler.request({
      method: "task/run",
      params: {
        taskId
      }
    }, {
      queueForReconnect: true
    });
  }
  runCommand(command, saveToConfig, name) {
    return this.messageHandler.request({
      method: "task/runCommand",
      params: {
        command,
        name,
        saveToConfig
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  stopTask(taskId) {
    return this.messageHandler.request({
      method: "task/stop",
      params: {
        taskId
      }
    }, {
      queueForReconnect: true
    });
  }
  updateTask(taskId, taskFields) {
    return this.messageHandler.request({
      method: "task/update",
      params: {
        taskId,
        taskFields
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  async createTask(taskFields, startTask = false) {
    const tasks = await this.messageHandler.request({
      method: "task/create",
      params: {
        taskFields,
        startTask
      }
    }, {
      seamlessForkStrategy: "queue"
    });
    this.tasksValue.set(tasks);
    const tasksObject = this.tasksValue.get().tasks;
    const createdTask = Object.values(tasksObject).find((task) => task.command === taskFields.command);
    if (!createdTask) {
      throw new Error(`Cannot find the task running '${taskFields.command}'`);
    }
    return createdTask;
  }
  saveToConfig(taskId) {
    return this.messageHandler.request({
      method: "task/saveToConfig",
      params: {
        taskId
      }
    });
  }
  generateConfigFile() {
    return new Promise((resolve, reject) => {
      const unsubscribe3 = this.messageHandler.onNotification("fs/operations", ({ operations }) => {
        const createOperation = operations.map((ev) => ev.operation).find((op) => op.type === "create" && op.newEntry.name === "tasks.json");
        if (!createOperation || createOperation.type !== "create") {
          return;
        }
        const fileId = createOperation.newEntry.id;
        resolve(fileId);
        unsubscribe3();
      });
      setTimeout(() => {
        reject(new Error("Config file was not generated"));
        unsubscribe3();
      }, 5e3);
      this.messageHandler.request({
        method: "task/generateConfig",
        params: {}
      }).catch((err) => {
        reject(err);
        unsubscribe3();
      });
    });
  }
  createSetupTasks(tasks) {
    return this.messageHandler.request({
      method: "task/createSetupTasks",
      params: { tasks }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/index.js
var vmD = (0, import_debug3.default)("csb:vm");
var INITIAL_MAX_CONNECTION_TRIES = 3;
var INITIAL_CONNECTION_DELAY_MS = 500;
var INITIAL_CONNECTION_TIMEOUT_MS = 9e4;
var RECONNECT_MAX_CONNECTION_TRIES = 3;
var RECONNECT_CONNECTION_DELAY_MS = 500;
var RECONNECT_CONNECTION_TIMEOUT_MS = 1e4;
var PONG_DETECTION_TIMEOUT = 15e3;
var FOCUS_PONG_DETECTION_TIMEOUT = 5e3;
if (typeof process !== "undefined" && false) {
  vmD("Using test timeouts");
  PONG_DETECTION_TIMEOUT = 200;
  INITIAL_MAX_CONNECTION_TRIES = 3;
  INITIAL_CONNECTION_DELAY_MS = 10;
  INITIAL_CONNECTION_TIMEOUT_MS = 1e3;
}
function createConnectionString(hostResponse, reconnectToken) {
  return `${hostResponse.pitcherURL}/?token=${hostResponse.pitcherToken}${reconnectToken ? `&reconnectToken=${reconnectToken}` : ""}`;
}
var PitcherVMClient = class extends import_pitcher_common31.Disposable {
  get bootupType() {
    return this.hostResponse.bootupType;
  }
  get currentClient() {
    return this.joinResult.client;
  }
  get capabilities() {
    return this.joinResult.capabilities;
  }
  get permissions() {
    return this.joinResult.permissions;
  }
  get pitcherVersion() {
    return this.joinResult.version;
  }
  get pitcherManagerVersion() {
    return this.hostResponse.pitcherManagerVersion;
  }
  get pitcherProtocolVersion() {
    return this.joinResult.protocolVersion;
  }
  get workspacePath() {
    return this.hostResponse.workspacePath;
  }
  get userWorkspacePath() {
    return this.hostResponse.userWorkspacePath;
  }
  get cluster() {
    return this.hostResponse.cluster;
  }
  get reconnectToken() {
    return this.joinResult.reconnectToken;
  }
  constructor(opts) {
    super();
    this.type = "vm";
    this.lastFocusTimestamp = Date.now();
    this.isFocused = true;
    this.state = new import_class_states4.States({
      // We always instantiate with a connected connection
      state: "CONNECTED",
      lastActivity: Date.now(),
      lastFocus: Date.now(),
      connectedAt: Date.now()
    });
    this.onStateChange = this.state.onTransition;
    this.onReconnectedEmitter = new import_pitcher_common31.Emitter();
    this.onReconnected = this.onReconnectedEmitter.event;
    this.onInstanceChangedEmitter = new import_pitcher_common31.Emitter();
    this.onInstanceChanged = this.onInstanceChangedEmitter.event;
    this.sessionStartTime = Date.now();
    this.instanceId = opts.instanceId;
    this.hostResponse = opts.hostResponse;
    this.joinResult = opts.joinResult;
    this.messageHandler = opts.messageHandler;
    this.onFocusChange = opts.onFocusChange;
    this.onInstanceChangeRequired = this.messageHandler.onInstanceChangeRequired;
    this.appId = opts.appId;
    this.subscriptions = opts.subscriptions;
    this.requestPitcherInstance = opts.requestPitcherInstance;
    this.hostResponse = opts.hostResponse;
    this.subscribeConnection(opts.initialConnection);
    this.connection = opts.initialConnection;
    const fsClient = new FSClient(this.workspacePath, this.userWorkspacePath, this.messageHandler);
    const fileClient = new FileClient(this.messageHandler, fsClient, this.workspacePath);
    const clientClient = new ClientClient(this.messageHandler);
    this.clients = {
      fs: fsClient,
      client: clientClient,
      shell: new ShellClient(this.messageHandler),
      port: new PortClient(this.messageHandler),
      file: fileClient,
      language: new LanguageClient(this.messageHandler, fileClient),
      git: new GitClient(this.messageHandler),
      setup: new SetupClient(this.messageHandler),
      channel: new ChannelClient({
        clientClient,
        currentClient: this.currentClient,
        messageHandler: this.messageHandler
      }),
      task: new TaskClient(this.messageHandler),
      system: new SystemClient(this.messageHandler),
      command: new CommandClient(this.messageHandler),
      notification: new NotificationClient(this.messageHandler),
      ai: new AiClient(this.messageHandler),
      container: new ContainerClient(this.messageHandler)
    };
    this.onMessageError = this.messageHandler.onError;
    this.onMessage = (cb) => this.messageHandler.onMessage(cb);
    this.messageHandler.onInstanceChangeRequired(() => {
      this.messageHandler.setOnSendRequest(() => {
        throw new Error("Instance change required");
      });
    });
    this.clients.system.onHibernate(() => {
      this.state.set({
        state: "HIBERNATED",
        wasFocused: this.isFocused,
        disconnectedAt: Date.now()
      });
      this.connection.dispose("Hibernation");
    });
    this.clients.client.onClientsUpdated((clients) => {
      const currentClient = clients.find((client2) => client2.clientId === this.currentClient.clientId);
      if (currentClient && (this.currentClient.name !== currentClient.name || !this.currentClient.avatarUrl)) {
        this.currentClient.name = currentClient.name;
        this.currentClient.avatarUrl = currentClient.avatarUrl;
      }
    });
    this.onFocusChangeDisposer = this.onFocusChange((isFocused) => {
      this.isFocused = isFocused;
      const state = this.state.get();
      if (isFocused) {
        this.lastFocusTimestamp = Date.now();
      }
      if (isFocused && state.state === "CONNECTED") {
        this.connection.ping(FOCUS_PONG_DETECTION_TIMEOUT);
      } else if (isFocused && (state.state === "DISCONNECTED" || state.state === "HIBERNATED")) {
        this.attemptReconnect({
          disconnectReason: state.state === "DISCONNECTED" ? state.reason : "HIBERNATED",
          disconnectedAt: state.disconnectedAt
        }).catch(() => {
        });
      }
    });
  }
  subscribeConnection(ws2) {
    const onMessageDisposer = ws2.onMessage((message) => {
      this.messageHandler.receiveMessage(message);
    });
    this.messageHandler.setOnSendRequest((request) => {
      const state = this.state.get();
      if (state.state === "CONNECTED" || request.method === "client/join") {
        ws2.send(request.message);
        return;
      }
      if (this.isFocused && (state.state === "DISCONNECTED" || state.state === "HIBERNATED")) {
        this.attemptReconnect({
          disconnectReason: state.state === "DISCONNECTED" ? state.reason : "HIBERNATED",
          disconnectedAt: state.disconnectedAt
        }).catch(() => {
        });
      }
      throw new Error("Not able to send message in state " + state.state);
    });
    const onDisconnectedDisposer = ws2.onDisconnected(({ reason, code, wasClean }) => {
      const state = this.state.get();
      if (this.isFocused && state.state === "CONNECTED") {
        this.attemptReconnect({
          disconnectReason: reason,
          disconnectedAt: Date.now()
        }).catch(() => {
        });
      } else {
        this.state.set({
          state: "DISCONNECTED",
          reason,
          code,
          wasClean,
          wasFocused: this.isFocused,
          disconnectedAt: Date.now()
        });
      }
    });
    ws2.onWillDispose(() => {
      onMessageDisposer.dispose();
      onDisconnectedDisposer.dispose();
    });
  }
  async resolveCurrentConnection() {
    this.subscribeConnection(this.connection);
    vmD("[pitcher-client]: Joining");
    this.joinResult = await this.clients.client.join({
      clientInfo: {
        protocolVersion: import_pitcher_protocol5.version,
        appId: this.appId
      },
      asyncProgress: false,
      subscriptions: this.subscriptions
    });
    this.state.set({
      state: "CONNECTED",
      lastActivity: this.connection.lastActivity,
      lastFocus: this.lastFocusTimestamp,
      connectedAt: Date.now()
    });
  }
  async reconnect() {
    return this.state.match({
      DISCONNECTED: ({ reason, disconnectedAt }) => this.attemptReconnect({
        disconnectReason: reason,
        disconnectedAt
      }),
      CONNECTED: () => this.attemptReconnect({
        disconnectReason: "MANUAL_RECONNECT",
        disconnectedAt: Date.now()
      }),
      _: () => {
      }
    });
  }
  async attemptReconnect({ disconnectReason, disconnectedAt }) {
    if (this.isDisposed) {
      return;
    }
    if (this.state.is("RECONNECTING")) {
      return Promise.reject("Already reconnecting");
    }
    vmD("[pitcher-client]: Attempting reconnect");
    this.connection.dispose(disconnectReason);
    this.messageHandler.getPendingMessages().forEach((message) => {
      message.reject(new Error("Attempting reconnect"));
    });
    let attempt = 1;
    const wasFocused = this.isFocused;
    try {
      await retryPromise(async (cancellationToken) => {
        this.addDisposable(cancellationToken);
        this.state.set({
          state: "RECONNECTING",
          disconnectReason,
          wasFocused,
          attempt: attempt++,
          lastActivity: this.connection.lastActivity,
          disconnectedAt,
          lastFocus: this.lastFocusTimestamp
        });
        vmD("[pitcher-client]: Resolving instance");
        try {
          this.hostResponse = await this.requestPitcherInstance(this.instanceId);
        } catch (error) {
          if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
            throw new CancellationError(error);
          }
          throw error;
        }
        cancellationToken.throwErrorIfCancelled();
        vmD("[pitcher-client]: Connecting to instance");
        const connection = await createWebSocketClient(createConnectionString(this.hostResponse, this.reconnectToken));
        cancellationToken.throwErrorIfCancelled(() => {
          connection.dispose("Reconnect timed out");
        });
        this.connection = connection;
        await this.resolveCurrentConnection();
        cancellationToken.throwErrorIfCancelled(() => {
          connection.dispose("Reconnect timed out");
        });
        vmD("[pitcher-client]: Connected, resyncing ");
      }, RECONNECT_MAX_CONNECTION_TRIES, RECONNECT_CONNECTION_DELAY_MS, RECONNECT_CONNECTION_TIMEOUT_MS);
      await this.messageHandler.flushReconnectQueue();
      await Promise.all([
        this.clients.client.resync(),
        // TODO: We should not use permission here, but capability. But currently Pitcher returns true on
        // this, even though it does not handle it
        this.permissions.git?.status ? this.clients.git.resync() : Promise.resolve(),
        this.clients.port.resync(),
        this.clients.setup.resync(),
        this.clients.shell.resync(),
        this.clients.language.resync(),
        this.clients.task.resync(),
        this.clients.system.resync(),
        this.clients.command.resync(),
        this.clients.fs.resync(),
        this.clients.file.resync(),
        this.clients.channel.resync()
      ]);
      vmD("[pitcher-client]: Resynced ");
      this.onReconnectedEmitter.fire();
    } catch (error) {
      vmD("[pitcher-client]: Unable to connect - " + String(error));
      this.state.set({
        state: "DISCONNECTED",
        code: -1,
        disconnectedAt,
        reason: String(error),
        wasClean: false,
        wasFocused: this.isFocused
      });
      throw error;
    }
  }
  hasFeature(feature) {
    const result = (0, import_semver.compare)(this.pitcherVersion, PitcherFeatureToVersionMap[feature]);
    return result === -1 ? false : true;
  }
  revertSeamlessFork() {
    this.onInstanceChangedEmitter.fire({ instanceId: this.instanceId });
  }
  toggleSeamlessFork(value) {
    this.messageHandler.toggleSeamlessFork(value);
  }
  async changeInstance(instanceId) {
    return this.state.match({
      CONNECTED: async () => {
        this.connection.silence();
        this.instanceId = instanceId;
        await retryPromise(async (cancellationToken) => {
          this.addDisposable(cancellationToken);
          try {
            this.hostResponse = await this.requestPitcherInstance(instanceId);
          } catch (error) {
            if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
              throw new CancellationError(error);
            }
            throw error;
          }
          cancellationToken.throwErrorIfCancelled();
          this.connection.dispose("Seamless forking");
          const connection = await createWebSocketClient(createConnectionString(this.hostResponse, this.reconnectToken));
          cancellationToken.throwErrorIfCancelled(() => {
            connection.dispose("Seamless connection timed out");
          });
          this.connection = connection;
          await this.resolveCurrentConnection();
          cancellationToken.throwErrorIfCancelled(() => {
            connection.dispose("Seamless connection timed out");
          });
        }, RECONNECT_MAX_CONNECTION_TRIES, RECONNECT_CONNECTION_DELAY_MS, RECONNECT_CONNECTION_TIMEOUT_MS);
        this.connection.setPongDetectionTimeout(PONG_DETECTION_TIMEOUT);
        this.messageHandler.disableSeamlessFork();
        await Promise.all([
          this.clients.file.resync().then(() => this.messageHandler.flushReconnectQueue()),
          // We need to wait for the new git status or we show that the branch is out of sync
          // TODO: We should not use permission here, but capability. But currently Pitcher returns true on
          // this, even though it does not handle it
          this.permissions.git?.status ? this.clients.git.resync() : Promise.resolve()
        ]);
        this.clients.task.resync();
        this.clients.port.resync();
        this.clients.client.resync();
        this.clients.shell.resync();
        this.clients.language.resync();
        this.clients.channel.resync();
        this.onInstanceChangedEmitter.fire({ instanceId: this.instanceId });
      },
      _: () => {
        throw new Error("You can not change instance when: " + this.state.get().state);
      }
    });
  }
  isUpToDate() {
    return this.hostResponse.pitcherVersion === this.hostResponse.latestPitcherVersion;
  }
  disconnect() {
    this.state.set({
      state: "DISCONNECTED",
      code: -1,
      disconnectedAt: Date.now(),
      reason: "Manual disconnect",
      wasClean: true,
      wasFocused: this.isFocused
    });
    this.connection.dispose("Manual disconnect");
  }
  dispose() {
    this.onFocusChangeDisposer();
    this.messageHandler.dispose();
    this.state.dispose();
    this.connection.dispose("Dispose");
  }
};
var INIT_PROGRESS_START = 60;
function offsetPitcherInitProgress(oldProgress) {
  return oldProgress * (100 - INIT_PROGRESS_START) / 100 + INIT_PROGRESS_START;
}
async function initPitcherClient(opts, initStatusCb, hostResponseCb) {
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Connecting to pitcher");
  }
  let hasEmittedConnectingStatus = false;
  const { connection, hostResponse } = await retryPromise(async (cancellationToken) => {
    let hostResponse2;
    try {
      hostResponse2 = await opts.requestPitcherInstance(opts.instanceId);
      hostResponseCb?.(hostResponse2);
    } catch (error) {
      if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
        throw new CancellationError(error);
      }
      throw error;
    }
    cancellationToken.throwErrorIfCancelled();
    if (!hasEmittedConnectingStatus) {
      hasEmittedConnectingStatus = true;
      initStatusCb({
        message: "MicroVM started, connecting...",
        // We give 5 percent to connect to VM, where Pitcher init messages
        // will start at INIT_PROGRESS_START
        progress: INIT_PROGRESS_START - 5,
        nextProgress: INIT_PROGRESS_START
      });
    }
    const connection2 = await createWebSocketClient(createConnectionString(hostResponse2));
    cancellationToken.throwErrorIfCancelled(() => {
      connection2.dispose("Initial connection timed out");
    });
    return { connection: connection2, hostResponse: hostResponse2 };
  }, INITIAL_MAX_CONNECTION_TRIES, INITIAL_CONNECTION_DELAY_MS, INITIAL_CONNECTION_TIMEOUT_MS);
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Setting up message handler and clients");
  }
  const messageHandler = new PitcherMessageHandler((request) => {
    connection.send(request.message);
  }, Boolean(opts.seamlessFork));
  const onMessageDisposer = connection.onMessage((message) => {
    messageHandler.receiveMessage(message);
  });
  const clientClient = new ClientClient(messageHandler);
  const systemClient = new SystemClient(messageHandler);
  const initStatusUpdateDisposer = systemClient.onInitStatusUpdate((status) => {
    status.progress = offsetPitcherInitProgress(status.progress);
    status.nextProgress = offsetPitcherInitProgress(status.nextProgress);
    initStatusCb(status);
  });
  const joinResult = await clientClient.join({
    clientInfo: {
      protocolVersion: import_pitcher_protocol5.version,
      appId: opts.appId
    },
    asyncProgress: true,
    subscriptions: opts.subscriptions
  });
  initStatusUpdateDisposer.dispose();
  onMessageDisposer.dispose();
  const client2 = new PitcherVMClient({
    instanceId: opts.instanceId,
    appId: opts.appId,
    subscriptions: opts.subscriptions,
    requestPitcherInstance: opts.requestPitcherInstance,
    onFocusChange: opts.onFocusChange,
    seamlessFork: opts.seamlessFork,
    messageHandler,
    joinResult,
    initialConnection: connection,
    hostResponse
  });
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Awaiting fs initialization");
  }
  await Promise.all([
    client2.clients.fs.readyPromise,
    client2.clients.port.readyPromise,
    client2.clients.task.readyPromise,
    client2.clients.setup.readyPromise,
    client2.clients.shell.readyPromise
  ]);
  connection.setPongDetectionTimeout(PONG_DETECTION_TIMEOUT);
  if (typeof window !== "undefined") {
    window._DEBUG_PITCHER_CLIENT = client2;
  }
  return client2;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var AsyncDocument = class extends import_pitcher_common32.ot.AsyncDocument {
};

// src/client/sdk.gen.ts
var client = L(z());
var sandboxFork = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/sandbox/{id}/fork"
  });
};
var vmHibernate = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/hibernate"
  });
};
var vmShutdown = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/shutdown"
  });
};
var vmStart = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/start"
  });
};
var vmUpdateSpecs = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/update_specs"
  });
};

// src/utils/event.ts
var Emitter28 = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Set();
  }
  get event() {
    if (!this._event) {
      this._event = (listener) => {
        this.registeredListeners.add(listener);
        return Disposable16.create(() => {
          this.registeredListeners.delete(listener);
        });
      };
    }
    return this._event;
  }
  /** Invoke all listeners registered to this event. */
  fire(event) {
    this.registeredListeners.forEach((listener) => {
      listener(event);
    });
  }
  dispose() {
    this.registeredListeners = /* @__PURE__ */ new Set();
  }
};

// src/utils/disposable.ts
var Disposable16 = class _Disposable {
  constructor() {
    this.onWillDisposeEmitter = new Emitter28();
    this.onWillDispose = this.onWillDisposeEmitter.event;
    this.onDidDisposeEmitter = new Emitter28();
    this.onDidDispose = this.onDidDisposeEmitter.event;
    this.toDispose = [];
    this.isDisposed = false;
  }
  addDisposable(disposable) {
    this.toDispose.push(disposable);
    return disposable;
  }
  onDispose(cb) {
    this.toDispose.push(_Disposable.create(cb));
  }
  dispose() {
    if (this.isDisposed) return;
    this.onWillDisposeEmitter.fire(null);
    this.isDisposed = true;
    this.toDispose.forEach((disposable) => {
      disposable.dispose();
    });
    this.onDidDisposeEmitter.fire(null);
    this.onWillDisposeEmitter.dispose();
    this.onDidDisposeEmitter.dispose();
  }
  static is(arg) {
    return typeof arg === "object" && arg !== null && "dispose" in arg && typeof arg.dispose === "function";
  }
  static create(cb) {
    return {
      dispose: cb
    };
  }
};
var DisposableStore = class _DisposableStore {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set();
    this._isDisposed = false;
  }
  static {
    this.DISABLE_DISPOSED_WARNING = true;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.clear();
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    try {
      for (const disposable of this._toDispose.values()) {
        disposable.dispose();
      }
    } finally {
      this._toDispose.clear();
    }
  }
  add(o2) {
    if (!o2) {
      return o2;
    }
    if (o2 === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    if (this._isDisposed) {
      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(
          new Error(
            "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!"
          ).stack
        );
      }
    } else {
      this._toDispose.add(o2);
    }
    return o2;
  }
};

// src/filesystem.ts
var FileSystem = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
  }
  /**
   * Write a file.
   *
   * @param path - The path to write to.
   * @param content - The content to write.
   * @param opts - The options for the write.
   */
  async writeFile(path, content, opts = {}) {
    const result = await this.pitcherClient.clients.fs.writeFile(
      path,
      content,
      opts.create ?? true,
      opts.overwrite ?? true
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Write a file as a string.
   *
   * @param path - The path to write to.
   * @param content - The content to write.
   * @param opts - The options for the write.
   */
  async writeTextFile(path, content, opts = {}) {
    return this.writeFile(path, new TextEncoder().encode(content), opts);
  }
  /**
   * Create a directory.
   *
   * @param path - The path to create.
   * @param recursive - Whether to create the directory recursively.
   */
  async mkdir(path, recursive = false) {
    const result = await this.pitcherClient.clients.fs.mkdir(path, recursive);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Read a directory.
   *
   * @param path - The path to read.
   * @returns The entries in the directory.
   */
  async readdir(path) {
    const result = await this.pitcherClient.clients.fs.readdir(path);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return result.result.entries.map((entry) => ({
      ...entry,
      type: entry.type === 0 ? "file" : "directory"
    }));
  }
  /**
   * Read a file
   *
   * @param path - The path to read.
   * @returns The content of the file as a Uint8Array.
   */
  async readFile(path) {
    const result = await this.pitcherClient.clients.fs.readFile(path);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return result.result.content;
  }
  /**
   * Read a file as a string.
   *
   * @param path - The path to read.
   * @returns The content of the file as a string.
   */
  async readTextFile(path) {
    return await this.readFile(path).then(
      (content) => new TextDecoder("utf-8").decode(content)
    );
  }
  /**
   * Get the stat of a file or directory.
   *
   * @param path - The path to get the stat of.
   * @returns The stat of the file or directory.
   */
  async stat(path) {
    const result = await this.pitcherClient.clients.fs.stat(path);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return {
      ...result.result,
      type: result.result.type === 0 ? "file" : "directory"
    };
  }
  /**
   * Copy a file or directory.
   *
   * @param from - The path to copy from.
   * @param to - The path to copy to.
   * @param recursive - Whether to copy the directory recursively.
   * @param overwrite - Whether to overwrite the destination if it exists.
   */
  async copy(from, to, recursive = false, overwrite = false) {
    const result = await this.pitcherClient.clients.fs.copy(
      from,
      to,
      recursive,
      overwrite
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Rename a file or directory.
   *
   * @param from - The path to rename from.
   * @param to - The path to rename to.
   * @param overwrite - Whether to overwrite the destination if it exists.
   */
  async rename(from, to, overwrite = false) {
    const result = await this.pitcherClient.clients.fs.rename(
      from,
      to,
      overwrite
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Remove a file or directory.
   *
   * @param path - The path to remove.
   * @param recursive - Whether to remove the directory recursively.
   */
  async remove(path, recursive = false) {
    const result = await this.pitcherClient.clients.fs.remove(path, recursive);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Watch for changes in the filesystem.
   *
   * ```ts
   * const watcher = await sandbox.fs.watch("/path/to/watch");
   * watcher.onEvent((event) => {
   *   console.log(event);
   * });
   *
   * // When done
   * watcher.dispose();
   * ```
   *
   * @param path - The path to watch.
   * @param options - The options for the watch.
   * @returns A watcher that can be disposed to stop the watch.
   */
  async watch(path, options = {}) {
    const emitter = new Emitter28();
    const result = await this.pitcherClient.clients.fs.watch(
      path,
      options,
      (event) => emitter.fire(event)
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    const watcher = {
      dispose: () => {
        result.dispose();
        emitter.dispose();
      },
      onEvent: emitter.event
    };
    this.addDisposable(watcher);
    return watcher;
  }
  /**
   * Download a file or folder from the filesystem, can only be used to download
   * from within the workspace directory.
   *
   * @param path - The path to download.
   * @returns A download URL that's valid for 5 minutes.
   */
  async download(path) {
    const result = await this.pitcherClient.clients.fs.download(path);
    return result;
  }
};

// src/ports.ts
var PortInfo = class {
  constructor(port, hostname) {
    this.port = port;
    this.hostname = hostname;
  }
  getPreviewUrl(protocol2 = "https://") {
    return `${protocol2}${this.hostname}`;
  }
};
var Ports = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.onDidPortOpenEmitter = this.addDisposable(new Emitter28());
    this.onDidPortCloseEmitter = this.addDisposable(new Emitter28());
    this.lastOpenedPorts = /* @__PURE__ */ new Set();
    pitcherClient.clients.port.getPorts().forEach((port) => {
      this.lastOpenedPorts.add(port.port);
    });
    this.addDisposable(
      pitcherClient.clients.port.onPortsUpdated((ports) => {
        const openedPorts = ports.filter((port) => !this.lastOpenedPorts.has(port.port)).map((port) => new PortInfo(port.port, port.url));
        const closedPorts = [...this.lastOpenedPorts].filter(
          (port) => !ports.some((p2) => p2.port === port)
        );
        if (openedPorts.length) {
          for (const port of openedPorts) {
            this.onDidPortOpenEmitter.fire(port);
          }
        }
        if (closedPorts.length) {
          for (const port of closedPorts) {
            this.onDidPortCloseEmitter.fire(port);
          }
        }
        this.lastOpenedPorts = new Set(ports.map((port) => port.port));
      })
    );
  }
  get onDidPortOpen() {
    return this.onDidPortOpenEmitter.event;
  }
  get onDidPortClose() {
    return this.onDidPortCloseEmitter.event;
  }
  getOpenedPort(port) {
    return this.getOpenedPorts().find((p2) => p2.port === port);
  }
  getOpenedPorts() {
    return this.pitcherClient.clients.port.getPorts().map((port) => new PortInfo(port.port, port.url));
  }
  getPreviewUrl(port, protocol2 = "https://") {
    const hostname = this.pitcherClient.clients.port.getPorts().find((p2) => p2.port === port)?.url;
    return hostname ? `${protocol2}${hostname}` : void 0;
  }
  /**
   * Wait for a port to be opened.
   *
   * @param port - The port to wait for.
   * @returns A promise that resolves when the port is opened.
   */
  async waitForPort(port) {
    await this.pitcherClient.clients.port.readyPromise;
    return new Promise((resolve) => {
      const portInfo = this.getOpenedPorts().find((p2) => p2.port === port);
      if (portInfo) {
        resolve(portInfo);
        return;
      }
      const disposable = this.addDisposable(
        this.onDidPortOpen((portInfo2) => {
          if (portInfo2.port === port) {
            resolve(portInfo2);
            disposable.dispose();
          }
        })
      );
    });
  }
};

// src/setup.ts
var import_event5 = __toESM(require_event());
var Setup = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.onSetupProgressUpdateEmitter = this.addDisposable(
      new Emitter28()
    );
    /**
     * Emitted when the setup progress is updated.
     */
    this.onSetupProgressUpdate = this.onSetupProgressUpdateEmitter.event;
    this.addDisposable(
      pitcherClient.clients.setup.onSetupProgressUpdate((progress) => {
        this.onSetupProgressUpdateEmitter.fire(progress);
      })
    );
  }
  /**
   * Run the setup tasks, this will prepare the docker image, and run the user defined
   * setup steps. This will automatically run when a sandbox is started.
   */
  async run() {
    return this.pitcherClient.clients.setup.init();
  }
  /**
   * Returns the current progress of the setup tasks.
   */
  async getProgress() {
    await this.pitcherClient.clients.setup.readyPromise;
    return this.pitcherClient.clients.setup.getProgress();
  }
  async waitForFinish() {
    const progress = await this.getProgress();
    if (progress.state === "FINISHED") {
      return Promise.resolve(progress);
    }
    return (0, import_event5.listenOnce)(this.onSetupProgressUpdate, (progress2) => {
      return progress2.state === "FINISHED";
    });
  }
};

// src/shells.ts
var import_pitcher_common34 = __toESM(require_dist3());
var DEFAULT_SHELL_SIZE = { cols: 128, rows: 24 };
var Shells = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.js = new LanguageInterpreter(this.pitcherClient, {
      runtime: "node",
      extension: "js",
      env: { NO_COLOR: "true" }
    });
    this.python = new LanguageInterpreter(this.pitcherClient, {
      runtime: "python",
      extension: "py",
      env: {}
    });
  }
  /**
   * Creates a shell that can run commands, will return output as data is sent to stdin.
   *
   * ## Example
   *
   * ```ts
   * const shell = await sandbox.shell.create();
   *
   * const disposable = shell.onShellOut((data) => {
   *   console.log(data);
   * });
   *
   * // Write to the shell
   * shell.write("echo 'Hello, world!'");
   *
   * // Stop listening to the shell
   * disposable.dispose();
   *
   * // Kill the shell
   * await shell.kill();
   * ```
   *
   * @param command - The command to run in the shell.
   * @param shellSize - The size of the shell.
   * @returns A disposable shell instance.
   */
  async create(command = "bash", opts) {
    const shell = await this.pitcherClient.clients.shell.create(
      this.pitcherClient.workspacePath,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE,
      command,
      "TERMINAL",
      true
    );
    return new ShellInstance(shell, this.pitcherClient);
  }
  /**
   * Opens an existing shell.
   */
  async open(shellId, opts) {
    const shell = await this.pitcherClient.clients.shell.open(
      shellId,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE
    );
    return new ShellInstance(shell, this.pitcherClient);
  }
  /**
   * Runs the given command, and can be listened to for streaming output. To get all
   * output, you can optionally await the returned promise.
   *
   * ## Example
   *
   * ```ts
   * const shell = await sandbox.shell.runCommand("echo 'Hello, world!'");
   *
   * shell.onOutput((data) => {
   *   console.log(data);
   * });
   *
   * const result = await shell;
   *
   * console.log(result.output, result.exitCode);
   * ```
   */
  run(command, opts) {
    const shell = runCommandAsUser(
      this.pitcherClient,
      command,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE,
      void 0,
      void 0,
      opts?.shellName
    );
    return shell;
  }
  /**
   * Gets all shells that are running or have ran before in the current sandbox.
   */
  async getShells() {
    const shells = this.pitcherClient.clients.shell.getShells();
    return shells.map((shell) => new ShellInstance(shell, this.pitcherClient));
  }
};
function getRandomString() {
  return Math.random().toString(36).substring(7);
}
var LanguageInterpreter = class {
  constructor(pitcherClient, opts) {
    this.pitcherClient = pitcherClient;
    this.opts = opts;
  }
  async run(code) {
    const randomString = getRandomString();
    const tmpFileName = `/tmp/tmp.${randomString}.${this.opts.extension}`;
    const command = `${this.opts.runtime} ${tmpFileName}`;
    const result = runCommandAsUser(
      this.pitcherClient,
      command,
      DEFAULT_SHELL_SIZE,
      async () => {
        const tmpFile = await this.pitcherClient.clients.fs.writeFile(
          tmpFileName,
          new TextEncoder().encode(code),
          true,
          true
        );
        if (tmpFile.type === "error") {
          throw new Error(`${tmpFile.errno}: ${tmpFile.error}`);
        }
      },
      this.opts.env
    );
    return result;
  }
};
var ShellInstance = class extends Disposable16 {
  constructor(shell, pitcherClient) {
    super();
    this.shell = shell;
    this.pitcherClient = pitcherClient;
    // TODO: differentiate between stdout and stderr, also send back bytes instead of
    // strings
    this.onShellOutputEmitter = this.addDisposable(new Emitter28());
    this.onOutput = this.onShellOutputEmitter.event;
    this.onShellUpdatedEmitter = this.addDisposable(new Emitter28());
    this.onShellUpdated = this.onShellUpdatedEmitter.event;
    this.output = this.shell.buffer || [];
    this.addDisposable(
      pitcherClient.clients.shell.onShellsUpdated((shells) => {
        const updatedShell = shells.find(
          (s3) => s3.shellId === this.shell.shellId
        );
        if (updatedShell) {
          this.shell = { ...updatedShell, buffer: [] };
          this.onShellUpdatedEmitter.fire();
        }
      })
    );
    this.addDisposable(
      this.pitcherClient.clients.shell.onShellOut(({ shellId, out }) => {
        if (shellId === this.shell.shellId) {
          this.onShellOutputEmitter.fire(out);
          this.output.push(out);
          if (this.output.length > 1e3) {
            this.output.shift();
          }
        }
      })
    );
    this.onWillDispose(async () => {
      try {
        await this.pitcherClient.clients.shell.close(this.shell.shellId);
      } catch (e3) {
      }
    });
  }
  /**
   * Gets the ID of the shell. Can be used to open the shell again.
   */
  get id() {
    return this.shell.shellId;
  }
  /**
   * Gets the name of the shell.
   */
  get name() {
    return this.shell.name;
  }
  get exitCode() {
    return this.shell.exitCode;
  }
  /**
   * Gets the status of the shell.
   */
  get status() {
    return this.shell.status;
  }
  async write(input) {
    await this.pitcherClient.clients.shell.send(this.shell.shellId, input, {
      cols: 80,
      rows: 24
    });
  }
  // TODO: allow for kill signals
  async kill() {
    await this.pitcherClient.clients.shell.delete(this.shell.shellId);
  }
  /**
   * @returns The total output of the shell
   */
  getOutput() {
    return this.output.join("\n");
  }
};
function runCommandAsUser(pitcher, command, shellSize = DEFAULT_SHELL_SIZE, runPreCommand, env, shellName) {
  const disposableStore = new import_pitcher_common34.DisposableStore();
  const onOutput = new Emitter28();
  disposableStore.add(onOutput);
  let shell;
  const resultPromise = (async () => {
    if (runPreCommand) {
      await runPreCommand();
    }
    const commandWithEnv = `env ${Object.entries(env ?? {}).map(([key, value]) => `${key}=${value}`).join(" ")} ${command}`;
    shell = await pitcher.clients.shell.create(
      pitcher.workspacePath,
      shellSize,
      commandWithEnv,
      "TERMINAL",
      true
    );
    if (shellName) {
      pitcher.clients.shell.rename(shell.shellId, shellName);
    }
    if (shell.status === "FINISHED") {
      return {
        output: shell.buffer.join("\n").trim(),
        exitCode: shell.exitCode
      };
    }
    let combinedOut = shell.buffer.join("\n");
    if (combinedOut) {
      onOutput.fire(combinedOut);
    }
    const barrier = new import_pitcher_common34.Barrier();
    disposableStore.add(
      pitcher.clients.shell.onShellOut(({ shellId, out }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        onOutput.fire(out);
        combinedOut += out;
      })
    );
    disposableStore.add(
      pitcher.clients.shell.onShellExited(({ shellId, exitCode }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        barrier.open({ exitCode });
      })
    );
    disposableStore.add(
      pitcher.clients.shell.onShellTerminated(({ shellId }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        barrier.open({ exitCode: void 0 });
      })
    );
    const result = await barrier.wait();
    disposableStore.dispose();
    if (result.status === "disposed") {
      throw new Error("Shell was disposed");
    }
    return {
      output: combinedOut.trim(),
      exitCode: result.value.exitCode
    };
  })();
  resultPromise.kill = () => {
    disposableStore.dispose();
    if (shell) {
      pitcher.clients.shell.delete(shell.shellId);
    }
  };
  resultPromise.onOutput = onOutput.event;
  return resultPromise;
}

// src/tasks.ts
var Tasks = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
  }
  /**
   * Gets all tasks that are available in the current sandbox.
   */
  async getTasks() {
    const tasks = await this.pitcherClient.clients.task.getTasks();
    return Object.values(tasks.tasks).map(taskFromDTO);
  }
  /**
   * Gets a task by its ID.
   */
  async getTask(taskId) {
    const task = await this.pitcherClient.clients.task.getTask(taskId);
    if (!task) {
      return void 0;
    }
    return taskFromDTO(task);
  }
  /**
   * Runs a task by its ID.
   */
  async runTask(taskId) {
    const task = await this.pitcherClient.clients.task.runTask(taskId);
    return taskFromDTO(task);
  }
};
function taskFromDTO(value) {
  return {
    id: value.id,
    name: value.name,
    command: value.command,
    runAtStart: value.runAtStart,
    preview: value.preview,
    shellId: value.shell?.shellId ?? null,
    ports: value.ports.map((port) => new PortInfo(port.port, port.url))
  };
}

// src/sandbox.ts
var SandboxWithoutClient = class extends import_pitcher_common33.Disposable {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    /**
     * Namespace for all filesystem operations on this sandbox.
     */
    this.fs = this.addDisposable(new FileSystem(this.pitcherClient));
    /**
     * Namespace for running shell commands on this sandbox.
     */
    this.shells = this.addDisposable(new Shells(this.pitcherClient));
    /**
     * Namespace for detecting open ports on this sandbox, and getting preview URLs for
     * them.
     */
    this.ports = this.addDisposable(new Ports(this.pitcherClient));
    /**
     * Namespace for all setup operations on this sandbox (installing dependencies, etc).
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    this.setup = this.addDisposable(new Setup(this.pitcherClient));
    /**
     * Namespace for all task operations on a sandbox. This includes running tasks,
     * getting tasks, and stopping tasks.
     *
     * In CodeSandbox, you can create tasks and manage them by creating a `.codesandbox/tasks.json`
     * in the sandbox. These tasks become available under this namespace, this way you can manage
     * tasks that you will need to run more often (like a dev server).
     *
     * More documentation: https://codesandbox.io/docs/learn/devboxes/task#adding-and-configuring-tasks
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    this.tasks = this.addDisposable(new Tasks(this.pitcherClient));
    this.addDisposable(this.pitcherClient);
  }
  /**
   * The ID of the sandbox.
   */
  get id() {
    return this.pitcherClient.instanceId;
  }
  /**
   * Get the URL to the editor for this sandbox. Keep in mind that this URL is not
   * available if the sandbox is private, and the user opening this sandbox does not
   * have access to the sandbox.
   */
  get editorUrl() {
    return `https://codesandbox.io/p/devbox/${this.id}`;
  }
  // TODO: Bring this back once metrics polling does not reset inactivity
  // /**
  //  * Get the current system metrics. This return type may change in the future.
  //  */
  // public async getMetrics(): Promise<SystemMetricsStatus> {
  //   await this.pitcherClient.clients.system.update();
  //   const barrier = new Barrier<_protocol.system.SystemMetricsStatus>();
  //   const initialMetrics = this.pitcherClient.clients.system.getMetrics();
  //   if (!initialMetrics) {
  //     const disposable = this.pitcherClient.clients.system.onMetricsUpdated(
  //       (metrics) => {
  //         if (metrics) {
  //           barrier.open(metrics);
  //         }
  //       }
  //     );
  //     disposable.dispose();
  //   } else {
  //     barrier.open(initialMetrics);
  //   }
  //   const barrierResult = await barrier.wait();
  //   if (barrierResult.status === "disposed") {
  //     throw new Error("Metrics not available");
  //   }
  //   const metrics = barrierResult.value;
  //   return {
  //     cpu: {
  //       cores: metrics.cpu.cores,
  //       used: metrics.cpu.used / 100,
  //       configured: metrics.cpu.configured,
  //     },
  //     memory: {
  //       usedKiB: metrics.memory.used * 1024 * 1024,
  //       totalKiB: metrics.memory.total * 1024 * 1024,
  //       configuredKiB: metrics.memory.total * 1024 * 1024,
  //     },
  //     storage: {
  //       usedKB: metrics.storage.used * 1000 * 1000,
  //       totalKB: metrics.storage.total * 1000 * 1000,
  //       configuredKB: metrics.storage.configured * 1000 * 1000,
  //     },
  //   };
  // }
  /**
   * Disconnect from the sandbox, this does not hibernate the sandbox (but it will
   * automatically hibernate after an inactivity timer).
   */
  disconnect() {
    this.pitcherClient.disconnect();
    this.dispose();
  }
};
var Sandbox = class extends SandboxWithoutClient {
  constructor(sandboxClient, pitcherClient) {
    super(pitcherClient);
    this.sandboxClient = sandboxClient;
  }
  /**
   * This creates a copy of the current sandbox, both memory and disk is copied, which means
   * that running processes will continue to run in the forked sandbox.
   */
  async fork() {
    return this.sandboxClient.create({
      template: this.id
    });
  }
  /**
   * Hibernate the sandbox. This will snapshot the disk and memory of the sandbox, so it
   * can be restored later from the exact current state. Will resolve once the sandbox is hibernated.
   */
  async hibernate() {
    this.dispose();
    this.pitcherClient.disconnect();
    await this.sandboxClient.hibernate(this.id);
  }
  /**
   * Shutdown the sandbox. This will stop all running processes and stop the sandbox. When you
   * start the sandbox next time, you will still have the same files and state as when you
   * shut down the sandbox.
   *
   * Will resolve once the sandbox is shutdown.
   */
  async shutdown() {
    this.dispose();
    this.pitcherClient.disconnect();
    await this.sandboxClient.shutdown(this.id);
  }
  /**
   * Reboot the sandbox. This will shutdown the sandbox, and then start it again. Files in
   * the project directory (`/project/sandbox`) will be preserved.
   *
   * Will resolve once the sandbox is rebooted.
   */
  async reboot() {
    await this.shutdown();
    const newSandbox = await this.sandboxClient.open(this.id);
    Object.assign(this, newSandbox);
  }
  /**
   * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
   * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
   * than it can scale down to, it can become very slow.
   */
  async updateTier(tier) {
    await this.sandboxClient.updateTier(this.id, tier);
  }
};

// src/utils/rate-limit.ts
var RATE_LIMIT_HEADERS = {
  sandboxes: {
    unit: "sandboxes",
    remaining: "x-csb-sandbox-hourly-remaining",
    reset: "x-csb-sandbox-hourly-reset",
    used: "x-csb-sandbox-hourly-used"
  },
  requests: {
    unit: "requests",
    remaining: "x-csb-rate-hourly-remaining",
    reset: "x-csb-rate-hourly-reset",
    used: "x-csb-rate-hourly-used"
  },
  vms: {
    unit: "concurrently running vms",
    remaining: "x-csb-vms-remaining",
    used: "x-csb-vms-used"
  }
};
var RateLimitError = class _RateLimitError extends Error {
  constructor() {
    super(...arguments);
    this.type = "rate-limit";
  }
  static fromResponse(response, errorPrefix, serverError) {
    const headers = response.headers;
    const rateLimitRemainingExceeded = Object.values(RATE_LIMIT_HEADERS).find(
      (headers2) => {
        const remaining = response.headers.get(headers2.remaining);
        return remaining && parseInt(remaining) <= 0;
      }
    );
    if (rateLimitRemainingExceeded) {
      const total = parseInt(
        response.headers.get(rateLimitRemainingExceeded.remaining) ?? "0"
      ) + parseInt(response.headers.get(rateLimitRemainingExceeded.used) ?? "0");
      let message = `${errorPrefix}: 0 of ${total} ${rateLimitRemainingExceeded.unit} remaining.`;
      if (rateLimitRemainingExceeded.reset) {
        message += ` Limit resets at ${headers.get(
          rateLimitRemainingExceeded.reset
        )}.`;
      }
      message += " Contact hello@codesandbox.io to raise your rate limit.";
      return new _RateLimitError(message);
    }
    return new _RateLimitError(`${errorPrefix}: ${serverError}`);
  }
};

// src/utils/handle-response.ts
function handleResponse(result, errorPrefix) {
  if (result.response.status === 429 && "error" in result) {
    const error = result.error.errors[0];
    throw RateLimitError.fromResponse(result.response, errorPrefix, error);
  }
  if (result.response.status === 404) {
    throw new Error(errorPrefix + ": Sandbox not found");
  }
  if (result.response.status === 403) {
    throw new Error(errorPrefix + ": Unauthorized");
  }
  if (result.response.status === 502) {
    throw new Error(errorPrefix + ": Bad gateway");
  }
  if ("error" in result) {
    const error = result.error.errors[0];
    throw new Error(errorPrefix + ": " + error);
  }
  if (!result.data || !result.data.data) {
    throw new Error(errorPrefix + ": No data returned");
  }
  return result.data.data;
}

// src/sandbox-client.ts
var DEFAULT_SUBSCRIPTIONS = {
  client: {
    status: true
  },
  file: {
    status: true,
    selection: true,
    ot: true
  },
  fs: {
    operations: true
  },
  git: {
    status: true,
    operations: true
  },
  port: {
    status: true
  },
  setup: {
    progress: true
  },
  shell: {
    status: true
  },
  system: {
    metrics: true
  }
};
var VMTier = class _VMTier {
  constructor(name, cpuCores, memoryGiB, diskGB) {
    this.name = name;
    this.cpuCores = cpuCores;
    this.memoryGiB = memoryGiB;
    this.diskGB = diskGB;
  }
  static {
    /** 1 CPU, 2GiB RAM */
    this.Pico = new _VMTier("Pico", 1, 2, 20);
  }
  static {
    /** 2 CPU, 4GiB RAM */
    this.Nano = new _VMTier("Nano", 2, 4, 20);
  }
  static {
    /** 4 CPU, 8GiB RAM */
    this.Micro = new _VMTier("Micro", 4, 8, 20);
  }
  static {
    /** 8 CPU, 16GiB RAM */
    this.Small = new _VMTier("Small", 8, 16, 30);
  }
  static {
    /** 16 CPU, 32GiB RAM */
    this.Medium = new _VMTier("Medium", 16, 32, 40);
  }
  static {
    /** 32 CPU, 64GiB RAM */
    this.Large = new _VMTier("Large", 32, 64, 50);
  }
  static {
    /** 64 CPU, 128GiB RAM */
    this.XLarge = new _VMTier("XLarge", 64, 128, 50);
  }
  static fromName(name) {
    return _VMTier[name];
  }
  /**
   * Returns the tier that complies to the given minimum specs.
   * @param cpuCores Amount of CPU cores needed
   * @param memoryGiB Amount of memory needed in GiB
   * @param diskGB Amount of disk space needed in GB
   */
  static fromSpecs(specs) {
    return Object.values(_VMTier).find(
      (tier) => tier.cpuCores >= specs.cpu && tier.memoryGiB >= specs.memGiB && (specs.diskGB === void 0 || tier.diskGB >= specs.diskGB)
    );
  }
};
function startOptionsFromOpts(opts) {
  if (!opts) return void 0;
  return {
    ipcountry: opts.ipcountry,
    tier: opts.vmTier?.name,
    hibernation_timeout_seconds: opts.hibernationTimeoutSeconds
  };
}
var SandboxClient = class {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  get defaultTemplate() {
    if (this.apiClient.getConfig().baseUrl?.includes("codesandbox.stream")) {
      return "7ngcrf";
    }
    return "pcz35m";
  }
  /**
   * Open, start & connect to a sandbox that already exists
   */
  async open(id, startOpts) {
    return this.connectToSandbox(id, () => this.start(id, startOpts));
  }
  /**
   * Try to start a sandbox that already exists, it will return the data of the started
   * VM, which you can pass to the browser. In the browser you can call `connectToSandbox` with this
   * data to control the VM without sharing your CodeSandbox API token in the browser.
   *
   * @param id the ID of the sandbox
   * @returns The start data, contains a single use token to connect to the VM
   */
  async start(id, opts) {
    const startResult = await vmStart({
      client: this.apiClient,
      body: startOptionsFromOpts(opts),
      path: {
        id
      }
    });
    const data = handleResponse(startResult, `Failed to start sandbox ${id}`);
    return data;
  }
  async create(opts) {
    const templateId = opts?.template || this.defaultTemplate;
    const privacy = opts?.privacy || "public";
    const tags = opts?.tags || ["sdk"];
    const path = opts?.path || "/SDK";
    const tagsWithSdk = tags.includes("sdk") ? tags : [...tags, "sdk"];
    const result = await sandboxFork({
      client: this.apiClient,
      body: {
        privacy: privacyToNumber(privacy),
        title: opts?.title,
        description: opts?.description,
        tags: tagsWithSdk,
        path,
        start_options: opts?.autoConnect === false ? void 0 : startOptionsFromOpts(opts || {})
      },
      path: {
        id: typeof templateId === "string" ? templateId : templateId.id
      }
    });
    const sandbox = handleResponse(result, "Failed to create sandbox");
    return this.connectToSandbox(sandbox.id, () => {
      if (sandbox.start_response) {
        return Promise.resolve(sandbox.start_response);
      }
      return this.start(sandbox.id, opts);
    });
  }
  async fork(id, opts = {}) {
    return this.create({ ...opts, template: id });
  }
  /**
   * Shuts down a sandbox. Files will be saved, and the sandbox will be stopped.
   *
   * @param id The ID of the sandbox to shutdown
   */
  async shutdown(id) {
    const response = await vmShutdown({
      client: this.apiClient,
      path: {
        id
      }
    });
    handleResponse(response, `Failed to shutdown sandbox ${id}`);
  }
  /**
   * Hibernates a sandbox. Files will be saved, and the sandbox will be put to sleep. Next time
   * you start the sandbox it will be resumed from the last state it was in.
   *
   * @param id The ID of the sandbox to hibernate
   */
  async hibernate(id) {
    const response = await vmHibernate({
      client: this.apiClient,
      path: {
        id
      }
    });
    handleResponse(response, `Failed to hibernate sandbox ${id}`);
  }
  /**
   * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
   * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
   * than it can scale down to, it can become very slow.
   *
   * @param id The ID of the sandbox to update
   * @param tier The new VM tier
   */
  async updateTier(id, tier) {
    const response = await vmUpdateSpecs({
      client: this.apiClient,
      path: { id },
      body: {
        tier: tier.name
      }
    });
    handleResponse(response, `Failed to update sandbox tier ${id}`);
  }
  async connectToSandbox(id, startVm) {
    const pitcherClient = await initPitcherClient(
      {
        appId: "sdk",
        instanceId: id,
        onFocusChange() {
          return () => {
          };
        },
        requestPitcherInstance: async () => {
          const data = await startVm();
          const headers = this.apiClient.getConfig().headers;
          if (headers.get("x-pitcher-manager-url")) {
            const preferredManager = headers.get("x-pitcher-manager-url")?.replace("/api/v1", "").replace("https://", "");
            const baseUrl = this.apiClient.getConfig().baseUrl?.replace("api", "global-scheduler");
            await fetch(
              `${baseUrl}/api/v1/cluster/${data.id}?preferredManager=${preferredManager}`
            ).then((res) => res.json());
          }
          return {
            bootupType: data.bootup_type,
            pitcherURL: data.pitcher_url,
            workspacePath: data.workspace_path,
            userWorkspacePath: data.user_workspace_path,
            pitcherManagerVersion: data.pitcher_manager_version,
            pitcherVersion: data.pitcher_version,
            latestPitcherVersion: data.latest_pitcher_version,
            pitcherToken: data.pitcher_token,
            cluster: data.cluster
          };
        },
        subscriptions: DEFAULT_SUBSCRIPTIONS
      },
      () => {
      }
    );
    return new Sandbox(this, pitcherClient);
  }
};
function privacyToNumber(privacy) {
  switch (privacy) {
    case "public":
      return 0;
    case "unlisted":
      return 1;
    case "private":
      return 2;
  }
}

// src/index.ts
function ensure(value, message) {
  if (!value) {
    throw new Error(message);
  }
  return value;
}
function getBaseUrl(token) {
  if (token.startsWith("csb_")) {
    return "https://api.codesandbox.io";
  }
  return "https://api.together.ai/csb/sdk";
}
var CodeSandbox = class {
  constructor(apiToken, opts = {}) {
    this.opts = opts;
    this.apiToken = apiToken || ensure(
      typeof process !== "undefined" ? process.env?.CSB_API_KEY || process.env?.TOGETHER_API_KEY : void 0,
      "CSB_API_KEY or TOGETHER_API_KEY is not set"
    );
    this.baseUrl = opts.baseUrl ?? getBaseUrl(this.apiToken);
    this.apiClient = L(
      z({
        baseUrl: this.baseUrl,
        headers: {
          Authorization: `Bearer ${this.apiToken}`,
          ...opts.headers ?? {}
        }
      })
    );
    this.sandbox = new SandboxClient(this.apiClient);
  }
};
export {
  CodeSandbox,
  PortInfo,
  Sandbox,
  SandboxClient,
  SandboxWithoutClient,
  VMTier
};
/*! Bundled license information:

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
