import type { Client } from "@hey-api/client-fetch";
import type { VmStartResponse, tier } from "./client";
import { Sandbox } from "./sandbox";
export type SandboxPrivacy = "public" | "unlisted" | "private";
export type SandboxStartData = Required<VmStartResponse>["data"];
export declare const DEFAULT_SUBSCRIPTIONS: {
    client: {
        status: boolean;
    };
    file: {
        status: boolean;
        selection: boolean;
        ot: boolean;
    };
    fs: {
        operations: boolean;
    };
    git: {
        status: boolean;
        operations: boolean;
    };
    port: {
        status: boolean;
    };
    setup: {
        progress: boolean;
    };
    shell: {
        status: boolean;
    };
    system: {
        metrics: boolean;
    };
};
export type CreateSandboxOpts = {
    /**
     * What template to fork from, this is the id of another sandbox. Defaults to our
     * [universal template](https://codesandbox.io/s/github/codesandbox/sandbox-templates/tree/main/universal).
     */
    template?: string | Sandbox;
    /**
     * What the privacy of the new sandbox should be. Defaults to "public".
     */
    privacy?: SandboxPrivacy;
    /**
     * The title of the new sandbox.
     */
    title?: string;
    /**
     * The description of the new sandbox.
     */
    description?: string;
    /**
     * Whether to automatically connect to the sandbox after creation. If this is set to `false`,
     * the sandbox will not be connected to, and you will have to call {@link SandboxClient.start}
     * yourself or pass the returned start data to the browser.
     */
    autoConnect?: boolean;
    /**
     * Which tags to add to the sandbox, can be used for categorization and filtering. Max 10 tags.
     */
    tags?: string[];
    /**
     * In which folder to put the sandbox in (inside your workspace).
     */
    path?: string;
} & StartSandboxOpts;
/**
 * A VM tier is how we classify the specs of a VM. You can use this to request a VM with specific
 * specs.
 *
 * You can either get a tier by its name, or by specifying the minimum specs you need.
 *
 * ## Example
 *
 * ```ts
 * const tier = VMTier.Pico;
 * ```
 *
 * ```ts
 * const tier = VMTier.fromSpecs(16, 32, 40);
 * ```
 */
export declare class VMTier {
    readonly name: tier;
    readonly cpuCores: number;
    readonly memoryGiB: number;
    readonly diskGB: number;
    /** 1 CPU, 2GiB RAM */
    static readonly Pico: VMTier;
    /** 2 CPU, 4GiB RAM */
    static readonly Nano: VMTier;
    /** 4 CPU, 8GiB RAM */
    static readonly Micro: VMTier;
    /** 8 CPU, 16GiB RAM */
    static readonly Small: VMTier;
    /** 16 CPU, 32GiB RAM */
    static readonly Medium: VMTier;
    /** 32 CPU, 64GiB RAM */
    static readonly Large: VMTier;
    /** 64 CPU, 128GiB RAM */
    static readonly XLarge: VMTier;
    private constructor();
    static fromName(name: tier): VMTier;
    /**
     * Returns the tier that complies to the given minimum specs.
     * @param cpuCores Amount of CPU cores needed
     * @param memoryGiB Amount of memory needed in GiB
     * @param diskGB Amount of disk space needed in GB
     */
    static fromSpecs(specs: {
        cpu: number;
        memGiB: number;
        diskGB?: number;
    }): VMTier | undefined;
}
export interface StartSandboxOpts {
    /**
     * Country, served as a hint on where you want the sandbox to be scheduled. For example, if "NL" is given
     * as a country, the sandbox will be scheduled in a cluster inside Europe. Note that this is not a guarantee,
     * and the sandbox might end up in a different region based on availability and scheduling decisions.
     *
     * Follows ISO 3166-1 alpha-2 codes.
     */
    ipcountry?: string;
    /**
     * Determines which specs to start the VM with. If not specified, the VM will start with the default specs for the workspace.
     * Check {@link VMTier} for available tiers.
     *
     * You can only specify a VM tier when starting a VM that is inside your workspace.
     * Specifying a VM tier for someone else's sandbox will return an error.
     */
    vmTier?: VMTier;
    /**
     * The amount of seconds to wait before hibernating the sandbox after inactivity.
     *
     * Defaults to 300 seconds for free users, 1800 seconds for pro users. Maximum is 86400 seconds (1 day).
     */
    hibernationTimeoutSeconds?: number;
}
export type HandledResponse<D, E> = {
    data?: {
        data?: D;
    };
    error?: E;
    response: Response;
};
export declare class SandboxClient {
    private readonly apiClient;
    constructor(apiClient: Client);
    private get defaultTemplate();
    /**
     * Open, start & connect to a sandbox that already exists
     */
    open(id: string, startOpts?: StartSandboxOpts): Promise<Sandbox>;
    /**
     * Try to start a sandbox that already exists, it will return the data of the started
     * VM, which you can pass to the browser. In the browser you can call `connectToSandbox` with this
     * data to control the VM without sharing your CodeSandbox API token in the browser.
     *
     * @param id the ID of the sandbox
     * @returns The start data, contains a single use token to connect to the VM
     */
    start(id: string, opts?: StartSandboxOpts): Promise<SandboxStartData>;
    /**
     * Creates a sandbox by forking a template. You can pass in any template or sandbox id (from
     * any sandbox/template created on codesandbox.io, even your own templates) or don't pass
     * in anything and we'll use the default universal template.
     *
     * This function will also start & connect to the VM of the created sandbox, and return a {@link Sandbox}
     * that allows you to control the VM.
     *
     * @param opts Additional options for creating the sandbox
     *
     * @returns A promise that resolves to a {@link Sandbox}, which you can use to control the VM
     */
    create(opts: {
        autoConnect: false;
    } & CreateSandboxOpts): Promise<SandboxStartData>;
    create(opts?: {
        autoConnect?: true;
    } & CreateSandboxOpts): Promise<Sandbox>;
    create(opts?: CreateSandboxOpts): Promise<Sandbox>;
    /**
     * This is the same functionality as {@link SandboxClient.create}, but added to make forking more
     * discoverable.
     */
    fork(id: string, opts: {
        autoConnect: false;
    } & Omit<CreateSandboxOpts, "template">): Promise<SandboxStartData>;
    fork(id: string, opts?: {
        autoConnect?: true;
    } & Omit<CreateSandboxOpts, "template">): Promise<Sandbox>;
    fork(id: string, opts?: Omit<CreateSandboxOpts, "template">): Promise<Sandbox>;
    /**
     * Shuts down a sandbox. Files will be saved, and the sandbox will be stopped.
     *
     * @param id The ID of the sandbox to shutdown
     */
    shutdown(id: string): Promise<void>;
    /**
     * Hibernates a sandbox. Files will be saved, and the sandbox will be put to sleep. Next time
     * you start the sandbox it will be resumed from the last state it was in.
     *
     * @param id The ID of the sandbox to hibernate
     */
    hibernate(id: string): Promise<void>;
    /**
     * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
     * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
     * than it can scale down to, it can become very slow.
     *
     * @param id The ID of the sandbox to update
     * @param tier The new VM tier
     */
    updateTier(id: string, tier: VMTier): Promise<void>;
    private connectToSandbox;
}
