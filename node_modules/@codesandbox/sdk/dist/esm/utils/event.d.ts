import { type IDisposable } from "./disposable";
/**
 * A typed event.
 */
export interface Event<T> {
    /**
     *
     * @param listener The listener function will be called when the event happens.
     * @return a disposable to remove the listener again.
     */
    (listener: (e: T) => void): IDisposable;
}
/**
 * Waits for the event to fire, then resolves the promise once finished
 */
export declare function listenOnce<T>(event: Event<T>, condition?: (ev: T) => boolean): Promise<T>;
export declare function onceEvent<T>(event: Event<T>): Event<T>;
export declare class Emitter<T> implements IDisposable {
    private registeredListeners;
    private _event;
    get event(): Event<T>;
    /** Invoke all listeners registered to this event. */
    fire(event: T): void;
    dispose(): void;
}
/**
 * A typed event.
 */
export interface AsyncEvent<T> {
    /**
     *
     * @param listener The listener function will be called when the event happens
     * @return a disposable to remove the listener again.
     */
    (listener: (e: T) => Promise<void>): IDisposable;
}
/**
 * Works just like Emitter, but requires the listeners to return a promise. When "fire" is called
 * it will be resolved rejected, based on calling the listeners. The constructor takes a timeout
 */
export declare class AsyncEmitter<T> implements IDisposable {
    private timeoutMs;
    private registeredListeners;
    private _event;
    constructor(timeoutMs: number);
    get event(): AsyncEvent<T>;
    /** Invoke all listeners registered to this event and wait for them to resolve, unless timeout occurs. */
    fire(event: T): Promise<void>;
    dispose(): void;
}
