import { Disposable, type IPitcherClient } from "@codesandbox/pitcher-client";
import { FileSystem } from "./filesystem";
import { Ports } from "./ports";
import { Setup } from "./setup";
import { Shells } from "./shells";
import { Tasks } from "./tasks";
import type { SandboxClient, VMTier } from ".";
export { FSStatResult, WriteFileOpts, ReaddirEntry, WatchOpts, WatchEvent, Watcher, } from "./filesystem";
export { PortInfo } from "./ports";
export { SetupProgress, Step, SetupShellStatus } from "./setup";
export { RunningCommand, ShellSize, ShellStatus, ShellCreateOpts, ShellRunOpts, ShellOpenOpts, } from "./shells";
export { Task, TaskDefinition } from "./tasks";
export interface SystemMetricsStatus {
    cpu: {
        cores: number;
        used: number;
        configured: number;
    };
    memory: {
        usedKiB: number;
        totalKiB: number;
        configuredKiB: number;
    };
    storage: {
        usedKB: number;
        totalKB: number;
        configuredKB: number;
    };
}
export declare class SandboxWithoutClient extends Disposable {
    protected pitcherClient: IPitcherClient;
    /**
     * Namespace for all filesystem operations on this sandbox.
     */
    readonly fs: FileSystem;
    /**
     * Namespace for running shell commands on this sandbox.
     */
    readonly shells: Shells;
    /**
     * Namespace for detecting open ports on this sandbox, and getting preview URLs for
     * them.
     */
    readonly ports: Ports;
    /**
     * Namespace for all setup operations on this sandbox (installing dependencies, etc).
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    readonly setup: Setup;
    /**
     * Namespace for all task operations on a sandbox. This includes running tasks,
     * getting tasks, and stopping tasks.
     *
     * In CodeSandbox, you can create tasks and manage them by creating a `.codesandbox/tasks.json`
     * in the sandbox. These tasks become available under this namespace, this way you can manage
     * tasks that you will need to run more often (like a dev server).
     *
     * More documentation: https://codesandbox.io/docs/learn/devboxes/task#adding-and-configuring-tasks
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    readonly tasks: Tasks;
    constructor(pitcherClient: IPitcherClient);
    /**
     * The ID of the sandbox.
     */
    get id(): string;
    /**
     * Get the URL to the editor for this sandbox. Keep in mind that this URL is not
     * available if the sandbox is private, and the user opening this sandbox does not
     * have access to the sandbox.
     */
    get editorUrl(): string;
    /**
     * Disconnect from the sandbox, this does not hibernate the sandbox (but it will
     * automatically hibernate after an inactivity timer).
     */
    disconnect(): void;
}
export declare class Sandbox extends SandboxWithoutClient {
    private sandboxClient;
    constructor(sandboxClient: SandboxClient, pitcherClient: IPitcherClient);
    /**
     * This creates a copy of the current sandbox, both memory and disk is copied, which means
     * that running processes will continue to run in the forked sandbox.
     */
    fork(): Promise<Sandbox>;
    /**
     * Hibernate the sandbox. This will snapshot the disk and memory of the sandbox, so it
     * can be restored later from the exact current state. Will resolve once the sandbox is hibernated.
     */
    hibernate(): Promise<void>;
    /**
     * Shutdown the sandbox. This will stop all running processes and stop the sandbox. When you
     * start the sandbox next time, you will still have the same files and state as when you
     * shut down the sandbox.
     *
     * Will resolve once the sandbox is shutdown.
     */
    shutdown(): Promise<void>;
    /**
     * Reboot the sandbox. This will shutdown the sandbox, and then start it again. Files in
     * the project directory (`/project/sandbox`) will be preserved.
     *
     * Will resolve once the sandbox is rebooted.
     */
    reboot(): Promise<void>;
    /**
     * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
     * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
     * than it can scale down to, it can become very slow.
     */
    updateTier(tier: VMTier): Promise<void>;
}
