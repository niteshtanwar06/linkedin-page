#!/usr/bin/env node


"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@codesandbox/pitcher-common/dist/Barrier.js
var require_Barrier = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Barrier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClosableBarrier = exports2.Barrier = void 0;
    var Barrier5 = class {
      _isOpen;
      _promise;
      _completePromise;
      constructor() {
        this._isOpen = false;
        this._promise = new Promise((resolve5) => {
          this._completePromise = resolve5;
        });
      }
      /**
       * Returns true if the barrier is open, false if it is closed
       * @returns true if the barrier is open, false if it is closed
       */
      isOpen() {
        return this._isOpen;
      }
      /**
       * Opens the barrier. If the barrier is already open, this method does nothing.
       * @param value the value to return when the barrier is opened
       * @returns
       */
      open(value) {
        if (this._isOpen) {
          return;
        }
        this._isOpen = true;
        this._completePromise({ status: "resolved", value });
      }
      /**
       *
       * @returns a promise that resolves when the barrier is opened. If the barrier is already open, the promise resolves immediately.
       */
      wait() {
        return this._promise;
      }
      /**
       * DO NOT USE THIS METHOD in production code. This is only for tests.
       * This is a convenience method that waits for the barrier to open and then returns the value.
       * If the Barrier is disposed while waiting to open, an error is thrown.
       * @returns the value if the barrier is open, otherwise throws an error
       */
      async __waitAndThrowIfDisposed() {
        const r3 = await this.wait();
        if (r3.status === "disposed") {
          throw new Error("Barrier was disposed");
        }
        return r3.value;
      }
      /**
       * Disposes the barrier.
       * If there is a promise waiting for the barrier to open, it will be resolved with a status of "disposed".
       */
      dispose() {
        this._completePromise({ status: "disposed" });
      }
    };
    exports2.Barrier = Barrier5;
    var ClosableBarrier2 = class extends Barrier5 {
      close() {
        this._isOpen = false;
        this._promise = new Promise((resolve5) => {
          this._completePromise = resolve5;
        });
      }
    };
    exports2.ClosableBarrier = ClosableBarrier2;
  }
});

// node_modules/uuid/dist/cjs/max.js
var require_max = __commonJS({
  "node_modules/uuid/dist/cjs/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/uuid/dist/cjs/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/cjs/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/cjs/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/cjs/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist/cjs/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/cjs/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var regex_js_1 = require_regex();
    function validate(uuid) {
      return typeof uuid === "string" && regex_js_1.default.test(uuid);
    }
    exports2.default = validate;
  }
});

// node_modules/uuid/dist/cjs/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/cjs/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function parse(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v3;
      return Uint8Array.of((v3 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v3 >>> 16 & 255, v3 >>> 8 & 255, v3 & 255, (v3 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v3 & 255, (v3 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v3 / 4294967296 & 255, v3 >>> 24 & 255, v3 >>> 16 & 255, v3 >>> 8 & 255, v3 & 255);
    }
    exports2.default = parse;
  }
});

// node_modules/uuid/dist/cjs/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/cjs/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unsafeStringify = unsafeStringify;
    var validate_js_1 = require_validate();
    var byteToHex = [];
    for (let i4 = 0; i4 < 256; ++i4) {
      byteToHex.push((i4 + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    exports2.default = stringify;
  }
});

// node_modules/uuid/dist/cjs/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/cjs/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = rng;
    var crypto_1 = require("crypto");
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        (0, crypto_1.randomFillSync)(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// node_modules/uuid/dist/cjs/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/cjs/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateV1State = updateV1State;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v1(options, buf, offset) {
      let bytes;
      const isV6 = options?._v6 ?? false;
      if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
          options = void 0;
        }
      }
      if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
      }
      return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV1State(state, now, rnds) {
      state.msecs ??= -Infinity;
      state.nsecs ??= 0;
      if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 1e4) {
          state.node = void 0;
          state.nsecs = 0;
        }
      } else if (now > state.msecs) {
        state.nsecs = 0;
      } else if (now < state.msecs) {
        state.node = void 0;
      }
      if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 1;
        state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
      }
      state.msecs = now;
      return state;
    }
    function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      }
      msecs ??= Date.now();
      nsecs ??= 0;
      clockseq ??= (rnds[8] << 8 | rnds[9]) & 16383;
      node ??= rnds.slice(10, 16);
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      buf[offset++] = tl >>> 24 & 255;
      buf[offset++] = tl >>> 16 & 255;
      buf[offset++] = tl >>> 8 & 255;
      buf[offset++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      buf[offset++] = tmh >>> 8 & 255;
      buf[offset++] = tmh & 255;
      buf[offset++] = tmh >>> 24 & 15 | 16;
      buf[offset++] = tmh >>> 16 & 255;
      buf[offset++] = clockseq >>> 8 | 128;
      buf[offset++] = clockseq & 255;
      for (let n2 = 0; n2 < 6; ++n2) {
        buf[offset++] = node[n2];
      }
      return buf;
    }
    exports2.default = v1;
  }
});

// node_modules/uuid/dist/cjs/v1ToV6.js
var require_v1ToV6 = __commonJS({
  "node_modules/uuid/dist/cjs/v1ToV6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = v1ToV6;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v1ToV6(uuid) {
      const v1Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v6Bytes = _v1ToV6(v1Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
    }
    function _v1ToV6(v1Bytes) {
      return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
    }
  }
});

// node_modules/uuid/dist/cjs/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/cjs/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return (0, crypto_1.createHash)("md5").update(bytes).digest();
    }
    exports2.default = md5;
  }
});

// node_modules/uuid/dist/cjs/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/cjs/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = void 0;
    exports2.stringToBytes = stringToBytes;
    exports2.default = v35;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = new Uint8Array(str.length);
      for (let i4 = 0; i4 < str.length; ++i4) {
        bytes[i4] = str.charCodeAt(i4);
      }
      return bytes;
    }
    exports2.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    function v35(version, hash, value, namespace, buf, offset) {
      const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
      const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1.default)(namespace) : namespace;
      if (typeof namespace === "string") {
        namespace = (0, parse_js_1.default)(namespace);
      }
      if (namespace?.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + valueBytes.length);
      bytes.set(namespaceBytes);
      bytes.set(valueBytes, namespaceBytes.length);
      bytes = hash(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i4 = 0; i4 < 16; ++i4) {
          buf[offset + i4] = bytes[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
  }
});

// node_modules/uuid/dist/cjs/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/cjs/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = void 0;
    var md5_js_1 = require_md5();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports2, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v3(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value, namespace, buf, offset);
    }
    v3.DNS = v35_js_1.DNS;
    v3.URL = v35_js_1.URL;
    exports2.default = v3;
  }
});

// node_modules/uuid/dist/cjs/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/cjs/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    exports2.default = { randomUUID: crypto_1.randomUUID };
  }
});

// node_modules/uuid/dist/cjs/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/cjs/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var native_js_1 = require_native();
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    function v4(options, buf, offset) {
      if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || rng_js_1.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i4 = 0; i4 < 16; ++i4) {
          buf[offset + i4] = rnds[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(rnds);
    }
    exports2.default = v4;
  }
});

// node_modules/uuid/dist/cjs/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/cjs/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return (0, crypto_1.createHash)("sha1").update(bytes).digest();
    }
    exports2.default = sha1;
  }
});

// node_modules/uuid/dist/cjs/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/cjs/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = void 0;
    var sha1_js_1 = require_sha1();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports2, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v5(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace, buf, offset);
    }
    v5.DNS = v35_js_1.DNS;
    v5.URL = v35_js_1.URL;
    exports2.default = v5;
  }
});

// node_modules/uuid/dist/cjs/v6.js
var require_v6 = __commonJS({
  "node_modules/uuid/dist/cjs/v6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stringify_js_1 = require_stringify();
    var v1_js_1 = require_v1();
    var v1ToV6_js_1 = require_v1ToV6();
    function v6(options, buf, offset) {
      options ??= {};
      offset ??= 0;
      let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
      bytes = (0, v1ToV6_js_1.default)(bytes);
      if (buf) {
        for (let i4 = 0; i4 < 16; i4++) {
          buf[offset + i4] = bytes[i4];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports2.default = v6;
  }
});

// node_modules/uuid/dist/cjs/v6ToV1.js
var require_v6ToV1 = __commonJS({
  "node_modules/uuid/dist/cjs/v6ToV1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = v6ToV1;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v6ToV1(uuid) {
      const v6Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v1Bytes = _v6ToV1(v6Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
    }
    function _v6ToV1(v6Bytes) {
      return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
    }
  }
});

// node_modules/uuid/dist/cjs/v7.js
var require_v7 = __commonJS({
  "node_modules/uuid/dist/cjs/v7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateV7State = updateV7State;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v7(options, buf, offset) {
      let bytes;
      if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
      }
      return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV7State(state, now, rnds) {
      state.msecs ??= -Infinity;
      state.seq ??= 0;
      if (now > state.msecs) {
        state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
        state.msecs = now;
      } else {
        state.seq = state.seq + 1 | 0;
        if (state.seq === 0) {
          state.msecs++;
        }
      }
      return state;
    }
    function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      }
      msecs ??= Date.now();
      seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
      buf[offset++] = msecs / 1099511627776 & 255;
      buf[offset++] = msecs / 4294967296 & 255;
      buf[offset++] = msecs / 16777216 & 255;
      buf[offset++] = msecs / 65536 & 255;
      buf[offset++] = msecs / 256 & 255;
      buf[offset++] = msecs & 255;
      buf[offset++] = 112 | seq >>> 28 & 15;
      buf[offset++] = seq >>> 20 & 255;
      buf[offset++] = 128 | seq >>> 14 & 63;
      buf[offset++] = seq >>> 6 & 255;
      buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
      buf[offset++] = rnds[11];
      buf[offset++] = rnds[12];
      buf[offset++] = rnds[13];
      buf[offset++] = rnds[14];
      buf[offset++] = rnds[15];
      return buf;
    }
    exports2.default = v7;
  }
});

// node_modules/uuid/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/cjs/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function version(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    exports2.default = version;
  }
});

// node_modules/uuid/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/uuid/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = exports2.validate = exports2.v7 = exports2.v6ToV1 = exports2.v6 = exports2.v5 = exports2.v4 = exports2.v3 = exports2.v1ToV6 = exports2.v1 = exports2.stringify = exports2.parse = exports2.NIL = exports2.MAX = void 0;
    var max_js_1 = require_max();
    Object.defineProperty(exports2, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = require_nil();
    Object.defineProperty(exports2, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = require_parse();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = require_v1();
    Object.defineProperty(exports2, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = require_v1ToV6();
    Object.defineProperty(exports2, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = require_v3();
    Object.defineProperty(exports2, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = require_v4();
    Object.defineProperty(exports2, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = require_v5();
    Object.defineProperty(exports2, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = require_v6();
    Object.defineProperty(exports2, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = require_v6ToV1();
    Object.defineProperty(exports2, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = require_v7();
    Object.defineProperty(exports2, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = require_validate();
    Object.defineProperty(exports2, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = require_version();
    Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Id.js
var require_Id = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newId = void 0;
    var uuid_1 = require_cjs();
    var newId5 = () => (0, uuid_1.v4)();
    exports2.newId = newId5;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/sleep.js
var require_sleep = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/sleep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sleep = void 0;
    function sleep5(ms) {
      return new Promise((resolve5) => setTimeout(resolve5, ms));
    }
    exports2.sleep = sleep5;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/event.js
var require_event = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/event.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncEmitter = exports2.Emitter = exports2.onceEvent = exports2.listenOnce = void 0;
    var Disposable_1 = require_Disposable();
    var sleep_1 = require_sleep();
    function listenOnce3(event, condition) {
      return new Promise((resolve5) => {
        const disposable = event((result) => {
          if (typeof condition === "undefined" || condition(result)) {
            disposable.dispose();
            resolve5(result);
          }
        });
      });
    }
    exports2.listenOnce = listenOnce3;
    function onceEvent(event) {
      return (listener, thisArgs) => {
        const result = event((e3) => {
          result.dispose();
          return listener.call(thisArgs, e3);
        });
        return result;
      };
    }
    exports2.onceEvent = onceEvent;
    var Emitter29 = class {
      registeredListeners = /* @__PURE__ */ new Set();
      _event;
      get event() {
        if (!this._event) {
          this._event = (listener) => {
            this.registeredListeners.add(listener);
            return Disposable_1.Disposable.create(() => {
              this.registeredListeners.delete(listener);
            });
          };
        }
        return this._event;
      }
      /** Invoke all listeners registered to this event. */
      fire(event) {
        this.registeredListeners.forEach((listener) => {
          listener(event);
        });
      }
      dispose() {
        this.registeredListeners = /* @__PURE__ */ new Set();
      }
    };
    exports2.Emitter = Emitter29;
    var AsyncEmitter = class {
      timeoutMs;
      registeredListeners = /* @__PURE__ */ new Set();
      _event;
      constructor(timeoutMs) {
        this.timeoutMs = timeoutMs;
      }
      get event() {
        if (!this._event) {
          this._event = (listener) => {
            this.registeredListeners.add(listener);
            return Disposable_1.Disposable.create(() => {
              this.registeredListeners.delete(listener);
            });
          };
        }
        return this._event;
      }
      /** Invoke all listeners registered to this event and wait for them to resolve, unless timeout occurs. */
      fire(event) {
        return Promise.race([
          (0, sleep_1.sleep)(this.timeoutMs).then(() => {
            throw new Error("Timeout firing async event");
          }),
          // We run all listeners in parallel, where if any fails, the firing of the event fails
          Promise.allSettled(Array.from(this.registeredListeners).map((listener) => listener(event))).then((results) => {
            for (const result of results) {
              if (result.status === "rejected") {
                throw result.reason;
              }
            }
          })
        ]);
      }
      dispose() {
        this.registeredListeners = /* @__PURE__ */ new Set();
      }
    };
    exports2.AsyncEmitter = AsyncEmitter;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Disposable.js
var require_Disposable = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DisposableStore = exports2.Disposable = void 0;
    var event_1 = require_event();
    var Disposable17 = class _Disposable {
      onWillDisposeEmitter = new event_1.Emitter();
      onWillDispose = this.onWillDisposeEmitter.event;
      onDidDisposeEmitter = new event_1.Emitter();
      onDidDispose = this.onDidDisposeEmitter.event;
      toDispose = [];
      isDisposed = false;
      addDisposable(disposable) {
        this.toDispose.push(disposable);
        return disposable;
      }
      onDispose(cb) {
        this.toDispose.push(_Disposable.create(cb));
      }
      dispose() {
        if (this.isDisposed)
          return;
        this.onWillDisposeEmitter.fire(null);
        this.isDisposed = true;
        this.toDispose.forEach((disposable) => {
          disposable.dispose();
        });
        this.onDidDisposeEmitter.fire(null);
        this.onWillDisposeEmitter.dispose();
        this.onDidDisposeEmitter.dispose();
      }
      static is(arg) {
        return typeof arg["dispose"] === "function";
      }
      static create(cb) {
        return {
          dispose: cb
        };
      }
    };
    exports2.Disposable = Disposable17;
    var DisposableStore4 = class _DisposableStore {
      static DISABLE_DISPOSED_WARNING = false;
      _toDispose = /* @__PURE__ */ new Set();
      _isDisposed = false;
      /**
       * Dispose of all registered disposables and mark this object as disposed.
       *
       * Any future disposables added to this object will be disposed of on `add`.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.clear();
      }
      /**
       * Dispose of all registered disposables but do not mark this object as disposed.
       */
      clear() {
        try {
          for (const disposable of this._toDispose.values()) {
            disposable.dispose();
          }
        } finally {
          this._toDispose.clear();
        }
      }
      add(o2) {
        if (!o2) {
          return o2;
        }
        if (o2 === this) {
          throw new Error("Cannot register a disposable on itself!");
        }
        if (this._isDisposed) {
          if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
            console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
          }
        } else {
          this._toDispose.add(o2);
        }
        return o2;
      }
    };
    exports2.DisposableStore = DisposableStore4;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/SliceList.js
var require_SliceList = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/SliceList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SliceList = void 0;
    var SliceList3 = class {
      idx = 0;
      store = /* @__PURE__ */ new Map();
      /**
       * Add a value to the list
       *
       * @returns a unique reference to delete the item
       */
      add(value) {
        const nextIdx = this.idx + 1;
        this.idx = nextIdx;
        this.store.set(nextIdx, value);
        return nextIdx;
      }
      /**
       * Remove a value using the unique reference
       */
      remove(idx) {
        this.store.delete(idx);
      }
      /**
       * Get values as an iterator
       */
      values() {
        return this.store.values();
      }
      /**
       * Get values as an array
       */
      array() {
        return Array.from(this.store.values());
      }
      /**
       * Get amount of items in the list
       */
      size() {
        return this.store.size;
      }
    };
    exports2.SliceList = SliceList3;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/EventEmitter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventEmitter = void 0;
    var Disposable_1 = require_Disposable();
    var SliceList_1 = require_SliceList();
    var EventEmitter2 = class extends Disposable_1.Disposable {
      registeredListeners = {};
      _on;
      constructor() {
        super();
        this.onWillDispose(() => {
          this.registeredListeners = {};
        });
      }
      // This is a trick that allows us to reference "on" directly
      // and still bind it to the instance
      get on() {
        if (!this._on) {
          this._on = (type, listener) => {
            if (!this.registeredListeners[type]) {
              this.registeredListeners[type] = new SliceList_1.SliceList();
            }
            const idx = this.registeredListeners[type].add(listener);
            const disposable = {
              dispose: () => {
                if (this.registeredListeners[type]) {
                  this.registeredListeners[type].remove(idx);
                }
              }
            };
            return disposable;
          };
        }
        return this._on;
      }
      onType(type) {
        return this.on.bind(this, type);
      }
      emit(type, data) {
        if (!this.registeredListeners[type]) {
          return;
        }
        for (const listener of this.registeredListeners[type].values()) {
          listener(data);
        }
      }
      emitType(type) {
        return this.emit.bind(this, type);
      }
    };
    exports2.EventEmitter = EventEmitter2;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/errors.js
var require_errors = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BugIndicatingError = exports2.ErrorNoTelemetry = exports2.CancellationError = exports2.isCancellationError = exports2.onUnexpectedError = exports2.errorHandler = exports2.ErrorHandler = void 0;
    var ErrorHandler = class {
      constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function(e3) {
          setTimeout(() => {
            if (e3.stack) {
              if (ErrorNoTelemetry.isErrorNoTelemetry(e3)) {
                throw new ErrorNoTelemetry(e3.message + "\n\n" + e3.stack);
              }
              throw new Error(e3.message + "\n\n" + e3.stack);
            }
            throw e3;
          }, 0);
        };
      }
      addListener(listener) {
        this.listeners.push(listener);
        return () => {
          this._removeListener(listener);
        };
      }
      emit(e3) {
        this.listeners.forEach((listener) => {
          listener(e3);
        });
      }
      _removeListener(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
      }
      setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
      }
      getUnexpectedErrorHandler() {
        return this.unexpectedErrorHandler;
      }
      onUnexpectedError(e3) {
        this.unexpectedErrorHandler(e3);
        this.emit(e3);
      }
      // For external errors, we don't want the listeners to be called
      onUnexpectedExternalError(e3) {
        this.unexpectedErrorHandler(e3);
      }
    };
    exports2.ErrorHandler = ErrorHandler;
    exports2.errorHandler = new ErrorHandler();
    function onUnexpectedError(e3) {
      if (!isCancellationError(e3)) {
        exports2.errorHandler.onUnexpectedError(e3);
      }
      return void 0;
    }
    exports2.onUnexpectedError = onUnexpectedError;
    var canceledName = "Canceled";
    function isCancellationError(error) {
      if (error instanceof CancellationError2) {
        return true;
      }
      return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports2.isCancellationError = isCancellationError;
    var CancellationError2 = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    exports2.CancellationError = CancellationError2;
    var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
      constructor(msg) {
        super(msg);
        this.name = "CodeExpectedError";
      }
      static fromError(err) {
        if (err instanceof _ErrorNoTelemetry) {
          return err;
        }
        const result = new _ErrorNoTelemetry();
        result.message = err.message;
        result.stack = err.stack;
        return result;
      }
      static isErrorNoTelemetry(err) {
        return err.name === "CodeExpectedError";
      }
    };
    exports2.ErrorNoTelemetry = ErrorNoTelemetry;
    var BugIndicatingError = class _BugIndicatingError extends Error {
      constructor(message) {
        super(message || "An unexpected bug occurred.");
        Object.setPrototypeOf(this, _BugIndicatingError.prototype);
      }
    };
    exports2.BugIndicatingError = BugIndicatingError;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/offsetRange.js
var require_offsetRange = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/offsetRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OffsetRangeSet = exports2.OffsetRange = void 0;
    var errors_1 = require_errors();
    var OffsetRange = class _OffsetRange {
      static addRange(range, sortedRanges) {
        let i4 = 0;
        while (i4 < sortedRanges.length && sortedRanges[i4].endExclusive < range.start) {
          i4++;
        }
        let j3 = i4;
        while (j3 < sortedRanges.length && sortedRanges[j3].start <= range.endExclusive) {
          j3++;
        }
        if (i4 === j3) {
          sortedRanges.splice(i4, 0, range);
        } else {
          const start = Math.min(range.start, sortedRanges[i4].start);
          const end = Math.max(range.endExclusive, sortedRanges[j3 - 1].endExclusive);
          sortedRanges.splice(i4, j3 - i4, new _OffsetRange(start, end));
        }
      }
      static tryCreate(start, endExclusive) {
        if (start > endExclusive) {
          return void 0;
        }
        return new _OffsetRange(start, endExclusive);
      }
      static ofLength(length) {
        return new _OffsetRange(0, length);
      }
      constructor(start, endExclusive) {
        this.start = start;
        this.endExclusive = endExclusive;
        if (start > endExclusive) {
          throw new errors_1.BugIndicatingError(`Invalid range: ${this.toString()}`);
        }
      }
      get isEmpty() {
        return this.start === this.endExclusive;
      }
      delta(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive + offset);
      }
      deltaStart(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive);
      }
      deltaEnd(offset) {
        return new _OffsetRange(this.start, this.endExclusive + offset);
      }
      get length() {
        return this.endExclusive - this.start;
      }
      toString() {
        return `[${this.start}, ${this.endExclusive})`;
      }
      equals(other) {
        return this.start === other.start && this.endExclusive === other.endExclusive;
      }
      containsRange(other) {
        return this.start <= other.start && other.endExclusive <= this.endExclusive;
      }
      contains(offset) {
        return this.start <= offset && offset < this.endExclusive;
      }
      /**
       * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
       * The joined range is the smallest range that contains both ranges.
       */
      join(other) {
        return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
      }
      /**
       * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
       *
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        if (start <= end) {
          return new _OffsetRange(start, end);
        }
        return void 0;
      }
      slice(arr) {
        return arr.slice(this.start, this.endExclusive);
      }
      /**
       * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
       * The range must not be empty.
       */
      clip(value) {
        if (this.isEmpty) {
          throw new errors_1.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        return Math.max(this.start, Math.min(this.endExclusive - 1, value));
      }
      /**
       * Returns `r := value + k * length` such that `r` is contained in this range.
       * The range must not be empty.
       *
       * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
       */
      clipCyclic(value) {
        if (this.isEmpty) {
          throw new errors_1.BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        if (value < this.start) {
          return this.endExclusive - (this.start - value) % this.length;
        }
        if (value >= this.endExclusive) {
          return this.start + (value - this.start) % this.length;
        }
        return value;
      }
    };
    exports2.OffsetRange = OffsetRange;
    var OffsetRangeSet = class _OffsetRangeSet {
      constructor() {
        this._sortedRanges = [];
      }
      addRange(range) {
        let i4 = 0;
        while (i4 < this._sortedRanges.length && this._sortedRanges[i4].endExclusive < range.start) {
          i4++;
        }
        let j3 = i4;
        while (j3 < this._sortedRanges.length && this._sortedRanges[j3].start <= range.endExclusive) {
          j3++;
        }
        if (i4 === j3) {
          this._sortedRanges.splice(i4, 0, range);
        } else {
          const start = Math.min(range.start, this._sortedRanges[i4].start);
          const end = Math.max(range.endExclusive, this._sortedRanges[j3 - 1].endExclusive);
          this._sortedRanges.splice(i4, j3 - i4, new OffsetRange(start, end));
        }
      }
      toString() {
        return this._sortedRanges.map((r3) => r3.toString()).join(", ");
      }
      /**
       * Returns of there is a value that is contained in this instance and the given range.
       */
      intersectsStrict(other) {
        let i4 = 0;
        while (i4 < this._sortedRanges.length && this._sortedRanges[i4].endExclusive <= other.start) {
          i4++;
        }
        return i4 < this._sortedRanges.length && this._sortedRanges[i4].start < other.endExclusive;
      }
      intersectWithRange(other) {
        const result = new _OffsetRangeSet();
        for (const range of this._sortedRanges) {
          const intersection = range.intersect(other);
          if (intersection) {
            result.addRange(intersection);
          }
        }
        return result;
      }
      intersectWithRangeLength(other) {
        return this.intersectWithRange(other).length;
      }
      get length() {
        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);
      }
    };
    exports2.OffsetRangeSet = OffsetRangeSet;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/position.js
var require_position = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/position.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Position = void 0;
    var Position = class _Position {
      constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
      }
      /**
       * Create a new position from this position.
       *
       * @param newLineNumber new line number
       * @param newColumn new column
       */
      with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
          return this;
        } else {
          return new _Position(newLineNumber, newColumn);
        }
      }
      /**
       * Derive a new position from this position.
       *
       * @param deltaLineNumber line number delta
       * @param deltaColumn column delta
       */
      delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
      }
      /**
       * Test if this position equals other position
       */
      equals(other) {
        return _Position.equals(this, other);
      }
      /**
       * Test if position `a` equals position `b`
       */
      static equals(a3, b) {
        if (!a3 && !b) {
          return true;
        }
        return !!a3 && !!b && a3.lineNumber === b.lineNumber && a3.column === b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be false.
       */
      isBefore(other) {
        return _Position.isBefore(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be false.
       */
      static isBefore(a3, b) {
        if (a3.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a3.lineNumber) {
          return false;
        }
        return a3.column < b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be true.
       */
      isBeforeOrEqual(other) {
        return _Position.isBeforeOrEqual(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be true.
       */
      static isBeforeOrEqual(a3, b) {
        if (a3.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a3.lineNumber) {
          return false;
        }
        return a3.column <= b.column;
      }
      /**
       * A function that compares positions, useful for sorting
       */
      static compare(a3, b) {
        const aLineNumber = a3.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
          const aColumn = a3.column | 0;
          const bColumn = b.column | 0;
          return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
      }
      /**
       * Clone this position.
       */
      clone() {
        return new _Position(this.lineNumber, this.column);
      }
      /**
       * Convert to a human-readable representation.
       */
      toString() {
        return "(" + this.lineNumber + "," + this.column + ")";
      }
      // ---
      /**
       * Create a `Position` from an `IPosition`.
       */
      static lift(pos) {
        return new _Position(pos.lineNumber, pos.column);
      }
      /**
       * Test if `obj` is an `IPosition`.
       */
      static isIPosition(obj) {
        return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
      }
    };
    exports2.Position = Position;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/range.js
var require_range = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/range.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Range = void 0;
    var position_1 = require_position();
    var Range = class _Range {
      constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
          this.startLineNumber = endLineNumber;
          this.startColumn = endColumn;
          this.endLineNumber = startLineNumber;
          this.endColumn = startColumn;
        } else {
          this.startLineNumber = startLineNumber;
          this.startColumn = startColumn;
          this.endLineNumber = endLineNumber;
          this.endColumn = endColumn;
        }
      }
      /**
       * Test if this range is empty.
       */
      isEmpty() {
        return _Range.isEmpty(this);
      }
      /**
       * Test if `range` is empty.
       */
      static isEmpty(range) {
        return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
      }
      /**
       * Test if position is in this range. If the position is at the edges, will return true.
       */
      containsPosition(position) {
        return _Range.containsPosition(this, position);
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return true.
       */
      static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return false.
       * @internal
       */
      static strictContainsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
          return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if range is in this range. If the range is equal to this range, will return true.
       */
      containsRange(range) {
        return _Range.containsRange(this, range);
      }
      /**
       * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
       */
      static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
       */
      strictContainsRange(range) {
        return _Range.strictContainsRange(this, range);
      }
      /**
       * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
       */
      static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      plusRange(range) {
        return _Range.plusRange(this, range);
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      static plusRange(a3, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a3.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = b.startColumn;
        } else if (b.startLineNumber === a3.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = Math.min(b.startColumn, a3.startColumn);
        } else {
          startLineNumber = a3.startLineNumber;
          startColumn = a3.startColumn;
        }
        if (b.endLineNumber > a3.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = b.endColumn;
        } else if (b.endLineNumber === a3.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = Math.max(b.endColumn, a3.endColumn);
        } else {
          endLineNumber = a3.endLineNumber;
          endColumn = a3.endColumn;
        }
        return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      /**
       * A intersection of the two ranges.
       */
      intersectRanges(range) {
        return _Range.intersectRanges(this, range);
      }
      /**
       * A intersection of the two ranges.
       */
      static intersectRanges(a3, b) {
        let resultStartLineNumber = a3.startLineNumber;
        let resultStartColumn = a3.startColumn;
        let resultEndLineNumber = a3.endLineNumber;
        let resultEndColumn = a3.endColumn;
        const otherStartLineNumber = b.startLineNumber;
        const otherStartColumn = b.startColumn;
        const otherEndLineNumber = b.endLineNumber;
        const otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
          resultStartLineNumber = otherStartLineNumber;
          resultStartColumn = otherStartColumn;
        } else if (resultStartLineNumber === otherStartLineNumber) {
          resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
          resultEndLineNumber = otherEndLineNumber;
          resultEndColumn = otherEndColumn;
        } else if (resultEndLineNumber === otherEndLineNumber) {
          resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        if (resultStartLineNumber > resultEndLineNumber) {
          return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
          return null;
        }
        return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
      }
      /**
       * Test if this range equals other.
       */
      equalsRange(other) {
        return _Range.equalsRange(this, other);
      }
      /**
       * Test if range `a` equals `b`.
       */
      static equalsRange(a3, b) {
        if (!a3 && !b) {
          return true;
        }
        return !!a3 && !!b && a3.startLineNumber === b.startLineNumber && a3.startColumn === b.startColumn && a3.endLineNumber === b.endLineNumber && a3.endColumn === b.endColumn;
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      getEndPosition() {
        return _Range.getEndPosition(this);
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      static getEndPosition(range) {
        return new position_1.Position(range.endLineNumber, range.endColumn);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      getStartPosition() {
        return _Range.getStartPosition(this);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      static getStartPosition(range) {
        return new position_1.Position(range.startLineNumber, range.startColumn);
      }
      /**
       * Transform to a user presentable string representation.
       */
      toString() {
        return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
      }
      /**
       * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
       */
      setEndPosition(endLineNumber, endColumn) {
        return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      /**
       * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
       */
      setStartPosition(startLineNumber, startColumn) {
        return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      collapseToStart() {
        return _Range.collapseToStart(this);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      static collapseToStart(range) {
        return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      collapseToEnd() {
        return _Range.collapseToEnd(this);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      static collapseToEnd(range) {
        return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Moves the range by the given amount of lines.
       */
      delta(lineCount) {
        return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
      }
      // ---
      static fromPositions(start, end = start) {
        return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
      }
      static lift(range) {
        if (!range) {
          return null;
        }
        return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      }
      /**
       * Test if `obj` is an `IRange`.
       */
      static isIRange(obj) {
        return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
      }
      /**
       * Test if the two ranges are touching in any way.
       */
      static areIntersectingOrTouching(a3, b) {
        if (a3.endLineNumber < b.startLineNumber || a3.endLineNumber === b.startLineNumber && a3.endColumn < b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a3.startLineNumber || b.endLineNumber === a3.startLineNumber && b.endColumn < a3.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if the two ranges are intersecting. If the ranges are touching it returns true.
       */
      static areIntersecting(a3, b) {
        if (a3.endLineNumber < b.startLineNumber || a3.endLineNumber === b.startLineNumber && a3.endColumn <= b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a3.startLineNumber || b.endLineNumber === a3.startLineNumber && b.endColumn <= a3.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the startPosition and then on the endPosition
       */
      static compareRangesUsingStarts(a3, b) {
        if (a3 && b) {
          const aStartLineNumber = a3.startLineNumber | 0;
          const bStartLineNumber = b.startLineNumber | 0;
          if (aStartLineNumber === bStartLineNumber) {
            const aStartColumn = a3.startColumn | 0;
            const bStartColumn = b.startColumn | 0;
            if (aStartColumn === bStartColumn) {
              const aEndLineNumber = a3.endLineNumber | 0;
              const bEndLineNumber = b.endLineNumber | 0;
              if (aEndLineNumber === bEndLineNumber) {
                const aEndColumn = a3.endColumn | 0;
                const bEndColumn = b.endColumn | 0;
                return aEndColumn - bEndColumn;
              }
              return aEndLineNumber - bEndLineNumber;
            }
            return aStartColumn - bStartColumn;
          }
          return aStartLineNumber - bStartLineNumber;
        }
        const aExists = a3 ? 1 : 0;
        const bExists = b ? 1 : 0;
        return aExists - bExists;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the endPosition and then on the startPosition
       */
      static compareRangesUsingEnds(a3, b) {
        if (a3.endLineNumber === b.endLineNumber) {
          if (a3.endColumn === b.endColumn) {
            if (a3.startLineNumber === b.startLineNumber) {
              return a3.startColumn - b.startColumn;
            }
            return a3.startLineNumber - b.startLineNumber;
          }
          return a3.endColumn - b.endColumn;
        }
        return a3.endLineNumber - b.endLineNumber;
      }
      /**
       * Test if the range spans multiple lines.
       */
      static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
      }
      toJSON() {
        return this;
      }
    };
    exports2.Range = Range;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/core/lineRange.js
var require_lineRange = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/core/lineRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LineRange = void 0;
    var errors_1 = require_errors();
    var offsetRange_1 = require_offsetRange();
    var range_1 = require_range();
    var LineRange = class _LineRange {
      static fromRange(range) {
        return new _LineRange(range.startLineNumber, range.endLineNumber);
      }
      static subtract(a3, b) {
        if (!b) {
          return [a3];
        }
        if (a3.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a3.endLineNumberExclusive) {
          return [
            new _LineRange(a3.startLineNumber, b.startLineNumber),
            new _LineRange(b.endLineNumberExclusive, a3.endLineNumberExclusive)
          ];
        } else if (b.startLineNumber <= a3.startLineNumber && a3.endLineNumberExclusive <= b.endLineNumberExclusive) {
          return [];
        } else if (b.endLineNumberExclusive < a3.endLineNumberExclusive) {
          return [new _LineRange(Math.max(b.endLineNumberExclusive, a3.startLineNumber), a3.endLineNumberExclusive)];
        } else {
          return [new _LineRange(a3.startLineNumber, Math.min(b.startLineNumber, a3.endLineNumberExclusive))];
        }
      }
      /**
       * @param lineRanges An array of sorted line ranges.
       */
      static joinMany(lineRanges) {
        if (lineRanges.length === 0) {
          return [];
        }
        let result = lineRanges[0];
        for (let i4 = 1; i4 < lineRanges.length; i4++) {
          result = this.join(result, lineRanges[i4]);
        }
        return result;
      }
      /**
       * @param lineRanges1 Must be sorted.
       * @param lineRanges2 Must be sorted.
       */
      static join(lineRanges1, lineRanges2) {
        if (lineRanges1.length === 0) {
          return lineRanges2;
        }
        if (lineRanges2.length === 0) {
          return lineRanges1;
        }
        const result = [];
        let i1 = 0;
        let i22 = 0;
        let current = null;
        while (i1 < lineRanges1.length || i22 < lineRanges2.length) {
          let next = null;
          if (i1 < lineRanges1.length && i22 < lineRanges2.length) {
            const lineRange1 = lineRanges1[i1];
            const lineRange2 = lineRanges2[i22];
            if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
              next = lineRange1;
              i1++;
            } else {
              next = lineRange2;
              i22++;
            }
          } else if (i1 < lineRanges1.length) {
            next = lineRanges1[i1];
            i1++;
          } else {
            next = lineRanges2[i22];
            i22++;
          }
          if (current === null) {
            current = next;
          } else {
            if (current.endLineNumberExclusive >= next.startLineNumber) {
              current = new _LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
            } else {
              result.push(current);
              current = next;
            }
          }
        }
        if (current !== null) {
          result.push(current);
        }
        return result;
      }
      static ofLength(startLineNumber, length) {
        return new _LineRange(startLineNumber, startLineNumber + length);
      }
      /**
       * @internal
       */
      static deserialize(lineRange) {
        return new _LineRange(lineRange[0], lineRange[1]);
      }
      constructor(startLineNumber, endLineNumberExclusive) {
        if (startLineNumber > endLineNumberExclusive) {
          throw new errors_1.BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
        }
        this.startLineNumber = startLineNumber;
        this.endLineNumberExclusive = endLineNumberExclusive;
      }
      /**
       * Indicates if this line range contains the given line number.
       */
      contains(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Indicates if this line range is empty.
       */
      get isEmpty() {
        return this.startLineNumber === this.endLineNumberExclusive;
      }
      /**
       * Moves this line range by the given offset of line numbers.
       */
      delta(offset) {
        return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
      }
      deltaLength(offset) {
        return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
      }
      /**
       * The number of lines this line range spans.
       */
      get length() {
        return this.endLineNumberExclusive - this.startLineNumber;
      }
      /**
       * Creates a line range that combines this and the given line range.
       */
      join(other) {
        return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
      }
      toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
      }
      /**
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
        if (startLineNumber <= endLineNumberExclusive) {
          return new _LineRange(startLineNumber, endLineNumberExclusive);
        }
        return void 0;
      }
      intersectsStrict(other) {
        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
      }
      overlapOrTouch(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
      }
      equals(b) {
        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
      }
      toInclusiveRange() {
        if (this.isEmpty) {
          return null;
        }
        return new range_1.Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
      }
      toExclusiveRange() {
        return new range_1.Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
      }
      mapToLineArray(f3) {
        const result = [];
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          result.push(f3(lineNumber));
        }
        return result;
      }
      forEach(f3) {
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          f3(lineNumber);
        }
      }
      /**
       * @internal
       */
      serialize() {
        return [this.startLineNumber, this.endLineNumberExclusive];
      }
      includes(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
       * @internal
       */
      toOffsetRange() {
        return new offsetRange_1.OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
      }
    };
    exports2.LineRange = LineRange;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/linesDiffComputer.js
var require_linesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/linesDiffComputer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MovedText = exports2.SimpleLineRangeMapping = exports2.RangeMapping = exports2.LineRangeMapping = exports2.LinesDiff = void 0;
    var lineRange_1 = require_lineRange();
    var LinesDiff = class {
      constructor(changes, moves, hitTimeout) {
        this.changes = changes;
        this.moves = moves;
        this.hitTimeout = hitTimeout;
      }
    };
    exports2.LinesDiff = LinesDiff;
    var LineRangeMapping = class _LineRangeMapping {
      static inverse(mapping, originalLineCount, modifiedLineCount) {
        const result = [];
        let lastOriginalEndLineNumber = 1;
        let lastModifiedEndLineNumber = 1;
        for (const m3 of mapping) {
          const r4 = new _LineRangeMapping(new lineRange_1.LineRange(lastOriginalEndLineNumber, m3.originalRange.startLineNumber), new lineRange_1.LineRange(lastModifiedEndLineNumber, m3.modifiedRange.startLineNumber), void 0);
          if (!r4.modifiedRange.isEmpty) {
            result.push(r4);
          }
          lastOriginalEndLineNumber = m3.originalRange.endLineNumberExclusive;
          lastModifiedEndLineNumber = m3.modifiedRange.endLineNumberExclusive;
        }
        const r3 = new _LineRangeMapping(new lineRange_1.LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new lineRange_1.LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), void 0);
        if (!r3.modifiedRange.isEmpty) {
          result.push(r3);
        }
        return result;
      }
      constructor(originalRange, modifiedRange, innerChanges) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
        this.innerChanges = innerChanges;
      }
      toString() {
        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
      }
      get changedLineCount() {
        return Math.max(this.originalRange.length, this.modifiedRange.length);
      }
      flip() {
        return new _LineRangeMapping(this.modifiedRange, this.originalRange, this.innerChanges?.map((c3) => c3.flip()));
      }
    };
    exports2.LineRangeMapping = LineRangeMapping;
    var RangeMapping = class _RangeMapping {
      constructor(originalRange, modifiedRange) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
      }
      toString() {
        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
      }
      flip() {
        return new _RangeMapping(this.modifiedRange, this.originalRange);
      }
    };
    exports2.RangeMapping = RangeMapping;
    var SimpleLineRangeMapping = class _SimpleLineRangeMapping {
      constructor(original, modified) {
        this.original = original;
        this.modified = modified;
      }
      toString() {
        return `{${this.original.toString()}->${this.modified.toString()}}`;
      }
      flip() {
        return new _SimpleLineRangeMapping(this.modified, this.original);
      }
      join(other) {
        return new _SimpleLineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
      }
    };
    exports2.SimpleLineRangeMapping = SimpleLineRangeMapping;
    var MovedText = class _MovedText {
      constructor(lineRangeMapping, changes) {
        this.lineRangeMapping = lineRangeMapping;
        this.changes = changes;
      }
      flip() {
        return new _MovedText(this.lineRangeMapping.flip(), this.changes.map((c3) => c3.flip()));
      }
    };
    exports2.MovedText = MovedText;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/strings.js
var require_strings = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/strings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeCodePoint = exports2.isLowSurrogate = exports2.isHighSurrogate = exports2.lastNonWhitespaceIndex = exports2.firstNonWhitespaceIndex = void 0;
    function firstNonWhitespaceIndex(str) {
      for (let i4 = 0, len = str.length; i4 < len; i4++) {
        const chCode = str.charCodeAt(i4);
        if (chCode !== 32 && chCode !== 9) {
          return i4;
        }
      }
      return -1;
    }
    exports2.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
      for (let i4 = startIndex; i4 >= 0; i4--) {
        const chCode = str.charCodeAt(i4);
        if (chCode !== 32 && chCode !== 9) {
          return i4;
        }
      }
      return -1;
    }
    exports2.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function isHighSurrogate(charCode) {
      return 55296 <= charCode && charCode <= 56319;
    }
    exports2.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
      return 56320 <= charCode && charCode <= 57343;
    }
    exports2.isLowSurrogate = isLowSurrogate;
    function computeCodePoint(highSurrogate, lowSurrogate) {
      return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
    }
    exports2.computeCodePoint = computeCodePoint;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/hash.js
var require_hash = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/hash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringSHA1 = exports2.toHexString = exports2.stringHash = exports2.numberHash = exports2.doHash = void 0;
    var strings = require_strings();
    function doHash(obj, hashVal) {
      switch (typeof obj) {
        case "object":
          if (obj === null) {
            return numberHash(349, hashVal);
          } else if (Array.isArray(obj)) {
            return arrayHash(obj, hashVal);
          }
          return objectHash(obj, hashVal);
        case "string":
          return stringHash(obj, hashVal);
        case "boolean":
          return booleanHash(obj, hashVal);
        case "number":
          return numberHash(obj, hashVal);
        case "undefined":
          return numberHash(937, hashVal);
        default:
          return numberHash(617, hashVal);
      }
    }
    exports2.doHash = doHash;
    function numberHash(val, initialHashVal) {
      return (initialHashVal << 5) - initialHashVal + val | 0;
    }
    exports2.numberHash = numberHash;
    function booleanHash(b, initialHashVal) {
      return numberHash(b ? 433 : 863, initialHashVal);
    }
    function stringHash(s3, hashVal) {
      hashVal = numberHash(149417, hashVal);
      for (let i4 = 0, length = s3.length; i4 < length; i4++) {
        hashVal = numberHash(s3.charCodeAt(i4), hashVal);
      }
      return hashVal;
    }
    exports2.stringHash = stringHash;
    function arrayHash(arr, initialHashVal) {
      initialHashVal = numberHash(104579, initialHashVal);
      return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
    }
    function objectHash(obj, initialHashVal) {
      initialHashVal = numberHash(181387, initialHashVal);
      return Object.keys(obj).sort().reduce((hashVal, key) => {
        hashVal = stringHash(key, hashVal);
        return doHash(obj[key], hashVal);
      }, initialHashVal);
    }
    function leftRotate(value, bits, totalBits = 32) {
      const delta = totalBits - bits;
      const mask = ~((1 << delta) - 1);
      return (value << bits | (mask & value) >>> delta) >>> 0;
    }
    function fill(dest, index = 0, count = dest.byteLength, value = 0) {
      for (let i4 = 0; i4 < count; i4++) {
        dest[index + i4] = value;
      }
    }
    function leftPad(value, length, char = "0") {
      while (value.length < length) {
        value = char + value;
      }
      return value;
    }
    function toHexString(bufferOrValue, bitsize = 32) {
      if (bufferOrValue instanceof ArrayBuffer) {
        return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
      }
      return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
    }
    exports2.toHexString = toHexString;
    var StringSHA1 = class _StringSHA1 {
      constructor() {
        this._h0 = 1732584193;
        this._h1 = 4023233417;
        this._h2 = 2562383102;
        this._h3 = 271733878;
        this._h4 = 3285377520;
        this._buff = new Uint8Array(
          64 + 3
          /* to fit any utf-8 */
        );
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
      }
      update(str) {
        const strLen = str.length;
        if (strLen === 0) {
          return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
          charCode = leftoverHighSurrogate;
          offset = -1;
          leftoverHighSurrogate = 0;
        } else {
          charCode = str.charCodeAt(0);
          offset = 0;
        }
        while (true) {
          let codePoint = charCode;
          if (strings.isHighSurrogate(charCode)) {
            if (offset + 1 < strLen) {
              const nextCharCode = str.charCodeAt(offset + 1);
              if (strings.isLowSurrogate(nextCharCode)) {
                offset++;
                codePoint = strings.computeCodePoint(charCode, nextCharCode);
              } else {
                codePoint = 65533;
              }
            } else {
              leftoverHighSurrogate = charCode;
              break;
            }
          } else if (strings.isLowSurrogate(charCode)) {
            codePoint = 65533;
          }
          buffLen = this._push(buff, buffLen, codePoint);
          offset++;
          if (offset < strLen) {
            charCode = str.charCodeAt(offset);
          } else {
            break;
          }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
      }
      _push(buff, buffLen, codePoint) {
        if (codePoint < 128) {
          buff[buffLen++] = codePoint;
        } else if (codePoint < 2048) {
          buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else if (codePoint < 65536) {
          buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        } else {
          buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
          buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
          buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
          buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
        }
        if (buffLen >= 64) {
          this._step();
          buffLen -= 64;
          this._totalLen += 64;
          buff[0] = buff[64 + 0];
          buff[1] = buff[64 + 1];
          buff[2] = buff[64 + 2];
        }
        return buffLen;
      }
      digest() {
        if (!this._finished) {
          this._finished = true;
          if (this._leftoverHighSurrogate) {
            this._leftoverHighSurrogate = 0;
            this._buffLen = this._push(
              this._buff,
              this._buffLen,
              65533
              /* SHA1Constant.UNICODE_REPLACEMENT */
            );
          }
          this._totalLen += this._buffLen;
          this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
      }
      _wrapUp() {
        this._buff[this._buffLen++] = 128;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
          this._step();
          fill(this._buff);
        }
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
      }
      _step() {
        const bigBlock32 = _StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j3 = 0; j3 < 64; j3 += 4) {
          bigBlock32.setUint32(j3, data.getUint32(j3, false), false);
        }
        for (let j3 = 64; j3 < 320; j3 += 4) {
          bigBlock32.setUint32(j3, leftRotate(bigBlock32.getUint32(j3 - 12, false) ^ bigBlock32.getUint32(j3 - 32, false) ^ bigBlock32.getUint32(j3 - 56, false) ^ bigBlock32.getUint32(j3 - 64, false), 1), false);
        }
        let a3 = this._h0;
        let b = this._h1;
        let c3 = this._h2;
        let d2 = this._h3;
        let e3 = this._h4;
        let f3, k4;
        let temp;
        for (let j3 = 0; j3 < 80; j3++) {
          if (j3 < 20) {
            f3 = b & c3 | ~b & d2;
            k4 = 1518500249;
          } else if (j3 < 40) {
            f3 = b ^ c3 ^ d2;
            k4 = 1859775393;
          } else if (j3 < 60) {
            f3 = b & c3 | b & d2 | c3 & d2;
            k4 = 2400959708;
          } else {
            f3 = b ^ c3 ^ d2;
            k4 = 3395469782;
          }
          temp = leftRotate(a3, 5) + f3 + e3 + k4 + bigBlock32.getUint32(j3 * 4, false) & 4294967295;
          e3 = d2;
          d2 = c3;
          c3 = leftRotate(b, 30);
          b = a3;
          a3 = temp;
        }
        this._h0 = this._h0 + a3 & 4294967295;
        this._h1 = this._h1 + b & 4294967295;
        this._h2 = this._h2 + c3 & 4294967295;
        this._h3 = this._h3 + d2 & 4294967295;
        this._h4 = this._h4 + e3 & 4294967295;
      }
    };
    exports2.StringSHA1 = StringSHA1;
    StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
});

// node_modules/vscode-diff/dist/vs/base/common/diff/diffChange.js
var require_diffChange = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/diff/diffChange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiffChange = void 0;
    var DiffChange = class {
      /**
       * Constructs a new DiffChange with the given sequence information
       * and content.
       */
      constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
      }
      /**
       * The end point (exclusive) of the change in the original sequence.
       */
      getOriginalEnd() {
        return this.originalStart + this.originalLength;
      }
      /**
       * The end point (exclusive) of the change in the modified sequence.
       */
      getModifiedEnd() {
        return this.modifiedStart + this.modifiedLength;
      }
    };
    exports2.DiffChange = DiffChange;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/diff/diff.js
var require_diff = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/diff/diff.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LcsDiff = exports2.stringDiff = exports2.StringDiffSequence = void 0;
    var hash_1 = require_hash();
    var diffChange_1 = require_diffChange();
    var StringDiffSequence = class {
      constructor(source) {
        this.source = source;
      }
      getElements() {
        const source = this.source;
        const characters = new Int32Array(source.length);
        for (let i4 = 0, len = source.length; i4 < len; i4++) {
          characters[i4] = source.charCodeAt(i4);
        }
        return characters;
      }
    };
    exports2.StringDiffSequence = StringDiffSequence;
    function stringDiff(original, modified, pretty) {
      return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
    }
    exports2.stringDiff = stringDiff;
    var Debug = class {
      static Assert(condition, message) {
        if (!condition) {
          throw new Error(message);
        }
      }
    };
    var MyArray = class {
      /**
       * Copies a range of elements from an Array starting at the specified source index and pastes
       * them to another Array starting at the specified destination index. The length and the indexes
       * are specified as 64-bit integers.
       * sourceArray:
       *		The Array that contains the data to copy.
       * sourceIndex:
       *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
       * destinationArray:
       *		The Array that receives the data.
       * destinationIndex:
       *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
       * length:
       *		A 64-bit integer that represents the number of elements to copy.
       */
      static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i4 = 0; i4 < length; i4++) {
          destinationArray[destinationIndex + i4] = sourceArray[sourceIndex + i4];
        }
      }
      static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i4 = 0; i4 < length; i4++) {
          destinationArray[destinationIndex + i4] = sourceArray[sourceIndex + i4];
        }
      }
    };
    var DiffChangeHelper = class {
      /**
       * Constructs a new DiffChangeHelper for the given DiffSequences.
       */
      constructor() {
        this.m_changes = [];
        this.m_originalStart = 1073741824;
        this.m_modifiedStart = 1073741824;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
      }
      /**
       * Marks the beginning of the next change in the set of differences.
       */
      MarkNextChange() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824;
        this.m_modifiedStart = 1073741824;
      }
      /**
       * Adds the original element at the given position to the elements
       * affected by the current change. The modified index gives context
       * to the change position with respect to the original sequence.
       * @param originalIndex The index of the original element to add.
       * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
       */
      AddOriginalElement(originalIndex, modifiedIndex) {
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
      }
      /**
       * Adds the modified element at the given position to the elements
       * affected by the current change. The original index gives context
       * to the change position with respect to the modified sequence.
       * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
       * @param modifiedIndex The index of the modified element to add.
       */
      AddModifiedElement(originalIndex, modifiedIndex) {
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
      }
      /**
       * Retrieves all of the changes marked by the class.
       */
      getChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.MarkNextChange();
        }
        return this.m_changes;
      }
      /**
       * Retrieves all of the changes marked by the class in the reverse order
       */
      getReverseChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
          this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
      }
    };
    var LcsDiff = class _LcsDiff {
      /**
       * Constructs the DiffFinder
       */
      constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        this._originalSequence = originalSequence;
        this._modifiedSequence = modifiedSequence;
        const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
        this._hasStrings = originalHasStrings && modifiedHasStrings;
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
      }
      static _isStringArray(arr) {
        return arr.length > 0 && typeof arr[0] === "string";
      }
      static _getElements(sequence) {
        const elements = sequence.getElements();
        if (_LcsDiff._isStringArray(elements)) {
          const hashes = new Int32Array(elements.length);
          for (let i4 = 0, len = elements.length; i4 < len; i4++) {
            hashes[i4] = (0, hash_1.stringHash)(elements[i4], 0);
          }
          return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
          return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
      }
      ElementsAreEqual(originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
          return false;
        }
        return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
      }
      ElementsAreStrictEqual(originalIndex, newIndex) {
        if (!this.ElementsAreEqual(originalIndex, newIndex)) {
          return false;
        }
        const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
        const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
        return originalElement === modifiedElement;
      }
      static _getStrictElement(sequence, index) {
        if (typeof sequence.getStrictElement === "function") {
          return sequence.getStrictElement(index);
        }
        return null;
      }
      OriginalElementsAreEqual(index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
          return false;
        }
        return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
      }
      ModifiedElementsAreEqual(index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
          return false;
        }
        return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
      }
      ComputeDiff(pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
      }
      /**
       * Computes the differences between the original and modified input
       * sequences on the bounded range.
       * @returns An array of the differences between the two input sequences.
       */
      _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        const quitEarlyArr = [false];
        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
          changes = this.PrettifyChanges(changes);
        }
        return {
          quitEarly: quitEarlyArr[0],
          changes
        };
      }
      /**
       * Private helper method which computes the differences on the bounded range
       * recursively.
       * @returns An array of the differences between the two input sequences.
       */
      ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
          originalStart++;
          modifiedStart++;
        }
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
          originalEnd--;
          modifiedEnd--;
        }
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
          let changes;
          if (modifiedStart <= modifiedEnd) {
            Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
            changes = [
              new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          } else if (originalStart <= originalEnd) {
            Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
            changes = [
              new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
            ];
          } else {
            Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
            Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
            changes = [];
          }
          return changes;
        }
        const midOriginalArr = [0];
        const midModifiedArr = [0];
        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        const midOriginal = midOriginalArr[0];
        const midModified = midModifiedArr[0];
        if (result !== null) {
          return result;
        } else if (!quitEarlyArr[0]) {
          const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
          let rightChanges = [];
          if (!quitEarlyArr[0]) {
            rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
          } else {
            rightChanges = [
              new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
            ];
          }
          return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        return [
          new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
      }
      WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        let forwardChanges = null;
        let reverseChanges = null;
        let changeHelper = new DiffChangeHelper();
        let diagonalMin = diagonalForwardStart;
        let diagonalMax = diagonalForwardEnd;
        let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
        let lastOriginalIndex = -1073741824;
        let historyIndex = this.m_forwardHistory.length - 1;
        do {
          const diagonal = diagonalRelative + diagonalForwardBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
            if (originalIndex < lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
            diagonalRelative = diagonal + 1 - diagonalForwardBase;
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
            if (originalIndex < lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex - 1;
            changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalForwardBase;
          }
          if (historyIndex >= 0) {
            forwardPoints = this.m_forwardHistory[historyIndex];
            diagonalForwardBase = forwardPoints[0];
            diagonalMin = 1;
            diagonalMax = forwardPoints.length - 1;
          }
        } while (--historyIndex >= -1);
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
          let originalStartPoint = midOriginalArr[0] + 1;
          let modifiedStartPoint = midModifiedArr[0] + 1;
          if (forwardChanges !== null && forwardChanges.length > 0) {
            const lastForwardChange = forwardChanges[forwardChanges.length - 1];
            originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
            modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
          }
          reverseChanges = [
            new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
          ];
        } else {
          changeHelper = new DiffChangeHelper();
          diagonalMin = diagonalReverseStart;
          diagonalMax = diagonalReverseEnd;
          diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
          lastOriginalIndex = 1073741824;
          historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
          do {
            const diagonal = diagonalRelative + diagonalReverseBase;
            if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
              originalIndex = reversePoints[diagonal + 1] - 1;
              modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
              if (originalIndex > lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex + 1;
              changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
              diagonalRelative = diagonal + 1 - diagonalReverseBase;
            } else {
              originalIndex = reversePoints[diagonal - 1];
              modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
              if (originalIndex > lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex;
              changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
              diagonalRelative = diagonal - 1 - diagonalReverseBase;
            }
            if (historyIndex >= 0) {
              reversePoints = this.m_reverseHistory[historyIndex];
              diagonalReverseBase = reversePoints[0];
              diagonalMin = 1;
              diagonalMax = reversePoints.length - 1;
            }
          } while (--historyIndex >= -1);
          reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
      }
      /**
       * Given the range to compute the diff on, this method finds the point:
       * (midOriginal, midModified)
       * that exists in the middle of the LCS of the two sequences and
       * is the point at which the LCS problem may be broken down recursively.
       * This method will try to keep the LCS trace in memory. If the LCS recursion
       * point is calculated and the full trace is available in memory, then this method
       * will return the change list.
       * @param originalStart The start bound of the original sequence range
       * @param originalEnd The end bound of the original sequence range
       * @param modifiedStart The start bound of the modified sequence range
       * @param modifiedEnd The end bound of the modified sequence range
       * @param midOriginal The middle point of the original sequence range
       * @param midModified The middle point of the modified sequence range
       * @returns The diff changes, if available, otherwise null
       */
      ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        let originalIndex = 0, modifiedIndex = 0;
        let diagonalForwardStart = 0, diagonalForwardEnd = 0;
        let diagonalReverseStart = 0, diagonalReverseEnd = 0;
        originalStart--;
        modifiedStart--;
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
        const numDiagonals = maxDifferences + 1;
        const forwardPoints = new Int32Array(numDiagonals);
        const reversePoints = new Int32Array(numDiagonals);
        const diagonalForwardBase = modifiedEnd - modifiedStart;
        const diagonalReverseBase = originalEnd - originalStart;
        const diagonalForwardOffset = originalStart - modifiedStart;
        const diagonalReverseOffset = originalEnd - modifiedEnd;
        const delta = diagonalReverseBase - diagonalForwardBase;
        const deltaIsEven = delta % 2 === 0;
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        quitEarlyArr[0] = false;
        for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
          let furthestOriginalIndex = 0;
          let furthestModifiedIndex = 0;
          diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
          diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
          for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
            if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
              originalIndex = forwardPoints[diagonal + 1];
            } else {
              originalIndex = forwardPoints[diagonal - 1] + 1;
            }
            modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
            const tempOriginalIndex = originalIndex;
            while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
              originalIndex++;
              modifiedIndex++;
            }
            forwardPoints[diagonal] = originalIndex;
            if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
              furthestOriginalIndex = originalIndex;
              furthestModifiedIndex = modifiedIndex;
            }
            if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
              if (originalIndex >= reversePoints[diagonal]) {
                midOriginalArr[0] = originalIndex;
                midModifiedArr[0] = modifiedIndex;
                if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                  return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                } else {
                  return null;
                }
              }
            }
          }
          const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
          if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
            quitEarlyArr[0] = true;
            midOriginalArr[0] = furthestOriginalIndex;
            midModifiedArr[0] = furthestModifiedIndex;
            if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              originalStart++;
              modifiedStart++;
              return [
                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
              ];
            }
          }
          diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
          diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
          for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
            if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
              originalIndex = reversePoints[diagonal + 1] - 1;
            } else {
              originalIndex = reversePoints[diagonal - 1];
            }
            modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
            const tempOriginalIndex = originalIndex;
            while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
              originalIndex--;
              modifiedIndex--;
            }
            reversePoints[diagonal] = originalIndex;
            if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
              if (originalIndex <= forwardPoints[diagonal]) {
                midOriginalArr[0] = originalIndex;
                midModifiedArr[0] = modifiedIndex;
                if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                  return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                } else {
                  return null;
                }
              }
            }
          }
          if (numDifferences <= 1447) {
            let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
            temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
            MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
            this.m_forwardHistory.push(temp);
            temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
            temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
            MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
            this.m_reverseHistory.push(temp);
          }
        }
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
      }
      /**
       * Shifts the given changes to provide a more intuitive diff.
       * While the first element in a diff matches the first element after the diff,
       * we shift the diff down.
       *
       * @param changes The list of changes to shift
       * @returns The shifted changes
       */
      PrettifyChanges(changes) {
        for (let i4 = 0; i4 < changes.length; i4++) {
          const change = changes[i4];
          const originalStop = i4 < changes.length - 1 ? changes[i4 + 1].originalStart : this._originalElementsOrHash.length;
          const modifiedStop = i4 < changes.length - 1 ? changes[i4 + 1].modifiedStart : this._modifiedElementsOrHash.length;
          const checkOriginal = change.originalLength > 0;
          const checkModified = change.modifiedLength > 0;
          while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
            const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
            const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
            if (endStrictEqual && !startStrictEqual) {
              break;
            }
            change.originalStart++;
            change.modifiedStart++;
          }
          const mergedChangeArr = [null];
          if (i4 < changes.length - 1 && this.ChangesOverlap(changes[i4], changes[i4 + 1], mergedChangeArr)) {
            changes[i4] = mergedChangeArr[0];
            changes.splice(i4 + 1, 1);
            i4--;
            continue;
          }
        }
        for (let i4 = changes.length - 1; i4 >= 0; i4--) {
          const change = changes[i4];
          let originalStop = 0;
          let modifiedStop = 0;
          if (i4 > 0) {
            const prevChange = changes[i4 - 1];
            originalStop = prevChange.originalStart + prevChange.originalLength;
            modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
          }
          const checkOriginal = change.originalLength > 0;
          const checkModified = change.modifiedLength > 0;
          let bestDelta = 0;
          let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
          for (let delta = 1; ; delta++) {
            const originalStart = change.originalStart - delta;
            const modifiedStart = change.modifiedStart - delta;
            if (originalStart < originalStop || modifiedStart < modifiedStop) {
              break;
            }
            if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
              break;
            }
            if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
              break;
            }
            const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
            const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
            if (score > bestScore) {
              bestScore = score;
              bestDelta = delta;
            }
          }
          change.originalStart -= bestDelta;
          change.modifiedStart -= bestDelta;
          const mergedChangeArr = [null];
          if (i4 > 0 && this.ChangesOverlap(changes[i4 - 1], changes[i4], mergedChangeArr)) {
            changes[i4 - 1] = mergedChangeArr[0];
            changes.splice(i4, 1);
            i4++;
            continue;
          }
        }
        if (this._hasStrings) {
          for (let i4 = 1, len = changes.length; i4 < len; i4++) {
            const aChange = changes[i4 - 1];
            const bChange = changes[i4];
            const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
            const aOriginalStart = aChange.originalStart;
            const bOriginalEnd = bChange.originalStart + bChange.originalLength;
            const abOriginalLength = bOriginalEnd - aOriginalStart;
            const aModifiedStart = aChange.modifiedStart;
            const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
            const abModifiedLength = bModifiedEnd - aModifiedStart;
            if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
              const t3 = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
              if (t3) {
                const [originalMatchStart, modifiedMatchStart] = t3;
                if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                  aChange.originalLength = originalMatchStart - aChange.originalStart;
                  aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                  bChange.originalStart = originalMatchStart + matchedLength;
                  bChange.modifiedStart = modifiedMatchStart + matchedLength;
                  bChange.originalLength = bOriginalEnd - bChange.originalStart;
                  bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                }
              }
            }
          }
        }
        return changes;
      }
      _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
        if (originalLength < desiredLength || modifiedLength < desiredLength) {
          return null;
        }
        const originalMax = originalStart + originalLength - desiredLength + 1;
        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
        let bestScore = 0;
        let bestOriginalStart = 0;
        let bestModifiedStart = 0;
        for (let i4 = originalStart; i4 < originalMax; i4++) {
          for (let j3 = modifiedStart; j3 < modifiedMax; j3++) {
            const score = this._contiguousSequenceScore(i4, j3, desiredLength);
            if (score > 0 && score > bestScore) {
              bestScore = score;
              bestOriginalStart = i4;
              bestModifiedStart = j3;
            }
          }
        }
        if (bestScore > 0) {
          return [bestOriginalStart, bestModifiedStart];
        }
        return null;
      }
      _contiguousSequenceScore(originalStart, modifiedStart, length) {
        let score = 0;
        for (let l3 = 0; l3 < length; l3++) {
          if (!this.ElementsAreEqual(originalStart + l3, modifiedStart + l3)) {
            return 0;
          }
          score += this._originalStringElements[originalStart + l3].length;
        }
        return score;
      }
      _OriginalIsBoundary(index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
          return true;
        }
        return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
      }
      _OriginalRegionIsBoundary(originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
          return true;
        }
        if (originalLength > 0) {
          const originalEnd = originalStart + originalLength;
          if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
            return true;
          }
        }
        return false;
      }
      _ModifiedIsBoundary(index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
          return true;
        }
        return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
      }
      _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
          return true;
        }
        if (modifiedLength > 0) {
          const modifiedEnd = modifiedStart + modifiedLength;
          if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
            return true;
          }
        }
        return false;
      }
      _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
        const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
        const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
        return originalScore + modifiedScore;
      }
      /**
       * Concatenates the two input DiffChange lists and returns the resulting
       * list.
       * @param The left changes
       * @param The right changes
       * @returns The concatenated list
       */
      ConcatenateChanges(left2, right2) {
        const mergedChangeArr = [];
        if (left2.length === 0 || right2.length === 0) {
          return right2.length > 0 ? right2 : left2;
        } else if (this.ChangesOverlap(left2[left2.length - 1], right2[0], mergedChangeArr)) {
          const result = new Array(left2.length + right2.length - 1);
          MyArray.Copy(left2, 0, result, 0, left2.length - 1);
          result[left2.length - 1] = mergedChangeArr[0];
          MyArray.Copy(right2, 1, result, left2.length, right2.length - 1);
          return result;
        } else {
          const result = new Array(left2.length + right2.length);
          MyArray.Copy(left2, 0, result, 0, left2.length);
          MyArray.Copy(right2, 0, result, left2.length, right2.length);
          return result;
        }
      }
      /**
       * Returns true if the two changes overlap and can be merged into a single
       * change
       * @param left The left change
       * @param right The right change
       * @param mergedChange The merged change if the two overlap, null otherwise
       * @returns True if the two changes overlap
       */
      ChangesOverlap(left2, right2, mergedChangeArr) {
        Debug.Assert(left2.originalStart <= right2.originalStart, "Left change is not less than or equal to right change");
        Debug.Assert(left2.modifiedStart <= right2.modifiedStart, "Left change is not less than or equal to right change");
        if (left2.originalStart + left2.originalLength >= right2.originalStart || left2.modifiedStart + left2.modifiedLength >= right2.modifiedStart) {
          const originalStart = left2.originalStart;
          let originalLength = left2.originalLength;
          const modifiedStart = left2.modifiedStart;
          let modifiedLength = left2.modifiedLength;
          if (left2.originalStart + left2.originalLength >= right2.originalStart) {
            originalLength = right2.originalStart + right2.originalLength - left2.originalStart;
          }
          if (left2.modifiedStart + left2.modifiedLength >= right2.modifiedStart) {
            modifiedLength = right2.modifiedStart + right2.modifiedLength - left2.modifiedStart;
          }
          mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
          return true;
        } else {
          mergedChangeArr[0] = null;
          return false;
        }
      }
      /**
       * Helper method used to clip a diagonal index to the range of valid
       * diagonals. This also decides whether or not the diagonal index,
       * if it exceeds the boundary, should be clipped to the boundary or clipped
       * one inside the boundary depending on the Even/Odd status of the boundary
       * and numDifferences.
       * @param diagonal The index of the diagonal to clip.
       * @param numDifferences The current number of differences being iterated upon.
       * @param diagonalBaseIndex The base reference diagonal.
       * @param numDiagonals The total number of diagonals.
       * @returns The clipped diagonal index.
       */
      ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
          return diagonal;
        }
        const diagonalsBelow = diagonalBaseIndex;
        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        const diffEven = numDifferences % 2 === 0;
        if (diagonal < 0) {
          const lowerBoundEven = diagonalsBelow % 2 === 0;
          return diffEven === lowerBoundEven ? 0 : 1;
        } else {
          const upperBoundEven = diagonalsAbove % 2 === 0;
          return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
        }
      }
    };
    exports2.LcsDiff = LcsDiff;
  }
});

// node_modules/vscode-diff/dist/vs/base/common/assert.js
var require_assert = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkAdjacentItems = exports2.assertFn = void 0;
    var errors_1 = require_errors();
    function assertFn(condition) {
      if (!condition()) {
        debugger;
        condition();
        (0, errors_1.onUnexpectedError)(new errors_1.BugIndicatingError("Assertion Failed"));
      }
    }
    exports2.assertFn = assertFn;
    function checkAdjacentItems(items, predicate) {
      let i4 = 0;
      while (i4 < items.length - 1) {
        const a3 = items[i4];
        const b = items[i4 + 1];
        if (!predicate(a3, b)) {
          return false;
        }
        i4++;
      }
      return true;
    }
    exports2.checkAdjacentItems = checkAdjacentItems;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/legacyLinesDiffComputer.js
var require_legacyLinesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/legacyLinesDiffComputer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiffComputer = exports2.LegacyLinesDiffComputer = void 0;
    var assert_1 = require_assert();
    var diff_1 = require_diff();
    var strings = require_strings();
    var lineRange_1 = require_lineRange();
    var range_1 = require_range();
    var linesDiffComputer_1 = require_linesDiffComputer();
    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
    var LegacyLinesDiffComputer = class {
      computeDiff(originalLines, modifiedLines, options) {
        const diffComputer = new DiffComputer(originalLines, modifiedLines, {
          maxComputationTime: options.maxComputationTimeMs,
          shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
          shouldComputeCharChanges: true,
          shouldMakePrettyDiff: true,
          shouldPostProcessCharChanges: true
        });
        const result = diffComputer.computeDiff();
        const changes = [];
        let lastChange = null;
        for (const c3 of result.changes) {
          let originalRange;
          if (c3.originalEndLineNumber === 0) {
            originalRange = new lineRange_1.LineRange(c3.originalStartLineNumber + 1, c3.originalStartLineNumber + 1);
          } else {
            originalRange = new lineRange_1.LineRange(c3.originalStartLineNumber, c3.originalEndLineNumber + 1);
          }
          let modifiedRange;
          if (c3.modifiedEndLineNumber === 0) {
            modifiedRange = new lineRange_1.LineRange(c3.modifiedStartLineNumber + 1, c3.modifiedStartLineNumber + 1);
          } else {
            modifiedRange = new lineRange_1.LineRange(c3.modifiedStartLineNumber, c3.modifiedEndLineNumber + 1);
          }
          let change = new linesDiffComputer_1.LineRangeMapping(originalRange, modifiedRange, c3.charChanges?.map((c4) => new linesDiffComputer_1.RangeMapping(new range_1.Range(c4.originalStartLineNumber, c4.originalStartColumn, c4.originalEndLineNumber, c4.originalEndColumn), new range_1.Range(c4.modifiedStartLineNumber, c4.modifiedStartColumn, c4.modifiedEndLineNumber, c4.modifiedEndColumn))));
          if (lastChange) {
            if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {
              change = new linesDiffComputer_1.LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
              changes.pop();
            }
          }
          changes.push(change);
          lastChange = change;
        }
        (0, assert_1.assertFn)(() => {
          return (0, assert_1.checkAdjacentItems)(changes, (m1, m22) => m22.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m22.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
          m1.originalRange.endLineNumberExclusive < m22.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m22.modifiedRange.startLineNumber);
        });
        return new linesDiffComputer_1.LinesDiff(changes, [], result.quitEarly);
      }
    };
    exports2.LegacyLinesDiffComputer = LegacyLinesDiffComputer;
    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
      const diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
      return diffAlgo.ComputeDiff(pretty);
    }
    var LineSequence = class {
      constructor(lines) {
        const startColumns = [];
        const endColumns = [];
        for (let i4 = 0, length = lines.length; i4 < length; i4++) {
          startColumns[i4] = getFirstNonBlankColumn(lines[i4], 1);
          endColumns[i4] = getLastNonBlankColumn(lines[i4], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
      }
      getElements() {
        const elements = [];
        for (let i4 = 0, len = this.lines.length; i4 < len; i4++) {
          elements[i4] = this.lines[i4].substring(this._startColumns[i4] - 1, this._endColumns[i4] - 1);
        }
        return elements;
      }
      getStrictElement(index) {
        return this.lines[index];
      }
      getStartLineNumber(i4) {
        return i4 + 1;
      }
      getEndLineNumber(i4) {
        return i4 + 1;
      }
      createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        const charCodes = [];
        const lineNumbers = [];
        const columns = [];
        let len = 0;
        for (let index = startIndex; index <= endIndex; index++) {
          const lineContent = this.lines[index];
          const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
          const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
          for (let col = startColumn; col < endColumn; col++) {
            charCodes[len] = lineContent.charCodeAt(col - 1);
            lineNumbers[len] = index + 1;
            columns[len] = col;
            len++;
          }
          if (!shouldIgnoreTrimWhitespace && index < endIndex) {
            charCodes[len] = 10;
            lineNumbers[len] = index + 1;
            columns[len] = lineContent.length + 1;
            len++;
          }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
      }
    };
    var CharSequence = class {
      constructor(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
      }
      toString() {
        return "[" + this._charCodes.map((s3, idx) => (s3 === 10 ? "\\n" : String.fromCharCode(s3)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
      }
      _assertIndex(index, arr) {
        if (index < 0 || index >= arr.length) {
          throw new Error(`Illegal index`);
        }
      }
      getElements() {
        return this._charCodes;
      }
      getStartLineNumber(i4) {
        if (i4 > 0 && i4 === this._lineNumbers.length) {
          return this.getEndLineNumber(i4 - 1);
        }
        this._assertIndex(i4, this._lineNumbers);
        return this._lineNumbers[i4];
      }
      getEndLineNumber(i4) {
        if (i4 === -1) {
          return this.getStartLineNumber(i4 + 1);
        }
        this._assertIndex(i4, this._lineNumbers);
        if (this._charCodes[i4] === 10) {
          return this._lineNumbers[i4] + 1;
        }
        return this._lineNumbers[i4];
      }
      getStartColumn(i4) {
        if (i4 > 0 && i4 === this._columns.length) {
          return this.getEndColumn(i4 - 1);
        }
        this._assertIndex(i4, this._columns);
        return this._columns[i4];
      }
      getEndColumn(i4) {
        if (i4 === -1) {
          return this.getStartColumn(i4 + 1);
        }
        this._assertIndex(i4, this._columns);
        if (this._charCodes[i4] === 10) {
          return 1;
        }
        return this._columns[i4] + 1;
      }
    };
    var CharChange = class _CharChange {
      constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
      }
      static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
      }
    };
    function postProcessCharChanges(rawChanges) {
      if (rawChanges.length <= 1) {
        return rawChanges;
      }
      const result = [rawChanges[0]];
      let prevChange = result[0];
      for (let i4 = 1, len = rawChanges.length; i4 < len; i4++) {
        const currChange = rawChanges[i4];
        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
          prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
          prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
        } else {
          result.push(currChange);
          prevChange = currChange;
        }
      }
      return result;
    }
    var LineChange = class _LineChange {
      constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
      }
      static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let charChanges = void 0;
        if (diffChange.originalLength === 0) {
          originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
          originalEndLineNumber = 0;
        } else {
          originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
          originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
          modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
          modifiedEndLineNumber = 0;
        } else {
          modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
          modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
          const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
          const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
          if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
              rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i4 = 0, length = rawChanges.length; i4 < length; i4++) {
              charChanges.push(CharChange.createFromDiffChange(rawChanges[i4], originalCharSequence, modifiedCharSequence));
            }
          }
        }
        return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
      }
    };
    var DiffComputer = class {
      constructor(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
      }
      computeDiff() {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            return {
              quitEarly: false,
              changes: []
            };
          }
          return {
            quitEarly: false,
            changes: [{
              originalStartLineNumber: 1,
              originalEndLineNumber: 1,
              modifiedStartLineNumber: 1,
              modifiedEndLineNumber: this.modified.lines.length,
              charChanges: void 0
            }]
          };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: [{
              originalStartLineNumber: 1,
              originalEndLineNumber: this.original.lines.length,
              modifiedStartLineNumber: 1,
              modifiedEndLineNumber: 1,
              charChanges: void 0
            }]
          };
        }
        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        const rawChanges = diffResult.changes;
        const quitEarly = diffResult.quitEarly;
        if (this.shouldIgnoreTrimWhitespace) {
          const lineChanges = [];
          for (let i4 = 0, length = rawChanges.length; i4 < length; i4++) {
            lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i4], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          }
          return {
            quitEarly,
            changes: lineChanges
          };
        }
        const result = [];
        let originalLineIndex = 0;
        let modifiedLineIndex = 0;
        for (let i4 = -1, len = rawChanges.length; i4 < len; i4++) {
          const nextChange = i4 + 1 < len ? rawChanges[i4 + 1] : null;
          const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
          const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
          while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
            const originalLine = this.originalLines[originalLineIndex];
            const modifiedLine = this.modifiedLines[modifiedLineIndex];
            if (originalLine !== modifiedLine) {
              {
                let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                  const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                  const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                  if (originalChar !== modifiedChar) {
                    break;
                  }
                  originalStartColumn--;
                  modifiedStartColumn--;
                }
                if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                  this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                }
              }
              {
                let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                const originalMaxColumn = originalLine.length + 1;
                const modifiedMaxColumn = modifiedLine.length + 1;
                while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                  const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                  const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                  if (originalChar !== modifiedChar) {
                    break;
                  }
                  originalEndColumn++;
                  modifiedEndColumn++;
                }
                if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                  this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                }
              }
            }
            originalLineIndex++;
            modifiedLineIndex++;
          }
          if (nextChange) {
            result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            originalLineIndex += nextChange.originalLength;
            modifiedLineIndex += nextChange.modifiedLength;
          }
        }
        return {
          quitEarly,
          changes: result
        };
      }
      _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
          return;
        }
        let charChanges = void 0;
        if (this.shouldComputeCharChanges) {
          charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
      }
      _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        const len = result.length;
        if (len === 0) {
          return false;
        }
        const prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
          return false;
        }
        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
          if (this.shouldComputeCharChanges && prevChange.charChanges) {
            prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
          }
          return true;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
          prevChange.originalEndLineNumber = originalLineNumber;
          prevChange.modifiedEndLineNumber = modifiedLineNumber;
          if (this.shouldComputeCharChanges && prevChange.charChanges) {
            prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
          }
          return true;
        }
        return false;
      }
    };
    exports2.DiffComputer = DiffComputer;
    function getFirstNonBlankColumn(txt, defaultValue) {
      const r3 = strings.firstNonWhitespaceIndex(txt);
      if (r3 === -1) {
        return defaultValue;
      }
      return r3 + 1;
    }
    function getLastNonBlankColumn(txt, defaultValue) {
      const r3 = strings.lastNonWhitespaceIndex(txt);
      if (r3 === -1) {
        return defaultValue;
      }
      return r3 + 2;
    }
    function createContinueProcessingPredicate(maximumRuntime) {
      if (maximumRuntime === 0) {
        return () => true;
      }
      const startTime = Date.now();
      return () => {
        return Date.now() - startTime < maximumRuntime;
      };
    }
  }
});

// node_modules/vscode-diff/dist/vs/base/common/arrays.js
var require_arrays = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/arrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallbackIterable = exports2.reverseOrder = exports2.numberComparator = exports2.compareBy = exports2.CompareResult = exports2.findLastIndex = exports2.equals = void 0;
    function equals(one, other, itemEquals = (a3, b) => a3 === b) {
      if (one === other) {
        return true;
      }
      if (!one || !other) {
        return false;
      }
      if (one.length !== other.length) {
        return false;
      }
      for (let i4 = 0, len = one.length; i4 < len; i4++) {
        if (!itemEquals(one[i4], other[i4])) {
          return false;
        }
      }
      return true;
    }
    exports2.equals = equals;
    function findLastIndex(array, fn) {
      for (let i4 = array.length - 1; i4 >= 0; i4--) {
        const element = array[i4];
        if (fn(element)) {
          return i4;
        }
      }
      return -1;
    }
    exports2.findLastIndex = findLastIndex;
    var CompareResult;
    (function(CompareResult2) {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult2.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult2.isGreaterThan = isGreaterThan;
    })(CompareResult || (exports2.CompareResult = CompareResult = {}));
    function compareBy(selector, comparator) {
      return (a3, b) => comparator(selector(a3), selector(b));
    }
    exports2.compareBy = compareBy;
    var numberComparator = (a3, b) => a3 - b;
    exports2.numberComparator = numberComparator;
    function reverseOrder(comparator) {
      return (a3, b) => -comparator(a3, b);
    }
    exports2.reverseOrder = reverseOrder;
    var CallbackIterable = class _CallbackIterable {
      constructor(iterate) {
        this.iterate = iterate;
      }
      forEach(handler) {
        this.iterate((item) => {
          handler(item);
          return true;
        });
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      some(predicate) {
        let result = false;
        this.iterate((item) => {
          result = predicate(item);
          return !result;
        });
        return result;
      }
      findFirst(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
            return false;
          }
          return true;
        });
        return result;
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
    exports2.CallbackIterable = CallbackIterable;
    CallbackIterable.empty = new CallbackIterable((_callback) => {
    });
  }
});

// node_modules/vscode-diff/dist/vs/base/common/collections.js
var require_collections = __commonJS({
  "node_modules/vscode-diff/dist/vs/base/common/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetMap = void 0;
    var SetMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      add(key, value) {
        let values = this.map.get(key);
        if (!values) {
          values = /* @__PURE__ */ new Set();
          this.map.set(key, values);
        }
        values.add(value);
      }
      delete(key, value) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.delete(value);
        if (values.size === 0) {
          this.map.delete(key);
        }
      }
      forEach(key, fn) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.forEach(fn);
      }
      get(key) {
        const values = this.map.get(key);
        if (!values) {
          return /* @__PURE__ */ new Set();
        }
        return values;
      }
    };
    exports2.SetMap = SetMap;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/diffAlgorithm.js
var require_diffAlgorithm = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/diffAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DateTimeout = exports2.InfiniteTimeout = exports2.SequenceDiff = exports2.DiffAlgorithmResult = void 0;
    var errors_1 = require_errors();
    var offsetRange_1 = require_offsetRange();
    var DiffAlgorithmResult = class _DiffAlgorithmResult {
      static trivial(seq1, seq2) {
        return new _DiffAlgorithmResult([new SequenceDiff(new offsetRange_1.OffsetRange(0, seq1.length), new offsetRange_1.OffsetRange(0, seq2.length))], false);
      }
      static trivialTimedOut(seq1, seq2) {
        return new _DiffAlgorithmResult([new SequenceDiff(new offsetRange_1.OffsetRange(0, seq1.length), new offsetRange_1.OffsetRange(0, seq2.length))], true);
      }
      constructor(diffs, hitTimeout) {
        this.diffs = diffs;
        this.hitTimeout = hitTimeout;
      }
    };
    exports2.DiffAlgorithmResult = DiffAlgorithmResult;
    var SequenceDiff = class _SequenceDiff {
      constructor(seq1Range, seq2Range) {
        this.seq1Range = seq1Range;
        this.seq2Range = seq2Range;
      }
      reverse() {
        return new _SequenceDiff(this.seq2Range, this.seq1Range);
      }
      toString() {
        return `${this.seq1Range} <-> ${this.seq2Range}`;
      }
      join(other) {
        return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
      }
      delta(offset) {
        if (offset === 0) {
          return this;
        }
        return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
      }
    };
    exports2.SequenceDiff = SequenceDiff;
    var InfiniteTimeout = class {
      isValid() {
        return true;
      }
    };
    exports2.InfiniteTimeout = InfiniteTimeout;
    InfiniteTimeout.instance = new InfiniteTimeout();
    var DateTimeout = class {
      constructor(timeout) {
        this.timeout = timeout;
        this.startTime = Date.now();
        this.valid = true;
        if (timeout <= 0) {
          throw new errors_1.BugIndicatingError("timeout must be positive");
        }
      }
      // Recommendation: Set a log-point `{this.disable()}` in the body
      isValid() {
        const valid = Date.now() - this.startTime < this.timeout;
        if (!valid && this.valid) {
          this.valid = false;
          debugger;
        }
        return this.valid;
      }
      disable() {
        this.timeout = Number.MAX_SAFE_INTEGER;
        this.isValid = () => true;
        this.valid = true;
      }
    };
    exports2.DateTimeout = DateTimeout;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/utils.js
var require_utils = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Array2D = void 0;
    var Array2D = class {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.array = [];
        this.array = new Array(width * height);
      }
      get(x3, y3) {
        return this.array[x3 + y3 * this.width];
      }
      set(x3, y3, value) {
        this.array[x3 + y3 * this.width] = value;
      }
    };
    exports2.Array2D = Array2D;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js
var require_dynamicProgrammingDiffing = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DynamicProgrammingDiffing = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var utils_1 = require_utils();
    var DynamicProgrammingDiffing = class {
      compute(sequence1, sequence2, timeout = diffAlgorithm_1.InfiniteTimeout.instance, equalityScore) {
        if (sequence1.length === 0 || sequence2.length === 0) {
          return diffAlgorithm_1.DiffAlgorithmResult.trivial(sequence1, sequence2);
        }
        const lcsLengths = new utils_1.Array2D(sequence1.length, sequence2.length);
        const directions = new utils_1.Array2D(sequence1.length, sequence2.length);
        const lengths = new utils_1.Array2D(sequence1.length, sequence2.length);
        for (let s12 = 0; s12 < sequence1.length; s12++) {
          for (let s23 = 0; s23 < sequence2.length; s23++) {
            if (!timeout.isValid()) {
              return diffAlgorithm_1.DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
            }
            const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s23);
            const verticalLen = s23 === 0 ? 0 : lcsLengths.get(s12, s23 - 1);
            let extendedSeqScore;
            if (sequence1.getElement(s12) === sequence2.getElement(s23)) {
              if (s12 === 0 || s23 === 0) {
                extendedSeqScore = 0;
              } else {
                extendedSeqScore = lcsLengths.get(s12 - 1, s23 - 1);
              }
              if (s12 > 0 && s23 > 0 && directions.get(s12 - 1, s23 - 1) === 3) {
                extendedSeqScore += lengths.get(s12 - 1, s23 - 1);
              }
              extendedSeqScore += equalityScore ? equalityScore(s12, s23) : 1;
            } else {
              extendedSeqScore = -1;
            }
            const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
            if (newValue === extendedSeqScore) {
              const prevLen = s12 > 0 && s23 > 0 ? lengths.get(s12 - 1, s23 - 1) : 0;
              lengths.set(s12, s23, prevLen + 1);
              directions.set(s12, s23, 3);
            } else if (newValue === horizontalLen) {
              lengths.set(s12, s23, 0);
              directions.set(s12, s23, 1);
            } else if (newValue === verticalLen) {
              lengths.set(s12, s23, 0);
              directions.set(s12, s23, 2);
            }
            lcsLengths.set(s12, s23, newValue);
          }
        }
        const result = [];
        let lastAligningPosS1 = sequence1.length;
        let lastAligningPosS2 = sequence2.length;
        function reportDecreasingAligningPositions(s12, s23) {
          if (s12 + 1 !== lastAligningPosS1 || s23 + 1 !== lastAligningPosS2) {
            result.push(new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(s12 + 1, lastAligningPosS1), new offsetRange_1.OffsetRange(s23 + 1, lastAligningPosS2)));
          }
          lastAligningPosS1 = s12;
          lastAligningPosS2 = s23;
        }
        let s1 = sequence1.length - 1;
        let s22 = sequence2.length - 1;
        while (s1 >= 0 && s22 >= 0) {
          if (directions.get(s1, s22) === 3) {
            reportDecreasingAligningPositions(s1, s22);
            s1--;
            s22--;
          } else {
            if (directions.get(s1, s22) === 1) {
              s1--;
            } else {
              s22--;
            }
          }
        }
        reportDecreasingAligningPositions(-1, -1);
        result.reverse();
        return new diffAlgorithm_1.DiffAlgorithmResult(result, false);
      }
    };
    exports2.DynamicProgrammingDiffing = DynamicProgrammingDiffing;
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/joinSequenceDiffs.js
var require_joinSequenceDiffs = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/joinSequenceDiffs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shiftSequenceDiffs = exports2.joinSequenceDiffs = exports2.removeRandomMatches = exports2.removeRandomLineMatches = exports2.smoothenSequenceDiffs = exports2.optimizeSequenceDiffs = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      let result = sequenceDiffs;
      result = joinSequenceDiffs(sequence1, sequence2, result);
      result = shiftSequenceDiffs(sequence1, sequence2, result);
      return result;
    }
    exports2.optimizeSequenceDiffs = optimizeSequenceDiffs;
    function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      const result = [];
      for (const s3 of sequenceDiffs) {
        const last = result[result.length - 1];
        if (!last) {
          result.push(s3);
          continue;
        }
        if (s3.seq1Range.start - last.seq1Range.endExclusive <= 2 || s3.seq2Range.start - last.seq2Range.endExclusive <= 2) {
          result[result.length - 1] = new diffAlgorithm_1.SequenceDiff(last.seq1Range.join(s3.seq1Range), last.seq2Range.join(s3.seq2Range));
        } else {
          result.push(s3);
        }
      }
      return result;
    }
    exports2.smoothenSequenceDiffs = smoothenSequenceDiffs;
    function removeRandomLineMatches(sequence1, _sequence2, sequenceDiffs) {
      let diffs = sequenceDiffs;
      if (diffs.length === 0) {
        return diffs;
      }
      let counter = 0;
      let shouldRepeat;
      do {
        shouldRepeat = false;
        const result = [
          diffs[0]
        ];
        for (let i4 = 1; i4 < diffs.length; i4++) {
          let shouldJoinDiffs = function(before, after) {
            const unchangedRange = new offsetRange_1.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
            const unchangedText = sequence1.getText(unchangedRange);
            const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
            if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
              return true;
            }
            return false;
          };
          const cur = diffs[i4];
          const lastResult = result[result.length - 1];
          const shouldJoin = shouldJoinDiffs(lastResult, cur);
          if (shouldJoin) {
            shouldRepeat = true;
            result[result.length - 1] = result[result.length - 1].join(cur);
          } else {
            result.push(cur);
          }
        }
        diffs = result;
      } while (counter++ < 10 && shouldRepeat);
      return diffs;
    }
    exports2.removeRandomLineMatches = removeRandomLineMatches;
    function removeRandomMatches(sequence1, sequence2, sequenceDiffs) {
      let diffs = sequenceDiffs;
      if (diffs.length === 0) {
        return diffs;
      }
      let counter = 0;
      let shouldRepeat;
      do {
        shouldRepeat = false;
        const result = [
          diffs[0]
        ];
        for (let i4 = 1; i4 < diffs.length; i4++) {
          let shouldJoinDiffs = function(before, after) {
            const unchangedRange = new offsetRange_1.OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
            const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
            if (unchangedLineCount > 5 || unchangedRange.length > 500) {
              return false;
            }
            const unchangedText = sequence1.getText(unchangedRange).trim();
            if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
              return false;
            }
            const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
            const beforeSeq1Length = before.seq1Range.length;
            const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
            const beforeSeq2Length = before.seq2Range.length;
            const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
            const afterSeq1Length = after.seq1Range.length;
            const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
            const afterSeq2Length = after.seq2Range.length;
            const max = 2 * 40 + 50;
            function cap(v3) {
              return Math.min(v3, max);
            }
            if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
              return true;
            }
            return false;
          };
          const cur = diffs[i4];
          const lastResult = result[result.length - 1];
          const shouldJoin = shouldJoinDiffs(lastResult, cur);
          if (shouldJoin) {
            shouldRepeat = true;
            result[result.length - 1] = result[result.length - 1].join(cur);
          } else {
            result.push(cur);
          }
        }
        diffs = result;
      } while (counter++ < 10 && shouldRepeat);
      for (let i4 = 0; i4 < diffs.length; i4++) {
        const cur = diffs[i4];
        let range1 = cur.seq1Range;
        let range2 = cur.seq2Range;
        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
        const prefix = sequence1.getText(new offsetRange_1.OffsetRange(fullRange1.start, cur.seq1Range.start));
        if (prefix.length > 0 && prefix.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100) {
          range1 = cur.seq1Range.deltaStart(-prefix.length);
          range2 = cur.seq2Range.deltaStart(-prefix.length);
        }
        const suffix = sequence1.getText(new offsetRange_1.OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
        if (suffix.length > 0 && (suffix.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 150)) {
          range1 = range1.deltaEnd(suffix.length);
          range2 = range2.deltaEnd(suffix.length);
        }
        diffs[i4] = new diffAlgorithm_1.SequenceDiff(range1, range2);
      }
      return diffs;
    }
    exports2.removeRandomMatches = removeRandomMatches;
    function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      if (sequenceDiffs.length === 0) {
        return sequenceDiffs;
      }
      const result = [];
      result.push(sequenceDiffs[0]);
      for (let i4 = 1; i4 < sequenceDiffs.length; i4++) {
        const prevResult = result[result.length - 1];
        let cur = sequenceDiffs[i4];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
          const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
          let d2;
          for (d2 = 1; d2 <= length; d2++) {
            if (sequence1.getElement(cur.seq1Range.start - d2) !== sequence1.getElement(cur.seq1Range.endExclusive - d2) || sequence2.getElement(cur.seq2Range.start - d2) !== sequence2.getElement(cur.seq2Range.endExclusive - d2)) {
              break;
            }
          }
          d2--;
          if (d2 === length) {
            result[result.length - 1] = new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new offsetRange_1.OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
            continue;
          }
          cur = cur.delta(-d2);
        }
        result.push(cur);
      }
      const result2 = [];
      for (let i4 = 0; i4 < result.length - 1; i4++) {
        const nextResult = result[i4 + 1];
        let cur = result[i4];
        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
          const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
          let d2;
          for (d2 = 0; d2 < length; d2++) {
            if (sequence1.getElement(cur.seq1Range.start + d2) !== sequence1.getElement(cur.seq1Range.endExclusive + d2) || sequence2.getElement(cur.seq2Range.start + d2) !== sequence2.getElement(cur.seq2Range.endExclusive + d2)) {
              break;
            }
          }
          if (d2 === length) {
            result[i4 + 1] = new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new offsetRange_1.OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
            continue;
          }
          if (d2 > 0) {
            cur = cur.delta(d2);
          }
        }
        result2.push(cur);
      }
      if (result.length > 0) {
        result2.push(result[result.length - 1]);
      }
      return result2;
    }
    exports2.joinSequenceDiffs = joinSequenceDiffs;
    function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
      if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
        return sequenceDiffs;
      }
      for (let i4 = 0; i4 < sequenceDiffs.length; i4++) {
        const prevDiff = i4 > 0 ? sequenceDiffs[i4 - 1] : void 0;
        const diff = sequenceDiffs[i4];
        const nextDiff = i4 + 1 < sequenceDiffs.length ? sequenceDiffs[i4 + 1] : void 0;
        const seq1ValidRange = new offsetRange_1.OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);
        const seq2ValidRange = new offsetRange_1.OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);
        if (diff.seq1Range.isEmpty) {
          sequenceDiffs[i4] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
        } else if (diff.seq2Range.isEmpty) {
          sequenceDiffs[i4] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();
        }
      }
      return sequenceDiffs;
    }
    exports2.shiftSequenceDiffs = shiftSequenceDiffs;
    function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
      const maxShiftLimit = 100;
      let deltaBefore = 1;
      while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
        deltaBefore++;
      }
      deltaBefore--;
      let deltaAfter = 0;
      while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
        deltaAfter++;
      }
      if (deltaBefore === 0 && deltaAfter === 0) {
        return diff;
      }
      let bestDelta = 0;
      let bestScore = -1;
      for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
        const seq2OffsetStart = diff.seq2Range.start + delta;
        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
        const seq1Offset = diff.seq1Range.start + delta;
        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
        if (score > bestScore) {
          bestScore = score;
          bestDelta = delta;
        }
      }
      return diff.delta(bestDelta);
    }
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js
var require_myersDiffAlgorithm = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MyersDiffAlgorithm = void 0;
    var offsetRange_1 = require_offsetRange();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var MyersDiffAlgorithm = class {
      compute(seq1, seq2, timeout = diffAlgorithm_1.InfiniteTimeout.instance) {
        if (seq1.length === 0 || seq2.length === 0) {
          return diffAlgorithm_1.DiffAlgorithmResult.trivial(seq1, seq2);
        }
        function getXAfterSnake(x3, y3) {
          while (x3 < seq1.length && y3 < seq2.length && seq1.getElement(x3) === seq2.getElement(y3)) {
            x3++;
            y3++;
          }
          return x3;
        }
        let d2 = 0;
        const V2 = new FastInt32Array();
        V2.set(0, getXAfterSnake(0, 0));
        const paths = new FastArrayNegativeIndices();
        paths.set(0, V2.get(0) === 0 ? null : new SnakePath(null, 0, 0, V2.get(0)));
        let k4 = 0;
        loop: while (true) {
          d2++;
          if (!timeout.isValid()) {
            return diffAlgorithm_1.DiffAlgorithmResult.trivialTimedOut(seq1, seq2);
          }
          const lowerBound = -Math.min(d2, seq2.length + d2 % 2);
          const upperBound = Math.min(d2, seq1.length + d2 % 2);
          for (k4 = lowerBound; k4 <= upperBound; k4 += 2) {
            const maxXofDLineTop = k4 === upperBound ? -1 : V2.get(k4 + 1);
            const maxXofDLineLeft = k4 === lowerBound ? -1 : V2.get(k4 - 1) + 1;
            const x3 = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);
            const y3 = x3 - k4;
            if (x3 > seq1.length || y3 > seq2.length) {
              continue;
            }
            const newMaxX = getXAfterSnake(x3, y3);
            V2.set(k4, newMaxX);
            const lastPath = x3 === maxXofDLineTop ? paths.get(k4 + 1) : paths.get(k4 - 1);
            paths.set(k4, newMaxX !== x3 ? new SnakePath(lastPath, x3, y3, newMaxX - x3) : lastPath);
            if (V2.get(k4) === seq1.length && V2.get(k4) - k4 === seq2.length) {
              break loop;
            }
          }
        }
        let path2 = paths.get(k4);
        const result = [];
        let lastAligningPosS1 = seq1.length;
        let lastAligningPosS2 = seq2.length;
        while (true) {
          const endX = path2 ? path2.x + path2.length : 0;
          const endY = path2 ? path2.y + path2.length : 0;
          if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
            result.push(new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(endX, lastAligningPosS1), new offsetRange_1.OffsetRange(endY, lastAligningPosS2)));
          }
          if (!path2) {
            break;
          }
          lastAligningPosS1 = path2.x;
          lastAligningPosS2 = path2.y;
          path2 = path2.prev;
        }
        result.reverse();
        return new diffAlgorithm_1.DiffAlgorithmResult(result, false);
      }
    };
    exports2.MyersDiffAlgorithm = MyersDiffAlgorithm;
    var SnakePath = class {
      constructor(prev, x3, y3, length) {
        this.prev = prev;
        this.x = x3;
        this.y = y3;
        this.length = length;
      }
    };
    var FastInt32Array = class {
      constructor() {
        this.positiveArr = new Int32Array(10);
        this.negativeArr = new Int32Array(10);
      }
      get(idx) {
        if (idx < 0) {
          idx = -idx - 1;
          return this.negativeArr[idx];
        } else {
          return this.positiveArr[idx];
        }
      }
      set(idx, value) {
        if (idx < 0) {
          idx = -idx - 1;
          if (idx >= this.negativeArr.length) {
            const arr = this.negativeArr;
            this.negativeArr = new Int32Array(arr.length * 2);
            this.negativeArr.set(arr);
          }
          this.negativeArr[idx] = value;
        } else {
          if (idx >= this.positiveArr.length) {
            const arr = this.positiveArr;
            this.positiveArr = new Int32Array(arr.length * 2);
            this.positiveArr.set(arr);
          }
          this.positiveArr[idx] = value;
        }
      }
    };
    var FastArrayNegativeIndices = class {
      constructor() {
        this.positiveArr = [];
        this.negativeArr = [];
      }
      get(idx) {
        if (idx < 0) {
          idx = -idx - 1;
          return this.negativeArr[idx];
        } else {
          return this.positiveArr[idx];
        }
      }
      set(idx, value) {
        if (idx < 0) {
          idx = -idx - 1;
          this.negativeArr[idx] = value;
        } else {
          this.positiveArr[idx] = value;
        }
      }
    };
  }
});

// node_modules/vscode-diff/dist/vs/editor/common/diff/advancedLinesDiffComputer.js
var require_advancedLinesDiffComputer = __commonJS({
  "node_modules/vscode-diff/dist/vs/editor/common/diff/advancedLinesDiffComputer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findFirstMonotonous = exports2.findLastMonotonous = exports2.LinesSliceCharSequence = exports2.LineSequence = exports2.getLineRangeMapping = exports2.lineRangeMappingFromRangeMappings = exports2.AdvancedLinesDiffComputer = void 0;
    var arrays_1 = require_arrays();
    var assert_1 = require_assert();
    var collections_1 = require_collections();
    var errors_1 = require_errors();
    var lineRange_1 = require_lineRange();
    var offsetRange_1 = require_offsetRange();
    var position_1 = require_position();
    var range_1 = require_range();
    var diffAlgorithm_1 = require_diffAlgorithm();
    var dynamicProgrammingDiffing_1 = require_dynamicProgrammingDiffing();
    var joinSequenceDiffs_1 = require_joinSequenceDiffs();
    var myersDiffAlgorithm_1 = require_myersDiffAlgorithm();
    var linesDiffComputer_1 = require_linesDiffComputer();
    var AdvancedLinesDiffComputer = class {
      constructor() {
        this.dynamicProgrammingDiffing = new dynamicProgrammingDiffing_1.DynamicProgrammingDiffing();
        this.myersDiffingAlgorithm = new myersDiffAlgorithm_1.MyersDiffAlgorithm();
      }
      computeDiff(originalLines, modifiedLines, options) {
        if (originalLines.length <= 1 && (0, arrays_1.equals)(originalLines, modifiedLines, (a3, b) => a3 === b)) {
          return new linesDiffComputer_1.LinesDiff([], [], false);
        }
        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
          return new linesDiffComputer_1.LinesDiff([
            new linesDiffComputer_1.LineRangeMapping(new lineRange_1.LineRange(1, originalLines.length + 1), new lineRange_1.LineRange(1, modifiedLines.length + 1), [
              new linesDiffComputer_1.RangeMapping(new range_1.Range(1, 1, originalLines.length, originalLines[0].length + 1), new range_1.Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))
            ])
          ], [], false);
        }
        const timeout = options.maxComputationTimeMs === 0 ? diffAlgorithm_1.InfiniteTimeout.instance : new diffAlgorithm_1.DateTimeout(options.maxComputationTimeMs);
        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
        const perfectHashes = /* @__PURE__ */ new Map();
        function getOrCreateHash(text) {
          let hash = perfectHashes.get(text);
          if (hash === void 0) {
            hash = perfectHashes.size;
            perfectHashes.set(text, hash);
          }
          return hash;
        }
        const srcDocLines = originalLines.map((l3) => getOrCreateHash(l3.trim()));
        const tgtDocLines = modifiedLines.map((l3) => getOrCreateHash(l3.trim()));
        const sequence1 = new LineSequence(srcDocLines, originalLines);
        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);
        const lineAlignmentResult = (() => {
          if (sequence1.length + sequence2.length < 1700) {
            return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
          }
          return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
        })();
        let lineAlignments = lineAlignmentResult.diffs;
        let hitTimeout = lineAlignmentResult.hitTimeout;
        lineAlignments = (0, joinSequenceDiffs_1.optimizeSequenceDiffs)(sequence1, sequence2, lineAlignments);
        lineAlignments = (0, joinSequenceDiffs_1.removeRandomLineMatches)(sequence1, sequence2, lineAlignments);
        const alignments = [];
        const scanForWhitespaceChanges = (equalLinesCount) => {
          if (!considerWhitespaceChanges) {
            return;
          }
          for (let i4 = 0; i4 < equalLinesCount; i4++) {
            const seq1Offset = seq1LastStart + i4;
            const seq2Offset = seq2LastStart + i4;
            if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
              const characterDiffs = this.refineDiff(originalLines, modifiedLines, new diffAlgorithm_1.SequenceDiff(new offsetRange_1.OffsetRange(seq1Offset, seq1Offset + 1), new offsetRange_1.OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
              for (const a3 of characterDiffs.mappings) {
                alignments.push(a3);
              }
              if (characterDiffs.hitTimeout) {
                hitTimeout = true;
              }
            }
          }
        };
        let seq1LastStart = 0;
        let seq2LastStart = 0;
        for (const diff of lineAlignments) {
          (0, assert_1.assertFn)(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
          const equalLinesCount = diff.seq1Range.start - seq1LastStart;
          scanForWhitespaceChanges(equalLinesCount);
          seq1LastStart = diff.seq1Range.endExclusive;
          seq2LastStart = diff.seq2Range.endExclusive;
          const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
          if (characterDiffs.hitTimeout) {
            hitTimeout = true;
          }
          for (const a3 of characterDiffs.mappings) {
            alignments.push(a3);
          }
        }
        scanForWhitespaceChanges(originalLines.length - seq1LastStart);
        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
        let moves = [];
        if (options.computeMoves) {
          moves = this.computeMoves(changes, originalLines, modifiedLines, srcDocLines, tgtDocLines, timeout, considerWhitespaceChanges);
        }
        (0, assert_1.assertFn)(() => {
          function validatePosition(pos, lines) {
            if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
              return false;
            }
            const line = lines[pos.lineNumber - 1];
            if (pos.column < 1 || pos.column > line.length + 1) {
              return false;
            }
            return true;
          }
          function validateRange(range, lines) {
            if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
              return false;
            }
            if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
              return false;
            }
            return true;
          }
          for (const c3 of changes) {
            if (!c3.innerChanges) {
              return false;
            }
            for (const ic of c3.innerChanges) {
              const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
              if (!valid) {
                return false;
              }
            }
            if (!validateRange(c3.modifiedRange, modifiedLines) || !validateRange(c3.originalRange, originalLines)) {
              return false;
            }
          }
          return true;
        });
        return new linesDiffComputer_1.LinesDiff(changes, moves, hitTimeout);
      }
      computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
        const moves = [];
        const deletions = changes.filter((c3) => c3.modifiedRange.isEmpty && c3.originalRange.length >= 3).map((d2) => new LineRangeFragment(d2.originalRange, originalLines, d2));
        const insertions = new Set(changes.filter((c3) => c3.originalRange.isEmpty && c3.modifiedRange.length >= 3).map((d2) => new LineRangeFragment(d2.modifiedRange, modifiedLines, d2)));
        const excludedChanges = /* @__PURE__ */ new Set();
        for (const deletion of deletions) {
          let highestSimilarity = -1;
          let best;
          for (const insertion of insertions) {
            const similarity = deletion.computeSimilarity(insertion);
            if (similarity > highestSimilarity) {
              highestSimilarity = similarity;
              best = insertion;
            }
          }
          if (highestSimilarity > 0.9 && best) {
            insertions.delete(best);
            moves.push(new linesDiffComputer_1.SimpleLineRangeMapping(deletion.range, best.range));
            excludedChanges.add(deletion.source);
            excludedChanges.add(best.source);
          }
          if (!timeout.isValid()) {
            return [];
          }
        }
        const original3LineHashes = new collections_1.SetMap();
        for (const change of changes) {
          if (excludedChanges.has(change)) {
            continue;
          }
          for (let i4 = change.originalRange.startLineNumber; i4 < change.originalRange.endLineNumberExclusive - 2; i4++) {
            const key = `${hashedOriginalLines[i4 - 1]}:${hashedOriginalLines[i4 + 1 - 1]}:${hashedOriginalLines[i4 + 2 - 1]}`;
            original3LineHashes.add(key, { range: new lineRange_1.LineRange(i4, i4 + 3) });
          }
        }
        const possibleMappings = [];
        changes.sort((0, arrays_1.compareBy)((c3) => c3.modifiedRange.startLineNumber, arrays_1.numberComparator));
        for (const change of changes) {
          if (excludedChanges.has(change)) {
            continue;
          }
          let lastMappings = [];
          for (let i4 = change.modifiedRange.startLineNumber; i4 < change.modifiedRange.endLineNumberExclusive - 2; i4++) {
            const key = `${hashedModifiedLines[i4 - 1]}:${hashedModifiedLines[i4 + 1 - 1]}:${hashedModifiedLines[i4 + 2 - 1]}`;
            const currentModifiedRange = new lineRange_1.LineRange(i4, i4 + 3);
            const nextMappings = [];
            original3LineHashes.forEach(key, ({ range }) => {
              for (const lastMapping of lastMappings) {
                if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
                  lastMapping.originalLineRange = new lineRange_1.LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
                  lastMapping.modifiedLineRange = new lineRange_1.LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
                  nextMappings.push(lastMapping);
                  return;
                }
              }
              const mapping = {
                modifiedLineRange: currentModifiedRange,
                originalLineRange: range
              };
              possibleMappings.push(mapping);
              nextMappings.push(mapping);
            });
            lastMappings = nextMappings;
          }
          if (!timeout.isValid()) {
            return [];
          }
        }
        possibleMappings.sort((0, arrays_1.reverseOrder)((0, arrays_1.compareBy)((m3) => m3.modifiedLineRange.length, arrays_1.numberComparator)));
        const modifiedSet = new LineRangeSet();
        const originalSet = new LineRangeSet();
        for (const mapping of possibleMappings) {
          const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
          const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
          const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).map((r3) => r3.delta(diffOrigToMod));
          const modifiedIntersectedSections = intersectRanges(modifiedSections, originalTranslatedSections);
          for (const s3 of modifiedIntersectedSections) {
            if (s3.length < 3) {
              continue;
            }
            const modifiedLineRange = s3;
            const originalLineRange = s3.delta(-diffOrigToMod);
            moves.push(new linesDiffComputer_1.SimpleLineRangeMapping(originalLineRange, modifiedLineRange));
            modifiedSet.addRange(modifiedLineRange);
            originalSet.addRange(originalLineRange);
          }
        }
        moves.sort((0, arrays_1.compareBy)((m3) => m3.original.startLineNumber, arrays_1.numberComparator));
        if (moves.length === 0) {
          return [];
        }
        let joinedMoves = [moves[0]];
        for (let i4 = 1; i4 < moves.length; i4++) {
          const last = joinedMoves[joinedMoves.length - 1];
          const current = moves[i4];
          const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
          const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
          const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
          if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
            joinedMoves[joinedMoves.length - 1] = last.join(current);
            continue;
          }
          const originalText = current.original.toOffsetRange().slice(originalLines).map((l3) => l3.trim()).join("\n");
          if (originalText.length <= 10) {
            continue;
          }
          joinedMoves.push(current);
        }
        const originalChanges = MonotonousFinder.createOfSorted(changes, (c3) => c3.originalRange.endLineNumberExclusive, arrays_1.numberComparator);
        joinedMoves = joinedMoves.filter((m3) => {
          const diffBeforeOriginalMove = originalChanges.findLastItemBeforeOrEqual(m3.original.startLineNumber) || new linesDiffComputer_1.LineRangeMapping(new lineRange_1.LineRange(1, 1), new lineRange_1.LineRange(1, 1), []);
          const modifiedDistToPrevDiff = m3.modified.startLineNumber - diffBeforeOriginalMove.modifiedRange.endLineNumberExclusive;
          const originalDistToPrevDiff = m3.original.startLineNumber - diffBeforeOriginalMove.originalRange.endLineNumberExclusive;
          const differentDistances = modifiedDistToPrevDiff !== originalDistToPrevDiff;
          return differentDistances;
        });
        const fullMoves = joinedMoves.map((m3) => {
          const moveChanges = this.refineDiff(originalLines, modifiedLines, new diffAlgorithm_1.SequenceDiff(m3.original.toOffsetRange(), m3.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
          const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
          return new linesDiffComputer_1.MovedText(m3, mappings);
        });
        return fullMoves;
      }
      refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
        const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
        let diffs = diffResult.diffs;
        diffs = (0, joinSequenceDiffs_1.optimizeSequenceDiffs)(slice1, slice2, diffs);
        diffs = coverFullWords(slice1, slice2, diffs);
        diffs = (0, joinSequenceDiffs_1.smoothenSequenceDiffs)(slice1, slice2, diffs);
        diffs = (0, joinSequenceDiffs_1.removeRandomMatches)(slice1, slice2, diffs);
        const result = diffs.map((d2) => new linesDiffComputer_1.RangeMapping(slice1.translateRange(d2.seq1Range), slice2.translateRange(d2.seq2Range)));
        return {
          mappings: result,
          hitTimeout: diffResult.hitTimeout
        };
      }
    };
    exports2.AdvancedLinesDiffComputer = AdvancedLinesDiffComputer;
    var MonotonousFinder = class _MonotonousFinder {
      static create(items, itemToDomain, domainComparator) {
        items.sort((a3, b) => domainComparator(itemToDomain(a3), itemToDomain(b)));
        return new _MonotonousFinder(items, itemToDomain, domainComparator);
      }
      static createOfSorted(items, itemToDomain, domainComparator) {
        return new _MonotonousFinder(items, itemToDomain, domainComparator);
      }
      constructor(_items, _itemToDomain, _domainComparator) {
        this._items = _items;
        this._itemToDomain = _itemToDomain;
        this._domainComparator = _domainComparator;
        this._currentIdx = 0;
        this._lastValue = void 0;
        this._hasLastValue = false;
      }
      /**
       * Assumes the values are monotonously increasing.
       */
      findLastItemBeforeOrEqual(value) {
        if (this._hasLastValue && arrays_1.CompareResult.isLessThan(this._domainComparator(value, this._lastValue))) {
          throw new errors_1.BugIndicatingError();
        }
        this._lastValue = value;
        this._hasLastValue = true;
        while (this._currentIdx < this._items.length && arrays_1.CompareResult.isLessThanOrEqual(this._domainComparator(this._itemToDomain(this._items[this._currentIdx]), value))) {
          this._currentIdx++;
        }
        return this._currentIdx === 0 ? void 0 : this._items[this._currentIdx - 1];
      }
    };
    function intersectRanges(ranges1, ranges2) {
      const result = [];
      let i1 = 0;
      let i22 = 0;
      while (i1 < ranges1.length && i22 < ranges2.length) {
        const r1 = ranges1[i1];
        const r22 = ranges2[i22];
        const i4 = r1.intersect(r22);
        if (i4 && !i4.isEmpty) {
          result.push(i4);
        }
        if (r1.endLineNumberExclusive < r22.endLineNumberExclusive) {
          i1++;
        } else {
          i22++;
        }
      }
      return result;
    }
    var LineRangeSet = class {
      constructor() {
        this._normalizedRanges = [];
      }
      addRange(range) {
        const joinRangeStartIdx = mapMinusOne(this._normalizedRanges.findIndex((r3) => r3.endLineNumberExclusive >= range.startLineNumber), this._normalizedRanges.length);
        const joinRangeEndIdxExclusive = (0, arrays_1.findLastIndex)(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
        } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
          const joinRange = this._normalizedRanges[joinRangeStartIdx];
          this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
        } else {
          const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
          this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
      }
      intersects(range) {
        for (const r3 of this._normalizedRanges) {
          if (r3.intersectsStrict(range)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Subtracts all ranges in this set from `range` and returns the result.
       */
      subtractFrom(range) {
        const joinRangeStartIdx = mapMinusOne(this._normalizedRanges.findIndex((r3) => r3.endLineNumberExclusive >= range.startLineNumber), this._normalizedRanges.length);
        const joinRangeEndIdxExclusive = (0, arrays_1.findLastIndex)(this._normalizedRanges, (r3) => r3.startLineNumber <= range.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          return [range];
        }
        const result = [];
        let startLineNumber = range.startLineNumber;
        for (let i4 = joinRangeStartIdx; i4 < joinRangeEndIdxExclusive; i4++) {
          const r3 = this._normalizedRanges[i4];
          if (r3.startLineNumber > startLineNumber) {
            result.push(new lineRange_1.LineRange(startLineNumber, r3.startLineNumber));
          }
          startLineNumber = r3.endLineNumberExclusive;
        }
        if (startLineNumber < range.endLineNumberExclusive) {
          result.push(new lineRange_1.LineRange(startLineNumber, range.endLineNumberExclusive));
        }
        return result;
      }
    };
    function mapMinusOne(idx, mapTo) {
      return idx === -1 ? mapTo : idx;
    }
    function coverFullWords(sequence1, sequence2, sequenceDiffs) {
      const additional = [];
      let lastModifiedWord = void 0;
      function maybePushWordToAdditional() {
        if (!lastModifiedWord) {
          return;
        }
        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;
        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;
        if (originalLength1 !== originalLength2) {
        }
        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {
          additional.push(new diffAlgorithm_1.SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));
        }
        lastModifiedWord = void 0;
      }
      for (const s3 of sequenceDiffs) {
        let processWord = function(s1Range, s2Range) {
          if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {
            if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {
              const s1Added = offsetRange_1.OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);
              const s2Added = offsetRange_1.OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);
              lastModifiedWord.deleted += s1Added?.length ?? 0;
              lastModifiedWord.added += s2Added?.length ?? 0;
              lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);
              lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);
            } else {
              maybePushWordToAdditional();
              lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range, s2Range };
            }
          }
          const changedS1 = s1Range.intersect(s3.seq1Range);
          const changedS2 = s2Range.intersect(s3.seq2Range);
          lastModifiedWord.count++;
          lastModifiedWord.deleted += changedS1?.length ?? 0;
          lastModifiedWord.added += changedS2?.length ?? 0;
        };
        const w1Before = sequence1.findWordContaining(s3.seq1Range.start - 1);
        const w2Before = sequence2.findWordContaining(s3.seq2Range.start - 1);
        const w1After = sequence1.findWordContaining(s3.seq1Range.endExclusive);
        const w2After = sequence2.findWordContaining(s3.seq2Range.endExclusive);
        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {
          processWord(w1Before, w2Before);
        } else {
          if (w1Before && w2Before) {
            processWord(w1Before, w2Before);
          }
          if (w1After && w2After) {
            processWord(w1After, w2After);
          }
        }
      }
      maybePushWordToAdditional();
      const merged = mergeSequenceDiffs(sequenceDiffs, additional);
      return merged;
    }
    function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
      const result = [];
      while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
        const sd1 = sequenceDiffs1[0];
        const sd2 = sequenceDiffs2[0];
        let next;
        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
          next = sequenceDiffs1.shift();
        } else {
          next = sequenceDiffs2.shift();
        }
        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
          result[result.length - 1] = result[result.length - 1].join(next);
        } else {
          result.push(next);
        }
      }
      return result;
    }
    function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
      const changes = [];
      for (const g of group(alignments.map((a3) => getLineRangeMapping(a3, originalLines, modifiedLines)), (a1, a22) => a1.originalRange.overlapOrTouch(a22.originalRange) || a1.modifiedRange.overlapOrTouch(a22.modifiedRange))) {
        const first = g[0];
        const last = g[g.length - 1];
        changes.push(new linesDiffComputer_1.LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map((a3) => a3.innerChanges[0])));
      }
      (0, assert_1.assertFn)(() => {
        if (!dontAssertStartLine) {
          if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {
            return false;
          }
        }
        return (0, assert_1.checkAdjacentItems)(changes, (m1, m22) => m22.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m22.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.originalRange.endLineNumberExclusive < m22.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m22.modifiedRange.startLineNumber);
      });
      return changes;
    }
    exports2.lineRangeMappingFromRangeMappings = lineRangeMappingFromRangeMappings;
    function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
      let lineStartDelta = 0;
      let lineEndDelta = 0;
      if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
        lineEndDelta = -1;
      }
      if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
        lineStartDelta = 1;
      }
      const originalLineRange = new lineRange_1.LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
      const modifiedLineRange = new lineRange_1.LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
      return new linesDiffComputer_1.LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
    }
    exports2.getLineRangeMapping = getLineRangeMapping;
    function* group(items, shouldBeGrouped) {
      let currentGroup;
      let last;
      for (const item of items) {
        if (last !== void 0 && shouldBeGrouped(last, item)) {
          currentGroup.push(item);
        } else {
          if (currentGroup) {
            yield currentGroup;
          }
          currentGroup = [item];
        }
        last = item;
      }
      if (currentGroup) {
        yield currentGroup;
      }
    }
    var LineSequence = class {
      constructor(trimmedHash, lines) {
        this.trimmedHash = trimmedHash;
        this.lines = lines;
      }
      getElement(offset) {
        return this.trimmedHash[offset];
      }
      get length() {
        return this.trimmedHash.length;
      }
      getBoundaryScore(length) {
        const indentationBefore = length === 0 ? 0 : getIndentation2(this.lines[length - 1]);
        const indentationAfter = length === this.lines.length ? 0 : getIndentation2(this.lines[length]);
        return 1e3 - (indentationBefore + indentationAfter);
      }
      getText(range) {
        return this.lines.slice(range.start, range.endExclusive).join("\n");
      }
      isStronglyEqual(offset1, offset2) {
        return this.lines[offset1] === this.lines[offset2];
      }
    };
    exports2.LineSequence = LineSequence;
    function getIndentation2(str) {
      let i4 = 0;
      while (i4 < str.length && (str.charCodeAt(i4) === 32 || str.charCodeAt(i4) === 9)) {
        i4++;
      }
      return i4;
    }
    var LinesSliceCharSequence = class {
      constructor(lines, lineRange, considerWhitespaceChanges) {
        this.lines = lines;
        this.considerWhitespaceChanges = considerWhitespaceChanges;
        this.elements = [];
        this.firstCharOffsetByLineMinusOne = [];
        this.additionalOffsetByLine = [];
        let trimFirstLineFully = false;
        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
          lineRange = new offsetRange_1.OffsetRange(lineRange.start - 1, lineRange.endExclusive);
          trimFirstLineFully = true;
        }
        this.lineRange = lineRange;
        for (let i4 = this.lineRange.start; i4 < this.lineRange.endExclusive; i4++) {
          let line = lines[i4];
          let offset = 0;
          if (trimFirstLineFully) {
            offset = line.length;
            line = "";
            trimFirstLineFully = false;
          } else if (!considerWhitespaceChanges) {
            const trimmedStartLine = line.trimStart();
            offset = line.length - trimmedStartLine.length;
            line = trimmedStartLine.trimEnd();
          }
          this.additionalOffsetByLine.push(offset);
          for (let i5 = 0; i5 < line.length; i5++) {
            this.elements.push(line.charCodeAt(i5));
          }
          if (i4 < lines.length - 1) {
            this.elements.push("\n".charCodeAt(0));
            this.firstCharOffsetByLineMinusOne[i4 - this.lineRange.start] = this.elements.length;
          }
        }
        this.additionalOffsetByLine.push(0);
      }
      toString() {
        return `Slice: "${this.text}"`;
      }
      get text() {
        return this.getText(new offsetRange_1.OffsetRange(0, this.length));
      }
      getText(range) {
        return this.elements.slice(range.start, range.endExclusive).map((e3) => String.fromCharCode(e3)).join("");
      }
      getElement(offset) {
        return this.elements[offset];
      }
      get length() {
        return this.elements.length;
      }
      getBoundaryScore(length) {
        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
        if (prevCategory === 6 && nextCategory === 7) {
          return 0;
        }
        let score2 = 0;
        if (prevCategory !== nextCategory) {
          score2 += 10;
          if (nextCategory === 1) {
            score2 += 1;
          }
        }
        score2 += getCategoryBoundaryScore(prevCategory);
        score2 += getCategoryBoundaryScore(nextCategory);
        return score2;
      }
      translateOffset(offset) {
        if (this.lineRange.isEmpty) {
          return new position_1.Position(this.lineRange.start + 1, 1);
        }
        let i4 = 0;
        let j3 = this.firstCharOffsetByLineMinusOne.length;
        while (i4 < j3) {
          const k4 = Math.floor((i4 + j3) / 2);
          if (this.firstCharOffsetByLineMinusOne[k4] > offset) {
            j3 = k4;
          } else {
            i4 = k4 + 1;
          }
        }
        const offsetOfFirstCharInLine = i4 === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i4 - 1];
        return new position_1.Position(this.lineRange.start + i4 + 1, offset - offsetOfFirstCharInLine + 1 + this.additionalOffsetByLine[i4]);
      }
      translateRange(range) {
        return range_1.Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
      }
      /**
       * Finds the word that contains the character at the given offset
       */
      findWordContaining(offset) {
        if (offset < 0 || offset >= this.elements.length) {
          return void 0;
        }
        if (!isWordChar(this.elements[offset])) {
          return void 0;
        }
        let start = offset;
        while (start > 0 && isWordChar(this.elements[start - 1])) {
          start--;
        }
        let end = offset;
        while (end < this.elements.length && isWordChar(this.elements[end])) {
          end++;
        }
        return new offsetRange_1.OffsetRange(start, end);
      }
      countLinesIn(range) {
        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
      }
      isStronglyEqual(offset1, offset2) {
        return this.elements[offset1] === this.elements[offset2];
      }
      extendToFullLines(range) {
        const start = findLastMonotonous(this.firstCharOffsetByLineMinusOne, (x3) => x3 <= range.start) ?? 0;
        const end = findFirstMonotonous(this.firstCharOffsetByLineMinusOne, (x3) => range.endExclusive <= x3) ?? this.elements.length;
        return new offsetRange_1.OffsetRange(start, end);
      }
    };
    exports2.LinesSliceCharSequence = LinesSliceCharSequence;
    function findLastIdxMonotonous(arr, predicate) {
      let i4 = 0;
      let j3 = arr.length;
      while (i4 < j3) {
        const k4 = Math.floor((i4 + j3) / 2);
        if (predicate(arr[k4])) {
          i4 = k4 + 1;
        } else {
          j3 = k4;
        }
      }
      return i4 - 1;
    }
    function findLastMonotonous(arr, predicate) {
      const idx = findLastIdxMonotonous(arr, predicate);
      return idx === -1 ? void 0 : arr[idx];
    }
    exports2.findLastMonotonous = findLastMonotonous;
    function findFirstIdxMonotonous(arr, predicate) {
      let i4 = 0;
      let j3 = arr.length;
      while (i4 < j3) {
        const k4 = Math.floor((i4 + j3) / 2);
        if (predicate(arr[k4])) {
          j3 = k4;
        } else {
          i4 = k4 + 1;
        }
      }
      return i4;
    }
    function findFirstMonotonous(arr, predicate) {
      const idx = findFirstIdxMonotonous(arr, predicate);
      return idx === arr.length ? void 0 : arr[idx];
    }
    exports2.findFirstMonotonous = findFirstMonotonous;
    function isWordChar(charCode) {
      return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
    }
    var score = {
      [
        0
        /* CharBoundaryCategory.WordLower */
      ]: 0,
      [
        1
        /* CharBoundaryCategory.WordUpper */
      ]: 0,
      [
        2
        /* CharBoundaryCategory.WordNumber */
      ]: 0,
      [
        3
        /* CharBoundaryCategory.End */
      ]: 10,
      [
        4
        /* CharBoundaryCategory.Other */
      ]: 2,
      [
        5
        /* CharBoundaryCategory.Space */
      ]: 3,
      [
        6
        /* CharBoundaryCategory.LineBreakCR */
      ]: 10,
      [
        7
        /* CharBoundaryCategory.LineBreakLF */
      ]: 10
    };
    function getCategoryBoundaryScore(category) {
      return score[category];
    }
    function getCategory(charCode) {
      if (charCode === 10) {
        return 7;
      } else if (charCode === 13) {
        return 6;
      } else if (isSpace(charCode)) {
        return 5;
      } else if (charCode >= 97 && charCode <= 122) {
        return 0;
      } else if (charCode >= 65 && charCode <= 90) {
        return 1;
      } else if (charCode >= 48 && charCode <= 57) {
        return 2;
      } else if (charCode === -1) {
        return 3;
      } else {
        return 4;
      }
    }
    function isSpace(charCode) {
      return charCode === 32 || charCode === 9;
    }
    var chrKeys = /* @__PURE__ */ new Map();
    function getKey(chr) {
      let key = chrKeys.get(chr);
      if (key === void 0) {
        key = chrKeys.size;
        chrKeys.set(chr, key);
      }
      return key;
    }
    var LineRangeFragment = class {
      constructor(range, lines, source) {
        this.range = range;
        this.lines = lines;
        this.source = source;
        this.histogram = [];
        let counter = 0;
        for (let i4 = range.startLineNumber - 1; i4 < range.endLineNumberExclusive - 1; i4++) {
          const line = lines[i4];
          for (let j3 = 0; j3 < line.length; j3++) {
            counter++;
            const chr = line[j3];
            const key2 = getKey(chr);
            this.histogram[key2] = (this.histogram[key2] || 0) + 1;
          }
          counter++;
          const key = getKey("\n");
          this.histogram[key] = (this.histogram[key] || 0) + 1;
        }
        this.totalCount = counter;
      }
      computeSimilarity(other) {
        let sumDifferences = 0;
        const maxLength = Math.max(this.histogram.length, other.histogram.length);
        for (let i4 = 0; i4 < maxLength; i4++) {
          sumDifferences += Math.abs((this.histogram[i4] ?? 0) - (other.histogram[i4] ?? 0));
        }
        return 1 - sumDifferences / (this.totalCount + other.totalCount);
      }
    };
  }
});

// node_modules/vscode-diff/dist/index.js
var require_dist = __commonJS({
  "node_modules/vscode-diff/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_linesDiffComputer(), exports2);
    __exportStar(require_diff(), exports2);
    __exportStar(require_diffChange(), exports2);
    __exportStar(require_legacyLinesDiffComputer(), exports2);
    __exportStar(require_advancedLinesDiffComputer(), exports2);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/TextOperation.js
var require_TextOperation = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/TextOperation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextOperation = void 0;
    var TextOperation = class _TextOperation {
      // When an operation is applied to an input string, you can think of this as
      // if an imaginary cursor runs over the entire string and skips over some
      // parts, deletes some parts and inserts characters at some positions. These
      // actions (skip/delete/insert) are stored as an array in the "ops" property.
      ops = [];
      // An operation's baseLength is the length of every string the operation
      // can be applied to.
      baseLength = 0;
      // The targetLength is the length of every string that results from applying
      // the operation on a valid input string.
      targetLength = 0;
      /**
       * Transform takes two operations A and B that happened concurrently and
       * produces two operations A' and B' (in an array) such that
       * `apply(apply(S, A), B') = apply(apply(S, B), A')`. This function is the
       * heart of OT.
       */
      static transform(operation1, operation2) {
        if (operation1.baseLength !== operation2.baseLength) {
          throw new Error("Both operations have to have the same base length");
        }
        const operation1prime = new _TextOperation();
        const operation2prime = new _TextOperation();
        const ops1 = operation1.ops, ops2 = operation2.ops;
        let i1 = 0, i22 = 0;
        let op1 = ops1[i1++], op2 = ops2[i22++];
        while (true) {
          if (typeof op1 === "undefined" && typeof op2 === "undefined") {
            break;
          }
          if (_TextOperation.isInsert(op1)) {
            operation1prime.insert(op1);
            operation2prime.retain(op1.length);
            op1 = ops1[i1++];
            continue;
          }
          if (_TextOperation.isInsert(op2)) {
            operation1prime.retain(op2.length);
            operation2prime.insert(op2);
            op2 = ops2[i22++];
            continue;
          }
          if (typeof op1 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too short.");
          }
          if (typeof op2 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too long.");
          }
          let minl;
          if (_TextOperation.isRetain(op1) && _TextOperation.isRetain(op2)) {
            if (op1 > op2) {
              minl = op2;
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              minl = op2;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = op1;
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
            operation1prime.retain(minl);
            operation2prime.retain(minl);
          } else if (_TextOperation.isDelete(op1) && _TextOperation.isDelete(op2)) {
            if (-op1 > -op2) {
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isDelete(op1) && _TextOperation.isRetain(op2)) {
            if (-op1 > op2) {
              minl = op2;
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (-op1 === op2) {
              minl = op2;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = -op1;
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
            operation1prime["delete"](minl);
          } else if (_TextOperation.isRetain(op1) && _TextOperation.isDelete(op2)) {
            if (op1 > -op2) {
              minl = -op2;
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (op1 === -op2) {
              minl = op1;
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              minl = op1;
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
            operation2prime["delete"](minl);
          } else {
            throw new Error("The two operations aren't compatible");
          }
        }
        return [operation1prime, operation2prime];
      }
      // Operation are essentially lists of ops. There are three types of ops:
      // 1. Retain ops: Advance the cursor position by a given number of characters.
      //   Represented by positive ints.
      static isRetain(op) {
        return typeof op === "number" && op > 0;
      }
      // 2. Insert ops: Insert a given string at the current cursor position.
      //   Represented by strings.
      static isInsert(op) {
        return typeof op === "string";
      }
      // 3. Delete ops: Delete the next n characters. Represented by negative ints.
      static isDelete(op) {
        return typeof op === "number" && op < 0;
      }
      // Converts a plain JS object into an operation and validates it.
      static fromJSON(ops) {
        const o2 = new _TextOperation();
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            o2.retain(op);
          } else if (_TextOperation.isInsert(op)) {
            o2.insert(op);
          } else if (_TextOperation.isDelete(op)) {
            o2["delete"](op);
          } else {
            throw new Error("unknown operation: " + JSON.stringify(op));
          }
        }
        return o2;
      }
      invert(str) {
        let strIndex = 0;
        const inverse = new _TextOperation();
        const ops = this.ops;
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            inverse.retain(op);
            strIndex += op;
          } else if (_TextOperation.isInsert(op)) {
            inverse["delete"](op.length);
          } else {
            inverse.insert(str.slice(strIndex, strIndex - op));
            strIndex -= op;
          }
        }
        return inverse;
      }
      equals(other) {
        if (this.baseLength !== other.baseLength) {
          return false;
        }
        if (this.targetLength !== other.targetLength) {
          return false;
        }
        if (this.ops.length !== other.ops.length) {
          return false;
        }
        for (let i4 = 0; i4 < this.ops.length; i4++) {
          if (this.ops[i4] !== other.ops[i4]) {
            return false;
          }
        }
        return true;
      }
      // Skip over a given number of characters.
      retain(n2) {
        if (typeof n2 !== "number") {
          throw new Error("retain expects an integer");
        }
        if (n2 === 0) {
          return this;
        }
        this.baseLength += n2;
        this.targetLength += n2;
        if (_TextOperation.isRetain(this.ops[this.ops.length - 1])) {
          this.ops[this.ops.length - 1] += n2;
        } else {
          this.ops.push(n2);
        }
        return this;
      }
      // Insert a string at the current position.
      insert(str) {
        if (typeof str !== "string") {
          throw new Error("insert expects a string");
        }
        if (str === "") {
          return this;
        }
        this.targetLength += str.length;
        const ops = this.ops;
        if (_TextOperation.isInsert(ops[ops.length - 1])) {
          ops[ops.length - 1] += str;
        } else if (_TextOperation.isDelete(ops[ops.length - 1])) {
          if (_TextOperation.isInsert(ops[ops.length - 2])) {
            ops[ops.length - 2] += str;
          } else {
            ops[ops.length] = ops[ops.length - 1];
            ops[ops.length - 2] = str;
          }
        } else {
          ops.push(str);
        }
        return this;
      }
      // Delete a string at the current position.
      delete(n2) {
        if (typeof n2 === "string") {
          n2 = n2.length;
        }
        if (typeof n2 !== "number") {
          throw new Error("delete expects an integer or a string");
        }
        if (n2 === 0) {
          return this;
        }
        if (n2 > 0) {
          n2 = -n2;
        }
        this.baseLength -= n2;
        if (_TextOperation.isDelete(this.ops[this.ops.length - 1])) {
          this.ops[this.ops.length - 1] += n2;
        } else {
          this.ops.push(n2);
        }
        return this;
      }
      // Tests whether this operation has no effect.
      isNoop() {
        return this.ops.length === 0 || this.ops.length === 1 && _TextOperation.isRetain(this.ops[0]);
      }
      // Apply an operation to a string, returning a new string. Throws an error if
      // there's a mismatch between the input string and the operation.
      apply(str) {
        if (str.length !== this.baseLength) {
          throw new Error("The operation's base length must be equal to the string's length.");
        }
        const newStr = [];
        let j3 = 0;
        let strIndex = 0;
        const ops = this.ops;
        for (let i4 = 0, l3 = ops.length; i4 < l3; i4++) {
          const op = ops[i4];
          if (_TextOperation.isRetain(op)) {
            if (strIndex + op > str.length) {
              throw new Error("Operation can't retain more characters than are left in the string.");
            }
            newStr[j3++] = str.slice(strIndex, strIndex + op);
            strIndex += op;
          } else if (_TextOperation.isInsert(op)) {
            newStr[j3++] = op;
          } else {
            strIndex -= op;
          }
        }
        if (strIndex !== str.length) {
          throw new Error("The operation didn't operate on the whole string.");
        }
        return newStr.join("");
      }
      /**
       * Compose merges two consecutive operations into one operation, that
       * preserves the changes of both. Or, in other words, for each input string S
       * and a pair of consecutive operations A and B,
       * apply(apply(S, A), B) = apply(S, compose(A, B)) must hold.
       */
      compose(operation2) {
        if (this.targetLength !== operation2.baseLength) {
          throw new Error("The base length of the second operation has to be the target length of the first operation");
        }
        const operation = new _TextOperation();
        const ops1 = this.ops, ops2 = operation2.ops;
        let i1 = 0, i22 = 0;
        let op1 = ops1[i1++], op2 = ops2[i22++];
        while (true) {
          if (typeof op1 === "undefined" && typeof op2 === "undefined") {
            break;
          }
          if (_TextOperation.isDelete(op1)) {
            operation["delete"](op1);
            op1 = ops1[i1++];
            continue;
          }
          if (_TextOperation.isInsert(op2)) {
            operation.insert(op2);
            op2 = ops2[i22++];
            continue;
          }
          if (typeof op1 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too short.");
          }
          if (typeof op2 === "undefined") {
            throw new Error("Cannot compose operations: first operation is too long.");
          }
          if (_TextOperation.isRetain(op1) && _TextOperation.isRetain(op2)) {
            if (op1 > op2) {
              operation.retain(op2);
              op1 = op1 - op2;
              op2 = ops2[i22++];
            } else if (op1 === op2) {
              operation.retain(op1);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation.retain(op1);
              op2 = op2 - op1;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isInsert(op1) && _TextOperation.isDelete(op2)) {
            if (op1.length > -op2) {
              op1 = op1.slice(-op2);
              op2 = ops2[i22++];
            } else if (op1.length === -op2) {
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              op2 = op2 + op1.length;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isInsert(op1) && _TextOperation.isRetain(op2)) {
            if (op1.length > op2) {
              operation.insert(op1.slice(0, op2));
              op1 = op1.slice(op2);
              op2 = ops2[i22++];
            } else if (op1.length === op2) {
              operation.insert(op1);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation.insert(op1);
              op2 = op2 - op1.length;
              op1 = ops1[i1++];
            }
          } else if (_TextOperation.isRetain(op1) && _TextOperation.isDelete(op2)) {
            if (op1 > -op2) {
              operation["delete"](op2);
              op1 = op1 + op2;
              op2 = ops2[i22++];
            } else if (op1 === -op2) {
              operation["delete"](op2);
              op1 = ops1[i1++];
              op2 = ops2[i22++];
            } else {
              operation["delete"](op1);
              op2 = op2 + op1;
              op1 = ops1[i1++];
            }
          } else {
            throw new Error("This shouldn't happen: op1: " + JSON.stringify(op1) + ", op2: " + JSON.stringify(op2));
          }
        }
        return operation;
      }
      // Pretty printing
      toString() {
        return this.ops.map((op) => {
          if (_TextOperation.isRetain(op)) {
            return "retain " + op;
          } else if (_TextOperation.isInsert(op)) {
            return "insert '" + op + "'";
          } else {
            return "delete " + -op;
          }
        }).join(", ");
      }
      toJSON() {
        return this.ops;
      }
    };
    exports2.TextOperation = TextOperation;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/utils.js
var require_utils2 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDiffTextOperation = exports2.findDiff = void 0;
    var vscode_diff_1 = require_dist();
    var TextOperation_1 = require_TextOperation();
    function findDiff(originalText, modifiedText, pretty) {
      return (0, vscode_diff_1.stringDiff)(originalText, modifiedText, pretty);
    }
    exports2.findDiff = findDiff;
    function createDiffTextOperation(originalText, modifiedText) {
      const ot5 = new TextOperation_1.TextOperation();
      if (originalText === modifiedText) {
        ot5.retain(originalText.length);
        return ot5;
      }
      const diffs = findDiff(originalText, modifiedText, false);
      let previousOriginalEndIndex = 0;
      diffs.forEach((change) => {
        const originalStartIndex = change.originalStart;
        const originalEndIndex = change.originalStart + change.originalLength;
        const charsToRetain = originalStartIndex - previousOriginalEndIndex;
        if (charsToRetain > 0) {
          ot5.retain(charsToRetain);
        } else if (charsToRetain < 0) {
          throw new Error("Invalid diff change start index, overlapping changes detected");
        }
        previousOriginalEndIndex = originalEndIndex;
        const oldText = originalText.substring(originalStartIndex, originalEndIndex);
        const newText = modifiedText.substring(change.modifiedStart, change.modifiedStart + change.modifiedLength);
        if (oldText !== newText) {
          ot5.insert(newText);
          ot5.delete(change.originalLength);
        }
      });
      const remainingChars = originalText.length - ot5.baseLength;
      if (remainingChars > 0) {
        ot5.retain(remainingChars);
      } else if (remainingChars < 0) {
        throw new Error("Invalid text diff, remaining chars is negative");
      }
      return ot5;
    }
    exports2.createDiffTextOperation = createDiffTextOperation;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/types.js
var require_types = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperationReason = void 0;
    var OperationReason;
    (function(OperationReason2) {
      OperationReason2[OperationReason2["USER"] = 0] = "USER";
      OperationReason2[OperationReason2["FS"] = 1] = "FS";
      OperationReason2[OperationReason2["RESYNC"] = 2] = "RESYNC";
    })(OperationReason || (exports2.OperationReason = OperationReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Client.js
var require_Client = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var utils_1 = require_utils2();
    var TextOperation_1 = require_TextOperation();
    var types_1 = require_types();
    var event_1 = require_event();
    var Client = class {
      incomingOperationEmitter = new event_1.Emitter();
      onIncomingOperation = this.incomingOperationEmitter.event;
      operationAckEmitter = new event_1.Emitter();
      onOperationAck = this.operationAckEmitter.event;
      outgoingOperationEmitter = new event_1.Emitter();
      onOutgoingOperation = this.outgoingOperationEmitter.event;
      documentChangeEmitter = new event_1.Emitter();
      onDocumentChange = this.documentChangeEmitter.event;
      // Current document content state
      _document;
      // Last known server document state, based on incoming operations and
      // acknowledged outgoing operations. This is used to sync server state after
      // disconnects
      _serverDocument;
      // Current revision of the document
      revision;
      // Callback to send an operation
      sendOperation;
      sendOperationAck;
      // Operation that has been sent to the server but hasn't been acknowledged yet
      pendingOperation = null;
      // Any edits that the user has done since the pendingOperation, get combined into a queued operation
      // and gets sent from the moment pending operation has been acknowledged
      queuedOperation = null;
      constructor(document2, revision, sendOperation, sendOperationAck) {
        this._document = document2;
        this._serverDocument = document2;
        this.revision = revision;
        this.sendOperation = sendOperation;
        this.sendOperationAck = sendOperationAck;
      }
      /** Check if client has pending operation, used for testing */
      get hasPendingOperation() {
        return Boolean(this.pendingOperation);
      }
      /** Check if client has pending operation, used for testing */
      get hasQueuedOperation() {
        return Boolean(this.queuedOperation);
      }
      /** returns the current state of the document */
      get document() {
        return this._document;
      }
      /** sets the content of the document and emits a documentChange event */
      set document(newContent) {
        this._document = newContent;
        this.documentChangeEmitter.fire({ newContent });
      }
      /** Enqueue operation to send to the server */
      enqueueOperation(op) {
        if (this.queuedOperation) {
          this.queuedOperation = this.queuedOperation.compose(op);
        } else {
          this.queuedOperation = op;
        }
        if (!this.pendingOperation) {
          this.sendQueuedOperation();
        }
      }
      transformServerOperation(serverOperation) {
        let incomingOperation = serverOperation;
        if (this.pendingOperation) {
          const transformed = TextOperation_1.TextOperation.transform(this.pendingOperation, incomingOperation);
          this.pendingOperation = transformed[0];
          incomingOperation = transformed[1];
        }
        if (this.queuedOperation) {
          const transformed = TextOperation_1.TextOperation.transform(this.queuedOperation, incomingOperation);
          this.queuedOperation = transformed[0];
          incomingOperation = transformed[1];
        }
        return incomingOperation;
      }
      sendPendingOperation() {
        if (this.pendingOperation) {
          const operation = this.pendingOperation;
          this.sendOperation(this.revision, operation);
        }
      }
      sendQueuedOperation() {
        if (!this.pendingOperation && this.queuedOperation) {
          this.pendingOperation = this.queuedOperation;
          this.queuedOperation = null;
          this.sendPendingOperation();
        }
      }
      /**
       * Resync with the server using the new content and last known revision
       *
       * Transforms the queued and pending operation on top of the diff between
       * our last known state and the expected state
       **/
      syncServerDocument(serverDocument, newRevision) {
        if (this.pendingOperation) {
          if (this.queuedOperation) {
            this.queuedOperation = this.pendingOperation.compose(this.queuedOperation);
          } else {
            this.queuedOperation = this.pendingOperation;
          }
          this.pendingOperation = null;
        }
        const diff = (0, utils_1.createDiffTextOperation)(this._serverDocument, serverDocument);
        if (diff.isNoop()) {
          this.revision = newRevision;
          this.sendQueuedOperation();
          return;
        }
        this.revision = newRevision - 1;
        return this.applyServerOperation(diff, types_1.OperationReason.RESYNC);
      }
      /**
       * If the OTClient errors on applying new operations from
       * the client, we can recover the state of the client document
       * by calling this method. It can potentially override server changes, but it is
       * more important that users do not loose any work
       */
      applyClientDocument(clientDocument) {
        const diff = (0, utils_1.createDiffTextOperation)(this.document, clientDocument);
        this.applyClientOperation(diff);
      }
      /**
       * Apply an operation originating from this client
       *
       * @param clientOperation the operation to apply to the document
       */
      applyClientOperation(clientOperation) {
        if (clientOperation.isNoop())
          return;
        this.document = clientOperation.apply(this.document);
        this.enqueueOperation(clientOperation);
        this.outgoingOperationEmitter.fire({
          operation: clientOperation,
          revision: this.revision
        });
      }
      /**
       * Apply operation coming from the ot server
       *
       * @param serverOperation the operation from the server that should be applied to the document
       * @param reason the reason for the operation to occur
       */
      applyServerOperation(op, reason) {
        this.revision++;
        const transformedOp = this.transformServerOperation(op);
        this.document = transformedOp.apply(this.document);
        this._serverDocument = op.apply(this._serverDocument);
        this.sendQueuedOperation();
        this.sendOperationAck(this.revision);
        this.incomingOperationEmitter.fire({
          operation: transformedOp,
          revision: this.revision,
          reason
        });
      }
      /**
       * On successful passing of an operation to the server. Any queued
       * operations will now be sent. The "onOperationAck" event is emitted when
       * there are no more pending operations or after we send any queued operations
       */
      serverAck() {
        if (this.pendingOperation) {
          this._serverDocument = this.pendingOperation.apply(this._serverDocument);
          this.revision++;
          this.pendingOperation = null;
          this.sendOperationAck(this.revision);
          this.sendQueuedOperation();
        }
        this.operationAckEmitter.fire({
          revision: this.revision
        });
      }
      dispose() {
        this.sendOperation = () => void 0;
        this.sendOperationAck = () => void 0;
        this.incomingOperationEmitter.dispose();
        this.operationAckEmitter.dispose();
        this.outgoingOperationEmitter.dispose();
        this.documentChangeEmitter.dispose();
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/OperationBuffer.js
var require_OperationBuffer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/OperationBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperationBuffer = void 0;
    var OperationBuffer = class {
      offset;
      operations;
      constructor() {
        this.offset = 0;
        this.operations = [];
      }
      /**
       * Returns the current revision in the buffer
       */
      get revision() {
        return this.offset + this.operations.length;
      }
      /**
       * Add new operation to the buffer
       */
      push(operation) {
        this.operations.push(operation);
      }
      /**
       * Get operation from buffer at given revision
       */
      get(revision) {
        return this.operations[revision - this.offset] ?? null;
      }
      /**
       * Get all operations after a certain revision/offset
       */
      slice(offset) {
        if (offset < this.offset) {
          throw new Error("Tried to get removed operations");
        }
        return this.operations.slice(offset - this.offset);
      }
      /**
       * Remove all operations from the buffer that happened before the specified revision
       *
       * @param revision the oldest revision that should be kept in the buffer
       */
      clear(revision) {
        const keepFromIndex = revision - this.offset;
        this.operations = this.operations.slice(keepFromIndex);
        this.offset += keepFromIndex;
      }
    };
    exports2.OperationBuffer = OperationBuffer;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Server.js
var require_Server = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/Server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var OperationBuffer_1 = require_OperationBuffer();
    var TextOperation_1 = require_TextOperation();
    var MAX_OPERATIONS = 100;
    var Server = class {
      document;
      clientRevisions = /* @__PURE__ */ new Map();
      operationBuffer;
      /**
       * Create a server instance, provided a document as a string and an array of
       * operations.
       */
      constructor(document2) {
        this.document = document2;
        this.operationBuffer = new OperationBuffer_1.OperationBuffer();
      }
      /** Get the current server revision of the document */
      get revision() {
        return this.operationBuffer.revision;
      }
      /** Call this whenever a client disconnects from the server, this cleans up their data */
      addClient(clientId, revision) {
        this.clientRevisions.set(clientId, revision);
      }
      /** Call this whenever a client disconnects from the server, this cleans up their data */
      removeClient(clientId) {
        this.clientRevisions.delete(clientId);
      }
      /** Use this to get the client's ot state */
      getClientRevision(clientId) {
        return this.clientRevisions.get(clientId) ?? null;
      }
      /** Call this whenever a client acknowledges a server operation */
      ack(clientId, revision) {
        const clientRevision = this.clientRevisions.get(clientId);
        if (clientRevision != null && revision > clientRevision) {
          this.clientRevisions.set(clientId, revision);
        }
      }
      /**
       * This will clear as many operations as possible. Meaning that clients
       * on older revisions will still stay in history so we can still transform
       * their incoming operations
       */
      clearOperations() {
        const fromRevision = Math.max(
          this.revision - MAX_OPERATIONS,
          // 220 - 100
          Math.min(...this.clientRevisions.values())
        );
        this.operationBuffer.clear(fromRevision);
      }
      getOperations() {
        return this.operationBuffer.operations;
      }
      /** Call this method whenever you receive an operation from a client. */
      receiveOperation(revision, operation) {
        if (revision < 0 || this.operationBuffer.revision < revision) {
          throw new Error("operation revision not in history");
        }
        const concurrentOperations = this.operationBuffer.slice(revision);
        for (let i4 = 0; i4 < concurrentOperations.length; i4++) {
          operation = TextOperation_1.TextOperation.transform(operation, concurrentOperations[i4])[0];
        }
        this.applyOperation(operation);
        return operation;
      }
      /** Call this method whenever you want to apply a server-generated operation. */
      applyOperation(operation) {
        this.document = operation.apply(this.document);
        this.operationBuffer.push(operation);
        this.clearOperations();
      }
    };
    exports2.Server = Server;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/SerialQueue.js
var require_SerialQueue = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/SerialQueue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SerialQueue = void 0;
    var SerialQueue3 = class {
      name;
      debug;
      items = [];
      isProcessing = false;
      constructor(name, debug4 = false) {
        this.name = name;
        this.debug = debug4;
      }
      async processQueue() {
        if (this.isProcessing)
          return;
        const item = this.items.shift();
        if (item) {
          if (this.debug) {
            console.log(`Running queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.isProcessing = true;
          try {
            const result = await item.callback();
            for (const resolve5 of item.resolves) {
              try {
                resolve5(result);
              } catch (err) {
              }
            }
          } catch (err) {
            for (const reject of item.rejects) {
              try {
                reject(err);
              } catch (err2) {
              }
            }
          }
          this.isProcessing = false;
          if (this.debug) {
            console.log(`Processed queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.processQueue();
        }
      }
      /**
       * Add a new promise callback to the queue
       *
       * in case you provide a key it will be used to de-duplicate against existing items in the queue
       * if there is an existing item, the callback of that item will be used and this function will
       * return the result of that callback instead
       */
      add(callback, key) {
        if (this.debug) {
          console.log(`Adding item ${this.name}#${key ?? "unknown"} to the queue`);
        }
        return new Promise((resolve5, reject) => {
          let shouldAdd = true;
          let item = {
            key,
            callback,
            resolves: [],
            rejects: []
          };
          if (key) {
            const foundItem = this.items.find((i4) => i4.key === key);
            if (foundItem) {
              item = foundItem;
              shouldAdd = false;
            }
          }
          item.resolves.push(resolve5);
          item.rejects.push(reject);
          if (shouldAdd) {
            this.items.push(item);
          }
          this.processQueue().catch(console.error);
        });
      }
    };
    exports2.SerialQueue = SerialQueue3;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/AsyncDocument.js
var require_AsyncDocument = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/AsyncDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncDocument = void 0;
    var TextOperation_1 = require_TextOperation();
    var SerialQueue_1 = require_SerialQueue();
    var APPLY_SERVER_OPERATION_MAX_TRIES = 5;
    var AsyncDocument2 = class {
      queue = new SerialQueue_1.SerialQueue("async-document-server-operations");
      bufferedDocument;
      pendingServerOperations = [];
      constructor(document2) {
        this.bufferedDocument = document2;
      }
      get document() {
        return this.bufferedDocument;
      }
      get hasPendingServerOperations() {
        return Boolean(this.pendingServerOperations.length);
      }
      /**
       * Applies the operation to the buffered document and returns the transformed
       * operation to be applied to the OT Client
       */
      applyClientOperation(operation) {
        const prevBufferedDocument = this.bufferedDocument;
        this.bufferedDocument = operation.apply(prevBufferedDocument);
        const pendingServerOperation = this.pendingServerOperations[0];
        if (pendingServerOperation) {
          const { operation: currentServerOperation } = pendingServerOperation;
          if (this.bufferedDocument === currentServerOperation.apply(prevBufferedDocument)) {
            this.pendingServerOperations.shift();
            return;
          }
        }
        let transformedOp = operation;
        for (let x3 = 0; x3 < this.pendingServerOperations.length; x3++) {
          const { operation: currentServerOperation } = this.pendingServerOperations[x3];
          const [a3, b] = TextOperation_1.TextOperation.transform(transformedOp, currentServerOperation);
          transformedOp = a3;
          this.pendingServerOperations[x3].operation = b;
        }
        return transformedOp;
      }
      /**
       * Adds the operation to the queue and calls the callback with the current
       * buffered document and the transformed operation to be applied to the
       * code editor. The callback should throw an error when applying the operation
       * to the code editor fails. The promise returned will reject after X retries
       */
      applyServerOperation(operation, cb) {
        const operationReference = { operation };
        this.pendingServerOperations.push(operationReference);
        return this.queue.add(() => {
          const applyOperation = async (currentTryCount) => {
            try {
              await cb(this.bufferedDocument, operationReference.operation);
            } catch (error) {
              if (currentTryCount > APPLY_SERVER_OPERATION_MAX_TRIES) {
                throw new Error(`Not able to apply incoming operation after ${APPLY_SERVER_OPERATION_MAX_TRIES} tries: ${String(error)}`);
              }
              return applyOperation(++currentTryCount);
            }
          };
          return applyOperation(1);
        });
      }
    };
    exports2.AsyncDocument = AsyncDocument2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/operational-transforms/index.js
var require_operational_transforms = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/operational-transforms/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDiffTextOperation = void 0;
    __exportStar(require_Client(), exports2);
    __exportStar(require_Server(), exports2);
    __exportStar(require_TextOperation(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_AsyncDocument(), exports2);
    var utils_1 = require_utils2();
    Object.defineProperty(exports2, "createDiffTextOperation", { enumerable: true, get: function() {
      return utils_1.createDiffTextOperation;
    } });
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i4 = 0; i4 < this._errors.length; i4++) {
        var error = this._errors[i4];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i4 = 0; i4 < opts.retries; i4++) {
        timeouts.push(this.createTimeout(i4, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i4, opts));
      }
      timeouts.sort(function(a3, b) {
        return a3 - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i4 = 0; i4 < methods.length; i4++) {
        var method = methods[i4];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/@codesandbox/pitcher-common/dist/p-retry.js
var require_p_retry = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/p-retry.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.run = exports2.AbortError = void 0;
    var retry_1 = __importDefault(require_retry2());
    var AbortError = class extends Error {
      originalError;
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    exports2.AbortError = AbortError;
    function decorateErrorWithCounts(error, attemptNumber, retries) {
      const retriesLeft = retries - (attemptNumber - 1);
      const decoratedError = error;
      decoratedError.attemptNumber = attemptNumber;
      decoratedError.retriesLeft = retriesLeft;
      return decoratedError;
    }
    function run(input, options = {}) {
      return new Promise((resolve5, reject) => {
        const retries = options.retries ?? 10;
        const operation = retry_1.default.operation({
          retries,
          factor: options.factor ?? 2,
          minTimeout: options.minTimeout ?? 1e3,
          maxTimeout: options.maxTimeout ?? 1e4,
          randomize: options.randomize ?? true
        });
        operation.attempt(async (attemptNumber) => {
          try {
            resolve5(await input(attemptNumber));
          } catch (error) {
            if (!(error instanceof Error)) {
              reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
              return;
            }
            const isAbortError = error instanceof AbortError;
            decorateErrorWithCounts(error, attemptNumber, retries);
            try {
              if (options.onFailedAttempt) {
                await options.onFailedAttempt(error);
              }
            } catch (error2) {
              reject(error2);
              return;
            }
            if (isAbortError) {
              reject(error);
              operation.stop();
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        });
      });
    }
    exports2.run = run;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x3) {
      return x3 < 0 ? -1 : 1;
    }
    function evenRound(x3) {
      if (x3 % 1 === 0.5 && (x3 & 1) === 0) {
        return Math.floor(x3);
      } else {
        return Math.round(x3);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts) opts = {};
        let x3 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x3)) {
            throw new TypeError("Argument is not a finite number");
          }
          x3 = sign(x3) * Math.floor(Math.abs(x3));
          if (x3 < lowerBound || x3 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x3;
        }
        if (!isNaN(x3) && opts.clamp) {
          x3 = evenRound(x3);
          if (x3 < lowerBound) x3 = lowerBound;
          if (x3 > upperBound) x3 = upperBound;
          return x3;
        }
        if (!Number.isFinite(x3) || x3 === 0) {
          return 0;
        }
        x3 = sign(x3) * Math.floor(Math.abs(x3));
        x3 = x3 % moduloVal;
        if (!typeOpts.unsigned && x3 >= moduloBound) {
          return x3 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x3 < 0) {
            x3 += moduloVal;
          } else if (x3 === -0) {
            return 0;
          }
        }
        return x3;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x3 = +V2;
      if (!Number.isFinite(x3)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x3;
    };
    conversions["unrestricted double"] = function(V2) {
      const x3 = +V2;
      if (isNaN(x3)) {
        throw new TypeError("Argument is NaN");
      }
      return x3;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x3 = String(V2);
      let c3 = void 0;
      for (let i4 = 0; (c3 = x3.codePointAt(i4)) !== void 0; ++i4) {
        if (c3 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x3;
    };
    conversions["USVString"] = function(V2) {
      const S3 = String(V2);
      const n2 = S3.length;
      const U2 = [];
      for (let i4 = 0; i4 < n2; ++i4) {
        const c3 = S3.charCodeAt(i4);
        if (c3 < 55296 || c3 > 57343) {
          U2.push(String.fromCodePoint(c3));
        } else if (56320 <= c3 && c3 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i4 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S3.charCodeAt(i4 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a3 = c3 & 1023;
              const b = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a3 + b));
              ++i4;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin3(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i4 = 0; i4 < keys.length; ++i4) {
        Object.defineProperty(target, keys[i4], Object.getOwnPropertyDescriptor(source, keys[i4]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize2(str) {
      return str.split("\0").map(function(s3) {
        return s3.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i4 = 0; i4 < len; ++i4) {
        var codePoint = domain_name.codePointAt(i4);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize2(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i4 = 0; i4 < len; ++i4) {
        var status = findStatus(label.codePointAt(i4));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize2(result.string);
      var labels = result.string.split(".");
      for (var i4 = 0; i4 < labels.length; ++i4) {
        try {
          var validation2 = validateLabel(labels[i4]);
          labels[i4] = validation2.label;
          result.error = result.error || validation2.error;
        } catch (e3) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l3) {
        try {
          return punycode.toASCII(l3);
        } catch (e3) {
          result.error = true;
          return l3;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i4 = 0; i4 < labels.length; ++i4) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c3 = input[idx];
      return isNaN(c3) ? void 0 : String.fromCodePoint(c3);
    }
    function isASCIIDigit(c3) {
      return c3 >= 48 && c3 <= 57;
    }
    function isASCIIAlpha(c3) {
      return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 122;
    }
    function isASCIIAlphanumeric(c3) {
      return isASCIIAlpha(c3) || isASCIIDigit(c3);
    }
    function isASCIIHex(c3) {
      return isASCIIDigit(c3) || c3 >= 65 && c3 <= 70 || c3 >= 97 && c3 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c3) {
      let hex = c3.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c3) {
      const buf = new Buffer(c3);
      let str = "";
      for (let i4 = 0; i4 < buf.length; ++i4) {
        str += percentEncode(buf[i4]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i4 = 0; i4 < input.length; ++i4) {
        if (input[i4] !== 37) {
          output.push(input[i4]);
        } else if (input[i4] === 37 && isASCIIHex(input[i4 + 1]) && isASCIIHex(input[i4 + 2])) {
          output.push(parseInt(input.slice(i4 + 1, i4 + 3).toString(), 16));
          i4 += 2;
        } else {
          output.push(input[i4]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c3) {
      return c3 <= 31 || c3 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c3) {
      return isC0ControlPercentEncode(c3) || extraPathPercentEncodeSet.has(c3);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c3) {
      return isPathPercentEncode(c3) || extraUserinfoPercentEncodeSet.has(c3);
    }
    function percentEncodeChar(c3, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c3);
      if (encodeSetPredicate(c3)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i4 = 0; i4 < numbers.length - 1; ++i4) {
        if (numbers[i4] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i4 = 1; i4 <= 4; ++i4) {
        output = String(n2 % 256) + output;
        if (i4 !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i4 = 0; i4 < decoded.length; ++i4) {
        output += percentEncodeChar(decoded[i4], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i4 = 0; i4 < arr.length; ++i4) {
        if (arr[i4] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i4;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c3 = this.input[this.pointer];
        const cStr = isNaN(c3) ? void 0 : String.fromCodePoint(c3);
        const ret = this["parse " + this.state](c3, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c3, cStr) {
      if (isASCIIAlpha(c3)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c3, cStr) {
      if (isASCIIAlphanumeric(c3) || c3 === 43 || c3 === 45 || c3 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c3 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c3) {
      if (this.base === null || this.base.cannotBeABaseURL && c3 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c3 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c3) {
      if (c3 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c3) {
      if (c3 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c3) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c3)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c3 === 47) {
        this.state = "relative slash";
      } else if (c3 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c3 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c3 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c3) {
      if (isSpecial(this.url) && (c3 === 47 || c3 === 92)) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c3 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c3) {
      if (c3 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c3) {
      if (c3 !== 47 && c3 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c3, cStr) {
      if (c3 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial(this.url) && c3 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c3, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c3 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial(this.url) && c3 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c3 === 91) {
          this.arrFlag = true;
        } else if (c3 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c3, cStr) {
      if (isASCIIDigit(c3)) {
        this.buffer += cStr;
      } else if (isNaN(c3) || c3 === 47 || c3 === 63 || c3 === 35 || isSpecial(this.url) && c3 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c3) {
      this.url.scheme = "file";
      if (c3 === 47 || c3 === 92) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c3)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c3 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c3 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c3, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c3) {
      if (c3 === 47 || c3 === 92) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c3, cStr) {
      if (isNaN(c3) || c3 === 47 || c3 === 92 || c3 === 63 || c3 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c3) {
      if (isSpecial(this.url)) {
        if (c3 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c3 !== 47 && c3 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c3 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c3 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c3 !== void 0) {
        this.state = "path";
        if (c3 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c3) {
      if (isNaN(c3) || c3 === 47 || isSpecial(this.url) && c3 === 92 || !this.stateOverride && (c3 === 63 || c3 === 35)) {
        if (isSpecial(this.url) && c3 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c3 !== 47 && !(isSpecial(this.url) && c3 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c3 !== 47 && !(isSpecial(this.url) && c3 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c3 === void 0 || c3 === 63 || c3 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c3 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c3 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c3, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c3) {
      if (c3 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c3 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c3) && c3 !== 37) {
          this.parseError = true;
        }
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c3)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c3, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c3, cStr) {
      if (isNaN(c3) || !this.stateOverride && c3 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i4 = 0; i4 < buffer.length; ++i4) {
          if (buffer[i4] < 33 || buffer[i4] > 126 || buffer[i4] === 34 || buffer[i4] === 35 || buffer[i4] === 60 || buffer[i4] === 62) {
            this.url.query += percentEncode(buffer[i4]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i4]);
          }
        }
        this.buffer = "";
        if (c3 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c3) {
      if (isNaN(c3)) {
      } else if (c3 === 0) {
        this.parseError = true;
      } else {
        if (c3 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c3, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e3) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i4 = 0; i4 < decoded.length; ++i4) {
        url.username += percentEncodeChar(decoded[i4], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i4 = 0; i4 < decoded.length; ++i4) {
        url.password += percentEncodeChar(decoded[i4], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v3) {
        const parsedURL = usm.basicURLParse(v3);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v3) {
        usm.basicURLParse(v3 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v3);
      }
      get password() {
        return this._url.password;
      }
      set password(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v3);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v3, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v3, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v3) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v3 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v3, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v3) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v3, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v3) {
        const url = this._url;
        if (v3 === "") {
          url.query = null;
          return;
        }
        const input = v3[0] === "?" ? v3.substring(1) : v3;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v3) {
        if (v3 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v3[0] === "#" ? v3.substring(1) : v3;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils3();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i4 = 0; i4 < arguments.length && i4 < 2; ++i4) {
        args[i4] = arguments[i4];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i4 = 0; i4 < arguments.length && i4 < 0; ++i4) {
        args[i4] = arguments[i4];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a3 = blobParts;
          const length = Number(a3.length);
          for (let i4 = 0; i4 < length; i4++) {
            const element = a3[i4];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e3) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve5, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve5(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i4 = 0;
        while (i4 < pairs.length) {
          var _pairs$i = pairs[i4];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i4++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k4) {
        return k4.toLowerCase();
      } : kind === "value" ? function(k4) {
        return headers[MAP][k4].join(", ");
      } : function(k4) {
        return [k4.toLowerCase(), headers[MAP][k4].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers2(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers2(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers2(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve5, reject) {
        const request = new Request2(url, opts);
        const options = getNodeRequestOptions(request);
        const send2 = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send2(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s3) {
            s3.addListener("close", function(hadError) {
              const hasDataListener = s3.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location2 = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve5(fetch2(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve5(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve5(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          response = new Response(body, response_options);
          resolve5(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s3) {
        socket = s3;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers2;
    exports2.Request = Request2;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports2, module2) {
    var nodeFetch2 = require_lib2();
    var realFetch = nodeFetch2.default || nodeFetch2;
    var fetch2 = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch2.ponyfill = true;
    module2.exports = exports2 = fetch2;
    exports2.fetch = fetch2;
    exports2.Headers = nodeFetch2.Headers;
    exports2.Request = nodeFetch2.Request;
    exports2.Response = nodeFetch2.Response;
    exports2.default = fetch2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/fetch.js
var require_fetch = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/fetch.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetch = exports2.retryFetch = void 0;
    var index_1 = require_dist3();
    var cross_fetch_1 = __importDefault(require_node_ponyfill());
    var ERROR_CODES_TO_RETRY = /* @__PURE__ */ new Set([
      408,
      429,
      424,
      499,
      444,
      502,
      503,
      504,
      599
    ]);
    function isRetryableStatus(errorcode) {
      return ERROR_CODES_TO_RETRY.has(errorcode);
    }
    function retryFetch(input, init, retryOptions = {}) {
      const tryFetch = async () => {
        const response = await (0, cross_fetch_1.default)(input, init);
        if (!response.ok && isRetryableStatus(response.status)) {
          throw new index_1.pRetry.AbortError(`[${response.status}]: ${response.statusText}`);
        }
        return response;
      };
      return index_1.pRetry.run(tryFetch, retryOptions);
    }
    exports2.retryFetch = retryFetch;
    var cross_fetch_2 = require_node_ponyfill();
    Object.defineProperty(exports2, "fetch", { enumerable: true, get: function() {
      return cross_fetch_2.fetch;
    } });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/timeout.js
var require_timeout = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = void 0;
    var sleep_1 = require_sleep();
    async function timeout(promise, timeoutMs) {
      const timeout2 = (0, sleep_1.sleep)(timeoutMs).then(() => "timeout-exceeded");
      const result = await Promise.race([promise, timeout2]);
      if (result === "timeout-exceeded") {
        return { type: "timeout-exceeded", timeoutMs };
      }
      return { type: "ok", result };
    }
    exports2.timeout = timeout;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/nullthrows.js
var require_nullthrows = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/nullthrows.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nullthrows = void 0;
    function nullthrows(value, message) {
      if (value == null) {
        throw new Error(message || "Value is nullish");
      }
      return value;
    }
    exports2.nullthrows = nullthrows;
  }
});

// node_modules/@emotion/hash/dist/hash.cjs.prod.js
var require_hash_cjs_prod = __commonJS({
  "node_modules/@emotion/hash/dist/hash.cjs.prod.js"(exports2) {
    "use strict";
    function murmur2(str) {
      for (var k4, h3 = 0, i4 = 0, len = str.length; len >= 4; ++i4, len -= 4) k4 = 1540483477 * (65535 & (k4 = 255 & str.charCodeAt(i4) | (255 & str.charCodeAt(++i4)) << 8 | (255 & str.charCodeAt(++i4)) << 16 | (255 & str.charCodeAt(++i4)) << 24)) + (59797 * (k4 >>> 16) << 16), h3 = 1540483477 * (65535 & (k4 ^= k4 >>> 24)) + (59797 * (k4 >>> 16) << 16) ^ 1540483477 * (65535 & h3) + (59797 * (h3 >>> 16) << 16);
      switch (len) {
        case 3:
          h3 ^= (255 & str.charCodeAt(i4 + 2)) << 16;
        case 2:
          h3 ^= (255 & str.charCodeAt(i4 + 1)) << 8;
        case 1:
          h3 = 1540483477 * (65535 & (h3 ^= 255 & str.charCodeAt(i4))) + (59797 * (h3 >>> 16) << 16);
      }
      return (((h3 = 1540483477 * (65535 & (h3 ^= h3 >>> 13)) + (59797 * (h3 >>> 16) << 16)) ^ h3 >>> 15) >>> 0).toString(36);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    }), exports2.default = murmur2;
  }
});

// node_modules/@emotion/hash/dist/hash.cjs.dev.js
var require_hash_cjs_dev = __commonJS({
  "node_modules/@emotion/hash/dist/hash.cjs.dev.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function murmur2(str) {
      var h3 = 0;
      var k4, i4 = 0, len = str.length;
      for (; len >= 4; ++i4, len -= 4) {
        k4 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
        k4 = /* Math.imul(k, m): */
        (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16);
        k4 ^= /* k >>> r: */
        k4 >>> 24;
        h3 = /* Math.imul(k, m): */
        (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h3 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
        case 2:
          h3 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
        case 1:
          h3 ^= str.charCodeAt(i4) & 255;
          h3 = /* Math.imul(h, m): */
          (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      }
      h3 ^= h3 >>> 13;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
      return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
    }
    exports2.default = murmur2;
  }
});

// node_modules/@emotion/hash/dist/hash.cjs.js
var require_hash_cjs = __commonJS({
  "node_modules/@emotion/hash/dist/hash.cjs.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_hash_cjs_prod();
    } else {
      module2.exports = require_hash_cjs_dev();
    }
  }
});

// node_modules/@codesandbox/pitcher-common/dist/murmur.js
var require_murmur = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/murmur.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.murmur = void 0;
    var hash_1 = __importDefault(require_hash_cjs());
    function murmur2(s3) {
      return (0, hash_1.default)(s3);
    }
    exports2.murmur = murmur2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Aborter.js
var require_Aborter = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Aborter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Aborter = void 0;
    var Aborter = class {
      isAborted = false;
      abort() {
        this.isAborted = true;
      }
    };
    exports2.Aborter = Aborter;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Debouncer.js
var require_Debouncer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Debouncer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Debouncer = void 0;
    var Debouncer2 = class {
      debounceTime;
      maxDebounceTime;
      lastExecutionAt;
      timeoutRef = null;
      callback;
      constructor(debounceTime, maxDebounceTime, callback) {
        this.debounceTime = debounceTime;
        this.maxDebounceTime = maxDebounceTime;
        this.lastExecutionAt = 0;
        this.callback = callback;
      }
      shouldDebounce() {
        if (!this.maxDebounceTime) {
          return true;
        }
        const timeSinceLastExecution = Date.now() - this.lastExecutionAt;
        return timeSinceLastExecution < this.maxDebounceTime;
      }
      debounce(...args) {
        const shouldDebounce = !this.timeoutRef || this.shouldDebounce();
        this.clear();
        if (!shouldDebounce) {
          this.fire(...args);
        } else {
          this.timeoutRef = setTimeout(() => {
            this.fire(...args);
          }, this.debounceTime);
        }
      }
      fire(...args) {
        this.clear();
        this.lastExecutionAt = Date.now();
        this.callback(...args);
      }
      flush(...args) {
        this.fire(...args);
      }
      clear() {
        if (this.timeoutRef) {
          clearTimeout(this.timeoutRef);
          this.timeoutRef = null;
        }
      }
    };
    exports2.Debouncer = Debouncer2;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BidirectionalMap.js
var require_BidirectionalMap = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BidirectionalMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BidirectionalMap = void 0;
    var BidirectionalMap3 = class {
      keyToValue = /* @__PURE__ */ new Map();
      valueToKey = /* @__PURE__ */ new Map();
      deleteEntry(key, value) {
        this.keyToValue.delete(key);
        this.valueToKey.delete(value);
      }
      get size() {
        return this.keyToValue.size;
      }
      deleteByValue(value) {
        const key = this.getKey(value);
        if (key !== void 0) {
          this.deleteEntry(key, value);
        }
      }
      deleteByKey(key) {
        const value = this.getValue(key);
        if (value !== void 0) {
          this.deleteEntry(key, value);
        }
      }
      set(key, value) {
        this.keyToValue.set(key, value);
        this.valueToKey.set(value, key);
      }
      getKey(value) {
        return this.valueToKey.get(value);
      }
      getValue(key) {
        return this.keyToValue.get(key);
      }
      keys() {
        return this.keyToValue.keys();
      }
      values() {
        return this.keyToValue.values();
      }
      entries() {
        return this.keyToValue.entries();
      }
    };
    exports2.BidirectionalMap = BidirectionalMap3;
  }
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util = __commonJS({
  "node_modules/ts-mixer/dist/cjs/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = exports2.unique = exports2.hardMixProtos = exports2.nearestCommonProto = exports2.protoChain = exports2.copyProps = void 0;
    var copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    exports2.copyProps = copyProps;
    var protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return (0, exports2.protoChain)(proto, [...currentChain, proto]);
    };
    exports2.protoChain = protoChain;
    var nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => (0, exports2.protoChain)(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    exports2.nearestCommonProto = nearestCommonProto;
    var hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a3;
      const base = (_a3 = (0, exports2.nearestCommonProto)(...ingredients)) !== null && _a3 !== void 0 ? _a3 : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = (0, exports2.protoChain)(base);
      for (let prototype of ingredients) {
        let protos = (0, exports2.protoChain)(prototype);
        for (let i4 = protos.length - 1; i4 >= 0; i4--) {
          let newProto = protos[i4];
          if (visitedProtos.indexOf(newProto) === -1) {
            (0, exports2.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    exports2.hardMixProtos = hardMixProtos;
    var unique = (arr) => arr.filter((e3, i4) => arr.indexOf(e3) == i4);
    exports2.unique = unique;
    var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a22) => [...a1, ...a22]);
    exports2.flatten = flatten;
  }
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS({
  "node_modules/ts-mixer/dist/cjs/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.softMixProtos = exports2.proxyMix = exports2.getIngredientWithProp = void 0;
    var util_1 = require_util();
    var getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i4 = ingredients.length - 1; i4 >= 0; i4--) {
          const searchTarget = protoChains[i4][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i4][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    exports2.getIngredientWithProp = getIngredientWithProp;
    var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_3, prop) {
        return Object.getOwnPropertyDescriptor((0, exports2.getIngredientWithProp)(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_3, prop) {
        return (0, exports2.getIngredientWithProp)(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_3, prop) {
        return ((0, exports2.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
      },
      set(_3, prop, val) {
        const ingredientWithProp = (0, exports2.getIngredientWithProp)(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    exports2.proxyMix = proxyMix;
    var softMixProtos = (ingredients, constructor) => (0, exports2.proxyMix)([...ingredients, { constructor }]);
    exports2.softMixProtos = softMixProtos;
  }
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS({
  "node_modules/ts-mixer/dist/cjs/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.settings = void 0;
    exports2.settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
  }
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS({
  "node_modules/ts-mixer/dist/cjs/mixin-tracking.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.registerMixins = exports2.getMixinsForClass = void 0;
    var util_1 = require_util();
    var mixins = /* @__PURE__ */ new WeakMap();
    var getMixinsForClass = (clazz) => mixins.get(clazz);
    exports2.getMixinsForClass = getMixinsForClass;
    var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    exports2.registerMixins = registerMixins;
    var hasMixin = (instance, mixin3) => {
      if (instance instanceof mixin3)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin3))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a3;
          const itemConstituents = (_a3 = mixins.get(item)) !== null && _a3 !== void 0 ? _a3 : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    exports2.hasMixin = hasMixin;
  }
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS({
  "node_modules/ts-mixer/dist/cjs/decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorate = exports2.getDecoratorsForClass = exports2.directDecoratorSearch = exports2.deepDecoratorSearch = void 0;
    var util_1 = require_util();
    var mixin_tracking_1 = require_mixin_tracking();
    var mergeObjectsOfDecorators = (o1, o2) => {
      var _a3, _b2;
      const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = (0, util_1.unique)([...(_a3 = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a3 !== void 0 ? _a3 : [], ...(_b2 = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b2 !== void 0 ? _b2 : []]);
      return mergedObject;
    };
    var mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a3, _b2, _c2, _d;
      return {
        property: mergeObjectsOfDecorators((_a3 = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a3 !== void 0 ? _a3 : {}, (_b2 = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b2 !== void 0 ? _b2 : {}),
        method: mergeObjectsOfDecorators((_c2 = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c2 !== void 0 ? _c2 : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    var mergeDecorators = (d1, d2) => {
      var _a3, _b2, _c2, _d, _e, _f;
      return {
        class: (0, util_1.unique)([...(_a3 = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a3 !== void 0 ? _a3 : [], ...(_b2 = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b2 !== void 0 ? _b2 : []]),
        static: mergePropertyAndMethodDecorators((_c2 = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c2 !== void 0 ? _c2 : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    var decorators = /* @__PURE__ */ new Map();
    var findAllConstituentClasses = (...classes) => {
      var _a3;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a3 = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a3 !== void 0 ? _a3 : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c3) => !allClasses.has(c3));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    var deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.deepDecoratorSearch = deepDecoratorSearch;
    var directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => (0, exports2.getDecoratorsForClass)(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.directDecoratorSearch = directDecoratorSearch;
    var getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    exports2.getDecoratorsForClass = getDecoratorsForClass;
    var decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    var decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a3, _b2, _c2;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      const decoratorsForTargetType = (_a3 = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a3 !== void 0 ? _a3 : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b2 = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b2 !== void 0 ? _b2 : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c2 = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c2 !== void 0 ? _c2 : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    var decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    exports2.decorate = decorate;
  }
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS({
  "node_modules/ts-mixer/dist/cjs/mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mix = exports2.Mixin = void 0;
    var proxy_1 = require_proxy();
    var settings_1 = require_settings();
    var util_1 = require_util();
    var decorator_1 = require_decorator();
    var mixin_tracking_1 = require_mixin_tracking();
    function Mixin(...constructors) {
      var _a3, _b2, _c2;
      const prototypes = constructors.map((constructor) => constructor.prototype);
      const initFunctionName = settings_1.settings.initFunction;
      if (initFunctionName !== null) {
        const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
        const combinedInitFunction = function(...args) {
          for (let initFunction of initFunctions)
            initFunction.apply(this, args);
        };
        const extraProto = { [initFunctionName]: combinedInitFunction };
        prototypes.push(extraProto);
      }
      function MixedClass(...args) {
        for (const constructor of constructors)
          (0, util_1.copyProps)(this, new constructor(...args));
        if (initFunctionName !== null && typeof this[initFunctionName] === "function")
          this[initFunctionName].apply(this, args);
      }
      MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
      Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
      let DecoratedMixedClass = MixedClass;
      if (settings_1.settings.decoratorInheritance !== "none") {
        const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
        for (let decorator of (_a3 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a3 !== void 0 ? _a3 : []) {
          const result = decorator(DecoratedMixedClass);
          if (result) {
            DecoratedMixedClass = result;
          }
        }
        applyPropAndMethodDecorators((_b2 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b2 !== void 0 ? _b2 : {}, DecoratedMixedClass);
        applyPropAndMethodDecorators((_c2 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c2 !== void 0 ? _c2 : {}, DecoratedMixedClass.prototype);
      }
      (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
      return DecoratedMixedClass;
    }
    exports2.Mixin = Mixin;
    var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    var mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
    exports2.mix = mix;
  }
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/ts-mixer/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.decorate = exports2.settings = exports2.mix = exports2.Mixin = void 0;
    var mixins_1 = require_mixins();
    Object.defineProperty(exports2, "Mixin", { enumerable: true, get: function() {
      return mixins_1.Mixin;
    } });
    Object.defineProperty(exports2, "mix", { enumerable: true, get: function() {
      return mixins_1.mix;
    } });
    var settings_1 = require_settings();
    Object.defineProperty(exports2, "settings", { enumerable: true, get: function() {
      return settings_1.settings;
    } });
    var decorator_1 = require_decorator();
    Object.defineProperty(exports2, "decorate", { enumerable: true, get: function() {
      return decorator_1.decorate;
    } });
    var mixin_tracking_1 = require_mixin_tracking();
    Object.defineProperty(exports2, "hasMixin", { enumerable: true, get: function() {
      return mixin_tracking_1.hasMixin;
    } });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/errors.js
var require_errors2 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nodeExists = exports2.OutOfSyncError = void 0;
    var OutOfSyncError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "OutOfSyncError";
      }
    };
    exports2.OutOfSyncError = OutOfSyncError;
    function nodeExists(node, errorMessage) {
      if (node)
        return;
      throw new OutOfSyncError(errorMessage);
    }
    exports2.nodeExists = nodeExists;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/Tree.js
var require_Tree = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/Tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tree = exports2.ROOT_ID = void 0;
    var TreeNode_1 = require_TreeNode();
    var BidirectionalMap_1 = require_BidirectionalMap();
    var errors_1 = require_errors2();
    exports2.ROOT_ID = "0";
    var Tree = class _Tree {
      /** Tree nodes indexed by id. */
      nodes = /* @__PURE__ */ new Map();
      /**
       * Parent id to child id index.
       * Allows lookups of children by name or child id.
       */
      children = /* @__PURE__ */ new Map();
      constructor() {
        this.createRootNode();
      }
      /** Create a new root node. */
      createRootNode() {
        const root = new TreeNode_1.ImmutableDirectory({ id: exports2.ROOT_ID, type: TreeNode_1.NodeType.Directory }, this);
        this.nodes.set(exports2.ROOT_ID, root);
      }
      /** The workspace's root directory. */
      get root() {
        return this.nodes.get(exports2.ROOT_ID);
      }
      /** Get a node by its id. */
      getNodeById(id) {
        return this.nodes.get(id);
      }
      /** Get a node's id with the given path. */
      getIdFromPath(path2) {
        const parts = path2.split("/");
        if (!parts[0]) {
          parts.shift();
        }
        const baseName = parts.pop();
        if (!baseName && parts.length === 0)
          return this.root.id;
        if (!baseName)
          return void 0;
        let node = this.root;
        for (const part of parts) {
          if (!node.isDirNode()) {
            return void 0;
          }
          node = node.getChildByName(part);
          if (!node) {
            return void 0;
          }
        }
        if (!node.isDirNode()) {
          return void 0;
        }
        return node.getChildByName(baseName)?.id;
      }
      /** Get a node with the given path. */
      getNodeFromPath(path2) {
        const id = this.getIdFromPath(path2);
        if (id) {
          return this.getNodeById(id);
        }
      }
      /** Move the provided node id to the given parent id. */
      moveNode(id, parentId, name) {
        const node = this.nodes.get(id);
        (0, errors_1.nodeExists)(node, `Attempting to move non-existent node: ${id}.`);
        this._removeChild(node);
        node.parentId = parentId;
        node.name = name ?? node.name;
        this._addChild(node, parentId);
        return node;
      }
      /** Delete the node with the given id. */
      deleteNode(id) {
        const node = this.nodes.get(id);
        (0, errors_1.nodeExists)(node, `Attempting to delete non-existent node: ${id}.`);
        this._removeNode(node);
      }
      /** Add a node to the tree. */
      _addNode(node) {
        const parentNode = node.parent;
        if (parentNode && parentNode.getChildByName(node.name)) {
          throw new Error(`${node.name} already exists in directory ${parentNode.name ?? "/"}.`);
        }
        this.nodes.set(node.id, node);
        if (node.isImmutableDirectory())
          return;
        this._addChild(node, node.parentId);
      }
      /** Add JSON Nodes to the tree. */
      _addJSONNodes(nodes) {
        for (const node of nodes) {
          this._addJSONNode(node);
        }
      }
      /** Add a node to the tree. */
      _addJSONNode(node) {
        this._addNode((0, TreeNode_1.createNode)(node, this));
      }
      /** Add a parent-child relation to the tree. */
      _addChild(node, parentId) {
        if (node.isImmutableDirectory())
          return;
        let childrenMap = this.children.get(parentId);
        if (!childrenMap) {
          childrenMap = new BidirectionalMap_1.BidirectionalMap();
          this.children.set(parentId, childrenMap);
        }
        childrenMap.set(node.id, node.name);
      }
      /** Recursively remove a node and all its children. */
      _removeNode(node) {
        if (node.isImmutableDirectory()) {
          throw new Error("Cannot remove the root node");
        }
        if (node.isDirNode()) {
          node.children.forEach((child) => this._removeNode(child));
        }
        this.nodes.delete(node.id);
        this._removeChild(node);
      }
      /** Remove a node's parent-child relation from the tree. */
      _removeChild(node) {
        if (node.isImmutableDirectory())
          return;
        const children = this.children.get(node.parentId);
        if (!children)
          return;
        children.deleteByKey(node.id);
        if (children.size === 0)
          this.children.delete(node.parentId);
      }
      /** Serialize a Tree to JSON. */
      toJSON() {
        const res = [];
        for (const node of this.nodes.values()) {
          res.push({
            id: node.id,
            type: node.type,
            name: node.name,
            parentId: node.parentId
          });
        }
        return res;
      }
      /** Deserialize a Tree from JSON. */
      static fromJSON(nodes) {
        const tree = new _Tree();
        tree._addJSONNodes(nodes);
        return tree;
      }
    };
    exports2.Tree = Tree;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/TreeNode.js
var require_TreeNode = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/TreeNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImmutableDirectory = exports2.Directory = exports2.File = exports2.DirNode = exports2.MutableNode = exports2.BaseNode = exports2.createNode = exports2.NodeType = void 0;
    var ts_mixer_1 = require_cjs2();
    var Id_1 = require_Id();
    var Tree_1 = require_Tree();
    var errors_1 = require_errors2();
    var NodeType2;
    (function(NodeType3) {
      NodeType3[NodeType3["File"] = 0] = "File";
      NodeType3[NodeType3["Directory"] = 1] = "Directory";
    })(NodeType2 || (exports2.NodeType = NodeType2 = {}));
    function createNode(opts, tree) {
      if (opts.type === NodeType2.File) {
        return new File2(opts, tree);
      }
      if (opts.parentId) {
        return new Directory(opts, tree);
      }
      return new ImmutableDirectory(opts, tree);
    }
    exports2.createNode = createNode;
    var BaseNode = class {
      /** Unique id of the node. */
      id;
      /** Type of the node. */
      type;
      /** Parent id of the node. */
      parentId;
      /** Name of the FS entry. */
      name;
      /** A reference to the tree. */
      tree;
      constructor(opts, tree) {
        this.id = opts.id;
        this.type = opts.type;
        this.name = opts.name ?? void 0;
        this.parentId = opts.parentId ?? void 0;
        this.tree = tree;
      }
      get parent() {
        if (!this.parentId) {
          return void 0;
        } else {
          const directory = this.tree.nodes.get(this.parentId);
          if (directory?.isDirNode()) {
            return directory;
          }
          return void 0;
        }
      }
      get path() {
        if (!this.parentId)
          return "/";
        if (this.parentId === Tree_1.ROOT_ID)
          return `/${this.name}`;
        return this.parent.path.concat(`/${this.name}`);
      }
      /** Returns whether this node is a {@link File}. */
      isFile() {
        return (0, ts_mixer_1.hasMixin)(this, File2);
      }
      /**
       * Returns whether this node is a {@link DirNode}.
       */
      isDirNode() {
        return (0, ts_mixer_1.hasMixin)(this, DirNode);
      }
      /**
       * Returns whether this node is a {@link Directory}.
       *
       * This does *not* include immutable directories like {@link ROOT}.
       * To identify {@link Directory} or {@link ImmutableDirectory}, use {@link isDirNode}.
       */
      isDirectory() {
        return (0, ts_mixer_1.hasMixin)(this, Directory);
      }
      /** Returns whether this node is a {@link MutableNode}. */
      isMutable() {
        return (0, ts_mixer_1.hasMixin)(this, MutableNode);
      }
      /** Returns whether this node is an {@link ImmutableDirectory}. */
      isImmutableDirectory() {
        return (0, ts_mixer_1.hasMixin)(this, ImmutableDirectory);
      }
    };
    exports2.BaseNode = BaseNode;
    var MutableNode = class extends BaseNode {
      /** This node's parent node. */
      get parent() {
        return super.parent;
      }
      /** Move this node to the provided directory node. */
      move(parent, name) {
        this.tree.moveNode(this.id, parent.id, name);
      }
      /**
       * Rename this node to the provided name.
       * Optionally, move it to the provided parent directory node.
       */
      rename(name) {
        this.tree.moveNode(this.id, this.parentId, name);
      }
      /** Delete this node. */
      delete() {
        this.tree.deleteNode(this.id);
      }
    };
    exports2.MutableNode = MutableNode;
    var DirNode = class extends BaseNode {
      /** Returns an array of a node's children. */
      get children() {
        const children = [];
        const childMap = this.tree.children.get(this.id);
        if (!childMap)
          return children;
        for (const childId of childMap.keys()) {
          const child = this.tree.nodes.get(childId);
          (0, errors_1.nodeExists)(child, `Attempting to get non-existent child of ${this}.`);
          children.push(child);
        }
        return children;
      }
      /** Find a child node by name */
      getChildByName(name) {
        const childMap = this.tree.children.get(this.id);
        if (!childMap)
          return void 0;
        const childId = childMap.getKey(name);
        if (!childId)
          return void 0;
        return this.tree.nodes.get(childId);
      }
      /** Create a file within this directory. */
      createFileWithId(id, name) {
        const node = createNode({ id, type: NodeType2.File, name, parentId: this.id }, this.tree);
        this.tree._addNode(node);
        return this.tree.nodes.get(id);
      }
      createFile(name) {
        const id = (0, Id_1.newId)();
        return this.createFileWithId(id, name);
      }
      /** Create a directory within this directory. */
      createDirectoryWithId(id, name) {
        const node = createNode({ id, type: NodeType2.Directory, name, parentId: this.id }, this.tree);
        this.tree._addNode(node);
        return this.tree.nodes.get(id);
      }
      /** Create a directory within this directory. */
      createDirectory(name) {
        const id = (0, Id_1.newId)();
        return this.createDirectoryWithId(id, name);
      }
    };
    exports2.DirNode = DirNode;
    var File2 = class extends MutableNode {
    };
    exports2.File = File2;
    var Directory = class extends (0, ts_mixer_1.Mixin)(MutableNode, DirNode) {
    };
    exports2.Directory = Directory;
    var ImmutableDirectory = class extends DirNode {
      get parent() {
        return super.parent;
      }
    };
    exports2.ImmutableDirectory = ImmutableDirectory;
  }
});

// node_modules/oo-ascii-tree/lib/ascii-tree.js
var require_ascii_tree = __commonJS({
  "node_modules/oo-ascii-tree/lib/ascii-tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsciiTree = void 0;
    var AsciiTree = class {
      /**
       * Creates a node.
       * @param text The node's text content
       * @param children Children of this node (can also be added via "add")
       */
      constructor(text, ...children) {
        this.text = text;
        this._children = new Array();
        for (const child of children) {
          this.add(child);
        }
      }
      /**
       * Prints the tree to an output stream.
       */
      printTree(output = process.stdout) {
        let ancestorsPrefix = "";
        for (const parent of this.ancestors) {
          if (parent.level <= 0) {
            continue;
          }
          if (parent.last) {
            ancestorsPrefix += "  ";
          } else {
            ancestorsPrefix += " \u2502";
          }
        }
        let myPrefix = "";
        let multilinePrefix = "";
        if (this.level > 0) {
          if (this.last) {
            if (!this.empty) {
              myPrefix += " \u2514\u2500\u252C ";
              multilinePrefix += " \u2514\u2500\u252C ";
            } else {
              myPrefix += " \u2514\u2500\u2500 ";
              multilinePrefix = "     ";
            }
          } else {
            if (!this.empty) {
              myPrefix += " \u251C\u2500\u252C ";
              multilinePrefix += " \u2502 \u2502 ";
            } else {
              myPrefix += " \u251C\u2500\u2500 ";
              multilinePrefix += " \u2502   ";
            }
          }
        }
        if (this.text) {
          output.write(ancestorsPrefix);
          output.write(myPrefix);
          const lines = this.text.split("\n");
          output.write(lines[0]);
          output.write("\n");
          for (const line of lines.splice(1)) {
            output.write(ancestorsPrefix);
            output.write(multilinePrefix);
            output.write(line);
            output.write("\n");
          }
        }
        for (const child of this._children) {
          child.printTree(output);
        }
      }
      /**
       * Returns a string representation of the tree.
       */
      toString() {
        let out = "";
        const printer = {
          write: (data) => {
            out += data;
            return true;
          }
        };
        this.printTree(printer);
        return out;
      }
      /**
       * Adds children to the node.
       */
      add(...children) {
        for (const child of children) {
          child.parent = this;
          this._children.push(child);
        }
      }
      /**
       * Returns a copy of the children array.
       */
      get children() {
        return this._children.map((x3) => x3);
      }
      /**
       * @returns true if this is the root node
       */
      get root() {
        return !this.parent;
      }
      /**
       * @returns true if this is the last child
       */
      get last() {
        if (!this.parent) {
          return true;
        }
        return this.parent.children.indexOf(this) === this.parent.children.length - 1;
      }
      /**
       * @returns the node level (0 is the root node)
       */
      get level() {
        if (!this.parent) {
          return this.text ? 0 : -1;
        }
        return this.parent.level + 1;
      }
      /**
       * @returns true if this node does not have any children
       */
      get empty() {
        return this.children.length === 0;
      }
      /**
       * @returns an array of parent nodes (from the root to this node, exclusive)
       */
      get ancestors() {
        if (!this.parent) {
          return [];
        }
        return [...this.parent.ancestors, this.parent];
      }
    };
    exports2.AsciiTree = AsciiTree;
  }
});

// node_modules/oo-ascii-tree/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/oo-ascii-tree/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ascii_tree(), exports2);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/serializer.js
var require_serializer = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.treeAsString = void 0;
    var index_1 = require_dist3();
    var oo_ascii_tree_1 = require_lib3();
    function treeAsString(fsTree) {
      const asciiTree = new oo_ascii_tree_1.AsciiTree("root");
      function populateBranch(branch, id) {
        const children = fsTree.children.get(id);
        if (!children)
          return;
        const childBranches = [...children.keys()].map((id2) => {
          const node = fsTree.getNodeById(id2);
          const typeEmoji = node?.type === index_1.bedrockFS.NodeType.File ? "\u{1F4C4}" : "\u{1F4C1}";
          const fileName = node?.name;
          const asciiNode = new oo_ascii_tree_1.AsciiTree(`${typeEmoji} ${fileName}`);
          populateBranch(asciiNode, id2);
          return asciiNode;
        }).sort((a3, b) => {
          if (a3.text === b.text) {
            return a3.children.length > b.children.length ? 1 : -1;
          }
          return a3.text > b.text ? 1 : -1;
        });
        branch.add(...childBranches);
        return branch;
      }
      populateBranch(asciiTree, fsTree.root.id);
      return asciiTree.toString();
    }
    exports2.treeAsString = treeAsString;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/BedrockFS/index.js
var require_BedrockFS = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/BedrockFS/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_TreeNode(), exports2);
    __exportStar(require_Tree(), exports2);
    __exportStar(require_serializer(), exports2);
  }
});

// node_modules/@codesandbox/pitcher-common/dist/shell-escape.js
var require_shell_escape = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/shell-escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shellescape = void 0;
    function shellescape(a3) {
      const ret = [];
      a3.forEach(function(s3) {
        if (/[^A-Za-z0-9_/:=-]/.test(s3)) {
          s3 = "'" + s3.replace(/'/g, "'\\''") + "'";
          s3 = s3.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
        }
        ret.push(s3);
      });
      return ret.join(" ");
    }
    exports2.shellescape = shellescape;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/object.js
var require_object = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.get = void 0;
    function get(obj, path2, seperator = ".") {
      if (obj == null) {
        return void 0;
      }
      const pathParts = path2.split(seperator);
      for (const key of pathParts) {
        if (typeof obj !== "object" || obj == null) {
          return void 0;
        }
        obj = obj[key];
      }
      return obj;
    }
    exports2.get = get;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/mutex.js
var require_mutex = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/mutex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMutex = void 0;
    var createMutex2 = () => {
      let token = true;
      return (f3, g) => {
        if (token) {
          token = false;
          try {
            f3();
          } finally {
            token = true;
          }
        } else if (g !== void 0) {
          g();
        }
      };
    };
    exports2.createMutex = createMutex2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee = new Array(l3); i4 < l3; i4++) {
        ee[i4] = handlers[i4].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a22);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events.push(listeners[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve5) => {
          resolve5(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve5) => {
          resolve5(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve5, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve5(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve5(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve5, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a3, b) => b.priority - a3.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter2 = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter2 {
      constructor(options) {
        var _a3, _b2, _c2, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b2 = (_a3 = options.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b2 !== void 0 ? _b2 : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c2 = options.interval) === null || _c2 === void 0 ? void 0 : _c2.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve5, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve5(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve5) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve5();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve5) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve5();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue;
  }
});

// node_modules/braces/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max)) return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n2 = 0, type) => {
      const node = block.nodes[n2];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i4 = 0; i4 < arr.length; i4++) {
          const ele = arr[i4];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = (ast, options = {}) => {
      const stringify = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a3 = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a3 - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a: a3, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a3 < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a3), state, opts);
        a3 = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a3, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare2);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i4 = 0; i4 < digits; i4++) {
        let [startDigit, stopDigit] = zipped[i4];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i4 = 0; i4 < ranges.length; i4++) {
        let max2 = ranges[i4];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a3, b) {
      let arr = [];
      for (let i4 = 0; i4 < a3.length; i4++) arr.push([a3[i4], b[i4]]);
      return arr;
    }
    function compare2(a3, b) {
      return a3 > b ? 1 : b > a3 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a3, b, options) {
      return `[${a3}${b - a3 === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-") value = value.slice(1);
      if (value === "0") return false;
      while (value[++index] === "0") ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a3, b) => a3 < b ? -1 : a3 > b ? 1 : 0);
      parts.positives.sort((a3, b) => a3 < b ? -1 : a3 > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v3) => toMaxLen(String(v3), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v3) => toMaxLen(String(v3), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a3, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a3, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a3);
      if (a3 === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap2 = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a3 = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a3) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a3 === 0) a3 = 0;
      if (b === 0) b = 0;
      let descending = a3 > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format3 = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a3 >= b : a3 <= b) {
        if (options.toRegex === true && step > 1) {
          push(a3);
        } else {
          range.push(pad(format3(a3, index), maxLen, toNumber));
        }
        a3 = descending ? a3 - step : a3 + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format3 = options.transform || ((val) => String.fromCharCode(val));
      let a3 = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a3 > b;
      let min = Math.min(a3, b);
      let max = Math.max(a3, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a3 >= b : a3 <= b) {
        range.push(format3(a3, index));
        a3 = descending ? a3 - step : a3 + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils4();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify2();
    var utils = require_utils4();
    var append = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p2 = parent;
        let q2 = parent.queue;
        while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
          p2 = p2.parent;
          q2 = p2.queue;
        }
        if (node.invalid || node.dollar) {
          q2.push(append(q2.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q2.push(append(q2.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q2.push(append(q2.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i4 = 0; i4 < node.nodes.length; i4++) {
          const child = node.nodes[i4];
          if (child.type === "comma" && node.type === "brace") {
            if (i4 === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q2.push(append(q2.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path2 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path2.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path2 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path2.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i4 = slashes[idx];
          const value = input.slice(n2, i4);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i4;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils5();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v3) => utils.escapeRegex(v3)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment2 = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment2("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m3;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment2("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment2("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment2("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i4 = arr.length - 1; i4 >= 0; i4--) {
              tokens.pop();
              if (arr[i4].type === "brace") {
                break;
              }
              if (arr[i4].type !== "dots") {
                range.unshift(arr[i4].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t3 of toks) {
              state.output += t3.output || t3.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create2 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create2(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create2(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path2 = require("path");
    var scan = require_scan();
    var parse = require_parse3();
    var utils = require_utils5();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format3 = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format3 ? format3(input) : input;
      if (match === false) {
        output = format3 ? format3(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p2) => picomatch.parse(p2, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils5();
    var isEmptyString = (v3) => v3 === "" || v3 === "./";
    var hasBraces = (v3) => {
      const index = v3.indexOf("{");
      return index > -1 && v3.indexOf("}", index) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i4 = 0; i4 < patterns.length; i4++) {
        let isMatch = picomatch(String(patterns[i4]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p2) => p2.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult) options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p2) => micromatch.contains(str, p2, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p2) => picomatch(p2, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v3) => v3 === void 0 ? "" : v3);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module2.exports = micromatch;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/glob.js
var require_glob = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/glob.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobCache = void 0;
    var micromatch_1 = __importDefault(require_micromatch());
    var GlobCache2 = class {
      _cache = /* @__PURE__ */ new Map();
      get(pattern) {
        let re = this._cache.get(pattern);
        if (!re) {
          re = micromatch_1.default.makeRe(pattern, { dot: true });
          this._cache.set(pattern, re);
        }
        return re;
      }
      clear() {
        this._cache = /* @__PURE__ */ new Map();
      }
    };
    exports2.GlobCache = GlobCache2;
  }
});

// node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/strip-json-comments/index.js"(exports2, module2) {
    "use strict";
    var singleComment = Symbol("singleComment");
    var multiComment = Symbol("multiComment");
    var stripWithoutWhitespace = () => "";
    var stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
    var isEscaped = (jsonString, quotePosition) => {
      let index = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index] === "\\") {
        index -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    };
    module2.exports = (jsonString, options = {}) => {
      if (typeof jsonString !== "string") {
        throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
      }
      const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      let insideString = false;
      let insideComment = false;
      let offset = 0;
      let result = "";
      for (let i4 = 0; i4 < jsonString.length; i4++) {
        const currentCharacter = jsonString[i4];
        const nextCharacter = jsonString[i4 + 1];
        if (!insideComment && currentCharacter === '"') {
          const escaped = isEscaped(jsonString, i4);
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentCharacter + nextCharacter === "//") {
          result += jsonString.slice(offset, i4);
          offset = i4;
          insideComment = singleComment;
          i4++;
        } else if (insideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
          i4++;
          insideComment = false;
          result += strip(jsonString, offset, i4);
          offset = i4;
          continue;
        } else if (insideComment === singleComment && currentCharacter === "\n") {
          insideComment = false;
          result += strip(jsonString, offset, i4);
          offset = i4;
        } else if (!insideComment && currentCharacter + nextCharacter === "/*") {
          result += jsonString.slice(offset, i4);
          offset = i4;
          insideComment = multiComment;
          i4++;
          continue;
        } else if (insideComment === multiComment && currentCharacter + nextCharacter === "*/") {
          i4++;
          insideComment = false;
          result += strip(jsonString, offset, i4 + 1);
          offset = i4 + 1;
          continue;
        }
      }
      return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
    };
  }
});

// node_modules/@codesandbox/pitcher-common/dist/jsonc.js
var require_jsonc = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/jsonc.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = exports2.parse = void 0;
    var strip_json_comments_1 = __importDefault(require_strip_json_comments());
    function parse(text) {
      const withoutComments = (0, strip_json_comments_1.default)(text);
      return JSON.parse(withoutComments);
    }
    exports2.parse = parse;
    function stringify(json) {
      return JSON.stringify(json);
    }
    exports2.stringify = stringify;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/WorkerMessageBus.js
var require_WorkerMessageBus = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/WorkerMessageBus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkerMessageBus = void 0;
    var Disposable_1 = require_Disposable();
    var WorkerMessageBus = class extends Disposable_1.Disposable {
      endpoint;
      handleRequest;
      handleNotification;
      handleError;
      channel;
      timeoutMs;
      pendingRequests = /* @__PURE__ */ new Map();
      _messageId = 0;
      constructor(opts) {
        super();
        this.channel = opts.channel;
        this.endpoint = opts.endpoint;
        this.handleRequest = opts.handleRequest;
        this.handleNotification = opts.handleNotification;
        this.handleError = opts.handleError;
        this.timeoutMs = opts.timeoutMs;
        const disposeMessageListener = this.endpoint.onMessage(async (data) => {
          if (data.channel !== this.channel) {
            return;
          }
          const messageId = data.id;
          if (data.method) {
            if (messageId == null) {
              this.handleNotification(data.method, data.data);
            } else if (data.method && data.params) {
              try {
                const result = await this.handleRequest(data.method, data.params);
                this.endpoint.send({
                  id: messageId,
                  channel: this.channel,
                  result
                });
              } catch (err) {
                this.endpoint.send({
                  id: messageId,
                  channel: this.channel,
                  error: String(err)
                });
              }
            }
          } else if (messageId != null) {
            const pendingRequest = this.pendingRequests.get(messageId);
            if (!pendingRequest) {
              return;
            }
            if (data.error !== void 0) {
              pendingRequest.reject(data.error);
            } else {
              pendingRequest.resolve(data.result);
            }
          }
        });
        this.toDispose.push(disposeMessageListener);
        const disposeErrorListener = this.endpoint.onError((err) => {
          this.handleError(err);
        });
        this.toDispose.push(disposeErrorListener);
      }
      nextMessageId() {
        this._messageId++;
        return this._messageId;
      }
      request(method, params) {
        const messageId = this.nextMessageId();
        const message = {
          channel: this.channel,
          id: messageId,
          method,
          params
        };
        const promise = new Promise((resolve5, reject) => {
          const timeoutRef = setTimeout(() => {
            this.pendingRequests.delete(messageId);
            reject(new Error(`Request on channel ${this.channel} timed out`));
          }, this.timeoutMs);
          this.pendingRequests.set(messageId, {
            resolve: (data) => {
              clearTimeout(timeoutRef);
              resolve5(data);
            },
            reject: (err) => {
              clearTimeout(timeoutRef);
              reject(err);
            }
          });
        });
        this.endpoint.send(message);
        return promise;
      }
    };
    exports2.WorkerMessageBus = WorkerMessageBus;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/PromiseQueue.js
var require_PromiseQueue = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/PromiseQueue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PromiseQueue = void 0;
    var Id_1 = require_Id();
    var PromiseQueue = class {
      items = [];
      runningTasks = /* @__PURE__ */ new Map();
      name;
      debug;
      concurrency;
      constructor(options) {
        const { name, debug: debug4 = false, concurrency = 25 } = options;
        this.name = name;
        this.debug = debug4;
        this.concurrency = concurrency;
      }
      async processQueue() {
        if (this.runningTasks.size >= this.concurrency)
          return;
        const item = this.items.shift();
        if (item) {
          const key = item.key;
          if (this.runningTasks.has(key)) {
            this.items.push(item);
            return;
          }
          if (this.debug) {
            console.log(`Running queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.runningTasks.set(key, item);
          try {
            const result = await item.callback();
            for (const resolve5 of item.resolves) {
              try {
                resolve5(result);
              } catch (err) {
              }
            }
          } catch (err) {
            for (const reject of item.rejects) {
              try {
                reject(err);
              } catch (err2) {
              }
            }
          }
          this.runningTasks.delete(key);
          if (this.debug) {
            console.log(`Processed queue item ${this.name}#${item.key ?? "unknown"}`);
          }
          this.processQueue();
        }
      }
      /**
       * Add a new promise callback to the queue
       *
       * in case you provide a key it will be used to de-duplicate against existing items in the queue
       * if there is an existing item, the callback of that item will be used and this function will
       * return the result of that callback instead
       */
      add(callback, key) {
        if (this.debug) {
          console.log(`Adding item ${this.name}#${key ?? "unknown"} to the queue`);
        }
        return new Promise((resolve5, reject) => {
          let shouldAdd = true;
          let item = {
            key: key ?? (0, Id_1.newId)(),
            callback,
            resolves: [],
            rejects: []
          };
          if (key) {
            const foundItem = this.items.find((i4) => i4.key === key);
            if (foundItem) {
              item = foundItem;
              item.callback = callback;
              shouldAdd = false;
            }
          }
          item.resolves.push(resolve5);
          item.rejects.push(reject);
          if (shouldAdd) {
            this.items.push(item);
          }
          this.processQueue().catch(console.error);
        });
      }
    };
    exports2.PromiseQueue = PromiseQueue;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/ContextualError.js
var require_ContextualError = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/ContextualError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContextualError = void 0;
    var ContextualError = class extends Error {
      code;
      /** Parent operation context. */
      context;
      error;
      publicMessage;
      constructor(options) {
        super(options.publicMessage);
        this.name = "ContextualError";
        this.code = options.code;
        this.error = options.error;
        this.stack = options.error.stack;
        this.publicMessage = options.publicMessage;
        if (!options.code) {
          throw new Error(`Failed to create a contextual "${this.name}" without an error code.`);
        }
      }
      /**
       * Extend this error with a parental context.
       * @param context Parental context.
       * @example
       * const error = new ContextualError({
       *   code: 'GIT_PULL_REJECTED',
       *   details,
       * })
       * error.setContext('GIT_COMMIT')
       */
      setContext(context) {
        this.context = context;
        return this;
      }
    };
    exports2.ContextualError = ContextualError;
  }
});

// node_modules/lru_map/dist/lru.js
var require_lru = __commonJS({
  "node_modules/lru_map/dist/lru.js"(exports2, module2) {
    !function(g, c3) {
      typeof exports2 == "object" && typeof module2 != "undefined" ? c3(exports2) : typeof define == "function" && define.amd ? define(["exports"], c3) : c3((g = g || self).lru_map = g.lru_map || {});
    }(exports2, function(g) {
      const c3 = Symbol("newer"), e3 = Symbol("older");
      class n2 {
        constructor(a3, b) {
          typeof a3 !== "number" && (b = a3, a3 = 0), this.size = 0, this.limit = a3, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a3 < 1 && (this.limit = this.size));
        }
        _markEntryAsUsed(a3) {
          if (a3 === this.newest) return;
          a3[c3] && (a3 === this.oldest && (this.oldest = a3[c3]), a3[c3][e3] = a3[e3]), a3[e3] && (a3[e3][c3] = a3[c3]), a3[c3] = void 0, a3[e3] = this.newest, this.newest && (this.newest[c3] = a3), this.newest = a3;
        }
        assign(a3) {
          let b, d2 = this.limit || Number.MAX_VALUE;
          this._keymap.clear();
          let m3 = a3[Symbol.iterator]();
          for (let h3 = m3.next(); !h3.done; h3 = m3.next()) {
            let f3 = new l3(h3.value[0], h3.value[1]);
            this._keymap.set(f3.key, f3), b ? (b[c3] = f3, f3[e3] = b) : this.oldest = f3, b = f3;
            if (d2-- == 0) throw new Error("overflow");
          }
          this.newest = b, this.size = this._keymap.size;
        }
        get(a3) {
          var b = this._keymap.get(a3);
          return b ? (this._markEntryAsUsed(b), b.value) : void 0;
        }
        set(a3, b) {
          var d2 = this._keymap.get(a3);
          return d2 ? (d2.value = b, this._markEntryAsUsed(d2), this) : (this._keymap.set(a3, d2 = new l3(a3, b)), this.newest ? (this.newest[c3] = d2, d2[e3] = this.newest) : this.oldest = d2, this.newest = d2, ++this.size, this.size > this.limit && this.shift(), this);
        }
        shift() {
          var a3 = this.oldest;
          if (a3) return this.oldest[c3] ? (this.oldest = this.oldest[c3], this.oldest[e3] = void 0) : (this.oldest = void 0, this.newest = void 0), a3[c3] = a3[e3] = void 0, this._keymap.delete(a3.key), --this.size, [a3.key, a3.value];
        }
        find(a3) {
          let b = this._keymap.get(a3);
          return b ? b.value : void 0;
        }
        has(a3) {
          return this._keymap.has(a3);
        }
        delete(a3) {
          var b = this._keymap.get(a3);
          return b ? (this._keymap.delete(b.key), b[c3] && b[e3] ? (b[e3][c3] = b[c3], b[c3][e3] = b[e3]) : b[c3] ? (b[c3][e3] = void 0, this.oldest = b[c3]) : b[e3] ? (b[e3][c3] = void 0, this.newest = b[e3]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
        }
        clear() {
          this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
        }
        keys() {
          return new j3(this.oldest);
        }
        values() {
          return new k4(this.oldest);
        }
        entries() {
          return this;
        }
        [Symbol.iterator]() {
          return new i4(this.oldest);
        }
        forEach(a3, b) {
          typeof b !== "object" && (b = this);
          let d2 = this.oldest;
          for (; d2; ) a3.call(b, d2.value, d2.key, this), d2 = d2[c3];
        }
        toJSON() {
          for (var a3 = new Array(this.size), b = 0, d2 = this.oldest; d2; ) a3[b++] = { key: d2.key, value: d2.value }, d2 = d2[c3];
          return a3;
        }
        toString() {
          for (var a3 = "", b = this.oldest; b; ) a3 += String(b.key) + ":" + b.value, b = b[c3], b && (a3 += " < ");
          return a3;
        }
      }
      g.LRUMap = n2;
      function l3(a3, b) {
        this.key = a3, this.value = b, this[c3] = void 0, this[e3] = void 0;
      }
      function i4(a3) {
        this.entry = a3;
      }
      i4.prototype[Symbol.iterator] = function() {
        return this;
      }, i4.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: [a3.key, a3.value] }) : { done: true, value: void 0 };
      };
      function j3(a3) {
        this.entry = a3;
      }
      j3.prototype[Symbol.iterator] = function() {
        return this;
      }, j3.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: a3.key }) : { done: true, value: void 0 };
      };
      function k4(a3) {
        this.entry = a3;
      }
      k4.prototype[Symbol.iterator] = function() {
        return this;
      }, k4.prototype.next = function() {
        let a3 = this.entry;
        return a3 ? (this.entry = a3[c3], { done: false, value: a3.value }) : { done: true, value: void 0 };
      };
    });
  }
});

// node_modules/@codesandbox/pitcher-common/dist/Throttle.js
var require_Throttle = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/Throttle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Throttle = void 0;
    var Throttle = class {
      lastExecution = 0;
      timeoutRef = null;
      ms;
      callback;
      constructor(callback, ms) {
        this.ms = ms;
        this.callback = callback;
        this.lastExecution = 0;
        this.timeoutRef = null;
      }
      execute() {
        if (Date.now() - this.lastExecution >= this.ms) {
          this.callback();
          this.lastExecution = Date.now();
        } else if (!this.timeoutRef) {
          this.timeoutRef = setTimeout(() => {
            this.lastExecution = Date.now();
            this.timeoutRef = null;
            this.callback();
          }, this.ms - (Date.now() - this.lastExecution));
        }
      }
      clear() {
        if (this.timeoutRef) {
          clearTimeout(this.timeoutRef);
          this.timeoutRef = null;
        }
        this.lastExecution = Date.now();
      }
    };
    exports2.Throttle = Throttle;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.undent = void 0;
    function undent(strings, ...interps) {
      let string = "";
      for (let i4 = 0; i4 < strings.length; i4++) {
        string += `${strings[i4] || ""}${interps[i4] || ""}`;
      }
      string = string.replace(/^[\r\n]+/, "").replace(/\s+$/, "");
      const dents = string.match(/^([ \t])*/gm);
      if (!dents || dents.length == 0) {
        return string;
      }
      dents.sort((dent1, dent2) => dent1.length - dent2.length);
      const minDent = dents[0];
      if (!minDent) {
        return string;
      }
      const dedented = string.replace(new RegExp(`^${minDent}`, "gm"), "");
      return dedented;
    }
    exports2.undent = undent;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/color.js
var require_color = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/color.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRandomColor = void 0;
    function hslToHex(h3, s3, l3) {
      h3 /= 360;
      s3 /= 100;
      l3 /= 100;
      let r3, g, b;
      if (s3 === 0) {
        r3 = g = b = l3;
      } else {
        const hue2rgb = (p3, q3, t3) => {
          if (t3 < 0)
            t3 += 1;
          if (t3 > 1)
            t3 -= 1;
          if (t3 < 1 / 6)
            return p3 + (q3 - p3) * 6 * t3;
          if (t3 < 1 / 2)
            return q3;
          if (t3 < 2 / 3)
            return p3 + (q3 - p3) * (2 / 3 - t3) * 6;
          return p3;
        };
        const q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
        const p2 = 2 * l3 - q2;
        r3 = hue2rgb(p2, q2, h3 + 1 / 3);
        g = hue2rgb(p2, q2, h3);
        b = hue2rgb(p2, q2, h3 - 1 / 3);
      }
      const toHex = (c3) => {
        const hex = Math.round(c3 * 255).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      };
      const hexR = toHex(r3);
      const hexG = toHex(g);
      const hexB = toHex(b);
      return `#${hexR}${hexG}${hexB}`;
    }
    function getRandomColor() {
      const hue = Math.floor(Math.random() * 360);
      const saturation = Math.floor(Math.random() * 25) + 75;
      const lightness = Math.floor(Math.random() * 25) + 75;
      return hslToHex(hue, saturation, lightness);
    }
    exports2.getRandomColor = getRandomColor;
  }
});

// node_modules/@codesandbox/pitcher-common/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@codesandbox/pitcher-common/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4)) __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRandomColor = exports2.undent = exports2.Throttle = exports2.LRUMap = exports2.DeduplicatingPromiseQueue = exports2.SliceList = exports2.WorkerMessageBus = exports2.jsonc = exports2.micromatch = exports2.GlobCache = exports2.SerialQueue = exports2.PromiseQueue = exports2.createMutex = exports2.object = exports2.shellescape = exports2.bedrockFS = exports2.BidirectionalMap = exports2.Debouncer = exports2.Aborter = exports2.murmur = exports2.nullthrows = exports2.timeout = exports2.sleep = exports2.pRetry = exports2.ot = exports2.AsyncEmitter = exports2.listenOnce = exports2.Emitter = exports2.EventEmitter = exports2.DisposableStore = exports2.Disposable = exports2.newId = exports2.ClosableBarrier = exports2.Barrier = void 0;
    var Barrier_1 = require_Barrier();
    Object.defineProperty(exports2, "Barrier", { enumerable: true, get: function() {
      return Barrier_1.Barrier;
    } });
    Object.defineProperty(exports2, "ClosableBarrier", { enumerable: true, get: function() {
      return Barrier_1.ClosableBarrier;
    } });
    var Id_1 = require_Id();
    Object.defineProperty(exports2, "newId", { enumerable: true, get: function() {
      return Id_1.newId;
    } });
    var Disposable_1 = require_Disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return Disposable_1.Disposable;
    } });
    Object.defineProperty(exports2, "DisposableStore", { enumerable: true, get: function() {
      return Disposable_1.DisposableStore;
    } });
    var EventEmitter_1 = require_EventEmitter();
    Object.defineProperty(exports2, "EventEmitter", { enumerable: true, get: function() {
      return EventEmitter_1.EventEmitter;
    } });
    var event_1 = require_event();
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return event_1.Emitter;
    } });
    Object.defineProperty(exports2, "listenOnce", { enumerable: true, get: function() {
      return event_1.listenOnce;
    } });
    Object.defineProperty(exports2, "AsyncEmitter", { enumerable: true, get: function() {
      return event_1.AsyncEmitter;
    } });
    exports2.ot = __importStar(require_operational_transforms());
    exports2.pRetry = __importStar(require_p_retry());
    __exportStar(require_fetch(), exports2);
    var sleep_1 = require_sleep();
    Object.defineProperty(exports2, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var nullthrows_1 = require_nullthrows();
    Object.defineProperty(exports2, "nullthrows", { enumerable: true, get: function() {
      return nullthrows_1.nullthrows;
    } });
    var murmur_1 = require_murmur();
    Object.defineProperty(exports2, "murmur", { enumerable: true, get: function() {
      return murmur_1.murmur;
    } });
    var Aborter_1 = require_Aborter();
    Object.defineProperty(exports2, "Aborter", { enumerable: true, get: function() {
      return Aborter_1.Aborter;
    } });
    var Debouncer_1 = require_Debouncer();
    Object.defineProperty(exports2, "Debouncer", { enumerable: true, get: function() {
      return Debouncer_1.Debouncer;
    } });
    var BidirectionalMap_1 = require_BidirectionalMap();
    Object.defineProperty(exports2, "BidirectionalMap", { enumerable: true, get: function() {
      return BidirectionalMap_1.BidirectionalMap;
    } });
    exports2.bedrockFS = __importStar(require_BedrockFS());
    var shell_escape_1 = require_shell_escape();
    Object.defineProperty(exports2, "shellescape", { enumerable: true, get: function() {
      return shell_escape_1.shellescape;
    } });
    exports2.object = __importStar(require_object());
    var mutex_1 = require_mutex();
    Object.defineProperty(exports2, "createMutex", { enumerable: true, get: function() {
      return mutex_1.createMutex;
    } });
    var p_queue_1 = require_dist2();
    Object.defineProperty(exports2, "PromiseQueue", { enumerable: true, get: function() {
      return __importDefault(p_queue_1).default;
    } });
    var SerialQueue_1 = require_SerialQueue();
    Object.defineProperty(exports2, "SerialQueue", { enumerable: true, get: function() {
      return SerialQueue_1.SerialQueue;
    } });
    var glob_1 = require_glob();
    Object.defineProperty(exports2, "GlobCache", { enumerable: true, get: function() {
      return glob_1.GlobCache;
    } });
    var micromatch_1 = require_micromatch();
    Object.defineProperty(exports2, "micromatch", { enumerable: true, get: function() {
      return __importDefault(micromatch_1).default;
    } });
    exports2.jsonc = __importStar(require_jsonc());
    var WorkerMessageBus_1 = require_WorkerMessageBus();
    Object.defineProperty(exports2, "WorkerMessageBus", { enumerable: true, get: function() {
      return WorkerMessageBus_1.WorkerMessageBus;
    } });
    var SliceList_1 = require_SliceList();
    Object.defineProperty(exports2, "SliceList", { enumerable: true, get: function() {
      return SliceList_1.SliceList;
    } });
    var PromiseQueue_1 = require_PromiseQueue();
    Object.defineProperty(exports2, "DeduplicatingPromiseQueue", { enumerable: true, get: function() {
      return PromiseQueue_1.PromiseQueue;
    } });
    __exportStar(require_ContextualError(), exports2);
    var lru_map_1 = require_lru();
    Object.defineProperty(exports2, "LRUMap", { enumerable: true, get: function() {
      return lru_map_1.LRUMap;
    } });
    var Throttle_1 = require_Throttle();
    Object.defineProperty(exports2, "Throttle", { enumerable: true, get: function() {
      return Throttle_1.Throttle;
    } });
    var template_literals_1 = require_template_literals();
    Object.defineProperty(exports2, "undent", { enumerable: true, get: function() {
      return template_literals_1.undent;
    } });
    var color_1 = require_color();
    Object.defineProperty(exports2, "getRandomColor", { enumerable: true, get: function() {
      return color_1.getRandomColor;
    } });
  }
});

// node_modules/ora/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/ora/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/ora/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/ora/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r3, g, b);
      const max = Math.max(r3, g, b);
      const delta = max - min;
      let h3;
      let s3;
      if (max === min) {
        h3 = 0;
      } else if (r3 === max) {
        h3 = (g - b) / delta;
      } else if (g === max) {
        h3 = 2 + (b - r3) / delta;
      } else if (b === max) {
        h3 = 4 + (r3 - g) / delta;
      }
      h3 = Math.min(h3 * 60, 360);
      if (h3 < 0) {
        h3 += 360;
      }
      const l3 = (min + max) / 2;
      if (max === min) {
        s3 = 0;
      } else if (l3 <= 0.5) {
        s3 = delta / (max + min);
      } else {
        s3 = delta / (2 - max - min);
      }
      return [h3, s3 * 100, l3 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h3;
      let s3;
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v3 = Math.max(r3, g, b);
      const diff = v3 - Math.min(r3, g, b);
      const diffc = function(c3) {
        return (v3 - c3) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h3 = 0;
        s3 = 0;
      } else {
        s3 = diff / v3;
        rdif = diffc(r3);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r3 === v3) {
          h3 = bdif - gdif;
        } else if (g === v3) {
          h3 = 1 / 3 + rdif - bdif;
        } else if (b === v3) {
          h3 = 2 / 3 + gdif - rdif;
        }
        if (h3 < 0) {
          h3 += 1;
        } else if (h3 > 1) {
          h3 -= 1;
        }
      }
      return [
        h3 * 360,
        s3 * 100,
        v3 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r3 = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h3 = convert.rgb.hsl(rgb)[0];
      const w4 = 1 / 255 * Math.min(r3, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r3, Math.max(g, b));
      return [h3, w4 * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k4 = Math.min(1 - r3, 1 - g, 1 - b);
      const c3 = (1 - r3 - k4) / (1 - k4) || 0;
      const m3 = (1 - g - k4) / (1 - k4) || 0;
      const y3 = (1 - b - k4) / (1 - k4) || 0;
      return [c3 * 100, m3 * 100, y3 * 100, k4 * 100];
    };
    function comparativeDistance(x3, y3) {
      return (x3[0] - y3[0]) ** 2 + (x3[1] - y3[1]) ** 2 + (x3[2] - y3[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r3 = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r3 = r3 > 0.04045 ? ((r3 + 0.055) / 1.055) ** 2.4 : r3 / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x3 = r3 * 0.4124 + g * 0.3576 + b * 0.1805;
      const y3 = r3 * 0.2126 + g * 0.7152 + b * 0.0722;
      const z4 = r3 * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x3 * 100, y3 * 100, z4 * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x3 = xyz[0];
      let y3 = xyz[1];
      let z4 = xyz[2];
      x3 /= 95.047;
      y3 /= 100;
      z4 /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z4 = z4 > 8856e-6 ? z4 ** (1 / 3) : 7.787 * z4 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x3 - y3);
      const b = 200 * (y3 - z4);
      return [l3, a3, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h3 = hsl[0] / 360;
      const s3 = hsl[1] / 100;
      const l3 = hsl[2] / 100;
      let t22;
      let t3;
      let val;
      if (s3 === 0) {
        val = l3 * 255;
        return [val, val, val];
      }
      if (l3 < 0.5) {
        t22 = l3 * (1 + s3);
      } else {
        t22 = l3 + s3 - l3 * s3;
      }
      const t1 = 2 * l3 - t22;
      const rgb = [0, 0, 0];
      for (let i4 = 0; i4 < 3; i4++) {
        t3 = h3 + 1 / 3 * -(i4 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t22 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t22;
        } else if (3 * t3 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i4] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h3 = hsl[0];
      let s3 = hsl[1] / 100;
      let l3 = hsl[2] / 100;
      let smin = s3;
      const lmin = Math.max(l3, 0.01);
      l3 *= 2;
      s3 *= l3 <= 1 ? l3 : 2 - l3;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v3 = (l3 + s3) / 2;
      const sv = l3 === 0 ? 2 * smin / (lmin + smin) : 2 * s3 / (l3 + s3);
      return [h3, sv * 100, v3 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h3 = hsv[0] / 60;
      const s3 = hsv[1] / 100;
      let v3 = hsv[2] / 100;
      const hi = Math.floor(h3) % 6;
      const f3 = h3 - Math.floor(h3);
      const p2 = 255 * v3 * (1 - s3);
      const q2 = 255 * v3 * (1 - s3 * f3);
      const t3 = 255 * v3 * (1 - s3 * (1 - f3));
      v3 *= 255;
      switch (hi) {
        case 0:
          return [v3, t3, p2];
        case 1:
          return [q2, v3, p2];
        case 2:
          return [p2, v3, t3];
        case 3:
          return [p2, q2, v3];
        case 4:
          return [t3, p2, v3];
        case 5:
          return [v3, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h3 = hsv[0];
      const s3 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const vmin = Math.max(v3, 0.01);
      let sl;
      let l3;
      l3 = (2 - s3) * v3;
      const lmin = (2 - s3) * vmin;
      sl = s3 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l3 /= 2;
      return [h3, sl * 100, l3 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h3 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f3;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i4 = Math.floor(6 * h3);
      const v3 = 1 - bl;
      f3 = 6 * h3 - i4;
      if ((i4 & 1) !== 0) {
        f3 = 1 - f3;
      }
      const n2 = wh + f3 * (v3 - wh);
      let r3;
      let g;
      let b;
      switch (i4) {
        default:
        case 6:
        case 0:
          r3 = v3;
          g = n2;
          b = wh;
          break;
        case 1:
          r3 = n2;
          g = v3;
          b = wh;
          break;
        case 2:
          r3 = wh;
          g = v3;
          b = n2;
          break;
        case 3:
          r3 = wh;
          g = n2;
          b = v3;
          break;
        case 4:
          r3 = n2;
          g = wh;
          b = v3;
          break;
        case 5:
          r3 = v3;
          g = wh;
          b = n2;
          break;
      }
      return [r3 * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c3 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k4 = cmyk[3] / 100;
      const r3 = 1 - Math.min(1, c3 * (1 - k4) + k4);
      const g = 1 - Math.min(1, m3 * (1 - k4) + k4);
      const b = 1 - Math.min(1, y3 * (1 - k4) + k4);
      return [r3 * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x3 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z4 = xyz[2] / 100;
      let r3;
      let g;
      let b;
      r3 = x3 * 3.2406 + y3 * -1.5372 + z4 * -0.4986;
      g = x3 * -0.9689 + y3 * 1.8758 + z4 * 0.0415;
      b = x3 * 0.0557 + y3 * -0.204 + z4 * 1.057;
      r3 = r3 > 31308e-7 ? 1.055 * r3 ** (1 / 2.4) - 0.055 : r3 * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r3 = Math.min(Math.max(0, r3), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r3 * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x3 = xyz[0];
      let y3 = xyz[1];
      let z4 = xyz[2];
      x3 /= 95.047;
      y3 /= 100;
      z4 /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z4 = z4 > 8856e-6 ? z4 ** (1 / 3) : 7.787 * z4 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x3 - y3);
      const b = 200 * (y3 - z4);
      return [l3, a3, b];
    };
    convert.lab.xyz = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b = lab[2];
      let x3;
      let y3;
      let z4;
      y3 = (l3 + 16) / 116;
      x3 = a3 / 500 + y3;
      z4 = y3 - b / 200;
      const y22 = y3 ** 3;
      const x22 = x3 ** 3;
      const z22 = z4 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x3 = x22 > 8856e-6 ? x22 : (x3 - 16 / 116) / 7.787;
      z4 = z22 > 8856e-6 ? z22 : (z4 - 16 / 116) / 7.787;
      x3 *= 95.047;
      y3 *= 100;
      z4 *= 108.883;
      return [x3, y3, z4];
    };
    convert.lab.lch = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b = lab[2];
      let h3;
      const hr = Math.atan2(b, a3);
      h3 = hr * 360 / 2 / Math.PI;
      if (h3 < 0) {
        h3 += 360;
      }
      const c3 = Math.sqrt(a3 * a3 + b * b);
      return [l3, c3, h3];
    };
    convert.lch.lab = function(lch) {
      const l3 = lch[0];
      const c3 = lch[1];
      const h3 = lch[2];
      const hr = h3 / 360 * 2 * Math.PI;
      const a3 = c3 * Math.cos(hr);
      const b = c3 * Math.sin(hr);
      return [l3, a3, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r3, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r3 / 255));
      if (value === 2) {
        ansi2 += 60;
      }
      return ansi2;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r3 = args[0];
      const g = args[1];
      const b = args[2];
      if (r3 === g && g === b) {
        if (r3 < 8) {
          return 16;
        }
        if (r3 > 248) {
          return 231;
        }
        return Math.round((r3 - 8) / 247 * 24) + 232;
      }
      const ansi2 = 16 + 36 * Math.round(r3 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi2;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r3 = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r3, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c3 = (args - 232) * 10 + 8;
        return [c3, c3, c3];
      }
      args -= 16;
      let rem;
      const r3 = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r3, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r3 = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r3, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r3, g), b);
      const min = Math.min(Math.min(r3, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r3) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r3) / chroma;
      } else {
        hue = 4 + (r3 - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s3 = hsl[1] / 100;
      const l3 = hsl[2] / 100;
      const c3 = l3 < 0.5 ? 2 * s3 * l3 : 2 * s3 * (1 - l3);
      let f3 = 0;
      if (c3 < 1) {
        f3 = (l3 - 0.5 * c3) / (1 - c3);
      }
      return [hsl[0], c3 * 100, f3 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s3 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const c3 = s3 * v3;
      let f3 = 0;
      if (c3 < 1) {
        f3 = (v3 - c3) / (1 - c3);
      }
      return [hsv[0], c3 * 100, f3 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h3 = hcg[0] / 360;
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c3 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h3 % 1 * 6;
      const v3 = hi % 1;
      const w4 = 1 - v3;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v3;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w4;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v3;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w4;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v3;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w4;
      }
      mg = (1 - c3) * g;
      return [
        (c3 * pure[0] + mg) * 255,
        (c3 * pure[1] + mg) * 255,
        (c3 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c3 + g * (1 - c3);
      let f3 = 0;
      if (v3 > 0) {
        f3 = c3 / v3;
      }
      return [hcg[0], f3 * 100, v3 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l3 = g * (1 - c3) + 0.5 * c3;
      let s3 = 0;
      if (l3 > 0 && l3 < 0.5) {
        s3 = c3 / (2 * l3);
      } else if (l3 >= 0.5 && l3 < 1) {
        s3 = c3 / (2 * (1 - l3));
      }
      return [hcg[0], s3 * 100, l3 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c3 + g * (1 - c3);
      return [hcg[0], (v3 - c3) * 100, (1 - v3) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w4 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v3 = 1 - b;
      const c3 = v3 - w4;
      let g = 0;
      if (c3 < 1) {
        g = (v3 - c3) / (1 - c3);
      }
      return [hwb[0], c3 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/ora/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/ora/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i4 = 0; i4 < len; i4++) {
        graph[models[i4]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i4 = 0; i4 < len; i4++) {
          const adjacent = adjacents[i4];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i4 = 0; i4 < len; i4++) {
        const toModel = models[i4];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/ora/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/ora/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i4 = 0; i4 < len; i4++) {
            result[i4] = Math.round(result[i4]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ora/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ora/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n2) => n2;
    var rgb2rgb = (r3, g, b) => [r3, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/ora/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/ora/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/ora/node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "node_modules/ora/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/ora/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/ora/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c3) {
      const u4 = c3[0] === "u";
      const bracket = c3[1] === "{";
      if (u4 && !bracket && c3.length === 5 || c3[0] === "x" && c3.length === 3) {
        return String.fromCharCode(parseInt(c3.slice(1), 16));
      }
      if (u4 && bracket) {
        return String.fromCodePoint(parseInt(c3.slice(2, -1), 16));
      }
      return ESCAPES.get(c3) || c3;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m3, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/ora/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/ora/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util2();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i4 = 1; i4 < firstString.length; i4++) {
        parts.push(
          String(arguments_[i4 - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i4])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/restore-cursor/index.js
var require_restore_cursor = __commonJS({
  "node_modules/restore-cursor/index.js"(exports2, module2) {
    "use strict";
    var onetime = require_onetime();
    var signalExit = require_signal_exit();
    module2.exports = onetime(() => {
      signalExit(() => {
        process.stderr.write("\x1B[?25h");
      }, { alwaysLast: true });
    });
  }
});

// node_modules/cli-cursor/index.js
var require_cli_cursor = __commonJS({
  "node_modules/cli-cursor/index.js"(exports2) {
    "use strict";
    var restoreCursor = require_restore_cursor();
    var isHidden = false;
    exports2.show = (writableStream = process.stderr) => {
      if (!writableStream.isTTY) {
        return;
      }
      isHidden = false;
      writableStream.write("\x1B[?25h");
    };
    exports2.hide = (writableStream = process.stderr) => {
      if (!writableStream.isTTY) {
        return;
      }
      restoreCursor();
      isHidden = true;
      writableStream.write("\x1B[?25l");
    };
    exports2.toggle = (force, writableStream) => {
      if (force !== void 0) {
        isHidden = force;
      }
      if (isHidden) {
        exports2.show(writableStream);
      } else {
        exports2.hide(writableStream);
      }
    };
  }
});

// node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  "node_modules/cli-spinners/spinners.json"(exports2, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u2839",
          "\u2838",
          "\u283C",
          "\u2834",
          "\u2826",
          "\u2827",
          "\u2807",
          "\u280F"
        ]
      },
      dots2: {
        interval: 80,
        frames: [
          "\u28FE",
          "\u28FD",
          "\u28FB",
          "\u28BF",
          "\u287F",
          "\u28DF",
          "\u28EF",
          "\u28F7"
        ]
      },
      dots3: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u281E",
          "\u2816",
          "\u2826",
          "\u2834",
          "\u2832",
          "\u2833",
          "\u2813"
        ]
      },
      dots4: {
        interval: 80,
        frames: [
          "\u2804",
          "\u2806",
          "\u2807",
          "\u280B",
          "\u2819",
          "\u2838",
          "\u2830",
          "\u2820",
          "\u2830",
          "\u2838",
          "\u2819",
          "\u280B",
          "\u2807",
          "\u2806"
        ]
      },
      dots5: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B"
        ]
      },
      dots6: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2834",
          "\u2832",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u281A",
          "\u2819",
          "\u2809",
          "\u2801"
        ]
      },
      dots7: {
        interval: 80,
        frames: [
          "\u2808",
          "\u2809",
          "\u280B",
          "\u2813",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2816",
          "\u2826",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808"
        ]
      },
      dots8: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808",
          "\u2808"
        ]
      },
      dots9: {
        interval: 80,
        frames: [
          "\u28B9",
          "\u28BA",
          "\u28BC",
          "\u28F8",
          "\u28C7",
          "\u2867",
          "\u2857",
          "\u284F"
        ]
      },
      dots10: {
        interval: 80,
        frames: [
          "\u2884",
          "\u2882",
          "\u2881",
          "\u2841",
          "\u2848",
          "\u2850",
          "\u2860"
        ]
      },
      dots11: {
        interval: 100,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2840",
          "\u2880",
          "\u2820",
          "\u2810",
          "\u2808"
        ]
      },
      dots12: {
        interval: 80,
        frames: [
          "\u2880\u2800",
          "\u2840\u2800",
          "\u2804\u2800",
          "\u2882\u2800",
          "\u2842\u2800",
          "\u2805\u2800",
          "\u2883\u2800",
          "\u2843\u2800",
          "\u280D\u2800",
          "\u288B\u2800",
          "\u284B\u2800",
          "\u280D\u2801",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2888\u2829",
          "\u2840\u2899",
          "\u2804\u2859",
          "\u2882\u2829",
          "\u2842\u2898",
          "\u2805\u2858",
          "\u2883\u2828",
          "\u2843\u2890",
          "\u280D\u2850",
          "\u288B\u2820",
          "\u284B\u2880",
          "\u280D\u2841",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2808\u2829",
          "\u2800\u2899",
          "\u2800\u2859",
          "\u2800\u2829",
          "\u2800\u2898",
          "\u2800\u2858",
          "\u2800\u2828",
          "\u2800\u2890",
          "\u2800\u2850",
          "\u2800\u2820",
          "\u2800\u2880",
          "\u2800\u2840"
        ]
      },
      dots13: {
        interval: 80,
        frames: [
          "\u28FC",
          "\u28F9",
          "\u28BB",
          "\u283F",
          "\u285F",
          "\u28CF",
          "\u28E7",
          "\u28F6"
        ]
      },
      dots8Bit: {
        interval: 80,
        frames: [
          "\u2800",
          "\u2801",
          "\u2802",
          "\u2803",
          "\u2804",
          "\u2805",
          "\u2806",
          "\u2807",
          "\u2840",
          "\u2841",
          "\u2842",
          "\u2843",
          "\u2844",
          "\u2845",
          "\u2846",
          "\u2847",
          "\u2808",
          "\u2809",
          "\u280A",
          "\u280B",
          "\u280C",
          "\u280D",
          "\u280E",
          "\u280F",
          "\u2848",
          "\u2849",
          "\u284A",
          "\u284B",
          "\u284C",
          "\u284D",
          "\u284E",
          "\u284F",
          "\u2810",
          "\u2811",
          "\u2812",
          "\u2813",
          "\u2814",
          "\u2815",
          "\u2816",
          "\u2817",
          "\u2850",
          "\u2851",
          "\u2852",
          "\u2853",
          "\u2854",
          "\u2855",
          "\u2856",
          "\u2857",
          "\u2818",
          "\u2819",
          "\u281A",
          "\u281B",
          "\u281C",
          "\u281D",
          "\u281E",
          "\u281F",
          "\u2858",
          "\u2859",
          "\u285A",
          "\u285B",
          "\u285C",
          "\u285D",
          "\u285E",
          "\u285F",
          "\u2820",
          "\u2821",
          "\u2822",
          "\u2823",
          "\u2824",
          "\u2825",
          "\u2826",
          "\u2827",
          "\u2860",
          "\u2861",
          "\u2862",
          "\u2863",
          "\u2864",
          "\u2865",
          "\u2866",
          "\u2867",
          "\u2828",
          "\u2829",
          "\u282A",
          "\u282B",
          "\u282C",
          "\u282D",
          "\u282E",
          "\u282F",
          "\u2868",
          "\u2869",
          "\u286A",
          "\u286B",
          "\u286C",
          "\u286D",
          "\u286E",
          "\u286F",
          "\u2830",
          "\u2831",
          "\u2832",
          "\u2833",
          "\u2834",
          "\u2835",
          "\u2836",
          "\u2837",
          "\u2870",
          "\u2871",
          "\u2872",
          "\u2873",
          "\u2874",
          "\u2875",
          "\u2876",
          "\u2877",
          "\u2838",
          "\u2839",
          "\u283A",
          "\u283B",
          "\u283C",
          "\u283D",
          "\u283E",
          "\u283F",
          "\u2878",
          "\u2879",
          "\u287A",
          "\u287B",
          "\u287C",
          "\u287D",
          "\u287E",
          "\u287F",
          "\u2880",
          "\u2881",
          "\u2882",
          "\u2883",
          "\u2884",
          "\u2885",
          "\u2886",
          "\u2887",
          "\u28C0",
          "\u28C1",
          "\u28C2",
          "\u28C3",
          "\u28C4",
          "\u28C5",
          "\u28C6",
          "\u28C7",
          "\u2888",
          "\u2889",
          "\u288A",
          "\u288B",
          "\u288C",
          "\u288D",
          "\u288E",
          "\u288F",
          "\u28C8",
          "\u28C9",
          "\u28CA",
          "\u28CB",
          "\u28CC",
          "\u28CD",
          "\u28CE",
          "\u28CF",
          "\u2890",
          "\u2891",
          "\u2892",
          "\u2893",
          "\u2894",
          "\u2895",
          "\u2896",
          "\u2897",
          "\u28D0",
          "\u28D1",
          "\u28D2",
          "\u28D3",
          "\u28D4",
          "\u28D5",
          "\u28D6",
          "\u28D7",
          "\u2898",
          "\u2899",
          "\u289A",
          "\u289B",
          "\u289C",
          "\u289D",
          "\u289E",
          "\u289F",
          "\u28D8",
          "\u28D9",
          "\u28DA",
          "\u28DB",
          "\u28DC",
          "\u28DD",
          "\u28DE",
          "\u28DF",
          "\u28A0",
          "\u28A1",
          "\u28A2",
          "\u28A3",
          "\u28A4",
          "\u28A5",
          "\u28A6",
          "\u28A7",
          "\u28E0",
          "\u28E1",
          "\u28E2",
          "\u28E3",
          "\u28E4",
          "\u28E5",
          "\u28E6",
          "\u28E7",
          "\u28A8",
          "\u28A9",
          "\u28AA",
          "\u28AB",
          "\u28AC",
          "\u28AD",
          "\u28AE",
          "\u28AF",
          "\u28E8",
          "\u28E9",
          "\u28EA",
          "\u28EB",
          "\u28EC",
          "\u28ED",
          "\u28EE",
          "\u28EF",
          "\u28B0",
          "\u28B1",
          "\u28B2",
          "\u28B3",
          "\u28B4",
          "\u28B5",
          "\u28B6",
          "\u28B7",
          "\u28F0",
          "\u28F1",
          "\u28F2",
          "\u28F3",
          "\u28F4",
          "\u28F5",
          "\u28F6",
          "\u28F7",
          "\u28B8",
          "\u28B9",
          "\u28BA",
          "\u28BB",
          "\u28BC",
          "\u28BD",
          "\u28BE",
          "\u28BF",
          "\u28F8",
          "\u28F9",
          "\u28FA",
          "\u28FB",
          "\u28FC",
          "\u28FD",
          "\u28FE",
          "\u28FF"
        ]
      },
      sand: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2840",
          "\u2848",
          "\u2850",
          "\u2860",
          "\u28C0",
          "\u28C1",
          "\u28C2",
          "\u28C4",
          "\u28CC",
          "\u28D4",
          "\u28E4",
          "\u28E5",
          "\u28E6",
          "\u28EE",
          "\u28F6",
          "\u28F7",
          "\u28FF",
          "\u287F",
          "\u283F",
          "\u289F",
          "\u281F",
          "\u285B",
          "\u281B",
          "\u282B",
          "\u288B",
          "\u280B",
          "\u280D",
          "\u2849",
          "\u2809",
          "\u2811",
          "\u2821",
          "\u2881"
        ]
      },
      line: {
        interval: 130,
        frames: [
          "-",
          "\\",
          "|",
          "/"
        ]
      },
      line2: {
        interval: 100,
        frames: [
          "\u2802",
          "-",
          "\u2013",
          "\u2014",
          "\u2013",
          "-"
        ]
      },
      pipe: {
        interval: 100,
        frames: [
          "\u2524",
          "\u2518",
          "\u2534",
          "\u2514",
          "\u251C",
          "\u250C",
          "\u252C",
          "\u2510"
        ]
      },
      simpleDots: {
        interval: 400,
        frames: [
          ".  ",
          ".. ",
          "...",
          "   "
        ]
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: [
          ".  ",
          ".. ",
          "...",
          " ..",
          "  .",
          "   "
        ]
      },
      star: {
        interval: 70,
        frames: [
          "\u2736",
          "\u2738",
          "\u2739",
          "\u273A",
          "\u2739",
          "\u2737"
        ]
      },
      star2: {
        interval: 80,
        frames: [
          "+",
          "x",
          "*"
        ]
      },
      flip: {
        interval: 70,
        frames: [
          "_",
          "_",
          "_",
          "-",
          "`",
          "`",
          "'",
          "\xB4",
          "-",
          "_",
          "_",
          "_"
        ]
      },
      hamburger: {
        interval: 100,
        frames: [
          "\u2631",
          "\u2632",
          "\u2634"
        ]
      },
      growVertical: {
        interval: 120,
        frames: [
          "\u2581",
          "\u2583",
          "\u2584",
          "\u2585",
          "\u2586",
          "\u2587",
          "\u2586",
          "\u2585",
          "\u2584",
          "\u2583"
        ]
      },
      growHorizontal: {
        interval: 120,
        frames: [
          "\u258F",
          "\u258E",
          "\u258D",
          "\u258C",
          "\u258B",
          "\u258A",
          "\u2589",
          "\u258A",
          "\u258B",
          "\u258C",
          "\u258D",
          "\u258E"
        ]
      },
      balloon: {
        interval: 140,
        frames: [
          " ",
          ".",
          "o",
          "O",
          "@",
          "*",
          " "
        ]
      },
      balloon2: {
        interval: 120,
        frames: [
          ".",
          "o",
          "O",
          "\xB0",
          "O",
          "o",
          "."
        ]
      },
      noise: {
        interval: 100,
        frames: [
          "\u2593",
          "\u2592",
          "\u2591"
        ]
      },
      bounce: {
        interval: 120,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2802"
        ]
      },
      boxBounce: {
        interval: 120,
        frames: [
          "\u2596",
          "\u2598",
          "\u259D",
          "\u2597"
        ]
      },
      boxBounce2: {
        interval: 100,
        frames: [
          "\u258C",
          "\u2580",
          "\u2590",
          "\u2584"
        ]
      },
      triangle: {
        interval: 50,
        frames: [
          "\u25E2",
          "\u25E3",
          "\u25E4",
          "\u25E5"
        ]
      },
      binary: {
        interval: 80,
        frames: [
          "010010",
          "001100",
          "100101",
          "111010",
          "111101",
          "010111",
          "101011",
          "111000",
          "110011",
          "110101"
        ]
      },
      arc: {
        interval: 100,
        frames: [
          "\u25DC",
          "\u25E0",
          "\u25DD",
          "\u25DE",
          "\u25E1",
          "\u25DF"
        ]
      },
      circle: {
        interval: 120,
        frames: [
          "\u25E1",
          "\u2299",
          "\u25E0"
        ]
      },
      squareCorners: {
        interval: 180,
        frames: [
          "\u25F0",
          "\u25F3",
          "\u25F2",
          "\u25F1"
        ]
      },
      circleQuarters: {
        interval: 120,
        frames: [
          "\u25F4",
          "\u25F7",
          "\u25F6",
          "\u25F5"
        ]
      },
      circleHalves: {
        interval: 50,
        frames: [
          "\u25D0",
          "\u25D3",
          "\u25D1",
          "\u25D2"
        ]
      },
      squish: {
        interval: 100,
        frames: [
          "\u256B",
          "\u256A"
        ]
      },
      toggle: {
        interval: 250,
        frames: [
          "\u22B6",
          "\u22B7"
        ]
      },
      toggle2: {
        interval: 80,
        frames: [
          "\u25AB",
          "\u25AA"
        ]
      },
      toggle3: {
        interval: 120,
        frames: [
          "\u25A1",
          "\u25A0"
        ]
      },
      toggle4: {
        interval: 100,
        frames: [
          "\u25A0",
          "\u25A1",
          "\u25AA",
          "\u25AB"
        ]
      },
      toggle5: {
        interval: 100,
        frames: [
          "\u25AE",
          "\u25AF"
        ]
      },
      toggle6: {
        interval: 300,
        frames: [
          "\u101D",
          "\u1040"
        ]
      },
      toggle7: {
        interval: 80,
        frames: [
          "\u29BE",
          "\u29BF"
        ]
      },
      toggle8: {
        interval: 100,
        frames: [
          "\u25CD",
          "\u25CC"
        ]
      },
      toggle9: {
        interval: 100,
        frames: [
          "\u25C9",
          "\u25CE"
        ]
      },
      toggle10: {
        interval: 100,
        frames: [
          "\u3282",
          "\u3280",
          "\u3281"
        ]
      },
      toggle11: {
        interval: 50,
        frames: [
          "\u29C7",
          "\u29C6"
        ]
      },
      toggle12: {
        interval: 120,
        frames: [
          "\u2617",
          "\u2616"
        ]
      },
      toggle13: {
        interval: 80,
        frames: [
          "=",
          "*",
          "-"
        ]
      },
      arrow: {
        interval: 100,
        frames: [
          "\u2190",
          "\u2196",
          "\u2191",
          "\u2197",
          "\u2192",
          "\u2198",
          "\u2193",
          "\u2199"
        ]
      },
      arrow2: {
        interval: 80,
        frames: [
          "\u2B06\uFE0F ",
          "\u2197\uFE0F ",
          "\u27A1\uFE0F ",
          "\u2198\uFE0F ",
          "\u2B07\uFE0F ",
          "\u2199\uFE0F ",
          "\u2B05\uFE0F ",
          "\u2196\uFE0F "
        ]
      },
      arrow3: {
        interval: 120,
        frames: [
          "\u25B9\u25B9\u25B9\u25B9\u25B9",
          "\u25B8\u25B9\u25B9\u25B9\u25B9",
          "\u25B9\u25B8\u25B9\u25B9\u25B9",
          "\u25B9\u25B9\u25B8\u25B9\u25B9",
          "\u25B9\u25B9\u25B9\u25B8\u25B9",
          "\u25B9\u25B9\u25B9\u25B9\u25B8"
        ]
      },
      bouncingBar: {
        interval: 80,
        frames: [
          "[    ]",
          "[=   ]",
          "[==  ]",
          "[=== ]",
          "[====]",
          "[ ===]",
          "[  ==]",
          "[   =]",
          "[    ]",
          "[   =]",
          "[  ==]",
          "[ ===]",
          "[====]",
          "[=== ]",
          "[==  ]",
          "[=   ]"
        ]
      },
      bouncingBall: {
        interval: 80,
        frames: [
          "( \u25CF    )",
          "(  \u25CF   )",
          "(   \u25CF  )",
          "(    \u25CF )",
          "(     \u25CF)",
          "(    \u25CF )",
          "(   \u25CF  )",
          "(  \u25CF   )",
          "( \u25CF    )",
          "(\u25CF     )"
        ]
      },
      smiley: {
        interval: 200,
        frames: [
          "\u{1F604} ",
          "\u{1F61D} "
        ]
      },
      monkey: {
        interval: 300,
        frames: [
          "\u{1F648} ",
          "\u{1F648} ",
          "\u{1F649} ",
          "\u{1F64A} "
        ]
      },
      hearts: {
        interval: 100,
        frames: [
          "\u{1F49B} ",
          "\u{1F499} ",
          "\u{1F49C} ",
          "\u{1F49A} ",
          "\u2764\uFE0F "
        ]
      },
      clock: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F550} ",
          "\u{1F551} ",
          "\u{1F552} ",
          "\u{1F553} ",
          "\u{1F554} ",
          "\u{1F555} ",
          "\u{1F556} ",
          "\u{1F557} ",
          "\u{1F558} ",
          "\u{1F559} ",
          "\u{1F55A} "
        ]
      },
      earth: {
        interval: 180,
        frames: [
          "\u{1F30D} ",
          "\u{1F30E} ",
          "\u{1F30F} "
        ]
      },
      material: {
        interval: 17,
        frames: [
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581"
        ]
      },
      moon: {
        interval: 80,
        frames: [
          "\u{1F311} ",
          "\u{1F312} ",
          "\u{1F313} ",
          "\u{1F314} ",
          "\u{1F315} ",
          "\u{1F316} ",
          "\u{1F317} ",
          "\u{1F318} "
        ]
      },
      runner: {
        interval: 140,
        frames: [
          "\u{1F6B6} ",
          "\u{1F3C3} "
        ]
      },
      pong: {
        interval: 80,
        frames: [
          "\u2590\u2802       \u258C",
          "\u2590\u2808       \u258C",
          "\u2590 \u2802      \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590  \u2840     \u258C",
          "\u2590  \u2820     \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590   \u2808    \u258C",
          "\u2590    \u2802   \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590     \u2840  \u258C",
          "\u2590     \u2820  \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590      \u2808 \u258C",
          "\u2590       \u2802\u258C",
          "\u2590       \u2820\u258C",
          "\u2590       \u2840\u258C",
          "\u2590      \u2820 \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590     \u2808  \u258C",
          "\u2590     \u2802  \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590    \u2840   \u258C",
          "\u2590   \u2820    \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590  \u2808     \u258C",
          "\u2590  \u2802     \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590 \u2840      \u258C",
          "\u2590\u2820       \u258C"
        ]
      },
      shark: {
        interval: 120,
        frames: [
          "\u2590|\\____________\u258C",
          "\u2590_|\\___________\u258C",
          "\u2590__|\\__________\u258C",
          "\u2590___|\\_________\u258C",
          "\u2590____|\\________\u258C",
          "\u2590_____|\\_______\u258C",
          "\u2590______|\\______\u258C",
          "\u2590_______|\\_____\u258C",
          "\u2590________|\\____\u258C",
          "\u2590_________|\\___\u258C",
          "\u2590__________|\\__\u258C",
          "\u2590___________|\\_\u258C",
          "\u2590____________|\\\u258C",
          "\u2590____________/|\u258C",
          "\u2590___________/|_\u258C",
          "\u2590__________/|__\u258C",
          "\u2590_________/|___\u258C",
          "\u2590________/|____\u258C",
          "\u2590_______/|_____\u258C",
          "\u2590______/|______\u258C",
          "\u2590_____/|_______\u258C",
          "\u2590____/|________\u258C",
          "\u2590___/|_________\u258C",
          "\u2590__/|__________\u258C",
          "\u2590_/|___________\u258C",
          "\u2590/|____________\u258C"
        ]
      },
      dqpb: {
        interval: 100,
        frames: [
          "d",
          "q",
          "p",
          "b"
        ]
      },
      weather: {
        interval: 100,
        frames: [
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u{1F324} ",
          "\u26C5\uFE0F ",
          "\u{1F325} ",
          "\u2601\uFE0F ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u26C8 ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u2601\uFE0F ",
          "\u{1F325} ",
          "\u26C5\uFE0F ",
          "\u{1F324} ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F "
        ]
      },
      christmas: {
        interval: 400,
        frames: [
          "\u{1F332}",
          "\u{1F384}"
        ]
      },
      grenade: {
        interval: 80,
        frames: [
          "\u060C  ",
          "\u2032  ",
          " \xB4 ",
          " \u203E ",
          "  \u2E0C",
          "  \u2E0A",
          "  |",
          "  \u204E",
          "  \u2055",
          " \u0DF4 ",
          "  \u2053",
          "   ",
          "   ",
          "   "
        ]
      },
      point: {
        interval: 125,
        frames: [
          "\u2219\u2219\u2219",
          "\u25CF\u2219\u2219",
          "\u2219\u25CF\u2219",
          "\u2219\u2219\u25CF",
          "\u2219\u2219\u2219"
        ]
      },
      layer: {
        interval: 150,
        frames: [
          "-",
          "=",
          "\u2261"
        ]
      },
      betaWave: {
        interval: 80,
        frames: [
          "\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1"
        ]
      },
      fingerDance: {
        interval: 160,
        frames: [
          "\u{1F918} ",
          "\u{1F91F} ",
          "\u{1F596} ",
          "\u270B ",
          "\u{1F91A} ",
          "\u{1F446} "
        ]
      },
      fistBump: {
        interval: 80,
        frames: [
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ",
          "\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ",
          "\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ",
          "\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 "
        ]
      },
      soccerHeader: {
        interval: 80,
        frames: [
          " \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} "
        ]
      },
      mindblown: {
        interval: 160,
        frames: [
          "\u{1F610} ",
          "\u{1F610} ",
          "\u{1F62E} ",
          "\u{1F62E} ",
          "\u{1F626} ",
          "\u{1F626} ",
          "\u{1F627} ",
          "\u{1F627} ",
          "\u{1F92F} ",
          "\u{1F4A5} ",
          "\u2728 ",
          "\u3000 ",
          "\u3000 ",
          "\u3000 "
        ]
      },
      speaker: {
        interval: 160,
        frames: [
          "\u{1F508} ",
          "\u{1F509} ",
          "\u{1F50A} ",
          "\u{1F509} "
        ]
      },
      orangePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} "
        ]
      },
      bluePulse: {
        interval: 100,
        frames: [
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} ",
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      timeTravel: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F55A} ",
          "\u{1F559} ",
          "\u{1F558} ",
          "\u{1F557} ",
          "\u{1F556} ",
          "\u{1F555} ",
          "\u{1F554} ",
          "\u{1F553} ",
          "\u{1F552} ",
          "\u{1F551} ",
          "\u{1F550} "
        ]
      },
      aesthetic: {
        interval: 80,
        frames: [
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0",
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1"
        ]
      },
      dwarfFortress: {
        interval: 80,
        frames: [
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A \u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A \u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
          "    \u263A \u2588\xA3\xA3\xA3  ",
          "     \u263A\u2588\xA3\xA3\xA3  ",
          "     \u263A\u2588\xA3\xA3\xA3  ",
          "     \u263A\u2593\xA3\xA3\xA3  ",
          "     \u263A\u2593\xA3\xA3\xA3  ",
          "     \u263A\u2592\xA3\xA3\xA3  ",
          "     \u263A\u2592\xA3\xA3\xA3  ",
          "     \u263A\u2591\xA3\xA3\xA3  ",
          "     \u263A\u2591\xA3\xA3\xA3  ",
          "     \u263A \xA3\xA3\xA3  ",
          "      \u263A\xA3\xA3\xA3  ",
          "      \u263A\xA3\xA3\xA3  ",
          "      \u263A\u2593\xA3\xA3  ",
          "      \u263A\u2593\xA3\xA3  ",
          "      \u263A\u2592\xA3\xA3  ",
          "      \u263A\u2592\xA3\xA3  ",
          "      \u263A\u2591\xA3\xA3  ",
          "      \u263A\u2591\xA3\xA3  ",
          "      \u263A \xA3\xA3  ",
          "       \u263A\xA3\xA3  ",
          "       \u263A\xA3\xA3  ",
          "       \u263A\u2593\xA3  ",
          "       \u263A\u2593\xA3  ",
          "       \u263A\u2592\xA3  ",
          "       \u263A\u2592\xA3  ",
          "       \u263A\u2591\xA3  ",
          "       \u263A\u2591\xA3  ",
          "       \u263A \xA3  ",
          "        \u263A\xA3  ",
          "        \u263A\xA3  ",
          "        \u263A\u2593  ",
          "        \u263A\u2593  ",
          "        \u263A\u2592  ",
          "        \u263A\u2592  ",
          "        \u263A\u2591  ",
          "        \u263A\u2591  ",
          "        \u263A   ",
          "        \u263A  &",
          "        \u263A \u263C&",
          "       \u263A \u263C &",
          "       \u263A\u263C  &",
          "      \u263A\u263C  & ",
          "      \u203C   & ",
          "     \u263A   &  ",
          "    \u203C    &  ",
          "   \u263A    &   ",
          "  \u203C     &   ",
          " \u263A     &    ",
          "\u203C      &    ",
          "      &     ",
          "      &     ",
          "     &   \u2591  ",
          "     &   \u2592  ",
          "    &    \u2593  ",
          "    &    \xA3  ",
          "   &    \u2591\xA3  ",
          "   &    \u2592\xA3  ",
          "  &     \u2593\xA3  ",
          "  &     \xA3\xA3  ",
          " &     \u2591\xA3\xA3  ",
          " &     \u2592\xA3\xA3  ",
          "&      \u2593\xA3\xA3  ",
          "&      \xA3\xA3\xA3  ",
          "      \u2591\xA3\xA3\xA3  ",
          "      \u2592\xA3\xA3\xA3  ",
          "      \u2593\xA3\xA3\xA3  ",
          "      \u2588\xA3\xA3\xA3  ",
          "     \u2591\u2588\xA3\xA3\xA3  ",
          "     \u2592\u2588\xA3\xA3\xA3  ",
          "     \u2593\u2588\xA3\xA3\xA3  ",
          "     \u2588\u2588\xA3\xA3\xA3  ",
          "    \u2591\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2592\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2593\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  "
        ]
      }
    };
  }
});

// node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  "node_modules/cli-spinners/index.js"(exports2, module2) {
    "use strict";
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, "random", {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      }
    });
    module2.exports = spinners;
  }
});

// node_modules/log-symbols/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/log-symbols/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/log-symbols/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/log-symbols/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r3, g, b);
      const max = Math.max(r3, g, b);
      const delta = max - min;
      let h3;
      let s3;
      if (max === min) {
        h3 = 0;
      } else if (r3 === max) {
        h3 = (g - b) / delta;
      } else if (g === max) {
        h3 = 2 + (b - r3) / delta;
      } else if (b === max) {
        h3 = 4 + (r3 - g) / delta;
      }
      h3 = Math.min(h3 * 60, 360);
      if (h3 < 0) {
        h3 += 360;
      }
      const l3 = (min + max) / 2;
      if (max === min) {
        s3 = 0;
      } else if (l3 <= 0.5) {
        s3 = delta / (max + min);
      } else {
        s3 = delta / (2 - max - min);
      }
      return [h3, s3 * 100, l3 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h3;
      let s3;
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v3 = Math.max(r3, g, b);
      const diff = v3 - Math.min(r3, g, b);
      const diffc = function(c3) {
        return (v3 - c3) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h3 = 0;
        s3 = 0;
      } else {
        s3 = diff / v3;
        rdif = diffc(r3);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r3 === v3) {
          h3 = bdif - gdif;
        } else if (g === v3) {
          h3 = 1 / 3 + rdif - bdif;
        } else if (b === v3) {
          h3 = 2 / 3 + gdif - rdif;
        }
        if (h3 < 0) {
          h3 += 1;
        } else if (h3 > 1) {
          h3 -= 1;
        }
      }
      return [
        h3 * 360,
        s3 * 100,
        v3 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r3 = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h3 = convert.rgb.hsl(rgb)[0];
      const w4 = 1 / 255 * Math.min(r3, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r3, Math.max(g, b));
      return [h3, w4 * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k4 = Math.min(1 - r3, 1 - g, 1 - b);
      const c3 = (1 - r3 - k4) / (1 - k4) || 0;
      const m3 = (1 - g - k4) / (1 - k4) || 0;
      const y3 = (1 - b - k4) / (1 - k4) || 0;
      return [c3 * 100, m3 * 100, y3 * 100, k4 * 100];
    };
    function comparativeDistance(x3, y3) {
      return (x3[0] - y3[0]) ** 2 + (x3[1] - y3[1]) ** 2 + (x3[2] - y3[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r3 = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r3 = r3 > 0.04045 ? ((r3 + 0.055) / 1.055) ** 2.4 : r3 / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x3 = r3 * 0.4124 + g * 0.3576 + b * 0.1805;
      const y3 = r3 * 0.2126 + g * 0.7152 + b * 0.0722;
      const z4 = r3 * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x3 * 100, y3 * 100, z4 * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x3 = xyz[0];
      let y3 = xyz[1];
      let z4 = xyz[2];
      x3 /= 95.047;
      y3 /= 100;
      z4 /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z4 = z4 > 8856e-6 ? z4 ** (1 / 3) : 7.787 * z4 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x3 - y3);
      const b = 200 * (y3 - z4);
      return [l3, a3, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h3 = hsl[0] / 360;
      const s3 = hsl[1] / 100;
      const l3 = hsl[2] / 100;
      let t22;
      let t3;
      let val;
      if (s3 === 0) {
        val = l3 * 255;
        return [val, val, val];
      }
      if (l3 < 0.5) {
        t22 = l3 * (1 + s3);
      } else {
        t22 = l3 + s3 - l3 * s3;
      }
      const t1 = 2 * l3 - t22;
      const rgb = [0, 0, 0];
      for (let i4 = 0; i4 < 3; i4++) {
        t3 = h3 + 1 / 3 * -(i4 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t22 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t22;
        } else if (3 * t3 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i4] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h3 = hsl[0];
      let s3 = hsl[1] / 100;
      let l3 = hsl[2] / 100;
      let smin = s3;
      const lmin = Math.max(l3, 0.01);
      l3 *= 2;
      s3 *= l3 <= 1 ? l3 : 2 - l3;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v3 = (l3 + s3) / 2;
      const sv = l3 === 0 ? 2 * smin / (lmin + smin) : 2 * s3 / (l3 + s3);
      return [h3, sv * 100, v3 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h3 = hsv[0] / 60;
      const s3 = hsv[1] / 100;
      let v3 = hsv[2] / 100;
      const hi = Math.floor(h3) % 6;
      const f3 = h3 - Math.floor(h3);
      const p2 = 255 * v3 * (1 - s3);
      const q2 = 255 * v3 * (1 - s3 * f3);
      const t3 = 255 * v3 * (1 - s3 * (1 - f3));
      v3 *= 255;
      switch (hi) {
        case 0:
          return [v3, t3, p2];
        case 1:
          return [q2, v3, p2];
        case 2:
          return [p2, v3, t3];
        case 3:
          return [p2, q2, v3];
        case 4:
          return [t3, p2, v3];
        case 5:
          return [v3, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h3 = hsv[0];
      const s3 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const vmin = Math.max(v3, 0.01);
      let sl;
      let l3;
      l3 = (2 - s3) * v3;
      const lmin = (2 - s3) * vmin;
      sl = s3 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l3 /= 2;
      return [h3, sl * 100, l3 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h3 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f3;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i4 = Math.floor(6 * h3);
      const v3 = 1 - bl;
      f3 = 6 * h3 - i4;
      if ((i4 & 1) !== 0) {
        f3 = 1 - f3;
      }
      const n2 = wh + f3 * (v3 - wh);
      let r3;
      let g;
      let b;
      switch (i4) {
        default:
        case 6:
        case 0:
          r3 = v3;
          g = n2;
          b = wh;
          break;
        case 1:
          r3 = n2;
          g = v3;
          b = wh;
          break;
        case 2:
          r3 = wh;
          g = v3;
          b = n2;
          break;
        case 3:
          r3 = wh;
          g = n2;
          b = v3;
          break;
        case 4:
          r3 = n2;
          g = wh;
          b = v3;
          break;
        case 5:
          r3 = v3;
          g = wh;
          b = n2;
          break;
      }
      return [r3 * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c3 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k4 = cmyk[3] / 100;
      const r3 = 1 - Math.min(1, c3 * (1 - k4) + k4);
      const g = 1 - Math.min(1, m3 * (1 - k4) + k4);
      const b = 1 - Math.min(1, y3 * (1 - k4) + k4);
      return [r3 * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x3 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z4 = xyz[2] / 100;
      let r3;
      let g;
      let b;
      r3 = x3 * 3.2406 + y3 * -1.5372 + z4 * -0.4986;
      g = x3 * -0.9689 + y3 * 1.8758 + z4 * 0.0415;
      b = x3 * 0.0557 + y3 * -0.204 + z4 * 1.057;
      r3 = r3 > 31308e-7 ? 1.055 * r3 ** (1 / 2.4) - 0.055 : r3 * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r3 = Math.min(Math.max(0, r3), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r3 * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x3 = xyz[0];
      let y3 = xyz[1];
      let z4 = xyz[2];
      x3 /= 95.047;
      y3 /= 100;
      z4 /= 108.883;
      x3 = x3 > 8856e-6 ? x3 ** (1 / 3) : 7.787 * x3 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z4 = z4 > 8856e-6 ? z4 ** (1 / 3) : 7.787 * z4 + 16 / 116;
      const l3 = 116 * y3 - 16;
      const a3 = 500 * (x3 - y3);
      const b = 200 * (y3 - z4);
      return [l3, a3, b];
    };
    convert.lab.xyz = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b = lab[2];
      let x3;
      let y3;
      let z4;
      y3 = (l3 + 16) / 116;
      x3 = a3 / 500 + y3;
      z4 = y3 - b / 200;
      const y22 = y3 ** 3;
      const x22 = x3 ** 3;
      const z22 = z4 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x3 = x22 > 8856e-6 ? x22 : (x3 - 16 / 116) / 7.787;
      z4 = z22 > 8856e-6 ? z22 : (z4 - 16 / 116) / 7.787;
      x3 *= 95.047;
      y3 *= 100;
      z4 *= 108.883;
      return [x3, y3, z4];
    };
    convert.lab.lch = function(lab) {
      const l3 = lab[0];
      const a3 = lab[1];
      const b = lab[2];
      let h3;
      const hr = Math.atan2(b, a3);
      h3 = hr * 360 / 2 / Math.PI;
      if (h3 < 0) {
        h3 += 360;
      }
      const c3 = Math.sqrt(a3 * a3 + b * b);
      return [l3, c3, h3];
    };
    convert.lch.lab = function(lch) {
      const l3 = lch[0];
      const c3 = lch[1];
      const h3 = lch[2];
      const hr = h3 / 360 * 2 * Math.PI;
      const a3 = c3 * Math.cos(hr);
      const b = c3 * Math.sin(hr);
      return [l3, a3, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r3, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r3 / 255));
      if (value === 2) {
        ansi2 += 60;
      }
      return ansi2;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r3 = args[0];
      const g = args[1];
      const b = args[2];
      if (r3 === g && g === b) {
        if (r3 < 8) {
          return 16;
        }
        if (r3 > 248) {
          return 231;
        }
        return Math.round((r3 - 8) / 247 * 24) + 232;
      }
      const ansi2 = 16 + 36 * Math.round(r3 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi2;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r3 = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r3, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c3 = (args - 232) * 10 + 8;
        return [c3, c3, c3];
      }
      args -= 16;
      let rem;
      const r3 = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r3, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r3 = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r3, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r3 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r3, g), b);
      const min = Math.min(Math.min(r3, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r3) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r3) / chroma;
      } else {
        hue = 4 + (r3 - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s3 = hsl[1] / 100;
      const l3 = hsl[2] / 100;
      const c3 = l3 < 0.5 ? 2 * s3 * l3 : 2 * s3 * (1 - l3);
      let f3 = 0;
      if (c3 < 1) {
        f3 = (l3 - 0.5 * c3) / (1 - c3);
      }
      return [hsl[0], c3 * 100, f3 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s3 = hsv[1] / 100;
      const v3 = hsv[2] / 100;
      const c3 = s3 * v3;
      let f3 = 0;
      if (c3 < 1) {
        f3 = (v3 - c3) / (1 - c3);
      }
      return [hsv[0], c3 * 100, f3 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h3 = hcg[0] / 360;
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c3 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h3 % 1 * 6;
      const v3 = hi % 1;
      const w4 = 1 - v3;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v3;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w4;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v3;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w4;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v3;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w4;
      }
      mg = (1 - c3) * g;
      return [
        (c3 * pure[0] + mg) * 255,
        (c3 * pure[1] + mg) * 255,
        (c3 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c3 + g * (1 - c3);
      let f3 = 0;
      if (v3 > 0) {
        f3 = c3 / v3;
      }
      return [hcg[0], f3 * 100, v3 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l3 = g * (1 - c3) + 0.5 * c3;
      let s3 = 0;
      if (l3 > 0 && l3 < 0.5) {
        s3 = c3 / (2 * l3);
      } else if (l3 >= 0.5 && l3 < 1) {
        s3 = c3 / (2 * (1 - l3));
      }
      return [hcg[0], s3 * 100, l3 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c3 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v3 = c3 + g * (1 - c3);
      return [hcg[0], (v3 - c3) * 100, (1 - v3) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w4 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v3 = 1 - b;
      const c3 = v3 - w4;
      let g = 0;
      if (c3 < 1) {
        g = (v3 - c3) / (1 - c3);
      }
      return [hwb[0], c3 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/log-symbols/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/log-symbols/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i4 = 0; i4 < len; i4++) {
        graph[models[i4]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i4 = 0; i4 < len; i4++) {
          const adjacent = adjacents[i4];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i4 = 0; i4 < len; i4++) {
        const toModel = models[i4];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/log-symbols/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/log-symbols/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i4 = 0; i4 < len; i4++) {
            result[i4] = Math.round(result[i4]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/log-symbols/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/log-symbols/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n2) => n2;
    var rgb2rgb = (r3, g, b) => [r3, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap2(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap2(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/log-symbols/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/log-symbols/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/log-symbols/node_modules/chalk/source/util.js
var require_util3 = __commonJS({
  "node_modules/log-symbols/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/log-symbols/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS({
  "node_modules/log-symbols/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c3) {
      const u4 = c3[0] === "u";
      const bracket = c3[1] === "{";
      if (u4 && !bracket && c3.length === 5 || c3[0] === "x" && c3.length === 3) {
        return String.fromCharCode(parseInt(c3.slice(1), 16));
      }
      if (u4 && bracket) {
        return String.fromCodePoint(parseInt(c3.slice(2, -1), 16));
      }
      return ESCAPES.get(c3) || c3;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m3, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/log-symbols/node_modules/chalk/source/index.js
var require_source2 = __commonJS({
  "node_modules/log-symbols/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles2();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color2();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util3();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i4 = 1; i4 < firstString.length; i4++) {
        parts.push(
          String(arguments_[i4 - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i4])
        );
      }
      if (template === void 0) {
        template = require_templates2();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/is-unicode-supported/index.js
var require_is_unicode_supported = __commonJS({
  "node_modules/is-unicode-supported/index.js"(exports2, module2) {
    "use strict";
    module2.exports = () => {
      if (process.platform !== "win32") {
        return true;
      }
      return Boolean(process.env.CI) || Boolean(process.env.WT_SESSION) || // Windows Terminal
      process.env.TERM_PROGRAM === "vscode" || process.env.TERM === "xterm-256color" || process.env.TERM === "alacritty";
    };
  }
});

// node_modules/log-symbols/index.js
var require_log_symbols = __commonJS({
  "node_modules/log-symbols/index.js"(exports2, module2) {
    "use strict";
    var chalk = require_source2();
    var isUnicodeSupported = require_is_unicode_supported();
    var main = {
      info: chalk.blue("\u2139"),
      success: chalk.green("\u2714"),
      warning: chalk.yellow("\u26A0"),
      error: chalk.red("\u2716")
    };
    var fallback = {
      info: chalk.blue("i"),
      success: chalk.green("\u221A"),
      warning: chalk.yellow("\u203C"),
      error: chalk.red("\xD7")
    };
    module2.exports = isUnicodeSupported() ? main : fallback;
  }
});

// node_modules/ora/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ora/node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/ora/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/ora/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports2, module2) {
    var clone = function() {
      "use strict";
      function clone2(parent, circular, depth, prototype) {
        var filter;
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          filter = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 == 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i4 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i4);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i4] = _clone(parent2[i4], depth2 - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c3 = function() {
        };
        c3.prototype = parent;
        return new c3();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      ;
      clone2.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      ;
      clone2.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      ;
      clone2.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      ;
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      ;
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// node_modules/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/defaults/index.js"(exports2, module2) {
    var clone = require_clone();
    module2.exports = function(options, defaults) {
      options = options || {};
      Object.keys(defaults).forEach(function(key) {
        if (typeof options[key] === "undefined") {
          options[key] = clone(defaults[key]);
        }
      });
      return options;
    };
  }
});

// node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  "node_modules/wcwidth/combining.js"(exports2, module2) {
    module2.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999]
    ];
  }
});

// node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  "node_modules/wcwidth/index.js"(exports2, module2) {
    "use strict";
    var defaults = require_defaults();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0
    };
    module2.exports = function wcwidth2(str) {
      return wcswidth(str, DEFAULTS);
    };
    module2.exports.config = function(opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth2(str) {
        return wcswidth(str, opts);
      };
    };
    function wcswidth(str, opts) {
      if (typeof str !== "string") return wcwidth(str, opts);
      var s3 = 0;
      for (var i4 = 0; i4 < str.length; i4++) {
        var n2 = wcwidth(str.charCodeAt(i4), opts);
        if (n2 < 0) return -1;
        s3 += n2;
      }
      return s3;
    }
    function wcwidth(ucs, opts) {
      if (ucs === 0) return opts.nul;
      if (ucs < 32 || ucs >= 127 && ucs < 160) return opts.control;
      if (bisearch(ucs)) return 0;
      return 1 + (ucs >= 4352 && (ucs <= 4447 || // Hangul Jamo init. consonants
      ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || // CJK ... Yi
      ucs >= 44032 && ucs <= 55203 || // Hangul Syllables
      ucs >= 63744 && ucs <= 64255 || // CJK Compatibility Ideographs
      ucs >= 65040 && ucs <= 65049 || // Vertical forms
      ucs >= 65072 && ucs <= 65135 || // CJK Compatibility Forms
      ucs >= 65280 && ucs <= 65376 || // Fullwidth Forms
      ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
    }
    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1]) return false;
      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1]) min = mid + 1;
        else if (ucs < combining[mid][0]) max = mid - 1;
        else return true;
      }
      return false;
    }
  }
});

// node_modules/is-interactive/index.js
var require_is_interactive = __commonJS({
  "node_modules/is-interactive/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ stream = process.stdout } = {}) => {
      return Boolean(
        stream && stream.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env)
      );
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = null != arguments[i4] ? arguments[i4] : {};
        i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i4 = 0; i4 < props.length; i4++) {
        var descriptor = props[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect2 = _require2.inspect;
    var custom = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v3) {
          var entry = {
            data: v3,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v3) {
          var entry = {
            data: v3,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s3) {
          if (this.length === 0) return "";
          var p2 = this.head;
          var ret = "" + p2.data;
          while (p2 = p2.next) ret += s3 + p2.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n2) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n2 >>> 0);
          var p2 = this.head;
          var i4 = 0;
          while (p2) {
            copyBuffer(p2.data, ret, i4);
            i4 += p2.data.length;
            p2 = p2.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n2, hasStrings) {
          var ret;
          if (n2 < this.head.data.length) {
            ret = this.head.data.slice(0, n2);
            this.head.data = this.head.data.slice(n2);
          } else if (n2 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n2) {
          var p2 = this.head;
          var c3 = 1;
          var ret = p2.data;
          n2 -= ret.length;
          while (p2 = p2.next) {
            var str = p2.data;
            var nb = n2 > str.length ? str.length : n2;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n2);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === str.length) {
                ++c3;
                if (p2.next) this.head = p2.next;
                else this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = str.slice(nb);
              }
              break;
            }
            ++c3;
          }
          this.length -= c3;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n2) {
          var ret = Buffer2.allocUnsafe(n2);
          var p2 = this.head;
          var c3 = 1;
          p2.data.copy(ret);
          n2 -= p2.data.length;
          while (p2 = p2.next) {
            var buf = p2.data;
            var nb = n2 > buf.length ? buf.length : n2;
            buf.copy(ret, ret.length - n2, 0, nb);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === buf.length) {
                ++c3;
                if (p2.next) this.head = p2.next;
                else this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = buf.slice(nb);
              }
              break;
            }
            ++c3;
          }
          this.length -= c3;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_3, options) {
          return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/bl/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i4) => String(i4));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e3) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l3 = state.bufferedRequestCount;
        var buffer = new Array(l3);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys2(Writable.prototype);
      for (v3 = 0; v3 < keys.length; v3++) {
        method = keys[v3];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v3;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r3;
      var i4;
      if (this.lastNeed) {
        r3 = this.fillLast(buf);
        if (r3 === void 0) return "";
        i4 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i4 = 0;
      }
      if (i4 < buf.length) return r3 ? r3 + this.text(buf, i4) : this.text(buf, i4);
      return r3 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j3 = buf.length - 1;
      if (j3 < i4) return 0;
      var nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j3 < i4 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j3 < i4 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p2) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed;
      var r3 = utf8CheckExtraBytes(this, buf, p2);
      if (r3 !== void 0) return r3;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p2, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p2, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed) return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r3 + "\uFFFD";
      return r3;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r3 = buf.toString("utf16le", i4);
        if (r3) {
          var c3 = r3.charCodeAt(r3.length - 1);
          if (c3 >= 55296 && c3 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r3.slice(0, -1);
          }
        }
        return r3;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r3 + this.lastChar.toString("utf16le", 0, end);
      }
      return r3;
    }
    function base64Text(buf, i4) {
      var n2 = (buf.length - i4) % 3;
      if (n2 === 0) return buf.toString("base64", i4);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i4, buf.length - n2);
    }
    function base64End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r3;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve5 = iter[kLastResolve];
      if (resolve5 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve5(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve5, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve5(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve5, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve5, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve5(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve5, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve5(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve5, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve5(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve5;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve5 = iterator[kLastResolve];
        if (resolve5 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve5(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve5(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve5, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = null != arguments[i4] ? arguments[i4] : {};
        i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug4;
    if (debugUtil && debugUtil.debuglog) {
      debug4 = debugUtil.debuglog("stream");
    } else {
      debug4 = function debug5() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug4("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p2 = this._readableState.buffer.head;
      var content = "";
      while (p2 !== null) {
        content += decoder.write(p2.data);
        p2 = p2.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM) {
        n2 = MAX_HWM;
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n2 !== n2) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state.length) return n2;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n2) {
      debug4("read", n2);
      n2 = parseInt(n2, 10);
      var state = this._readableState;
      var nOrig = n2;
      if (n2 !== 0) state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug4("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug4("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug4("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug4("reading or ended", doRead);
      } else if (doRead) {
        debug4("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n2 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n2 > 0) ret = fromList(n2, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n2 = 0;
      } else {
        state.length -= n2;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n2 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug4("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug4("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug4("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug4("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug4("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug4("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug4("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug4("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug4("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug4("ondata");
        var ret = dest.write(chunk);
        debug4("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug4("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug4("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug4("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug4("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug4("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug4("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i4 = 0; i4 < len; i4++) dests[i4].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug4("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug4("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug4("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug4("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug4("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug4("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug4("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug4("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug4("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      }
      this._read = function(n3) {
        debug4("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n2, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n2, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug4("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug4("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x3) {
      for (var i4 = 0, l3 = xs.length; i4 < l3; i4++) {
        if (xs[i4] === x3) return i4;
      }
      return -1;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n2) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/bl/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/bl/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i4 = 0; i4 < this._bufs.length; i4++) {
        const _t = tot + this._bufs[i4].length;
        if (offset < _t || i4 === this._bufs.length - 1) {
          return [i4, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i4 = 0; i4 < bufferId; i4++) {
        offset += this._bufs[i4].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i4 = 0; i4 < this._bufs.length; i4++) {
          this._bufs[i4].copy(dst, bufoff);
          bufoff += this._bufs[i4].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i4 = off[0]; i4 < this._bufs.length; i4++) {
        const l3 = this._bufs[i4].length - start;
        if (bytes > l3) {
          this._bufs[i4].copy(dst, bufoff, start);
          bufoff += l3;
        } else {
          this._bufs[i4].copy(dst, bufoff, start, start + bytes);
          bufoff += l3;
          break;
        }
        bytes -= l3;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff) return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i4 = 0; i4 < this._bufs.length; i4++) {
        copy.append(this._bufs[i4]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i4 = 0; i4 < buf.length; i4++) {
          this.append(buf[i4]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i4 = 0; i4 < buf._bufs.length; i4++) {
          this.append(buf._bufs[i4]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m3 in methods) {
        (function(m4) {
          if (methods[m4] === null) {
            BufferList.prototype[m4] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m4](0, byteLength);
            };
          } else {
            BufferList.prototype[m4] = function(offset = 0) {
              return this.slice(offset, offset + methods[m4])[m4](0);
            };
          }
        })(m3);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/ora/index.js
var require_ora = __commonJS({
  "node_modules/ora/index.js"(exports2, module2) {
    "use strict";
    var readline = require("readline");
    var chalk = require_source();
    var cliCursor = require_cli_cursor();
    var cliSpinners = require_cli_spinners();
    var logSymbols = require_log_symbols();
    var stripAnsi2 = require_strip_ansi();
    var wcwidth = require_wcwidth();
    var isInteractive = require_is_interactive();
    var isUnicodeSupported = require_is_unicode_supported();
    var { BufferListStream } = require_bl();
    var TEXT = Symbol("text");
    var PREFIX_TEXT = Symbol("prefixText");
    var ASCII_ETX_CODE = 3;
    var StdinDiscarder = class {
      constructor() {
        this.requests = 0;
        this.mutedStream = new BufferListStream();
        this.mutedStream.pipe(process.stdout);
        const self2 = this;
        this.ourEmit = function(event, data, ...args) {
          const { stdin } = process;
          if (self2.requests > 0 || stdin.emit === self2.ourEmit) {
            if (event === "keypress") {
              return;
            }
            if (event === "data" && data.includes(ASCII_ETX_CODE)) {
              process.emit("SIGINT");
            }
            Reflect.apply(self2.oldEmit, this, [event, data, ...args]);
          } else {
            Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
          }
        };
      }
      start() {
        this.requests++;
        if (this.requests === 1) {
          this.realStart();
        }
      }
      stop() {
        if (this.requests <= 0) {
          throw new Error("`stop` called more times than `start`");
        }
        this.requests--;
        if (this.requests === 0) {
          this.realStop();
        }
      }
      realStart() {
        if (process.platform === "win32") {
          return;
        }
        this.rl = readline.createInterface({
          input: process.stdin,
          output: this.mutedStream
        });
        this.rl.on("SIGINT", () => {
          if (process.listenerCount("SIGINT") === 0) {
            process.emit("SIGINT");
          } else {
            this.rl.close();
            process.kill(process.pid, "SIGINT");
          }
        });
      }
      realStop() {
        if (process.platform === "win32") {
          return;
        }
        this.rl.close();
        this.rl = void 0;
      }
    };
    var stdinDiscarder;
    var Ora = class {
      constructor(options) {
        if (!stdinDiscarder) {
          stdinDiscarder = new StdinDiscarder();
        }
        if (typeof options === "string") {
          options = {
            text: options
          };
        }
        this.options = {
          text: "",
          color: "cyan",
          stream: process.stderr,
          discardStdin: true,
          ...options
        };
        this.spinner = this.options.spinner;
        this.color = this.options.color;
        this.hideCursor = this.options.hideCursor !== false;
        this.interval = this.options.interval || this.spinner.interval || 100;
        this.stream = this.options.stream;
        this.id = void 0;
        this.isEnabled = typeof this.options.isEnabled === "boolean" ? this.options.isEnabled : isInteractive({ stream: this.stream });
        this.isSilent = typeof this.options.isSilent === "boolean" ? this.options.isSilent : false;
        this.text = this.options.text;
        this.prefixText = this.options.prefixText;
        this.linesToClear = 0;
        this.indent = this.options.indent;
        this.discardStdin = this.options.discardStdin;
        this.isDiscardingStdin = false;
      }
      get indent() {
        return this._indent;
      }
      set indent(indent = 0) {
        if (!(indent >= 0 && Number.isInteger(indent))) {
          throw new Error("The `indent` option must be an integer from 0 and up");
        }
        this._indent = indent;
      }
      _updateInterval(interval) {
        if (interval !== void 0) {
          this.interval = interval;
        }
      }
      get spinner() {
        return this._spinner;
      }
      set spinner(spinner) {
        this.frameIndex = 0;
        if (typeof spinner === "object") {
          if (spinner.frames === void 0) {
            throw new Error("The given spinner must have a `frames` property");
          }
          this._spinner = spinner;
        } else if (!isUnicodeSupported()) {
          this._spinner = cliSpinners.line;
        } else if (spinner === void 0) {
          this._spinner = cliSpinners.dots;
        } else if (spinner !== "default" && cliSpinners[spinner]) {
          this._spinner = cliSpinners[spinner];
        } else {
          throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
        }
        this._updateInterval(this._spinner.interval);
      }
      get text() {
        return this[TEXT];
      }
      set text(value) {
        this[TEXT] = value;
        this.updateLineCount();
      }
      get prefixText() {
        return this[PREFIX_TEXT];
      }
      set prefixText(value) {
        this[PREFIX_TEXT] = value;
        this.updateLineCount();
      }
      get isSpinning() {
        return this.id !== void 0;
      }
      getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = " ") {
        if (typeof prefixText === "string") {
          return prefixText + postfix;
        }
        if (typeof prefixText === "function") {
          return prefixText() + postfix;
        }
        return "";
      }
      updateLineCount() {
        const columns = this.stream.columns || 80;
        const fullPrefixText = this.getFullPrefixText(this.prefixText, "-");
        this.lineCount = 0;
        for (const line of stripAnsi2(fullPrefixText + "--" + this[TEXT]).split("\n")) {
          this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
        }
      }
      get isEnabled() {
        return this._isEnabled && !this.isSilent;
      }
      set isEnabled(value) {
        if (typeof value !== "boolean") {
          throw new TypeError("The `isEnabled` option must be a boolean");
        }
        this._isEnabled = value;
      }
      get isSilent() {
        return this._isSilent;
      }
      set isSilent(value) {
        if (typeof value !== "boolean") {
          throw new TypeError("The `isSilent` option must be a boolean");
        }
        this._isSilent = value;
      }
      frame() {
        const { frames } = this.spinner;
        let frame = frames[this.frameIndex];
        if (this.color) {
          frame = chalk[this.color](frame);
        }
        this.frameIndex = ++this.frameIndex % frames.length;
        const fullPrefixText = typeof this.prefixText === "string" && this.prefixText !== "" ? this.prefixText + " " : "";
        const fullText = typeof this.text === "string" ? " " + this.text : "";
        return fullPrefixText + frame + fullText;
      }
      clear() {
        if (!this.isEnabled || !this.stream.isTTY) {
          return this;
        }
        for (let i4 = 0; i4 < this.linesToClear; i4++) {
          if (i4 > 0) {
            this.stream.moveCursor(0, -1);
          }
          this.stream.clearLine();
          this.stream.cursorTo(this.indent);
        }
        this.linesToClear = 0;
        return this;
      }
      render() {
        if (this.isSilent) {
          return this;
        }
        this.clear();
        this.stream.write(this.frame());
        this.linesToClear = this.lineCount;
        return this;
      }
      start(text) {
        if (text) {
          this.text = text;
        }
        if (this.isSilent) {
          return this;
        }
        if (!this.isEnabled) {
          if (this.text) {
            this.stream.write(`- ${this.text}
`);
          }
          return this;
        }
        if (this.isSpinning) {
          return this;
        }
        if (this.hideCursor) {
          cliCursor.hide(this.stream);
        }
        if (this.discardStdin && process.stdin.isTTY) {
          this.isDiscardingStdin = true;
          stdinDiscarder.start();
        }
        this.render();
        this.id = setInterval(this.render.bind(this), this.interval);
        return this;
      }
      stop() {
        if (!this.isEnabled) {
          return this;
        }
        clearInterval(this.id);
        this.id = void 0;
        this.frameIndex = 0;
        this.clear();
        if (this.hideCursor) {
          cliCursor.show(this.stream);
        }
        if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
          stdinDiscarder.stop();
          this.isDiscardingStdin = false;
        }
        return this;
      }
      succeed(text) {
        return this.stopAndPersist({ symbol: logSymbols.success, text });
      }
      fail(text) {
        return this.stopAndPersist({ symbol: logSymbols.error, text });
      }
      warn(text) {
        return this.stopAndPersist({ symbol: logSymbols.warning, text });
      }
      info(text) {
        return this.stopAndPersist({ symbol: logSymbols.info, text });
      }
      stopAndPersist(options = {}) {
        if (this.isSilent) {
          return this;
        }
        const prefixText = options.prefixText || this.prefixText;
        const text = options.text || this.text;
        const fullText = typeof text === "string" ? " " + text : "";
        this.stop();
        this.stream.write(`${this.getFullPrefixText(prefixText, " ")}${options.symbol || " "}${fullText}
`);
        return this;
      }
    };
    var oraFactory = function(options) {
      return new Ora(options);
    };
    module2.exports = oraFactory;
    module2.exports.promise = (action, options) => {
      if (typeof action.then !== "function") {
        throw new TypeError("Parameter `action` must be a Promise");
      }
      const spinner = new Ora(options);
      spinner.start();
      (async () => {
        try {
          await action;
          spinner.succeed();
        } catch {
          spinner.fail();
        }
      })();
      return spinner;
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/protocol.js
var require_protocol = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PitcherResponseStatus = void 0;
    var PitcherResponseStatus4;
    (function(PitcherResponseStatus5) {
      PitcherResponseStatus5[PitcherResponseStatus5["RESOLVED"] = 0] = "RESOLVED";
      PitcherResponseStatus5[PitcherResponseStatus5["REJECTED"] = 1] = "REJECTED";
    })(PitcherResponseStatus4 || (exports2.PitcherResponseStatus = PitcherResponseStatus4 = {}));
  }
});

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUint64 = exports2.getInt64 = exports2.setInt64 = exports2.setUint64 = exports2.UINT32_MAX = void 0;
    exports2.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports2.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports2.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports2.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports2.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports2) {
    "use strict";
    var _a3;
    var _b2;
    var _c2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.utf8DecodeTD = exports2.TEXT_DECODER_THRESHOLD = exports2.utf8DecodeJs = exports2.utf8EncodeTE = exports2.TEXT_ENCODER_THRESHOLD = exports2.utf8EncodeJs = exports2.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a3 = process === null || process === void 0 ? void 0 : process.env) === null || _a3 === void 0 ? void 0 : _a3["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports2.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports2.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports2.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b2 = process === null || process === void 0 ? void 0 : process.env) === null || _b2 === void 0 ? void 0 : _b2["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports2.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports2.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports2.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c2 = process === null || process === void 0 ? void 0 : process.env) === null || _c2 === void 0 ? void 0 : _c2["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports2.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports2.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecodeError = void 0;
    var DecodeError = class _DecodeError extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(_DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: _DecodeError.name
        });
      }
    };
    exports2.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timestampExtension = exports2.decodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimestampExtension = exports2.encodeDateToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports2.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports2.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports2.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports2.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports2.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports2.decodeTimestampExtension = decodeTimestampExtension;
    exports2.timestampExtension = {
      type: exports2.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context) {
        for (let i4 = 0; i4 < this.builtInEncoders.length; i4++) {
          const encodeExt = this.builtInEncoders[i4];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i4;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i4 = 0; i4 < this.encoders.length; i4++) {
          const encodeExt = this.encoders[i4];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i4;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports2.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDataView = exports2.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports2.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports2.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encoder = exports2.DEFAULT_INITIAL_BUFFER_SIZE = exports2.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports2.DEFAULT_MAX_DEPTH = 100;
    exports2.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports2.DEFAULT_MAX_DEPTH, initialBufferSize = exports2.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports2.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports2.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports2.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i4 = 0; i4 < this.maxKeyLength; i4++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK: for (const record of records) {
          const recordBytes = record.bytes;
          for (let j3 = 0; j3 < byteLength; j3++) {
            if (recordBytes[j3] !== bytes[inputOffset + j3]) {
              continue FIND_CHUNK;
            }
          }
          return record.str;
        }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports2.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decoder = exports2.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports2.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e3) {
        return e3.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports2.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e3) {
            if (!(e3 instanceof exports2.DataViewIndexOutOfBoundsError)) {
              throw e3;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e3) {
            if (!(e3 instanceof exports2.DataViewIndexOutOfBoundsError)) {
              throw e3;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE: while (true) {
          const headByte = this.readHeadByte();
          let object;
          if (headByte >= 224) {
            object = headByte - 256;
          } else if (headByte < 192) {
            if (headByte < 128) {
              object = headByte;
            } else if (headByte < 144) {
              const size = headByte - 128;
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte < 160) {
              const size = headByte - 144;
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else {
              const byteLength = headByte - 160;
              object = this.decodeUtf8String(byteLength, 0);
            }
          } else if (headByte === 192) {
            object = null;
          } else if (headByte === 194) {
            object = false;
          } else if (headByte === 195) {
            object = true;
          } else if (headByte === 202) {
            object = this.readF32();
          } else if (headByte === 203) {
            object = this.readF64();
          } else if (headByte === 204) {
            object = this.readU8();
          } else if (headByte === 205) {
            object = this.readU16();
          } else if (headByte === 206) {
            object = this.readU32();
          } else if (headByte === 207) {
            object = this.readU64();
          } else if (headByte === 208) {
            object = this.readI8();
          } else if (headByte === 209) {
            object = this.readI16();
          } else if (headByte === 210) {
            object = this.readI32();
          } else if (headByte === 211) {
            object = this.readI64();
          } else if (headByte === 217) {
            const byteLength = this.lookU8();
            object = this.decodeUtf8String(byteLength, 1);
          } else if (headByte === 218) {
            const byteLength = this.lookU16();
            object = this.decodeUtf8String(byteLength, 2);
          } else if (headByte === 219) {
            const byteLength = this.lookU32();
            object = this.decodeUtf8String(byteLength, 4);
          } else if (headByte === 220) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 221) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 222) {
            const size = this.readU16();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 223) {
            const size = this.readU32();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 196) {
            const size = this.lookU8();
            object = this.decodeBinary(size, 1);
          } else if (headByte === 197) {
            const size = this.lookU16();
            object = this.decodeBinary(size, 2);
          } else if (headByte === 198) {
            const size = this.lookU32();
            object = this.decodeBinary(size, 4);
          } else if (headByte === 212) {
            object = this.decodeExtension(1, 0);
          } else if (headByte === 213) {
            object = this.decodeExtension(2, 0);
          } else if (headByte === 214) {
            object = this.decodeExtension(4, 0);
          } else if (headByte === 215) {
            object = this.decodeExtension(8, 0);
          } else if (headByte === 216) {
            object = this.decodeExtension(16, 0);
          } else if (headByte === 199) {
            const size = this.lookU8();
            object = this.decodeExtension(size, 1);
          } else if (headByte === 200) {
            const size = this.lookU16();
            object = this.decodeExtension(size, 2);
          } else if (headByte === 201) {
            const size = this.lookU32();
            object = this.decodeExtension(size, 4);
          } else {
            throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
          }
          this.complete();
          const stack = this.stack;
          while (stack.length > 0) {
            const state = stack[stack.length - 1];
            if (state.type === 0) {
              state.array[state.position] = object;
              state.position++;
              if (state.position === state.size) {
                stack.pop();
                object = state.array;
              } else {
                continue DECODE;
              }
            } else if (state.type === 1) {
              if (!isValidMapKeyType(object)) {
                throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
              }
              if (object === "__proto__") {
                throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
              }
              state.key = object;
              state.type = 2;
              continue DECODE;
            } else {
              state.map[state.key] = object;
              state.readCount++;
              if (state.readCount === state.size) {
                stack.pop();
                object = state.map;
              } else {
                state.key = null;
                state.type = 1;
                continue DECODE;
              }
            }
          }
          return object;
        }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a3;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a3 = this.keyDecoder) === null || _a3 === void 0 ? void 0 : _a3.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports2.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeMulti = exports2.decode = exports2.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports2.defaultDecodeOptions = {};
    function decode(buffer, options = exports2.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports2.decode = decode;
    function decodeMulti(buffer, options = exports2.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports2.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream2 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureAsyncIterable = exports2.asyncIterableFromStream = exports2.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports2.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports2.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports2.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeStream = exports2.decodeMultiStream = exports2.decodeArrayStream = exports2.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream2();
    var decode_1 = require_decode();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports2.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports2.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports2.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports2.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTimestampExtension = exports2.encodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.encodeDateToTimeSpec = exports2.EXT_TIMESTAMP = exports2.ExtData = exports2.ExtensionCodec = exports2.Encoder = exports2.DataViewIndexOutOfBoundsError = exports2.DecodeError = exports2.Decoder = exports2.decodeStream = exports2.decodeMultiStream = exports2.decodeArrayStream = exports2.decodeAsync = exports2.decodeMulti = exports2.decode = exports2.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports2, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports2, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports2, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports2, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports2, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports2, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports2, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports2, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports2, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports2, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports2, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports2, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports2, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports2, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports2, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports2, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports2, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports2, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/message.js
var require_message = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResponsePayload = exports2.createRequestPayload = exports2.createNotificationPayload = exports2.isResultPayload = exports2.isErrorPayload = exports2.isNotificationPayload = exports2.decodeMessage = exports2.encodeMessage = void 0;
    var msgpack_1 = require_dist4();
    function encodeMessage(message) {
      return (0, msgpack_1.encode)(message);
    }
    exports2.encodeMessage = encodeMessage;
    function decodeMessage2(blob) {
      return (0, msgpack_1.decode)(blob);
    }
    exports2.decodeMessage = decodeMessage2;
    function isNotificationPayload2(payload) {
      return !("id" in payload) && "params" in payload;
    }
    exports2.isNotificationPayload = isNotificationPayload2;
    function isErrorPayload2(payload) {
      return "error" in payload;
    }
    exports2.isErrorPayload = isErrorPayload2;
    function isResultPayload3(payload) {
      return "result" in payload;
    }
    exports2.isResultPayload = isResultPayload3;
    function createNotificationPayload(payload) {
      return encodeMessage(payload);
    }
    exports2.createNotificationPayload = createNotificationPayload;
    function createRequestPayload2(payload) {
      return encodeMessage(payload);
    }
    exports2.createRequestPayload = createRequestPayload2;
    function createResponsePayload(payload) {
      return encodeMessage(payload);
    }
    exports2.createResponsePayload = createResponsePayload;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/package.json
var require_package = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/package.json"(exports2, module2) {
    module2.exports = {
      name: "@codesandbox/pitcher-protocol",
      version: "0.360.2",
      repository: {
        type: "git",
        url: "ssh://git@github.com/codesandbox/pitcher.git",
        directory: "packages/pitcher-protocol"
      },
      license: "GPL-3.0",
      main: "dist/src/index.js",
      types: "dist/src/index.d.ts",
      files: [
        "dist"
      ],
      scripts: {
        build: "yarn clean && yarn compile",
        clean: "rm -fr ./dist",
        compile: "tsc -b tsconfig.build.json",
        test: "jest"
      },
      dependencies: {
        "@codesandbox/pitcher-common": "*",
        "@msgpack/msgpack": "^2.7.1"
      }
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/errors.js
var require_errors4 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PitcherErrorCode = void 0;
    var PitcherErrorCode2;
    (function(PitcherErrorCode3) {
      PitcherErrorCode3[PitcherErrorCode3["CRITICAL_ERROR"] = 0] = "CRITICAL_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["FEATURE_UNAVAILABLE"] = 1] = "FEATURE_UNAVAILABLE";
      PitcherErrorCode3[PitcherErrorCode3["NO_ACCESS"] = 2] = "NO_ACCESS";
      PitcherErrorCode3[PitcherErrorCode3["RATE_LIMIT"] = 3] = "RATE_LIMIT";
      PitcherErrorCode3[PitcherErrorCode3["INVALID_ID"] = 100] = "INVALID_ID";
      PitcherErrorCode3[PitcherErrorCode3["INVALID_PATH"] = 101] = "INVALID_PATH";
      PitcherErrorCode3[PitcherErrorCode3["RAWFS_ERROR"] = 102] = "RAWFS_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_NOT_ACCESSIBLE"] = 200] = "SHELL_NOT_ACCESSIBLE";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_CLOSED"] = 201] = "SHELL_CLOSED";
      PitcherErrorCode3[PitcherErrorCode3["SHELL_NOT_FOUND"] = 204] = "SHELL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["MODEL_NOT_FOUND"] = 300] = "MODEL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["GIT_OPERATION_IN_PROGRESS"] = 400] = "GIT_OPERATION_IN_PROGRESS";
      PitcherErrorCode3[PitcherErrorCode3["GIT_REMOTE_FILE_NOT_FOUND"] = 404] = "GIT_REMOTE_FILE_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["GIT_FETCH_FAIL"] = 410] = "GIT_FETCH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PULL_CONFLICT"] = 420] = "GIT_PULL_CONFLICT";
      PitcherErrorCode3[PitcherErrorCode3["GIT_RESET_LOCAL_REMOTE_ERROR"] = 430] = "GIT_RESET_LOCAL_REMOTE_ERROR";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PUSH_FAIL"] = 440] = "GIT_PUSH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_RESET_CHECKOUT_INITIAL_BRANCH_FAIL"] = 450] = "GIT_RESET_CHECKOUT_INITIAL_BRANCH_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_PULL_FAIL"] = 460] = "GIT_PULL_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["GIT_TRANSPOSE_LINES_FAIL"] = 470] = "GIT_TRANSPOSE_LINES_FAIL";
      PitcherErrorCode3[PitcherErrorCode3["CHANNEL_NOT_FOUND"] = 500] = "CHANNEL_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["CONFIG_FILE_ALREADY_EXISTS"] = 600] = "CONFIG_FILE_ALREADY_EXISTS";
      PitcherErrorCode3[PitcherErrorCode3["TASK_NOT_FOUND"] = 601] = "TASK_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["COMMAND_ALREADY_CONFIGURED"] = 602] = "COMMAND_ALREADY_CONFIGURED";
      PitcherErrorCode3[PitcherErrorCode3["COMMAND_NOT_FOUND"] = 704] = "COMMAND_NOT_FOUND";
      PitcherErrorCode3[PitcherErrorCode3["AI_NOT_AVAILABLE"] = 800] = "AI_NOT_AVAILABLE";
      PitcherErrorCode3[PitcherErrorCode3["PROMPT_TOO_BIG"] = 801] = "PROMPT_TOO_BIG";
      PitcherErrorCode3[PitcherErrorCode3["FAILED_TO_RESPOND"] = 802] = "FAILED_TO_RESPOND";
      PitcherErrorCode3[PitcherErrorCode3["AI_TOO_FREQUENT_REQUESTS"] = 803] = "AI_TOO_FREQUENT_REQUESTS";
      PitcherErrorCode3[PitcherErrorCode3["AI_CHAT_NOT_FOUND"] = 814] = "AI_CHAT_NOT_FOUND";
    })(PitcherErrorCode2 || (exports2.PitcherErrorCode = PitcherErrorCode2 = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/client.js
var require_client = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientDisposeReason = exports2.ClientAuthorization = void 0;
    var ClientAuthorization;
    (function(ClientAuthorization2) {
      ClientAuthorization2["READ"] = "Read";
      ClientAuthorization2["WRITE"] = "Write";
      ClientAuthorization2["OWNER"] = "Owner";
    })(ClientAuthorization || (exports2.ClientAuthorization = ClientAuthorization = {}));
    var ClientDisposeReason;
    (function(ClientDisposeReason2) {
      ClientDisposeReason2["AUTHORIZATION_CHANGED"] = "AuthorizationChanged";
      ClientDisposeReason2["DISCONNECT"] = "Disconnect";
      ClientDisposeReason2["PITCHER_SHUTDOWN"] = "PitcherShutdown";
    })(ClientDisposeReason || (exports2.ClientDisposeReason = ClientDisposeReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/ai.js
var require_ai = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/ai.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/port.js
var require_port = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/port.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/language.js
var require_language = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/git.js
var require_git = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/git.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitStatusShortFormat = void 0;
    var GitStatusShortFormat;
    (function(GitStatusShortFormat2) {
      GitStatusShortFormat2["UnModified"] = "";
      GitStatusShortFormat2["Modified"] = "M";
      GitStatusShortFormat2["Added"] = "A";
      GitStatusShortFormat2["Deleted"] = "D";
      GitStatusShortFormat2["Renamed"] = "R";
      GitStatusShortFormat2["Copied"] = "C";
      GitStatusShortFormat2["Updated"] = "U";
      GitStatusShortFormat2["Untracked"] = "?";
    })(GitStatusShortFormat || (exports2.GitStatusShortFormat = GitStatusShortFormat = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/setup.js
var require_setup = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/setup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/fs.js
var require_fs = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FSOperationResponseCode = void 0;
    var FSOperationResponseCode;
    (function(FSOperationResponseCode2) {
      FSOperationResponseCode2[FSOperationResponseCode2["Success"] = 0] = "Success";
      FSOperationResponseCode2[FSOperationResponseCode2["Ignored"] = 1] = "Ignored";
    })(FSOperationResponseCode || (exports2.FSOperationResponseCode = FSOperationResponseCode = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/channel.js
var require_channel = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/task.js
var require_task = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/task.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/file.js
var require_file = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionsUpdateReason = void 0;
    var SelectionsUpdateReason;
    (function(SelectionsUpdateReason2) {
      SelectionsUpdateReason2[SelectionsUpdateReason2["CONTENT_CHANGE"] = 0] = "CONTENT_CHANGE";
      SelectionsUpdateReason2[SelectionsUpdateReason2["SELECTION"] = 1] = "SELECTION";
      SelectionsUpdateReason2[SelectionsUpdateReason2["CLIENT_LEFT"] = 2] = "CLIENT_LEFT";
    })(SelectionsUpdateReason || (exports2.SelectionsUpdateReason = SelectionsUpdateReason = {}));
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/system.js
var require_system = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/shell.js
var require_shell = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/shell.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/command.js
var require_command = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/notification.js
var require_notification = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/messages/notification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/@codesandbox/pitcher-protocol/dist/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v3) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
    } : function(o2, v3) {
      o2["default"] = v3;
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4)) __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.notification = exports2.command = exports2.shell = exports2.system = exports2.file = exports2.task = exports2.channel = exports2.client = exports2.fs = exports2.setup = exports2.git = exports2.language = exports2.port = exports2.ai = exports2.ClientDisposeReason = exports2.ClientAuthorization = exports2.PitcherErrorCode = exports2.version = void 0;
    __exportStar(require_protocol(), exports2);
    __exportStar(require_message(), exports2);
    var package_json_1 = require_package();
    Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
      return package_json_1.version;
    } });
    var errors_1 = require_errors4();
    Object.defineProperty(exports2, "PitcherErrorCode", { enumerable: true, get: function() {
      return errors_1.PitcherErrorCode;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "ClientAuthorization", { enumerable: true, get: function() {
      return client_1.ClientAuthorization;
    } });
    Object.defineProperty(exports2, "ClientDisposeReason", { enumerable: true, get: function() {
      return client_1.ClientDisposeReason;
    } });
    exports2.ai = __importStar(require_ai());
    exports2.port = __importStar(require_port());
    exports2.language = __importStar(require_language());
    exports2.git = __importStar(require_git());
    exports2.setup = __importStar(require_setup());
    exports2.fs = __importStar(require_fs());
    exports2.client = __importStar(require_client());
    exports2.channel = __importStar(require_channel());
    exports2.task = __importStar(require_task());
    exports2.file = __importStar(require_file());
    exports2.system = __importStar(require_system());
    exports2.shell = __importStar(require_shell());
    exports2.command = __importStar(require_command());
    exports2.notification = __importStar(require_notification());
  }
});

// node_modules/core-js/modules/_global.js
var require_global = __commonJS({
  "node_modules/core-js/modules/_global.js"(exports2, module2) {
    var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number") __g = global2;
  }
});

// node_modules/core-js/modules/_core.js
var require_core = __commonJS({
  "node_modules/core-js/modules/_core.js"(exports2, module2) {
    var core = module2.exports = { version: "2.6.0" };
    if (typeof __e == "number") __e = core;
  }
});

// node_modules/core-js/modules/_is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/modules/_is-object.js"(exports2, module2) {
    module2.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/modules/_an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/modules/_an-object.js"(exports2, module2) {
    var isObject = require_is_object();
    module2.exports = function(it) {
      if (!isObject(it)) throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_fails.js
var require_fails = __commonJS({
  "node_modules/core-js/modules/_fails.js"(exports2, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (e3) {
        return true;
      }
    };
  }
});

// node_modules/core-js/modules/_descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/modules/_descriptors.js"(exports2, module2) {
    module2.exports = !require_fails()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_dom-create.js
var require_dom_create = __commonJS({
  "node_modules/core-js/modules/_dom-create.js"(exports2, module2) {
    var isObject = require_is_object();
    var document2 = require_global().document;
    var is = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return is ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/modules/_ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/modules/_ie8-dom-define.js"(exports2, module2) {
    module2.exports = !require_descriptors() && !require_fails()(function() {
      return Object.defineProperty(require_dom_create()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/modules/_to-primitive.js"(exports2, module2) {
    var isObject = require_is_object();
    module2.exports = function(it, S3) {
      if (!isObject(it)) return it;
      var fn, val;
      if (S3 && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
      if (!S3 && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/modules/_object-dp.js
var require_object_dp = __commonJS({
  "node_modules/core-js/modules/_object-dp.js"(exports2) {
    var anObject = require_an_object();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var toPrimitive = require_to_primitive();
    var dP = Object.defineProperty;
    exports2.f = require_descriptors() ? Object.defineProperty : function defineProperty(O3, P3, Attributes) {
      anObject(O3);
      P3 = toPrimitive(P3, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP(O3, P3, Attributes);
      } catch (e3) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O3[P3] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/modules/_property-desc.js
var require_property_desc = __commonJS({
  "node_modules/core-js/modules/_property-desc.js"(exports2, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/modules/_hide.js
var require_hide = __commonJS({
  "node_modules/core-js/modules/_hide.js"(exports2, module2) {
    var dP = require_object_dp();
    var createDesc = require_property_desc();
    module2.exports = require_descriptors() ? function(object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/modules/_has.js
var require_has = __commonJS({
  "node_modules/core-js/modules/_has.js"(exports2, module2) {
    var hasOwnProperty = {}.hasOwnProperty;
    module2.exports = function(it, key) {
      return hasOwnProperty.call(it, key);
    };
  }
});

// node_modules/core-js/modules/_uid.js
var require_uid = __commonJS({
  "node_modules/core-js/modules/_uid.js"(exports2, module2) {
    var id = 0;
    var px = Math.random();
    module2.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/modules/_redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/modules/_redefine.js"(exports2, module2) {
    var global2 = require_global();
    var hide = require_hide();
    var has = require_has();
    var SRC = require_uid()("src");
    var TO_STRING = "toString";
    var $toString = Function[TO_STRING];
    var TPL = ("" + $toString).split(TO_STRING);
    require_core().inspectSource = function(it) {
      return $toString.call(it);
    };
    (module2.exports = function(O3, key, val, safe) {
      var isFunction2 = typeof val == "function";
      if (isFunction2) has(val, "name") || hide(val, "name", key);
      if (O3[key] === val) return;
      if (isFunction2) has(val, SRC) || hide(val, SRC, O3[key] ? "" + O3[key] : TPL.join(String(key)));
      if (O3 === global2) {
        O3[key] = val;
      } else if (!safe) {
        delete O3[key];
        hide(O3, key, val);
      } else if (O3[key]) {
        O3[key] = val;
      } else {
        hide(O3, key, val);
      }
    })(Function.prototype, TO_STRING, function toString() {
      return typeof this == "function" && this[SRC] || $toString.call(this);
    });
  }
});

// node_modules/core-js/modules/_a-function.js
var require_a_function = __commonJS({
  "node_modules/core-js/modules/_a-function.js"(exports2, module2) {
    module2.exports = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_ctx.js
var require_ctx = __commonJS({
  "node_modules/core-js/modules/_ctx.js"(exports2, module2) {
    var aFunction = require_a_function();
    module2.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a3) {
            return fn.call(that, a3);
          };
        case 2:
          return function(a3, b) {
            return fn.call(that, a3, b);
          };
        case 3:
          return function(a3, b, c3) {
            return fn.call(that, a3, b, c3);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/modules/_export.js
var require_export = __commonJS({
  "node_modules/core-js/modules/_export.js"(exports2, module2) {
    var global2 = require_global();
    var core = require_core();
    var hide = require_hide();
    var redefine = require_redefine();
    var ctx = require_ctx();
    var PROTOTYPE = "prototype";
    var $export = function(type, name, source) {
      var IS_FORCED = type & $export.F;
      var IS_GLOBAL = type & $export.G;
      var IS_STATIC = type & $export.S;
      var IS_PROTO = type & $export.P;
      var IS_BIND = type & $export.B;
      var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
      var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports3[PROTOTYPE] || (exports3[PROTOTYPE] = {});
      var key, own, out, exp;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        out = (own ? target : source)[key];
        exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (target) redefine(target, key, out, type & $export.U);
        if (exports3[key] != out) hide(exports3, key, exp);
        if (IS_PROTO && expProto[key] != out) expProto[key] = out;
      }
    };
    global2.core = core;
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    module2.exports = $export;
  }
});

// node_modules/core-js/modules/_cof.js
var require_cof = __commonJS({
  "node_modules/core-js/modules/_cof.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/modules/_iobject.js
var require_iobject = __commonJS({
  "node_modules/core-js/modules/_iobject.js"(exports2, module2) {
    var cof = require_cof();
    module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/modules/_defined.js
var require_defined = __commonJS({
  "node_modules/core-js/modules/_defined.js"(exports2, module2) {
    module2.exports = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/modules/_to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/modules/_to-object.js"(exports2, module2) {
    var defined = require_defined();
    module2.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/modules/_to-integer.js
var require_to_integer = __commonJS({
  "node_modules/core-js/modules/_to-integer.js"(exports2, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/modules/_to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/modules/_to-length.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var min = Math.min;
    module2.exports = function(it) {
      return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/modules/_is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/modules/_is-array.js"(exports2, module2) {
    var cof = require_cof();
    module2.exports = Array.isArray || function isArray(arg) {
      return cof(arg) == "Array";
    };
  }
});

// node_modules/core-js/modules/_library.js
var require_library = __commonJS({
  "node_modules/core-js/modules/_library.js"(exports2, module2) {
    module2.exports = false;
  }
});

// node_modules/core-js/modules/_shared.js
var require_shared = __commonJS({
  "node_modules/core-js/modules/_shared.js"(exports2, module2) {
    var core = require_core();
    var global2 = require_global();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || (global2[SHARED] = {});
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library() ? "pure" : "global",
      copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/modules/_wks.js
var require_wks = __commonJS({
  "node_modules/core-js/modules/_wks.js"(exports2, module2) {
    var store = require_shared()("wks");
    var uid = require_uid();
    var Symbol2 = require_global().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module2.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/modules/_array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/modules/_array-species-constructor.js"(exports2, module2) {
    var isObject = require_is_object();
    var isArray = require_is_array();
    var SPECIES = require_wks()("species");
    module2.exports = function(original) {
      var C3;
      if (isArray(original)) {
        C3 = original.constructor;
        if (typeof C3 == "function" && (C3 === Array || isArray(C3.prototype))) C3 = void 0;
        if (isObject(C3)) {
          C3 = C3[SPECIES];
          if (C3 === null) C3 = void 0;
        }
      }
      return C3 === void 0 ? Array : C3;
    };
  }
});

// node_modules/core-js/modules/_array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/modules/_array-species-create.js"(exports2, module2) {
    var speciesConstructor = require_array_species_constructor();
    module2.exports = function(original, length) {
      return new (speciesConstructor(original))(length);
    };
  }
});

// node_modules/core-js/modules/_array-methods.js
var require_array_methods = __commonJS({
  "node_modules/core-js/modules/_array-methods.js"(exports2, module2) {
    var ctx = require_ctx();
    var IObject = require_iobject();
    var toObject = require_to_object();
    var toLength = require_to_length();
    var asc = require_array_species_create();
    module2.exports = function(TYPE, $create) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      var create2 = $create || asc;
      return function($this, callbackfn, that) {
        var O3 = toObject($this);
        var self2 = IObject(O3);
        var f3 = ctx(callbackfn, that, 3);
        var length = toLength(self2.length);
        var index = 0;
        var result = IS_MAP ? create2($this, length) : IS_FILTER ? create2($this, 0) : void 0;
        var val, res;
        for (; length > index; index++) if (NO_HOLES || index in self2) {
          val = self2[index];
          res = f3(val, index, O3);
          if (TYPE) {
            if (IS_MAP) result[index] = res;
            else if (res) switch (TYPE) {
              case 3:
                return true;
              // some
              case 5:
                return val;
              // find
              case 6:
                return index;
              // findIndex
              case 2:
                result.push(val);
            }
            else if (IS_EVERY) return false;
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
      };
    };
  }
});

// node_modules/core-js/modules/_add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/modules/_add-to-unscopables.js"(exports2, module2) {
    var UNSCOPABLES = require_wks()("unscopables");
    var ArrayProto = Array.prototype;
    if (ArrayProto[UNSCOPABLES] == void 0) require_hide()(ArrayProto, UNSCOPABLES, {});
    module2.exports = function(key) {
      ArrayProto[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es6.array.find-index.js
var require_es6_array_find_index = __commonJS({
  "node_modules/core-js/modules/es6.array.find-index.js"() {
    "use strict";
    var $export = require_export();
    var $find = require_array_methods()(6);
    var KEY = "findIndex";
    var forced = true;
    if (KEY in []) Array(1)[KEY](function() {
      forced = false;
    });
    $export($export.P + $export.F * forced, "Array", {
      findIndex: function findIndex(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()(KEY);
  }
});

// node_modules/core-js/modules/es6.array.find.js
var require_es6_array_find = __commonJS({
  "node_modules/core-js/modules/es6.array.find.js"() {
    "use strict";
    var $export = require_export();
    var $find = require_array_methods()(5);
    var KEY = "find";
    var forced = true;
    if (KEY in []) Array(1)[KEY](function() {
      forced = false;
    });
    $export($export.P + $export.F * forced, "Array", {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()(KEY);
  }
});

// node_modules/core-js/modules/es6.function.name.js
var require_es6_function_name = __commonJS({
  "node_modules/core-js/modules/es6.function.name.js"() {
    var dP = require_object_dp().f;
    var FProto = Function.prototype;
    var nameRE = /^\s*function ([^ (]*)/;
    var NAME = "name";
    NAME in FProto || require_descriptors() && dP(FProto, NAME, {
      configurable: true,
      get: function() {
        try {
          return ("" + this).match(nameRE)[1];
        } catch (e3) {
          return "";
        }
      }
    });
  }
});

// node_modules/babel-runtime/helpers/newArrowCheck.js
var require_newArrowCheck = __commonJS({
  "node_modules/babel-runtime/helpers/newArrowCheck.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.default = function(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    };
  }
});

// node_modules/@jumpn/utils-composite/node_modules/flow-static-land/lib/Fun.js
var require_Fun = __commonJS({
  "node_modules/@jumpn/utils-composite/node_modules/flow-static-land/lib/Fun.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.flip = flip;
    exports2.constant = constant;
    exports2.on = on;
    exports2.compose = compose;
    exports2.pipe = pipe;
    exports2.curry = curry;
    function flip(f3) {
      return function(b, a3) {
        return f3(a3, b);
      };
    }
    function constant(a3) {
      return function() {
        return a3;
      };
    }
    function on(o2, f3) {
      return function(x3, y3) {
        return o2(f3(x3), f3(y3));
      };
    }
    function compose() {
      var _this = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i = len; _i > -1; _i--) {
          y3 = fns[_i].call(_this, y3);
        }
        return y3;
      };
    }
    function pipe() {
      var _this2 = this;
      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i2 = 0; _i2 <= len; _i2++) {
          y3 = fns[_i2].call(_this2, y3);
        }
        return y3;
      };
    }
    function curried(f3, length, acc) {
      return function() {
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f3.apply(this, combined) : curried(f3, length, combined);
      };
    }
    function curry(f3) {
      return curried(f3, f3.length, []);
    }
  }
});

// node_modules/core-js/library/modules/_to-integer.js
var require_to_integer2 = __commonJS({
  "node_modules/core-js/library/modules/_to-integer.js"(exports2, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/library/modules/_defined.js
var require_defined2 = __commonJS({
  "node_modules/core-js/library/modules/_defined.js"(exports2, module2) {
    module2.exports = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_string-at.js
var require_string_at = __commonJS({
  "node_modules/core-js/library/modules/_string-at.js"(exports2, module2) {
    var toInteger = require_to_integer2();
    var defined = require_defined2();
    module2.exports = function(TO_STRING) {
      return function(that, pos) {
        var s3 = String(defined(that));
        var i4 = toInteger(pos);
        var l3 = s3.length;
        var a3, b;
        if (i4 < 0 || i4 >= l3) return TO_STRING ? "" : void 0;
        a3 = s3.charCodeAt(i4);
        return a3 < 55296 || a3 > 56319 || i4 + 1 === l3 || (b = s3.charCodeAt(i4 + 1)) < 56320 || b > 57343 ? TO_STRING ? s3.charAt(i4) : a3 : TO_STRING ? s3.slice(i4, i4 + 2) : (a3 - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/library/modules/_library.js
var require_library2 = __commonJS({
  "node_modules/core-js/library/modules/_library.js"(exports2, module2) {
    module2.exports = true;
  }
});

// node_modules/core-js/library/modules/_global.js
var require_global2 = __commonJS({
  "node_modules/core-js/library/modules/_global.js"(exports2, module2) {
    var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number") __g = global2;
  }
});

// node_modules/core-js/library/modules/_core.js
var require_core2 = __commonJS({
  "node_modules/core-js/library/modules/_core.js"(exports2, module2) {
    var core = module2.exports = { version: "2.6.0" };
    if (typeof __e == "number") __e = core;
  }
});

// node_modules/core-js/library/modules/_a-function.js
var require_a_function2 = __commonJS({
  "node_modules/core-js/library/modules/_a-function.js"(exports2, module2) {
    module2.exports = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_ctx.js
var require_ctx2 = __commonJS({
  "node_modules/core-js/library/modules/_ctx.js"(exports2, module2) {
    var aFunction = require_a_function2();
    module2.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a3) {
            return fn.call(that, a3);
          };
        case 2:
          return function(a3, b) {
            return fn.call(that, a3, b);
          };
        case 3:
          return function(a3, b, c3) {
            return fn.call(that, a3, b, c3);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/library/modules/_is-object.js
var require_is_object2 = __commonJS({
  "node_modules/core-js/library/modules/_is-object.js"(exports2, module2) {
    module2.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/library/modules/_an-object.js
var require_an_object2 = __commonJS({
  "node_modules/core-js/library/modules/_an-object.js"(exports2, module2) {
    var isObject = require_is_object2();
    module2.exports = function(it) {
      if (!isObject(it)) throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_fails.js
var require_fails2 = __commonJS({
  "node_modules/core-js/library/modules/_fails.js"(exports2, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (e3) {
        return true;
      }
    };
  }
});

// node_modules/core-js/library/modules/_descriptors.js
var require_descriptors2 = __commonJS({
  "node_modules/core-js/library/modules/_descriptors.js"(exports2, module2) {
    module2.exports = !require_fails2()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_dom-create.js
var require_dom_create2 = __commonJS({
  "node_modules/core-js/library/modules/_dom-create.js"(exports2, module2) {
    var isObject = require_is_object2();
    var document2 = require_global2().document;
    var is = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return is ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/library/modules/_ie8-dom-define.js
var require_ie8_dom_define2 = __commonJS({
  "node_modules/core-js/library/modules/_ie8-dom-define.js"(exports2, module2) {
    module2.exports = !require_descriptors2() && !require_fails2()(function() {
      return Object.defineProperty(require_dom_create2()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_to-primitive.js
var require_to_primitive2 = __commonJS({
  "node_modules/core-js/library/modules/_to-primitive.js"(exports2, module2) {
    var isObject = require_is_object2();
    module2.exports = function(it, S3) {
      if (!isObject(it)) return it;
      var fn, val;
      if (S3 && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
      if (!S3 && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/library/modules/_object-dp.js
var require_object_dp2 = __commonJS({
  "node_modules/core-js/library/modules/_object-dp.js"(exports2) {
    var anObject = require_an_object2();
    var IE8_DOM_DEFINE = require_ie8_dom_define2();
    var toPrimitive = require_to_primitive2();
    var dP = Object.defineProperty;
    exports2.f = require_descriptors2() ? Object.defineProperty : function defineProperty(O3, P3, Attributes) {
      anObject(O3);
      P3 = toPrimitive(P3, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP(O3, P3, Attributes);
      } catch (e3) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O3[P3] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/library/modules/_property-desc.js
var require_property_desc2 = __commonJS({
  "node_modules/core-js/library/modules/_property-desc.js"(exports2, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/library/modules/_hide.js
var require_hide2 = __commonJS({
  "node_modules/core-js/library/modules/_hide.js"(exports2, module2) {
    var dP = require_object_dp2();
    var createDesc = require_property_desc2();
    module2.exports = require_descriptors2() ? function(object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/library/modules/_has.js
var require_has2 = __commonJS({
  "node_modules/core-js/library/modules/_has.js"(exports2, module2) {
    var hasOwnProperty = {}.hasOwnProperty;
    module2.exports = function(it, key) {
      return hasOwnProperty.call(it, key);
    };
  }
});

// node_modules/core-js/library/modules/_export.js
var require_export2 = __commonJS({
  "node_modules/core-js/library/modules/_export.js"(exports2, module2) {
    var global2 = require_global2();
    var core = require_core2();
    var ctx = require_ctx2();
    var hide = require_hide2();
    var has = require_has2();
    var PROTOTYPE = "prototype";
    var $export = function(type, name, source) {
      var IS_FORCED = type & $export.F;
      var IS_GLOBAL = type & $export.G;
      var IS_STATIC = type & $export.S;
      var IS_PROTO = type & $export.P;
      var IS_BIND = type & $export.B;
      var IS_WRAP = type & $export.W;
      var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports3[PROTOTYPE];
      var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
      var key, own, out;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        if (own && has(exports3, key)) continue;
        out = own ? target[key] : source[key];
        exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C3) {
          var F2 = function(a3, b, c3) {
            if (this instanceof C3) {
              switch (arguments.length) {
                case 0:
                  return new C3();
                case 1:
                  return new C3(a3);
                case 2:
                  return new C3(a3, b);
              }
              return new C3(a3, b, c3);
            }
            return C3.apply(this, arguments);
          };
          F2[PROTOTYPE] = C3[PROTOTYPE];
          return F2;
        }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (IS_PROTO) {
          (exports3.virtual || (exports3.virtual = {}))[key] = out;
          if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
        }
      }
    };
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    module2.exports = $export;
  }
});

// node_modules/core-js/library/modules/_redefine.js
var require_redefine2 = __commonJS({
  "node_modules/core-js/library/modules/_redefine.js"(exports2, module2) {
    module2.exports = require_hide2();
  }
});

// node_modules/core-js/library/modules/_iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/library/modules/_iterators.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/library/modules/_cof.js
var require_cof2 = __commonJS({
  "node_modules/core-js/library/modules/_cof.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/library/modules/_iobject.js
var require_iobject2 = __commonJS({
  "node_modules/core-js/library/modules/_iobject.js"(exports2, module2) {
    var cof = require_cof2();
    module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/library/modules/_to-iobject.js
var require_to_iobject = __commonJS({
  "node_modules/core-js/library/modules/_to-iobject.js"(exports2, module2) {
    var IObject = require_iobject2();
    var defined = require_defined2();
    module2.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_to-length.js
var require_to_length2 = __commonJS({
  "node_modules/core-js/library/modules/_to-length.js"(exports2, module2) {
    var toInteger = require_to_integer2();
    var min = Math.min;
    module2.exports = function(it) {
      return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/library/modules/_to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/library/modules/_to-absolute-index.js"(exports2, module2) {
    var toInteger = require_to_integer2();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }
});

// node_modules/core-js/library/modules/_array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/library/modules/_array-includes.js"(exports2, module2) {
    var toIObject = require_to_iobject();
    var toLength = require_to_length2();
    var toAbsoluteIndex = require_to_absolute_index();
    module2.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIObject($this);
        var length = toLength(O3.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O3[index++];
          if (value != value) return true;
        }
        else for (; length > index; index++) if (IS_INCLUDES || index in O3) {
          if (O3[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/library/modules/_shared.js
var require_shared2 = __commonJS({
  "node_modules/core-js/library/modules/_shared.js"(exports2, module2) {
    var core = require_core2();
    var global2 = require_global2();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || (global2[SHARED] = {});
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library2() ? "pure" : "global",
      copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/library/modules/_uid.js
var require_uid2 = __commonJS({
  "node_modules/core-js/library/modules/_uid.js"(exports2, module2) {
    var id = 0;
    var px = Math.random();
    module2.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/library/modules/_shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/library/modules/_shared-key.js"(exports2, module2) {
    var shared = require_shared2()("keys");
    var uid = require_uid2();
    module2.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/library/modules/_object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/library/modules/_object-keys-internal.js"(exports2, module2) {
    var has = require_has2();
    var toIObject = require_to_iobject();
    var arrayIndexOf = require_array_includes()(false);
    var IE_PROTO = require_shared_key()("IE_PROTO");
    module2.exports = function(object, names) {
      var O3 = toIObject(object);
      var i4 = 0;
      var result = [];
      var key;
      for (key in O3) if (key != IE_PROTO) has(O3, key) && result.push(key);
      while (names.length > i4) if (has(O3, key = names[i4++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-bug-keys.js"(exports2, module2) {
    module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/library/modules/_object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/library/modules/_object-keys.js"(exports2, module2) {
    var $keys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys(O3) {
      return $keys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/library/modules/_object-dps.js
var require_object_dps = __commonJS({
  "node_modules/core-js/library/modules/_object-dps.js"(exports2, module2) {
    var dP = require_object_dp2();
    var anObject = require_an_object2();
    var getKeys = require_object_keys();
    module2.exports = require_descriptors2() ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject(O3);
      var keys = getKeys(Properties);
      var length = keys.length;
      var i4 = 0;
      var P3;
      while (length > i4) dP.f(O3, P3 = keys[i4++], Properties[P3]);
      return O3;
    };
  }
});

// node_modules/core-js/library/modules/_html.js
var require_html = __commonJS({
  "node_modules/core-js/library/modules/_html.js"(exports2, module2) {
    var document2 = require_global2().document;
    module2.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/library/modules/_object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/library/modules/_object-create.js"(exports2, module2) {
    var anObject = require_an_object2();
    var dPs = require_object_dps();
    var enumBugKeys = require_enum_bug_keys();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var Empty = function() {
    };
    var PROTOTYPE = "prototype";
    var createDict = function() {
      var iframe = require_dom_create2()("iframe");
      var i4 = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i4--) delete createDict[PROTOTYPE][enumBugKeys[i4]];
      return createDict();
    };
    module2.exports = Object.create || function create2(O3, Properties) {
      var result;
      if (O3 !== null) {
        Empty[PROTOTYPE] = anObject(O3);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    };
  }
});

// node_modules/core-js/library/modules/_wks.js
var require_wks2 = __commonJS({
  "node_modules/core-js/library/modules/_wks.js"(exports2, module2) {
    var store = require_shared2()("wks");
    var uid = require_uid2();
    var Symbol2 = require_global2().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module2.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/library/modules/_set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/library/modules/_set-to-string-tag.js"(exports2, module2) {
    var def = require_object_dp2().f;
    var has = require_has2();
    var TAG = require_wks2()("toStringTag");
    module2.exports = function(it, tag, stat2) {
      if (it && !has(it = stat2 ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/library/modules/_iter-create.js
var require_iter_create = __commonJS({
  "node_modules/core-js/library/modules/_iter-create.js"(exports2, module2) {
    "use strict";
    var create2 = require_object_create();
    var descriptor = require_property_desc2();
    var setToStringTag = require_set_to_string_tag();
    var IteratorPrototype = {};
    require_hide2()(IteratorPrototype, require_wks2()("iterator"), function() {
      return this;
    });
    module2.exports = function(Constructor, NAME, next) {
      Constructor.prototype = create2(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME + " Iterator");
    };
  }
});

// node_modules/core-js/library/modules/_to-object.js
var require_to_object2 = __commonJS({
  "node_modules/core-js/library/modules/_to-object.js"(exports2, module2) {
    var defined = require_defined2();
    module2.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_object-gpo.js
var require_object_gpo = __commonJS({
  "node_modules/core-js/library/modules/_object-gpo.js"(exports2, module2) {
    var has = require_has2();
    var toObject = require_to_object2();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module2.exports = Object.getPrototypeOf || function(O3) {
      O3 = toObject(O3);
      if (has(O3, IE_PROTO)) return O3[IE_PROTO];
      if (typeof O3.constructor == "function" && O3 instanceof O3.constructor) {
        return O3.constructor.prototype;
      }
      return O3 instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/library/modules/_iter-define.js
var require_iter_define = __commonJS({
  "node_modules/core-js/library/modules/_iter-define.js"(exports2, module2) {
    "use strict";
    var LIBRARY = require_library2();
    var $export = require_export2();
    var redefine = require_redefine2();
    var hide = require_hide2();
    var Iterators = require_iterators();
    var $iterCreate = require_iter_create();
    var setToStringTag = require_set_to_string_tag();
    var getPrototypeOf = require_object_gpo();
    var ITERATOR = require_wks2()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next);
      var getMethod = function(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch (kind) {
          case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }
        return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto = Base.prototype;
      var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
      var $default = $native || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
        }
      }
      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
        hide(proto, ITERATOR, $default);
      }
      Iterators[NAME] = $default;
      Iterators[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto)) redefine(proto, key, methods[key]);
        }
        else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/library/modules/es6.string.iterator.js
var require_es6_string_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.string.iterator.js"() {
    "use strict";
    var $at = require_string_at()(true);
    require_iter_define()(String, "String", function(iterated) {
      this._t = String(iterated);
      this._i = 0;
    }, function() {
      var O3 = this._t;
      var index = this._i;
      var point;
      if (index >= O3.length) return { value: void 0, done: true };
      point = $at(O3, index);
      this._i += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/library/modules/_add-to-unscopables.js
var require_add_to_unscopables2 = __commonJS({
  "node_modules/core-js/library/modules/_add-to-unscopables.js"(exports2, module2) {
    module2.exports = function() {
    };
  }
});

// node_modules/core-js/library/modules/_iter-step.js
var require_iter_step = __commonJS({
  "node_modules/core-js/library/modules/_iter-step.js"(exports2, module2) {
    module2.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/library/modules/es6.array.iterator.js
var require_es6_array_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.array.iterator.js"(exports2, module2) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables2();
    var step = require_iter_step();
    var Iterators = require_iterators();
    var toIObject = require_to_iobject();
    module2.exports = require_iter_define()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O3 = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O3 || index >= O3.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys") return step(0, index);
      if (kind == "values") return step(0, O3[index]);
      return step(0, [index, O3[index]]);
    }, "values");
    Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/library/modules/web.dom.iterable.js
var require_web_dom_iterable = __commonJS({
  "node_modules/core-js/library/modules/web.dom.iterable.js"() {
    require_es6_array_iterator();
    var global2 = require_global2();
    var hide = require_hide2();
    var Iterators = require_iterators();
    var TO_STRING_TAG = require_wks2()("toStringTag");
    var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
    for (i4 = 0; i4 < DOMIterables.length; i4++) {
      NAME = DOMIterables[i4];
      Collection = global2[NAME];
      proto = Collection && Collection.prototype;
      if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
      Iterators[NAME] = Iterators.Array;
    }
    var NAME;
    var Collection;
    var proto;
    var i4;
  }
});

// node_modules/core-js/library/modules/_wks-ext.js
var require_wks_ext = __commonJS({
  "node_modules/core-js/library/modules/_wks-ext.js"(exports2) {
    exports2.f = require_wks2();
  }
});

// node_modules/core-js/library/fn/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/core-js/library/fn/symbol/iterator.js"(exports2, module2) {
    require_es6_string_iterator();
    require_web_dom_iterable();
    module2.exports = require_wks_ext().f("iterator");
  }
});

// node_modules/babel-runtime/core-js/symbol/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol/iterator.js"(exports2, module2) {
    module2.exports = { "default": require_iterator(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_meta.js
var require_meta = __commonJS({
  "node_modules/core-js/library/modules/_meta.js"(exports2, module2) {
    var META = require_uid2()("meta");
    var isObject = require_is_object2();
    var has = require_has2();
    var setDesc = require_object_dp2().f;
    var id = 0;
    var isExtensible = Object.isExtensible || function() {
      return true;
    };
    var FREEZE = !require_fails2()(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var setMeta = function(it) {
      setDesc(it, META, { value: {
        i: "O" + ++id,
        // object ID
        w: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create2) {
      if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!has(it, META)) {
        if (!isExtensible(it)) return "F";
        if (!create2) return "E";
        setMeta(it);
      }
      return it[META].i;
    };
    var getWeak = function(it, create2) {
      if (!has(it, META)) {
        if (!isExtensible(it)) return true;
        if (!create2) return false;
        setMeta(it);
      }
      return it[META].w;
    };
    var onFreeze = function(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
      return it;
    };
    var meta = module2.exports = {
      KEY: META,
      NEED: false,
      fastKey,
      getWeak,
      onFreeze
    };
  }
});

// node_modules/core-js/library/modules/_wks-define.js
var require_wks_define = __commonJS({
  "node_modules/core-js/library/modules/_wks-define.js"(exports2, module2) {
    var global2 = require_global2();
    var core = require_core2();
    var LIBRARY = require_library2();
    var wksExt = require_wks_ext();
    var defineProperty = require_object_dp2().f;
    module2.exports = function(name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global2.Symbol || {});
      if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
    };
  }
});

// node_modules/core-js/library/modules/_object-gops.js
var require_object_gops = __commonJS({
  "node_modules/core-js/library/modules/_object-gops.js"(exports2) {
    exports2.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/library/modules/_object-pie.js
var require_object_pie = __commonJS({
  "node_modules/core-js/library/modules/_object-pie.js"(exports2) {
    exports2.f = {}.propertyIsEnumerable;
  }
});

// node_modules/core-js/library/modules/_enum-keys.js
var require_enum_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-keys.js"(exports2, module2) {
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    module2.exports = function(it) {
      var result = getKeys(it);
      var getSymbols = gOPS.f;
      if (getSymbols) {
        var symbols = getSymbols(it);
        var isEnum = pIE.f;
        var i4 = 0;
        var key;
        while (symbols.length > i4) if (isEnum.call(it, key = symbols[i4++])) result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_is-array.js
var require_is_array2 = __commonJS({
  "node_modules/core-js/library/modules/_is-array.js"(exports2, module2) {
    var cof = require_cof2();
    module2.exports = Array.isArray || function isArray(arg) {
      return cof(arg) == "Array";
    };
  }
});

// node_modules/core-js/library/modules/_object-gopn.js
var require_object_gopn = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn.js"(exports2) {
    var $keys = require_object_keys_internal();
    var hiddenKeys = require_enum_bug_keys().concat("length", "prototype");
    exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O3) {
      return $keys(O3, hiddenKeys);
    };
  }
});

// node_modules/core-js/library/modules/_object-gopn-ext.js
var require_object_gopn_ext = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn-ext.js"(exports2, module2) {
    var toIObject = require_to_iobject();
    var gOPN = require_object_gopn().f;
    var toString = {}.toString;
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return gOPN(it);
      } catch (e3) {
        return windowNames.slice();
      }
    };
    module2.exports.f = function getOwnPropertyNames(it) {
      return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
    };
  }
});

// node_modules/core-js/library/modules/_object-gopd.js
var require_object_gopd = __commonJS({
  "node_modules/core-js/library/modules/_object-gopd.js"(exports2) {
    var pIE = require_object_pie();
    var createDesc = require_property_desc2();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive2();
    var has = require_has2();
    var IE8_DOM_DEFINE = require_ie8_dom_define2();
    var gOPD = Object.getOwnPropertyDescriptor;
    exports2.f = require_descriptors2() ? gOPD : function getOwnPropertyDescriptor(O3, P3) {
      O3 = toIObject(O3);
      P3 = toPrimitive(P3, true);
      if (IE8_DOM_DEFINE) try {
        return gOPD(O3, P3);
      } catch (e3) {
      }
      if (has(O3, P3)) return createDesc(!pIE.f.call(O3, P3), O3[P3]);
    };
  }
});

// node_modules/core-js/library/modules/es6.symbol.js
var require_es6_symbol = __commonJS({
  "node_modules/core-js/library/modules/es6.symbol.js"() {
    "use strict";
    var global2 = require_global2();
    var has = require_has2();
    var DESCRIPTORS = require_descriptors2();
    var $export = require_export2();
    var redefine = require_redefine2();
    var META = require_meta().KEY;
    var $fails = require_fails2();
    var shared = require_shared2();
    var setToStringTag = require_set_to_string_tag();
    var uid = require_uid2();
    var wks = require_wks2();
    var wksExt = require_wks_ext();
    var wksDefine = require_wks_define();
    var enumKeys = require_enum_keys();
    var isArray = require_is_array2();
    var anObject = require_an_object2();
    var isObject = require_is_object2();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive2();
    var createDesc = require_property_desc2();
    var _create = require_object_create();
    var gOPNExt = require_object_gopn_ext();
    var $GOPD = require_object_gopd();
    var $DP = require_object_dp2();
    var $keys = require_object_keys();
    var gOPD = $GOPD.f;
    var dP = $DP.f;
    var gOPN = gOPNExt.f;
    var $Symbol = global2.Symbol;
    var $JSON = global2.JSON;
    var _stringify = $JSON && $JSON.stringify;
    var PROTOTYPE = "prototype";
    var HIDDEN = wks("_hidden");
    var TO_PRIMITIVE = wks("toPrimitive");
    var isEnum = {}.propertyIsEnumerable;
    var SymbolRegistry = shared("symbol-registry");
    var AllSymbols = shared("symbols");
    var OPSymbols = shared("op-symbols");
    var ObjectProto = Object[PROTOTYPE];
    var USE_NATIVE = typeof $Symbol == "function";
    var QObject = global2.QObject;
    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDesc = DESCRIPTORS && $fails(function() {
      return _create(dP({}, "a", {
        get: function() {
          return dP(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(it, key, D3) {
      var protoDesc = gOPD(ObjectProto, key);
      if (protoDesc) delete ObjectProto[key];
      dP(it, key, D3);
      if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
    } : dP;
    var wrap2 = function(tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
      sym._k = tag;
      return sym;
    };
    var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      return it instanceof $Symbol;
    };
    var $defineProperty = function defineProperty(it, key, D3) {
      if (it === ObjectProto) $defineProperty(OPSymbols, key, D3);
      anObject(it);
      key = toPrimitive(key, true);
      anObject(D3);
      if (has(AllSymbols, key)) {
        if (!D3.enumerable) {
          if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
          it[HIDDEN][key] = true;
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
          D3 = _create(D3, { enumerable: createDesc(0, false) });
        }
        return setSymbolDesc(it, key, D3);
      }
      return dP(it, key, D3);
    };
    var $defineProperties = function defineProperties(it, P3) {
      anObject(it);
      var keys = enumKeys(P3 = toIObject(P3));
      var i4 = 0;
      var l3 = keys.length;
      var key;
      while (l3 > i4) $defineProperty(it, key = keys[i4++], P3[key]);
      return it;
    };
    var $create = function create2(it, P3) {
      return P3 === void 0 ? _create(it) : $defineProperties(_create(it), P3);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(key) {
      var E2 = isEnum.call(this, key = toPrimitive(key, true));
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
      return E2 || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E2 : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
      it = toIObject(it);
      key = toPrimitive(key, true);
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
      var D3 = gOPD(it, key);
      if (D3 && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D3.enumerable = true;
      return D3;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(it) {
      var names = gOPN(toIObject(it));
      var result = [];
      var i4 = 0;
      var key;
      while (names.length > i4) {
        if (!has(AllSymbols, key = names[i4++]) && key != HIDDEN && key != META) result.push(key);
      }
      return result;
    };
    var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
      var IS_OP = it === ObjectProto;
      var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
      var result = [];
      var i4 = 0;
      var key;
      while (names.length > i4) {
        if (has(AllSymbols, key = names[i4++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
      }
      return result;
    };
    if (!USE_NATIVE) {
      $Symbol = function Symbol2() {
        if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
        var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
        var $set = function(value) {
          if (this === ObjectProto) $set.call(OPSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDesc(this, tag, createDesc(1, value));
        };
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
        return wrap2(tag);
      };
      redefine($Symbol[PROTOTYPE], "toString", function toString() {
        return this._k;
      });
      $GOPD.f = $getOwnPropertyDescriptor;
      $DP.f = $defineProperty;
      require_object_gopn().f = gOPNExt.f = $getOwnPropertyNames;
      require_object_pie().f = $propertyIsEnumerable;
      require_object_gops().f = $getOwnPropertySymbols;
      if (DESCRIPTORS && !require_library2()) {
        redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
      }
      wksExt.f = function(name) {
        return wrap2(wks(name));
      };
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
    for (es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j3 = 0; es6Symbols.length > j3; ) wks(es6Symbols[j3++]);
    var es6Symbols;
    var j3;
    for (wellKnownSymbols = $keys(wks.store), k4 = 0; wellKnownSymbols.length > k4; ) wksDefine(wellKnownSymbols[k4++]);
    var wellKnownSymbols;
    var k4;
    $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
      // 19.4.2.1 Symbol.for(key)
      "for": function(key) {
        return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
      },
      // 19.4.2.5 Symbol.keyFor(sym)
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
        for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
      },
      useSetter: function() {
        setter = true;
      },
      useSimple: function() {
        setter = false;
      }
    });
    $export($export.S + $export.F * !USE_NATIVE, "Object", {
      // 19.1.2.2 Object.create(O [, Properties])
      create: $create,
      // 19.1.2.4 Object.defineProperty(O, P, Attributes)
      defineProperty: $defineProperty,
      // 19.1.2.3 Object.defineProperties(O, Properties)
      defineProperties: $defineProperties,
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
      // 19.1.2.7 Object.getOwnPropertyNames(O)
      getOwnPropertyNames: $getOwnPropertyNames,
      // 19.1.2.8 Object.getOwnPropertySymbols(O)
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
      var S3 = $Symbol();
      return _stringify([S3]) != "[null]" || _stringify({ a: S3 }) != "{}" || _stringify(Object(S3)) != "{}";
    })), "JSON", {
      stringify: function stringify(it) {
        var args = [it];
        var i4 = 1;
        var replacer, $replacer;
        while (arguments.length > i4) args.push(arguments[i4++]);
        $replacer = replacer = args[1];
        if (!isObject(replacer) && it === void 0 || isSymbol(it)) return;
        if (!isArray(replacer)) replacer = function(key, value) {
          if (typeof $replacer == "function") value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return _stringify.apply($JSON, args);
      }
    });
    $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide2()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
    setToStringTag($Symbol, "Symbol");
    setToStringTag(Math, "Math", true);
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js/library/modules/es6.object.to-string.js
var require_es6_object_to_string = __commonJS({
  "node_modules/core-js/library/modules/es6.object.to-string.js"() {
  }
});

// node_modules/core-js/library/modules/es7.symbol.async-iterator.js
var require_es7_symbol_async_iterator = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.async-iterator.js"() {
    require_wks_define()("asyncIterator");
  }
});

// node_modules/core-js/library/modules/es7.symbol.observable.js
var require_es7_symbol_observable = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.observable.js"() {
    require_wks_define()("observable");
  }
});

// node_modules/core-js/library/fn/symbol/index.js
var require_symbol = __commonJS({
  "node_modules/core-js/library/fn/symbol/index.js"(exports2, module2) {
    require_es6_symbol();
    require_es6_object_to_string();
    require_es7_symbol_async_iterator();
    require_es7_symbol_observable();
    module2.exports = require_core2().Symbol;
  }
});

// node_modules/babel-runtime/core-js/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol.js"(exports2, module2) {
    module2.exports = { "default": require_symbol(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/babel-runtime/helpers/typeof.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _iterator = require_iterator2();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _symbol = require_symbol2();
    var _symbol2 = _interopRequireDefault(_symbol);
    var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof(obj);
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
    };
  }
});

// node_modules/core-js/library/modules/_iter-call.js
var require_iter_call = __commonJS({
  "node_modules/core-js/library/modules/_iter-call.js"(exports2, module2) {
    var anObject = require_an_object2();
    module2.exports = function(iterator, fn, value, entries) {
      try {
        return entries ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (e3) {
        var ret = iterator["return"];
        if (ret !== void 0) anObject(ret.call(iterator));
        throw e3;
      }
    };
  }
});

// node_modules/core-js/library/modules/_is-array-iter.js
var require_is_array_iter = __commonJS({
  "node_modules/core-js/library/modules/_is-array-iter.js"(exports2, module2) {
    var Iterators = require_iterators();
    var ITERATOR = require_wks2()("iterator");
    var ArrayProto = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/library/modules/_create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/library/modules/_create-property.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_object_dp2();
    var createDesc = require_property_desc2();
    module2.exports = function(object, index, value) {
      if (index in object) $defineProperty.f(object, index, createDesc(0, value));
      else object[index] = value;
    };
  }
});

// node_modules/core-js/library/modules/_classof.js
var require_classof = __commonJS({
  "node_modules/core-js/library/modules/_classof.js"(exports2, module2) {
    var cof = require_cof2();
    var TAG = require_wks2()("toStringTag");
    var ARG = cof(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (e3) {
      }
    };
    module2.exports = function(it) {
      var O3, T2, B4;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T2 = tryGet(O3 = Object(it), TAG)) == "string" ? T2 : ARG ? cof(O3) : (B4 = cof(O3)) == "Object" && typeof O3.callee == "function" ? "Arguments" : B4;
    };
  }
});

// node_modules/core-js/library/modules/core.get-iterator-method.js
var require_core_get_iterator_method = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator-method.js"(exports2, module2) {
    var classof = require_classof();
    var ITERATOR = require_wks2()("iterator");
    var Iterators = require_iterators();
    module2.exports = require_core2().getIteratorMethod = function(it) {
      if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/library/modules/_iter-detect.js
var require_iter_detect = __commonJS({
  "node_modules/core-js/library/modules/_iter-detect.js"(exports2, module2) {
    var ITERATOR = require_wks2()("iterator");
    var SAFE_CLOSING = false;
    try {
      riter = [7][ITERATOR]();
      riter["return"] = function() {
        SAFE_CLOSING = true;
      };
      Array.from(riter, function() {
        throw 2;
      });
    } catch (e3) {
    }
    var riter;
    module2.exports = function(exec, skipClosing) {
      if (!skipClosing && !SAFE_CLOSING) return false;
      var safe = false;
      try {
        var arr = [7];
        var iter = arr[ITERATOR]();
        iter.next = function() {
          return { done: safe = true };
        };
        arr[ITERATOR] = function() {
          return iter;
        };
        exec(arr);
      } catch (e3) {
      }
      return safe;
    };
  }
});

// node_modules/core-js/library/modules/es6.array.from.js
var require_es6_array_from = __commonJS({
  "node_modules/core-js/library/modules/es6.array.from.js"() {
    "use strict";
    var ctx = require_ctx2();
    var $export = require_export2();
    var toObject = require_to_object2();
    var call = require_iter_call();
    var isArrayIter = require_is_array_iter();
    var toLength = require_to_length2();
    var createProperty = require_create_property();
    var getIterFn = require_core_get_iterator_method();
    $export($export.S + $export.F * !require_iter_detect()(function(iter) {
      Array.from(iter);
    }), "Array", {
      // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
      from: function from(arrayLike) {
        var O3 = toObject(arrayLike);
        var C3 = typeof this == "function" ? this : Array;
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var index = 0;
        var iterFn = getIterFn(O3);
        var length, result, step, iterator;
        if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
        if (iterFn != void 0 && !(C3 == Array && isArrayIter(iterFn))) {
          for (iterator = iterFn.call(O3), result = new C3(); !(step = iterator.next()).done; index++) {
            createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
          }
        } else {
          length = toLength(O3.length);
          for (result = new C3(length); length > index; index++) {
            createProperty(result, index, mapping ? mapfn(O3[index], index) : O3[index]);
          }
        }
        result.length = index;
        return result;
      }
    });
  }
});

// node_modules/core-js/library/fn/array/from.js
var require_from2 = __commonJS({
  "node_modules/core-js/library/fn/array/from.js"(exports2, module2) {
    require_es6_string_iterator();
    require_es6_array_from();
    module2.exports = require_core2().Array.from;
  }
});

// node_modules/babel-runtime/core-js/array/from.js
var require_from3 = __commonJS({
  "node_modules/babel-runtime/core-js/array/from.js"(exports2, module2) {
    module2.exports = { "default": require_from2(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/babel-runtime/helpers/toConsumableArray.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _from = require_from3();
    var _from2 = _interopRequireDefault(_from);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = function(arr) {
      if (Array.isArray(arr)) {
        for (var i4 = 0, arr2 = Array(arr.length); i4 < arr.length; i4++) {
          arr2[i4] = arr[i4];
        }
        return arr2;
      } else {
        return (0, _from2.default)(arr);
      }
    };
  }
});

// node_modules/flow-static-land/lib/Fun.js
var require_Fun2 = __commonJS({
  "node_modules/flow-static-land/lib/Fun.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.flip = flip;
    exports2.constant = constant;
    exports2.on = on;
    exports2.compose = compose;
    exports2.pipe = pipe;
    exports2.curry = curry;
    function flip(f3) {
      return function(b, a3) {
        return f3(a3, b);
      };
    }
    function constant(a3) {
      return function() {
        return a3;
      };
    }
    function on(o2, f3) {
      return function(x3, y3) {
        return o2(f3(x3), f3(y3));
      };
    }
    function compose() {
      var _this = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i = len; _i > -1; _i--) {
          y3 = fns[_i].call(_this, y3);
        }
        return y3;
      };
    }
    function pipe() {
      var _this2 = this;
      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fns[_key2] = arguments[_key2];
      }
      var len = fns.length - 1;
      return function(x3) {
        var y3 = x3;
        for (var _i2 = 0; _i2 <= len; _i2++) {
          y3 = fns[_i2].call(_this2, y3);
        }
        return y3;
      };
    }
    function curried(f3, length, acc) {
      return function() {
        var combined = acc.concat(Array.prototype.slice.call(arguments));
        return combined.length >= length ? f3.apply(this, combined) : curried(f3, length, combined);
      };
    }
    function curry(f3) {
      return curried(f3, f3.length, []);
    }
  }
});

// node_modules/core-js/library/modules/_object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/library/modules/_object-assign.js"(exports2, module2) {
    "use strict";
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    var toObject = require_to_object2();
    var IObject = require_iobject2();
    var $assign = Object.assign;
    module2.exports = !$assign || require_fails2()(function() {
      var A3 = {};
      var B4 = {};
      var S3 = Symbol();
      var K = "abcdefghijklmnopqrst";
      A3[S3] = 7;
      K.split("").forEach(function(k4) {
        B4[k4] = k4;
      });
      return $assign({}, A3)[S3] != 7 || Object.keys($assign({}, B4)).join("") != K;
    }) ? function assign(target, source) {
      var T2 = toObject(target);
      var aLen = arguments.length;
      var index = 1;
      var getSymbols = gOPS.f;
      var isEnum = pIE.f;
      while (aLen > index) {
        var S3 = IObject(arguments[index++]);
        var keys = getSymbols ? getKeys(S3).concat(getSymbols(S3)) : getKeys(S3);
        var length = keys.length;
        var j3 = 0;
        var key;
        while (length > j3) if (isEnum.call(S3, key = keys[j3++])) T2[key] = S3[key];
      }
      return T2;
    } : $assign;
  }
});

// node_modules/core-js/library/modules/es6.object.assign.js
var require_es6_object_assign = __commonJS({
  "node_modules/core-js/library/modules/es6.object.assign.js"() {
    var $export = require_export2();
    $export($export.S + $export.F, "Object", { assign: require_object_assign() });
  }
});

// node_modules/core-js/library/fn/object/assign.js
var require_assign = __commonJS({
  "node_modules/core-js/library/fn/object/assign.js"(exports2, module2) {
    require_es6_object_assign();
    module2.exports = require_core2().Object.assign;
  }
});

// node_modules/babel-runtime/core-js/object/assign.js
var require_assign2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/assign.js"(exports2, module2) {
    module2.exports = { "default": require_assign(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/babel-runtime/helpers/extends.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _assign = require_assign2();
    var _assign2 = _interopRequireDefault(_assign);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = _assign2.default || function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
  }
});

// node_modules/core-js/library/modules/_object-sap.js
var require_object_sap = __commonJS({
  "node_modules/core-js/library/modules/_object-sap.js"(exports2, module2) {
    var $export = require_export2();
    var core = require_core2();
    var fails = require_fails2();
    module2.exports = function(KEY, exec) {
      var fn = (core.Object || {})[KEY] || Object[KEY];
      var exp = {};
      exp[KEY] = exec(fn);
      $export($export.S + $export.F * fails(function() {
        fn(1);
      }), "Object", exp);
    };
  }
});

// node_modules/core-js/library/modules/es6.object.keys.js
var require_es6_object_keys = __commonJS({
  "node_modules/core-js/library/modules/es6.object.keys.js"() {
    var toObject = require_to_object2();
    var $keys = require_object_keys();
    require_object_sap()("keys", function() {
      return function keys(it) {
        return $keys(toObject(it));
      };
    });
  }
});

// node_modules/core-js/library/fn/object/keys.js
var require_keys = __commonJS({
  "node_modules/core-js/library/fn/object/keys.js"(exports2, module2) {
    require_es6_object_keys();
    module2.exports = require_core2().Object.keys;
  }
});

// node_modules/babel-runtime/core-js/object/keys.js
var require_keys2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/keys.js"(exports2, module2) {
    module2.exports = { "default": require_keys(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_is-integer.js
var require_is_integer = __commonJS({
  "node_modules/core-js/library/modules/_is-integer.js"(exports2, module2) {
    var isObject = require_is_object2();
    var floor = Math.floor;
    module2.exports = function isInteger(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js/library/modules/es6.number.is-integer.js
var require_es6_number_is_integer = __commonJS({
  "node_modules/core-js/library/modules/es6.number.is-integer.js"() {
    var $export = require_export2();
    $export($export.S, "Number", { isInteger: require_is_integer() });
  }
});

// node_modules/core-js/library/fn/number/is-integer.js
var require_is_integer2 = __commonJS({
  "node_modules/core-js/library/fn/number/is-integer.js"(exports2, module2) {
    require_es6_number_is_integer();
    module2.exports = require_core2().Number.isInteger;
  }
});

// node_modules/babel-runtime/core-js/number/is-integer.js
var require_is_integer3 = __commonJS({
  "node_modules/babel-runtime/core-js/number/is-integer.js"(exports2, module2) {
    module2.exports = { "default": require_is_integer2(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/babel-runtime/helpers/objectWithoutProperties.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.default = function(obj, keys) {
      var target = {};
      for (var i4 in obj) {
        if (keys.indexOf(i4) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i4)) continue;
        target[i4] = obj[i4];
      }
      return target;
    };
  }
});

// node_modules/@jumpn/utils-array/compat/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@jumpn/utils-array/compat/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var _toConsumableArray = _interopDefault(require_toConsumableArray());
    var _newArrowCheck = _interopDefault(require_newArrowCheck());
    var Fun = require_Fun2();
    var _extends = _interopDefault(require_extends());
    var _Array$from = _interopDefault(require_from3());
    var _Object$keys = _interopDefault(require_keys2());
    var _Number$isInteger = _interopDefault(require_is_integer3());
    var _objectWithoutProperties = _interopDefault(require_objectWithoutProperties());
    var _this = void 0;
    var append = function(elements, array) {
      _newArrowCheck(this, _this);
      return [].concat(_toConsumableArray(array), _toConsumableArray(elements));
    }.bind(void 0);
    var append$1 = Fun.curry(append);
    var _this$1 = void 0;
    var convertIfNot = function(input) {
      _newArrowCheck(this, _this$1);
      return Array.isArray(input) ? input : [input];
    }.bind(void 0);
    var _this$3 = void 0;
    var isLastIndex = function(array, index) {
      _newArrowCheck(this, _this$3);
      return index === array.length - 1;
    }.bind(void 0);
    var isLastIndex$1 = Fun.curry(isLastIndex);
    var _this$2 = void 0;
    var cycleNext = function(array, currentIndex) {
      _newArrowCheck(this, _this$2);
      return isLastIndex$1(array, currentIndex) ? 0 : currentIndex + 1;
    }.bind(void 0);
    var cycleNext$1 = Fun.curry(cycleNext);
    var _this$4 = void 0;
    var getObjectLength = function(object) {
      _newArrowCheck(this, _this$4);
      return Math.max.apply(Math, _toConsumableArray(_Object$keys(object))) + 1;
    }.bind(void 0);
    var fromObject = function(object) {
      _newArrowCheck(this, _this$4);
      return _Array$from("length" in object ? object : _extends({}, object, { length: getObjectLength(object) }));
    }.bind(void 0);
    var _this$5 = void 0;
    var insert = function(index, elements, array) {
      _newArrowCheck(this, _this$5);
      return [].concat(_toConsumableArray(array.slice(0, index)), _toConsumableArray(elements), _toConsumableArray(array.slice(index + 1)));
    }.bind(void 0);
    var insert$1 = Fun.curry(insert);
    var _this$6 = void 0;
    var isIntGreaterThan = function(number, other) {
      _newArrowCheck(this, _this$6);
      return _Number$isInteger(number) && number >= other;
    }.bind(void 0);
    var isKey = function(string) {
      _newArrowCheck(this, _this$6);
      return isIntGreaterThan(Number(string), 0);
    }.bind(void 0);
    var _this$7 = void 0;
    var isPossibleFromObject = function(_ref) {
      var length = _ref.length, rest = _objectWithoutProperties(_ref, ["length"]);
      _newArrowCheck(this, _this$7);
      return _Object$keys(rest).every(isKey);
    }.bind(void 0);
    var _this$8 = void 0;
    var prepend = function(elements, array) {
      _newArrowCheck(this, _this$8);
      return [].concat(_toConsumableArray(elements), _toConsumableArray(array));
    }.bind(void 0);
    var prepend$1 = Fun.curry(prepend);
    var _this$9 = void 0;
    var reduceIf = function(filter, reduce, resultInitial, array) {
      _newArrowCheck(this, _this$9);
      return array.reduce(function(result, element, index) {
        _newArrowCheck(this, _this$9);
        return filter(element, index, result) ? reduce(result, element, index) : result;
      }.bind(this), resultInitial);
    }.bind(void 0);
    var reduceIf$1 = Fun.curry(reduceIf);
    var _this$10 = void 0;
    var reduceWhile = function(shouldProceed, reduce, resultInitial, array) {
      _newArrowCheck(this, _this$10);
      var result = resultInitial;
      array.every(function(element, index) {
        _newArrowCheck(this, _this$10);
        var proceed = shouldProceed(element, index, result);
        if (proceed) {
          result = reduce(result, element, index);
        }
        return proceed;
      }.bind(this));
      return result;
    }.bind(void 0);
    var reduceWhile$1 = Fun.curry(reduceWhile);
    var _this$11 = void 0;
    var remove = function(index, count, array) {
      _newArrowCheck(this, _this$11);
      return [].concat(_toConsumableArray(array.slice(0, index)), _toConsumableArray(array.slice(index + count)));
    }.bind(void 0);
    var remove$1 = Fun.curry(remove);
    var _this$12 = void 0;
    var repeat = function(count, element) {
      _newArrowCheck(this, _this$12);
      return [].concat(_toConsumableArray(Array(count))).map(function() {
        _newArrowCheck(this, _this$12);
        return element;
      }.bind(this));
    }.bind(void 0);
    var repeat$1 = Fun.curry(repeat);
    var _this$13 = void 0;
    var replace = function(index, elements, array) {
      _newArrowCheck(this, _this$13);
      return [].concat(_toConsumableArray(array.slice(0, index)), _toConsumableArray(elements), _toConsumableArray(array.slice(index + elements.length)));
    }.bind(void 0);
    var replace$1 = Fun.curry(replace);
    var _this$14 = void 0;
    var resolveIndex = function(array, relativeIndex) {
      _newArrowCheck(this, _this$14);
      return relativeIndex < 0 ? array.length - relativeIndex : relativeIndex;
    }.bind(void 0);
    var resolveIndex$1 = Fun.curry(resolveIndex);
    exports2.append = append$1;
    exports2.convertIfNot = convertIfNot;
    exports2.cycleNext = cycleNext$1;
    exports2.fromObject = fromObject;
    exports2.insert = insert$1;
    exports2.isKey = isKey;
    exports2.isLastIndex = isLastIndex$1;
    exports2.isPossibleFromObject = isPossibleFromObject;
    exports2.prepend = prepend$1;
    exports2.reduceIf = reduceIf$1;
    exports2.reduceWhile = reduceWhile$1;
    exports2.remove = remove$1;
    exports2.repeat = repeat$1;
    exports2.replace = replace$1;
    exports2.resolveIndex = resolveIndex$1;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a3, b) {
      if (a3 === b) return true;
      var arrA = Array.isArray(a3), arrB = Array.isArray(b), i4;
      if (arrA && arrB) {
        if (a3.length != b.length) return false;
        for (i4 = 0; i4 < a3.length; i4++)
          if (!equal(a3[i4], b[i4])) return false;
        return true;
      }
      if (arrA != arrB) return false;
      if (a3 && b && typeof a3 === "object" && typeof b === "object") {
        var keys = Object.keys(a3);
        if (keys.length !== Object.keys(b).length) return false;
        var dateA = a3 instanceof Date, dateB = b instanceof Date;
        if (dateA && dateB) return a3.getTime() == b.getTime();
        if (dateA != dateB) return false;
        var regexpA = a3 instanceof RegExp, regexpB = b instanceof RegExp;
        if (regexpA && regexpB) return a3.toString() == b.toString();
        if (regexpA != regexpB) return false;
        for (i4 = 0; i4 < keys.length; i4++)
          if (!Object.prototype.hasOwnProperty.call(b, keys[i4])) return false;
        for (i4 = 0; i4 < keys.length; i4++)
          if (!equal(a3[keys[i4]], b[keys[i4]])) return false;
        return true;
      }
      return false;
    };
  }
});

// node_modules/core-js/library/modules/es6.object.define-property.js
var require_es6_object_define_property = __commonJS({
  "node_modules/core-js/library/modules/es6.object.define-property.js"() {
    var $export = require_export2();
    $export($export.S + $export.F * !require_descriptors2(), "Object", { defineProperty: require_object_dp2().f });
  }
});

// node_modules/core-js/library/fn/object/define-property.js
var require_define_property = __commonJS({
  "node_modules/core-js/library/fn/object/define-property.js"(exports2, module2) {
    require_es6_object_define_property();
    var $Object = require_core2().Object;
    module2.exports = function defineProperty(it, key, desc) {
      return $Object.defineProperty(it, key, desc);
    };
  }
});

// node_modules/babel-runtime/core-js/object/define-property.js
var require_define_property2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/define-property.js"(exports2, module2) {
    module2.exports = { "default": require_define_property(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/babel-runtime/helpers/defineProperty.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _defineProperty = require_define_property2();
    var _defineProperty2 = _interopRequireDefault(_defineProperty);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = function(obj, key, value) {
      if (key in obj) {
        (0, _defineProperty2.default)(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
  }
});

// node_modules/core-js/library/modules/core.is-iterable.js
var require_core_is_iterable = __commonJS({
  "node_modules/core-js/library/modules/core.is-iterable.js"(exports2, module2) {
    var classof = require_classof();
    var ITERATOR = require_wks2()("iterator");
    var Iterators = require_iterators();
    module2.exports = require_core2().isIterable = function(it) {
      var O3 = Object(it);
      return O3[ITERATOR] !== void 0 || "@@iterator" in O3 || Iterators.hasOwnProperty(classof(O3));
    };
  }
});

// node_modules/core-js/library/fn/is-iterable.js
var require_is_iterable = __commonJS({
  "node_modules/core-js/library/fn/is-iterable.js"(exports2, module2) {
    require_web_dom_iterable();
    require_es6_string_iterator();
    module2.exports = require_core_is_iterable();
  }
});

// node_modules/babel-runtime/core-js/is-iterable.js
var require_is_iterable2 = __commonJS({
  "node_modules/babel-runtime/core-js/is-iterable.js"(exports2, module2) {
    module2.exports = { "default": require_is_iterable(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/core.get-iterator.js
var require_core_get_iterator = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator.js"(exports2, module2) {
    var anObject = require_an_object2();
    var get = require_core_get_iterator_method();
    module2.exports = require_core2().getIterator = function(it) {
      var iterFn = get(it);
      if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
      return anObject(iterFn.call(it));
    };
  }
});

// node_modules/core-js/library/fn/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/library/fn/get-iterator.js"(exports2, module2) {
    require_web_dom_iterable();
    require_es6_string_iterator();
    module2.exports = require_core_get_iterator();
  }
});

// node_modules/babel-runtime/core-js/get-iterator.js
var require_get_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/get-iterator.js"(exports2, module2) {
    module2.exports = { "default": require_get_iterator(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/babel-runtime/helpers/slicedToArray.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _isIterable2 = require_is_iterable2();
    var _isIterable3 = _interopRequireDefault(_isIterable2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = /* @__PURE__ */ function() {
      function sliceIterator(arr, i4) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i4 && _arr.length === i4) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i4) {
        if (Array.isArray(arr)) {
          return arr;
        } else if ((0, _isIterable3.default)(Object(arr))) {
          return sliceIterator(arr, i4);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
  }
});

// node_modules/core-js/library/modules/_object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js/library/modules/_object-to-array.js"(exports2, module2) {
    var getKeys = require_object_keys();
    var toIObject = require_to_iobject();
    var isEnum = require_object_pie().f;
    module2.exports = function(isEntries) {
      return function(it) {
        var O3 = toIObject(it);
        var keys = getKeys(O3);
        var length = keys.length;
        var i4 = 0;
        var result = [];
        var key;
        while (length > i4) if (isEnum.call(O3, key = keys[i4++])) {
          result.push(isEntries ? [key, O3[key]] : O3[key]);
        }
        return result;
      };
    };
  }
});

// node_modules/core-js/library/modules/es7.object.entries.js
var require_es7_object_entries = __commonJS({
  "node_modules/core-js/library/modules/es7.object.entries.js"() {
    var $export = require_export2();
    var $entries = require_object_to_array()(true);
    $export($export.S, "Object", {
      entries: function entries(it) {
        return $entries(it);
      }
    });
  }
});

// node_modules/core-js/library/fn/object/entries.js
var require_entries = __commonJS({
  "node_modules/core-js/library/fn/object/entries.js"(exports2, module2) {
    require_es7_object_entries();
    module2.exports = require_core2().Object.entries;
  }
});

// node_modules/babel-runtime/core-js/object/entries.js
var require_entries2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/entries.js"(exports2, module2) {
    module2.exports = { "default": require_entries(), __esModule: true };
  }
});

// node_modules/@jumpn/utils-composite/compat/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@jumpn/utils-composite/compat/cjs/index.js"(exports2) {
    "use strict";
    function _interopDefault(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3.default : e3;
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _newArrowCheck = _interopDefault(require_newArrowCheck());
    var Fun = require_Fun();
    var _typeof = _interopDefault(require_typeof());
    var utilsArray = require_cjs3();
    var _Object$keys = _interopDefault(require_keys2());
    var _toConsumableArray = _interopDefault(require_toConsumableArray());
    var isDeepEqual = _interopDefault(require_fast_deep_equal());
    var _defineProperty = _interopDefault(require_defineProperty());
    var _extends = _interopDefault(require_extends());
    var _slicedToArray = _interopDefault(require_slicedToArray());
    var _Object$entries = _interopDefault(require_entries2());
    var _objectWithoutProperties = _interopDefault(require_objectWithoutProperties());
    var _Symbol = _interopDefault(require_symbol2());
    var _this = void 0;
    var get = function(e3, r3) {
      return _newArrowCheck(this, _this), r3[e3];
    }.bind(void 0);
    var get$1 = Fun.curry(get);
    var _this$2 = void 0;
    var isObject = function(e3) {
      return _newArrowCheck(this, _this$2), null !== e3 && "object" === (void 0 === e3 ? "undefined" : _typeof(e3));
    }.bind(void 0);
    var is = function(e3) {
      return _newArrowCheck(this, _this$2), Array.isArray(e3) || isObject(e3);
    }.bind(void 0);
    var _this$1 = void 0;
    var getInIfNeeded = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$1), utilsArray.isLastIndex(r3, e3) ? t3 : getInRecur(e3 + 1, r3, t3);
    }.bind(void 0);
    var getNotCompositeErrorMessage = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$1), "Expected to find a composite at [" + String(r3.join(", ")) + "][" + String(e3) + "], but instead got: " + (void 0 === t3 ? "undefined" : _typeof(t3));
    }.bind(void 0);
    var ensureIsComposite = function(e3, r3, t3) {
      if (_newArrowCheck(this, _this$1), is(t3)) return t3;
      throw new Error(getNotCompositeErrorMessage(e3, r3, t3));
    }.bind(void 0);
    var getInRecur = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$1), void 0 === t3 ? void 0 : getInIfNeeded(e3, r3, get$1(r3[e3], ensureIsComposite(e3, r3, t3)));
    }.bind(void 0);
    var getIn = function(e3, r3) {
      return _newArrowCheck(this, _this$1), 0 === e3.length ? void 0 : getInRecur(0, e3, r3);
    }.bind(void 0);
    var getIn$1 = Fun.curry(getIn);
    var _this$3 = void 0;
    var getKeys = function(e3) {
      return _newArrowCheck(this, _this$3), Array.isArray(e3) ? [].concat(_toConsumableArray(e3.keys())) : _Object$keys(e3);
    }.bind(void 0);
    var _this$4 = void 0;
    var hasIn = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$4), isDeepEqual(getIn$1(e3, t3), r3);
    }.bind(void 0);
    var hasIn$1 = Fun.curry(hasIn);
    var _this$5 = void 0;
    var hasKey = function(e3, r3) {
      return _newArrowCheck(this, _this$5), Object.prototype.hasOwnProperty.call(r3, e3);
    }.bind(void 0);
    var hasKey$1 = Fun.curry(hasKey);
    var _this$6 = void 0;
    var haveSameProps = function(e3, r3) {
      _newArrowCheck(this, _this$6);
      var t3 = getKeys(e3);
      return t3.length === getKeys(r3).length && t3.every(function(t4) {
        return _newArrowCheck(this, _this$6), hasKey$1(t4, r3) && get$1(t4, e3) === get$1(t4, r3);
      }.bind(this));
    }.bind(void 0);
    var haveSameProps$1 = Fun.curry(haveSameProps);
    var _this$7 = void 0;
    var isEmpty = function(e3) {
      return _newArrowCheck(this, _this$7), 0 === getKeys(e3).length;
    }.bind(void 0);
    var _this$8 = void 0;
    var mapObject = function(e3, r3) {
      return _newArrowCheck(this, _this$8), _Object$entries(r3).reduce(function(t3, i4) {
        var n2 = _slicedToArray(i4, 2), o2 = n2[0], s3 = n2[1];
        return _newArrowCheck(this, _this$8), _extends({}, t3, _defineProperty({}, o2, e3(s3, o2, r3)));
      }.bind(this), {});
    }.bind(void 0);
    var map = function(e3, r3) {
      return _newArrowCheck(this, _this$8), Array.isArray(r3) ? r3.map(e3) : mapObject(e3, r3);
    }.bind(void 0);
    var map$1 = Fun.curry(map);
    var _this$9 = void 0;
    var objectRemove = function(e3, r3) {
      r3[e3];
      var t3 = _objectWithoutProperties(r3, [e3]);
      return _newArrowCheck(this, _this$9), t3;
    }.bind(void 0);
    var remove$1 = function(e3, r3) {
      return _newArrowCheck(this, _this$9), Array.isArray(r3) ? utilsArray.remove(e3, 1, r3) : objectRemove(e3, r3);
    }.bind(void 0);
    var remove$2 = Fun.curry(remove$1);
    var _this$12 = void 0;
    var shallowCopy = function(e3) {
      return _newArrowCheck(this, _this$12), Array.isArray(e3) ? [].concat(_toConsumableArray(e3)) : _extends({}, e3);
    }.bind(void 0);
    var _this$11 = void 0;
    var createReduceContext = function(e3) {
      _newArrowCheck(this, _this$11);
      var r3 = shallowCopy(e3);
      return { origin: r3, current: r3, previous: void 0 };
    }.bind(void 0);
    var set = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$11), t3[e3] = r3, get$1(e3, t3);
    }.bind(void 0);
    var updateSet = function(e3, r3, t3, i4) {
      return _newArrowCheck(this, _this$11), _extends({}, i4, { current: set(e3[r3], t3, i4.current), previous: i4.current });
    }.bind(void 0);
    var updateRemove = function(e3, r3, t3) {
      _newArrowCheck(this, _this$11);
      var i4 = remove$2(e3[r3], t3.current);
      return 0 === r3 ? _extends({}, t3, { current: i4, origin: i4 }) : _extends({}, t3, { previous: set(e3[r3 - 1], i4, t3.previous) });
    }.bind(void 0);
    var removeAction = _Symbol("composite.updateIn.removeAction");
    var update = function(e3, r3, t3, i4) {
      return _newArrowCheck(this, _this$11), t3 === removeAction ? updateRemove(e3, r3, i4) : updateSet(e3, r3, t3, i4);
    }.bind(void 0);
    var createSupporting = function(e3) {
      return _newArrowCheck(this, _this$11), "number" == typeof e3 ? [] : {};
    }.bind(void 0);
    var copyOrCreate = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$11), hasKey$1(e3, t3) ? shallowCopy(get$1(e3, t3)) : createSupporting(r3);
    }.bind(void 0);
    var getNext = function(e3, r3, t3, i4) {
      return _newArrowCheck(this, _this$11), utilsArray.isLastIndex(e3, t3) ? r3(get$1(e3[t3], i4)) : copyOrCreate(e3[t3], e3[t3 + 1], i4);
    }.bind(void 0);
    var getReducer = function(e3, r3) {
      return _newArrowCheck(this, _this$11), function(t3, i4, n2) {
        return _newArrowCheck(this, _this$11), update(e3, n2, getNext(e3, r3, n2, t3.current), t3);
      }.bind(this);
    }.bind(void 0);
    var updateIn = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$11), 0 === e3.length ? t3 : e3.reduce(getReducer(e3, r3), createReduceContext(t3)).origin;
    }.bind(void 0);
    var updateInCurried = Fun.curry(updateIn);
    updateInCurried.remove = removeAction;
    var _this$10 = void 0;
    var remove$3 = function() {
      return _newArrowCheck(this, _this$10), updateInCurried.remove;
    }.bind(void 0);
    var removeIn = function(e3, r3) {
      return _newArrowCheck(this, _this$10), updateInCurried(e3, remove$3, r3);
    }.bind(void 0);
    var removeIn$1 = Fun.curry(removeIn);
    var _this$13 = void 0;
    var set$1 = function(e3, r3, t3) {
      _newArrowCheck(this, _this$13);
      var i4 = shallowCopy(t3);
      return i4[e3] = r3, i4;
    }.bind(void 0);
    var set$2 = Fun.curry(set$1);
    var _this$14 = void 0;
    var setIn = function(e3, r3, t3) {
      return _newArrowCheck(this, _this$14), updateInCurried(e3, function() {
        return _newArrowCheck(this, _this$14), r3;
      }.bind(this), t3);
    }.bind(void 0);
    var setIn$1 = Fun.curry(setIn);
    var _this$15 = void 0;
    var xor = function(e3, r3) {
      return _newArrowCheck(this, _this$15), Boolean(Number(e3) ^ Number(r3));
    }.bind(void 0);
    var shallowEqual = function(e3, r3) {
      return _newArrowCheck(this, _this$15), e3 === r3 || !xor(Array.isArray(e3), Array.isArray(r3)) && haveSameProps$1(e3, r3);
    }.bind(void 0);
    var shallowEqual$1 = Fun.curry(shallowEqual);
    var _this$16 = void 0;
    var toUndefinedIfEmpty = function(e3) {
      return _newArrowCheck(this, _this$16), isEmpty(e3) ? void 0 : e3;
    }.bind(void 0);
    exports2.get = get$1, exports2.getIn = getIn$1, exports2.getKeys = getKeys, exports2.hasIn = hasIn$1, exports2.hasKey = hasKey$1, exports2.haveSameProps = haveSameProps$1, exports2.is = is, exports2.isEmpty = isEmpty, exports2.map = map$1, exports2.remove = remove$2, exports2.removeIn = removeIn$1, exports2.set = set$2, exports2.setIn = setIn$1, exports2.shallowCopy = shallowCopy, exports2.shallowEqual = shallowEqual$1, exports2.toUndefinedIfEmpty = toUndefinedIfEmpty, exports2.updateIn = updateInCurried;
  }
});

// node_modules/phoenix/priv/static/phoenix.cjs.js
var require_phoenix_cjs = __commonJS({
  "node_modules/phoenix/priv/static/phoenix.cjs.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var phoenix_exports = {};
    __export(phoenix_exports, {
      Channel: () => Channel2,
      LongPoll: () => LongPoll,
      Presence: () => Presence,
      Serializer: () => serializer_default,
      Socket: () => Socket2
    });
    module2.exports = __toCommonJS(phoenix_exports);
    var closure = (value) => {
      if (typeof value === "function") {
        return value;
      } else {
        let closure2 = function() {
          return value;
        };
        return closure2;
      }
    };
    var globalSelf = typeof self !== "undefined" ? self : null;
    var phxWindow = typeof window !== "undefined" ? window : null;
    var global2 = globalSelf || phxWindow || global2;
    var DEFAULT_VSN = "2.0.0";
    var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
    var DEFAULT_TIMEOUT = 1e4;
    var WS_CLOSE_NORMAL = 1e3;
    var CHANNEL_STATES = {
      closed: "closed",
      errored: "errored",
      joined: "joined",
      joining: "joining",
      leaving: "leaving"
    };
    var CHANNEL_EVENTS = {
      close: "phx_close",
      error: "phx_error",
      join: "phx_join",
      reply: "phx_reply",
      leave: "phx_leave"
    };
    var TRANSPORTS = {
      longpoll: "longpoll",
      websocket: "websocket"
    };
    var XHR_STATES = {
      complete: 4
    };
    var Push = class {
      constructor(channel, event, payload, timeout) {
        this.channel = channel;
        this.event = event;
        this.payload = payload || function() {
          return {};
        };
        this.receivedResp = null;
        this.timeout = timeout;
        this.timeoutTimer = null;
        this.recHooks = [];
        this.sent = false;
      }
      /**
       *
       * @param {number} timeout
       */
      resend(timeout) {
        this.timeout = timeout;
        this.reset();
        this.send();
      }
      /**
       *
       */
      send() {
        if (this.hasReceived("timeout")) {
          return;
        }
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
          topic: this.channel.topic,
          event: this.event,
          payload: this.payload(),
          ref: this.ref,
          join_ref: this.channel.joinRef()
        });
      }
      /**
       *
       * @param {*} status
       * @param {*} callback
       */
      receive(status, callback) {
        if (this.hasReceived(status)) {
          callback(this.receivedResp.response);
        }
        this.recHooks.push({ status, callback });
        return this;
      }
      /**
       * @private
       */
      reset() {
        this.cancelRefEvent();
        this.ref = null;
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
      }
      /**
       * @private
       */
      matchReceive({ status, response, _ref }) {
        this.recHooks.filter((h3) => h3.status === status).forEach((h3) => h3.callback(response));
      }
      /**
       * @private
       */
      cancelRefEvent() {
        if (!this.refEvent) {
          return;
        }
        this.channel.off(this.refEvent);
      }
      /**
       * @private
       */
      cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = null;
      }
      /**
       * @private
       */
      startTimeout() {
        if (this.timeoutTimer) {
          this.cancelTimeout();
        }
        this.ref = this.channel.socket.makeRef();
        this.refEvent = this.channel.replyEventName(this.ref);
        this.channel.on(this.refEvent, (payload) => {
          this.cancelRefEvent();
          this.cancelTimeout();
          this.receivedResp = payload;
          this.matchReceive(payload);
        });
        this.timeoutTimer = setTimeout(() => {
          this.trigger("timeout", {});
        }, this.timeout);
      }
      /**
       * @private
       */
      hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
      }
      /**
       * @private
       */
      trigger(status, response) {
        this.channel.trigger(this.refEvent, { status, response });
      }
    };
    var Timer = class {
      constructor(callback, timerCalc) {
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = null;
        this.tries = 0;
      }
      reset() {
        this.tries = 0;
        clearTimeout(this.timer);
      }
      /**
       * Cancels any previous scheduleTimeout and schedules callback
       */
      scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.tries = this.tries + 1;
          this.callback();
        }, this.timerCalc(this.tries + 1));
      }
    };
    var Channel2 = class {
      constructor(topic, params, socket) {
        this.state = CHANNEL_STATES.closed;
        this.topic = topic;
        this.params = closure(params || {});
        this.socket = socket;
        this.bindings = [];
        this.bindingRef = 0;
        this.timeout = this.socket.timeout;
        this.joinedOnce = false;
        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
        this.pushBuffer = [];
        this.stateChangeRefs = [];
        this.rejoinTimer = new Timer(() => {
          if (this.socket.isConnected()) {
            this.rejoin();
          }
        }, this.socket.rejoinAfterMs);
        this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
        this.stateChangeRefs.push(
          this.socket.onOpen(() => {
            this.rejoinTimer.reset();
            if (this.isErrored()) {
              this.rejoin();
            }
          })
        );
        this.joinPush.receive("ok", () => {
          this.state = CHANNEL_STATES.joined;
          this.rejoinTimer.reset();
          this.pushBuffer.forEach((pushEvent) => pushEvent.send());
          this.pushBuffer = [];
        });
        this.joinPush.receive("error", () => {
          this.state = CHANNEL_STATES.errored;
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.onClose(() => {
          this.rejoinTimer.reset();
          if (this.socket.hasLogger())
            this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
          this.state = CHANNEL_STATES.closed;
          this.socket.remove(this);
        });
        this.onError((reason) => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `error ${this.topic}`, reason);
          if (this.isJoining()) {
            this.joinPush.reset();
          }
          this.state = CHANNEL_STATES.errored;
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.joinPush.receive("timeout", () => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
          let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
          leavePush.send();
          this.state = CHANNEL_STATES.errored;
          this.joinPush.reset();
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
          this.trigger(this.replyEventName(ref), payload);
        });
      }
      /**
       * Join the channel
       * @param {integer} timeout
       * @returns {Push}
       */
      join(timeout = this.timeout) {
        if (this.joinedOnce) {
          throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
        } else {
          this.timeout = timeout;
          this.joinedOnce = true;
          this.rejoin();
          return this.joinPush;
        }
      }
      /**
       * Hook into channel close
       * @param {Function} callback
       */
      onClose(callback) {
        this.on(CHANNEL_EVENTS.close, callback);
      }
      /**
       * Hook into channel errors
       * @param {Function} callback
       */
      onError(callback) {
        return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
      }
      /**
       * Subscribes on channel events
       *
       * Subscription returns a ref counter, which can be used later to
       * unsubscribe the exact event listener
       *
       * @example
       * const ref1 = channel.on("event", do_stuff)
       * const ref2 = channel.on("event", do_other_stuff)
       * channel.off("event", ref1)
       * // Since unsubscription, do_stuff won't fire,
       * // while do_other_stuff will keep firing on the "event"
       *
       * @param {string} event
       * @param {Function} callback
       * @returns {integer} ref
       */
      on(event, callback) {
        let ref = this.bindingRef++;
        this.bindings.push({ event, ref, callback });
        return ref;
      }
      /**
       * Unsubscribes off of channel events
       *
       * Use the ref returned from a channel.on() to unsubscribe one
       * handler, or pass nothing for the ref to unsubscribe all
       * handlers for the given event.
       *
       * @example
       * // Unsubscribe the do_stuff handler
       * const ref1 = channel.on("event", do_stuff)
       * channel.off("event", ref1)
       *
       * // Unsubscribe all handlers from event
       * channel.off("event")
       *
       * @param {string} event
       * @param {integer} ref
       */
      off(event, ref) {
        this.bindings = this.bindings.filter((bind) => {
          return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
        });
      }
      /**
       * @private
       */
      canPush() {
        return this.socket.isConnected() && this.isJoined();
      }
      /**
       * Sends a message `event` to phoenix with the payload `payload`.
       * Phoenix receives this in the `handle_in(event, payload, socket)`
       * function. if phoenix replies or it times out (default 10000ms),
       * then optionally the reply can be received.
       *
       * @example
       * channel.push("event")
       *   .receive("ok", payload => console.log("phoenix replied:", payload))
       *   .receive("error", err => console.log("phoenix errored", err))
       *   .receive("timeout", () => console.log("timed out pushing"))
       * @param {string} event
       * @param {Object} payload
       * @param {number} [timeout]
       * @returns {Push}
       */
      push(event, payload, timeout = this.timeout) {
        payload = payload || {};
        if (!this.joinedOnce) {
          throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
        }
        let pushEvent = new Push(this, event, function() {
          return payload;
        }, timeout);
        if (this.canPush()) {
          pushEvent.send();
        } else {
          pushEvent.startTimeout();
          this.pushBuffer.push(pushEvent);
        }
        return pushEvent;
      }
      /** Leaves the channel
       *
       * Unsubscribes from server events, and
       * instructs channel to terminate on server
       *
       * Triggers onClose() hooks
       *
       * To receive leave acknowledgements, use the `receive`
       * hook to bind to the server ack, ie:
       *
       * @example
       * channel.leave().receive("ok", () => alert("left!") )
       *
       * @param {integer} timeout
       * @returns {Push}
       */
      leave(timeout = this.timeout) {
        this.rejoinTimer.reset();
        this.joinPush.cancelTimeout();
        this.state = CHANNEL_STATES.leaving;
        let onClose = () => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `leave ${this.topic}`);
          this.trigger(CHANNEL_EVENTS.close, "leave");
        };
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
        leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
        leavePush.send();
        if (!this.canPush()) {
          leavePush.trigger("ok", {});
        }
        return leavePush;
      }
      /**
       * Overridable message hook
       *
       * Receives all events for specialized message handling
       * before dispatching to the channel callbacks.
       *
       * Must return the payload, modified or unmodified
       * @param {string} event
       * @param {Object} payload
       * @param {integer} ref
       * @returns {Object}
       */
      onMessage(_event, payload, _ref) {
        return payload;
      }
      /**
       * @private
       */
      isMember(topic, event, payload, joinRef) {
        if (this.topic !== topic) {
          return false;
        }
        if (joinRef && joinRef !== this.joinRef()) {
          if (this.socket.hasLogger())
            this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
          return false;
        } else {
          return true;
        }
      }
      /**
       * @private
       */
      joinRef() {
        return this.joinPush.ref;
      }
      /**
       * @private
       */
      rejoin(timeout = this.timeout) {
        if (this.isLeaving()) {
          return;
        }
        this.socket.leaveOpenTopic(this.topic);
        this.state = CHANNEL_STATES.joining;
        this.joinPush.resend(timeout);
      }
      /**
       * @private
       */
      trigger(event, payload, ref, joinRef) {
        let handledPayload = this.onMessage(event, payload, ref, joinRef);
        if (payload && !handledPayload) {
          throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
        }
        let eventBindings = this.bindings.filter((bind) => bind.event === event);
        for (let i4 = 0; i4 < eventBindings.length; i4++) {
          let bind = eventBindings[i4];
          bind.callback(handledPayload, ref, joinRef || this.joinRef());
        }
      }
      /**
       * @private
       */
      replyEventName(ref) {
        return `chan_reply_${ref}`;
      }
      /**
       * @private
       */
      isClosed() {
        return this.state === CHANNEL_STATES.closed;
      }
      /**
       * @private
       */
      isErrored() {
        return this.state === CHANNEL_STATES.errored;
      }
      /**
       * @private
       */
      isJoined() {
        return this.state === CHANNEL_STATES.joined;
      }
      /**
       * @private
       */
      isJoining() {
        return this.state === CHANNEL_STATES.joining;
      }
      /**
       * @private
       */
      isLeaving() {
        return this.state === CHANNEL_STATES.leaving;
      }
    };
    var Ajax = class {
      static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
        if (global2.XDomainRequest) {
          let req = new global2.XDomainRequest();
          return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
        } else {
          let req = new global2.XMLHttpRequest();
          return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
        }
      }
      static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
        req.timeout = timeout;
        req.open(method, endPoint);
        req.onload = () => {
          let response = this.parseJSON(req.responseText);
          callback && callback(response);
        };
        if (ontimeout) {
          req.ontimeout = ontimeout;
        }
        req.onprogress = () => {
        };
        req.send(body);
        return req;
      }
      static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
        req.open(method, endPoint, true);
        req.timeout = timeout;
        req.setRequestHeader("Content-Type", accept);
        req.onerror = () => callback && callback(null);
        req.onreadystatechange = () => {
          if (req.readyState === XHR_STATES.complete && callback) {
            let response = this.parseJSON(req.responseText);
            callback(response);
          }
        };
        if (ontimeout) {
          req.ontimeout = ontimeout;
        }
        req.send(body);
        return req;
      }
      static parseJSON(resp) {
        if (!resp || resp === "") {
          return null;
        }
        try {
          return JSON.parse(resp);
        } catch (e3) {
          console && console.log("failed to parse JSON response", resp);
          return null;
        }
      }
      static serialize(obj, parentKey) {
        let queryStr = [];
        for (var key in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, key)) {
            continue;
          }
          let paramKey = parentKey ? `${parentKey}[${key}]` : key;
          let paramVal = obj[key];
          if (typeof paramVal === "object") {
            queryStr.push(this.serialize(paramVal, paramKey));
          } else {
            queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
          }
        }
        return queryStr.join("&");
      }
      static appendParams(url, params) {
        if (Object.keys(params).length === 0) {
          return url;
        }
        let prefix = url.match(/\?/) ? "&" : "?";
        return `${url}${prefix}${this.serialize(params)}`;
      }
    };
    var arrayBufferToBase64 = (buffer) => {
      let binary = "";
      let bytes = new Uint8Array(buffer);
      let len = bytes.byteLength;
      for (let i4 = 0; i4 < len; i4++) {
        binary += String.fromCharCode(bytes[i4]);
      }
      return btoa(binary);
    };
    var LongPoll = class {
      constructor(endPoint) {
        this.endPoint = null;
        this.token = null;
        this.skipHeartbeat = true;
        this.reqs = /* @__PURE__ */ new Set();
        this.awaitingBatchAck = false;
        this.currentBatch = null;
        this.currentBatchTimer = null;
        this.batchBuffer = [];
        this.onopen = function() {
        };
        this.onerror = function() {
        };
        this.onmessage = function() {
        };
        this.onclose = function() {
        };
        this.pollEndpoint = this.normalizeEndpoint(endPoint);
        this.readyState = SOCKET_STATES.connecting;
        setTimeout(() => this.poll(), 0);
      }
      normalizeEndpoint(endPoint) {
        return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
      }
      endpointURL() {
        return Ajax.appendParams(this.pollEndpoint, { token: this.token });
      }
      closeAndRetry(code, reason, wasClean) {
        this.close(code, reason, wasClean);
        this.readyState = SOCKET_STATES.connecting;
      }
      ontimeout() {
        this.onerror("timeout");
        this.closeAndRetry(1005, "timeout", false);
      }
      isActive() {
        return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
      }
      poll() {
        this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
          if (resp) {
            var { status, token, messages } = resp;
            this.token = token;
          } else {
            status = 0;
          }
          switch (status) {
            case 200:
              messages.forEach((msg) => {
                setTimeout(() => this.onmessage({ data: msg }), 0);
              });
              this.poll();
              break;
            case 204:
              this.poll();
              break;
            case 410:
              this.readyState = SOCKET_STATES.open;
              this.onopen({});
              this.poll();
              break;
            case 403:
              this.onerror(403);
              this.close(1008, "forbidden", false);
              break;
            case 0:
            case 500:
              this.onerror(500);
              this.closeAndRetry(1011, "internal server error", 500);
              break;
            default:
              throw new Error(`unhandled poll status ${status}`);
          }
        });
      }
      // we collect all pushes within the current event loop by
      // setTimeout 0, which optimizes back-to-back procedural
      // pushes against an empty buffer
      send(body) {
        if (typeof body !== "string") {
          body = arrayBufferToBase64(body);
        }
        if (this.currentBatch) {
          this.currentBatch.push(body);
        } else if (this.awaitingBatchAck) {
          this.batchBuffer.push(body);
        } else {
          this.currentBatch = [body];
          this.currentBatchTimer = setTimeout(() => {
            this.batchSend(this.currentBatch);
            this.currentBatch = null;
          }, 0);
        }
      }
      batchSend(messages) {
        this.awaitingBatchAck = true;
        this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
          this.awaitingBatchAck = false;
          if (!resp || resp.status !== 200) {
            this.onerror(resp && resp.status);
            this.closeAndRetry(1011, "internal server error", false);
          } else if (this.batchBuffer.length > 0) {
            this.batchSend(this.batchBuffer);
            this.batchBuffer = [];
          }
        });
      }
      close(code, reason, wasClean) {
        for (let req of this.reqs) {
          req.abort();
        }
        this.readyState = SOCKET_STATES.closed;
        let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
        this.batchBuffer = [];
        clearTimeout(this.currentBatchTimer);
        this.currentBatchTimer = null;
        if (typeof CloseEvent !== "undefined") {
          this.onclose(new CloseEvent("close", opts));
        } else {
          this.onclose(opts);
        }
      }
      ajax(method, contentType, body, onCallerTimeout, callback) {
        let req;
        let ontimeout = () => {
          this.reqs.delete(req);
          onCallerTimeout();
        };
        req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
          this.reqs.delete(req);
          if (this.isActive()) {
            callback(resp);
          }
        });
        this.reqs.add(req);
      }
    };
    var Presence = class {
      constructor(channel, opts = {}) {
        let events = opts.events || { state: "presence_state", diff: "presence_diff" };
        this.state = {};
        this.pendingDiffs = [];
        this.channel = channel;
        this.joinRef = null;
        this.caller = {
          onJoin: function() {
          },
          onLeave: function() {
          },
          onSync: function() {
          }
        };
        this.channel.on(events.state, (newState) => {
          let { onJoin, onLeave, onSync } = this.caller;
          this.joinRef = this.channel.joinRef();
          this.state = Presence.syncState(this.state, newState, onJoin, onLeave);
          this.pendingDiffs.forEach((diff) => {
            this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
          });
          this.pendingDiffs = [];
          onSync();
        });
        this.channel.on(events.diff, (diff) => {
          let { onJoin, onLeave, onSync } = this.caller;
          if (this.inPendingSyncState()) {
            this.pendingDiffs.push(diff);
          } else {
            this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
            onSync();
          }
        });
      }
      onJoin(callback) {
        this.caller.onJoin = callback;
      }
      onLeave(callback) {
        this.caller.onLeave = callback;
      }
      onSync(callback) {
        this.caller.onSync = callback;
      }
      list(by) {
        return Presence.list(this.state, by);
      }
      inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel.joinRef();
      }
      // lower-level public static API
      /**
       * Used to sync the list of presences on the server
       * with the client's state. An optional `onJoin` and `onLeave` callback can
       * be provided to react to changes in the client's local presences across
       * disconnects and reconnects with the server.
       *
       * @returns {Presence}
       */
      static syncState(currentState, newState, onJoin, onLeave) {
        let state = this.clone(currentState);
        let joins = {};
        let leaves = {};
        this.map(state, (key, presence) => {
          if (!newState[key]) {
            leaves[key] = presence;
          }
        });
        this.map(newState, (key, newPresence) => {
          let currentPresence = state[key];
          if (currentPresence) {
            let newRefs = newPresence.metas.map((m3) => m3.phx_ref);
            let curRefs = currentPresence.metas.map((m3) => m3.phx_ref);
            let joinedMetas = newPresence.metas.filter((m3) => curRefs.indexOf(m3.phx_ref) < 0);
            let leftMetas = currentPresence.metas.filter((m3) => newRefs.indexOf(m3.phx_ref) < 0);
            if (joinedMetas.length > 0) {
              joins[key] = newPresence;
              joins[key].metas = joinedMetas;
            }
            if (leftMetas.length > 0) {
              leaves[key] = this.clone(currentPresence);
              leaves[key].metas = leftMetas;
            }
          } else {
            joins[key] = newPresence;
          }
        });
        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
      }
      /**
       *
       * Used to sync a diff of presence join and leave
       * events from the server, as they happen. Like `syncState`, `syncDiff`
       * accepts optional `onJoin` and `onLeave` callbacks to react to a user
       * joining or leaving from a device.
       *
       * @returns {Presence}
       */
      static syncDiff(state, diff, onJoin, onLeave) {
        let { joins, leaves } = this.clone(diff);
        if (!onJoin) {
          onJoin = function() {
          };
        }
        if (!onLeave) {
          onLeave = function() {
          };
        }
        this.map(joins, (key, newPresence) => {
          let currentPresence = state[key];
          state[key] = this.clone(newPresence);
          if (currentPresence) {
            let joinedRefs = state[key].metas.map((m3) => m3.phx_ref);
            let curMetas = currentPresence.metas.filter((m3) => joinedRefs.indexOf(m3.phx_ref) < 0);
            state[key].metas.unshift(...curMetas);
          }
          onJoin(key, currentPresence, newPresence);
        });
        this.map(leaves, (key, leftPresence) => {
          let currentPresence = state[key];
          if (!currentPresence) {
            return;
          }
          let refsToRemove = leftPresence.metas.map((m3) => m3.phx_ref);
          currentPresence.metas = currentPresence.metas.filter((p2) => {
            return refsToRemove.indexOf(p2.phx_ref) < 0;
          });
          onLeave(key, currentPresence, leftPresence);
          if (currentPresence.metas.length === 0) {
            delete state[key];
          }
        });
        return state;
      }
      /**
       * Returns the array of presences, with selected metadata.
       *
       * @param {Object} presences
       * @param {Function} chooser
       *
       * @returns {Presence}
       */
      static list(presences, chooser) {
        if (!chooser) {
          chooser = function(key, pres) {
            return pres;
          };
        }
        return this.map(presences, (key, presence) => {
          return chooser(key, presence);
        });
      }
      // private
      static map(obj, func) {
        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
      }
      static clone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    };
    var serializer_default = {
      HEADER_LENGTH: 1,
      META_LENGTH: 4,
      KINDS: { push: 0, reply: 1, broadcast: 2 },
      encode(msg, callback) {
        if (msg.payload.constructor === ArrayBuffer) {
          return callback(this.binaryEncode(msg));
        } else {
          let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
          return callback(JSON.stringify(payload));
        }
      },
      decode(rawPayload, callback) {
        if (rawPayload.constructor === ArrayBuffer) {
          return callback(this.binaryDecode(rawPayload));
        } else {
          let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
          return callback({ join_ref, ref, topic, event, payload });
        }
      },
      // private
      binaryEncode(message) {
        let { join_ref, ref, event, topic, payload } = message;
        let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
        let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
        let view = new DataView(header);
        let offset = 0;
        view.setUint8(offset++, this.KINDS.push);
        view.setUint8(offset++, join_ref.length);
        view.setUint8(offset++, ref.length);
        view.setUint8(offset++, topic.length);
        view.setUint8(offset++, event.length);
        Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        var combined = new Uint8Array(header.byteLength + payload.byteLength);
        combined.set(new Uint8Array(header), 0);
        combined.set(new Uint8Array(payload), header.byteLength);
        return combined.buffer;
      },
      binaryDecode(buffer) {
        let view = new DataView(buffer);
        let kind = view.getUint8(0);
        let decoder = new TextDecoder();
        switch (kind) {
          case this.KINDS.push:
            return this.decodePush(buffer, view, decoder);
          case this.KINDS.reply:
            return this.decodeReply(buffer, view, decoder);
          case this.KINDS.broadcast:
            return this.decodeBroadcast(buffer, view, decoder);
        }
      },
      decodePush(buffer, view, decoder) {
        let joinRefSize = view.getUint8(1);
        let topicSize = view.getUint8(2);
        let eventSize = view.getUint8(3);
        let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
        offset = offset + joinRefSize;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        return { join_ref: joinRef, ref: null, topic, event, payload: data };
      },
      decodeReply(buffer, view, decoder) {
        let joinRefSize = view.getUint8(1);
        let refSize = view.getUint8(2);
        let topicSize = view.getUint8(3);
        let eventSize = view.getUint8(4);
        let offset = this.HEADER_LENGTH + this.META_LENGTH;
        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
        offset = offset + joinRefSize;
        let ref = decoder.decode(buffer.slice(offset, offset + refSize));
        offset = offset + refSize;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        let payload = { status: event, response: data };
        return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
      },
      decodeBroadcast(buffer, view, decoder) {
        let topicSize = view.getUint8(1);
        let eventSize = view.getUint8(2);
        let offset = this.HEADER_LENGTH + 2;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        return { join_ref: null, ref: null, topic, event, payload: data };
      }
    };
    var Socket2 = class {
      constructor(endPoint, opts = {}) {
        this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
        this.channels = [];
        this.sendBuffer = [];
        this.ref = 0;
        this.timeout = opts.timeout || DEFAULT_TIMEOUT;
        this.transport = opts.transport || global2.WebSocket || LongPoll;
        this.primaryPassedHealthCheck = false;
        this.longPollFallbackMs = opts.longPollFallbackMs;
        this.fallbackTimer = null;
        this.sessionStore = opts.sessionStorage || global2 && global2.sessionStorage;
        this.establishedConnections = 0;
        this.defaultEncoder = serializer_default.encode.bind(serializer_default);
        this.defaultDecoder = serializer_default.decode.bind(serializer_default);
        this.closeWasClean = false;
        this.binaryType = opts.binaryType || "arraybuffer";
        this.connectClock = 1;
        if (this.transport !== LongPoll) {
          this.encode = opts.encode || this.defaultEncoder;
          this.decode = opts.decode || this.defaultDecoder;
        } else {
          this.encode = this.defaultEncoder;
          this.decode = this.defaultDecoder;
        }
        let awaitingConnectionOnPageShow = null;
        if (phxWindow && phxWindow.addEventListener) {
          phxWindow.addEventListener("pagehide", (_e) => {
            if (this.conn) {
              this.disconnect();
              awaitingConnectionOnPageShow = this.connectClock;
            }
          });
          phxWindow.addEventListener("pageshow", (_e) => {
            if (awaitingConnectionOnPageShow === this.connectClock) {
              awaitingConnectionOnPageShow = null;
              this.connect();
            }
          });
        }
        this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
        this.rejoinAfterMs = (tries) => {
          if (opts.rejoinAfterMs) {
            return opts.rejoinAfterMs(tries);
          } else {
            return [1e3, 2e3, 5e3][tries - 1] || 1e4;
          }
        };
        this.reconnectAfterMs = (tries) => {
          if (opts.reconnectAfterMs) {
            return opts.reconnectAfterMs(tries);
          } else {
            return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
          }
        };
        this.logger = opts.logger || null;
        if (!this.logger && opts.debug) {
          this.logger = (kind, msg, data) => {
            console.log(`${kind}: ${msg}`, data);
          };
        }
        this.longpollerTimeout = opts.longpollerTimeout || 2e4;
        this.params = closure(opts.params || {});
        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
        this.vsn = opts.vsn || DEFAULT_VSN;
        this.heartbeatTimeoutTimer = null;
        this.heartbeatTimer = null;
        this.pendingHeartbeatRef = null;
        this.reconnectTimer = new Timer(() => {
          this.teardown(() => this.connect());
        }, this.reconnectAfterMs);
      }
      /**
       * Returns the LongPoll transport reference
       */
      getLongPollTransport() {
        return LongPoll;
      }
      /**
       * Disconnects and replaces the active transport
       *
       * @param {Function} newTransport - The new transport class to instantiate
       *
       */
      replaceTransport(newTransport) {
        this.connectClock++;
        this.closeWasClean = true;
        clearTimeout(this.fallbackTimer);
        this.reconnectTimer.reset();
        if (this.conn) {
          this.conn.close();
          this.conn = null;
        }
        this.transport = newTransport;
      }
      /**
       * Returns the socket protocol
       *
       * @returns {string}
       */
      protocol() {
        return location.protocol.match(/^https/) ? "wss" : "ws";
      }
      /**
       * The fully qualified socket url
       *
       * @returns {string}
       */
      endPointURL() {
        let uri = Ajax.appendParams(
          Ajax.appendParams(this.endPoint, this.params()),
          { vsn: this.vsn }
        );
        if (uri.charAt(0) !== "/") {
          return uri;
        }
        if (uri.charAt(1) === "/") {
          return `${this.protocol()}:${uri}`;
        }
        return `${this.protocol()}://${location.host}${uri}`;
      }
      /**
       * Disconnects the socket
       *
       * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
       *
       * @param {Function} callback - Optional callback which is called after socket is disconnected.
       * @param {integer} code - A status code for disconnection (Optional).
       * @param {string} reason - A textual description of the reason to disconnect. (Optional)
       */
      disconnect(callback, code, reason) {
        this.connectClock++;
        this.closeWasClean = true;
        clearTimeout(this.fallbackTimer);
        this.reconnectTimer.reset();
        this.teardown(callback, code, reason);
      }
      /**
       *
       * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
       *
       * Passing params to connect is deprecated; pass them in the Socket constructor instead:
       * `new Socket("/socket", {params: {user_id: userToken}})`.
       */
      connect(params) {
        if (params) {
          console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
          this.params = closure(params);
        }
        if (this.conn) {
          return;
        }
        if (this.longPollFallbackMs && this.transport !== LongPoll) {
          this.connectWithFallback(LongPoll, this.longPollFallbackMs);
        } else {
          this.transportConnect();
        }
      }
      /**
       * Logs the message. Override `this.logger` for specialized logging. noops by default
       * @param {string} kind
       * @param {string} msg
       * @param {Object} data
       */
      log(kind, msg, data) {
        this.logger && this.logger(kind, msg, data);
      }
      /**
       * Returns true if a logger has been set on this socket.
       */
      hasLogger() {
        return this.logger !== null;
      }
      /**
       * Registers callbacks for connection open events
       *
       * @example socket.onOpen(function(){ console.info("the socket was opened") })
       *
       * @param {Function} callback
       */
      onOpen(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.open.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection close events
       * @param {Function} callback
       */
      onClose(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.close.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection error events
       *
       * @example socket.onError(function(error){ alert("An error occurred") })
       *
       * @param {Function} callback
       */
      onError(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.error.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection message events
       * @param {Function} callback
       */
      onMessage(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.message.push([ref, callback]);
        return ref;
      }
      /**
       * Pings the server and invokes the callback with the RTT in milliseconds
       * @param {Function} callback
       *
       * Returns true if the ping was pushed or false if unable to be pushed.
       */
      ping(callback) {
        if (!this.isConnected()) {
          return false;
        }
        let ref = this.makeRef();
        let startTime = Date.now();
        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
        let onMsgRef = this.onMessage((msg) => {
          if (msg.ref === ref) {
            this.off([onMsgRef]);
            callback(Date.now() - startTime);
          }
        });
        return true;
      }
      /**
       * @private
       */
      transportConnect() {
        this.connectClock++;
        this.closeWasClean = false;
        this.conn = new this.transport(this.endPointURL());
        this.conn.binaryType = this.binaryType;
        this.conn.timeout = this.longpollerTimeout;
        this.conn.onopen = () => this.onConnOpen();
        this.conn.onerror = (error) => this.onConnError(error);
        this.conn.onmessage = (event) => this.onConnMessage(event);
        this.conn.onclose = (event) => this.onConnClose(event);
      }
      getSession(key) {
        return this.sessionStore && this.sessionStore.getItem(key);
      }
      storeSession(key, val) {
        this.sessionStore && this.sessionStore.setItem(key, val);
      }
      connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
        clearTimeout(this.fallbackTimer);
        let established = false;
        let primaryTransport = true;
        let openRef, errorRef;
        let fallback = (reason) => {
          this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
          this.off([openRef, errorRef]);
          primaryTransport = false;
          this.replaceTransport(fallbackTransport);
          this.transportConnect();
        };
        if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
          return fallback("memorized");
        }
        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
        errorRef = this.onError((reason) => {
          this.log("transport", "error", reason);
          if (primaryTransport && !established) {
            clearTimeout(this.fallbackTimer);
            fallback(reason);
          }
        });
        this.onOpen(() => {
          established = true;
          if (!primaryTransport) {
            if (!this.primaryPassedHealthCheck) {
              this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
            }
            return this.log("transport", `established ${fallbackTransport.name} fallback`);
          }
          clearTimeout(this.fallbackTimer);
          this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
          this.ping((rtt) => {
            this.log("transport", "connected to primary after", rtt);
            this.primaryPassedHealthCheck = true;
            clearTimeout(this.fallbackTimer);
          });
        });
        this.transportConnect();
      }
      clearHeartbeats() {
        clearTimeout(this.heartbeatTimer);
        clearTimeout(this.heartbeatTimeoutTimer);
      }
      onConnOpen() {
        if (this.hasLogger())
          this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
        this.closeWasClean = false;
        this.establishedConnections++;
        this.flushSendBuffer();
        this.reconnectTimer.reset();
        this.resetHeartbeat();
        this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
      }
      /**
       * @private
       */
      heartbeatTimeout() {
        if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
          if (this.hasLogger()) {
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          }
          this.triggerChanError();
          this.closeWasClean = false;
          this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
        }
      }
      resetHeartbeat() {
        if (this.conn && this.conn.skipHeartbeat) {
          return;
        }
        this.pendingHeartbeatRef = null;
        this.clearHeartbeats();
        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      teardown(callback, code, reason) {
        if (!this.conn) {
          return callback && callback();
        }
        this.waitForBufferDone(() => {
          if (this.conn) {
            if (code) {
              this.conn.close(code, reason || "");
            } else {
              this.conn.close();
            }
          }
          this.waitForSocketClosed(() => {
            if (this.conn) {
              this.conn.onopen = function() {
              };
              this.conn.onerror = function() {
              };
              this.conn.onmessage = function() {
              };
              this.conn.onclose = function() {
              };
              this.conn = null;
            }
            callback && callback();
          });
        });
      }
      waitForBufferDone(callback, tries = 1) {
        if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
          callback();
          return;
        }
        setTimeout(() => {
          this.waitForBufferDone(callback, tries + 1);
        }, 150 * tries);
      }
      waitForSocketClosed(callback, tries = 1) {
        if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
          callback();
          return;
        }
        setTimeout(() => {
          this.waitForSocketClosed(callback, tries + 1);
        }, 150 * tries);
      }
      onConnClose(event) {
        let closeCode = event && event.code;
        if (this.hasLogger())
          this.log("transport", "close", event);
        this.triggerChanError();
        this.clearHeartbeats();
        if (!this.closeWasClean && closeCode !== 1e3) {
          this.reconnectTimer.scheduleTimeout();
        }
        this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
      }
      /**
       * @private
       */
      onConnError(error) {
        if (this.hasLogger())
          this.log("transport", error);
        let transportBefore = this.transport;
        let establishedBefore = this.establishedConnections;
        this.stateChangeCallbacks.error.forEach(([, callback]) => {
          callback(error, transportBefore, establishedBefore);
        });
        if (transportBefore === this.transport || establishedBefore > 0) {
          this.triggerChanError();
        }
      }
      /**
       * @private
       */
      triggerChanError() {
        this.channels.forEach((channel) => {
          if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
            channel.trigger(CHANNEL_EVENTS.error);
          }
        });
      }
      /**
       * @returns {string}
       */
      connectionState() {
        switch (this.conn && this.conn.readyState) {
          case SOCKET_STATES.connecting:
            return "connecting";
          case SOCKET_STATES.open:
            return "open";
          case SOCKET_STATES.closing:
            return "closing";
          default:
            return "closed";
        }
      }
      /**
       * @returns {boolean}
       */
      isConnected() {
        return this.connectionState() === "open";
      }
      /**
       * @private
       *
       * @param {Channel}
       */
      remove(channel) {
        this.off(channel.stateChangeRefs);
        this.channels = this.channels.filter((c3) => c3 !== channel);
      }
      /**
       * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
       *
       * @param {refs} - list of refs returned by calls to
       *                 `onOpen`, `onClose`, `onError,` and `onMessage`
       */
      off(refs) {
        for (let key in this.stateChangeCallbacks) {
          this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
            return refs.indexOf(ref) === -1;
          });
        }
      }
      /**
       * Initiates a new channel for the given topic
       *
       * @param {string} topic
       * @param {Object} chanParams - Parameters for the channel
       * @returns {Channel}
       */
      channel(topic, chanParams = {}) {
        let chan = new Channel2(topic, chanParams, this);
        this.channels.push(chan);
        return chan;
      }
      /**
       * @param {Object} data
       */
      push(data) {
        if (this.hasLogger()) {
          let { topic, event, payload, ref, join_ref } = data;
          this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
        }
        if (this.isConnected()) {
          this.encode(data, (result) => this.conn.send(result));
        } else {
          this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
        }
      }
      /**
       * Return the next message ref, accounting for overflows
       * @returns {string}
       */
      makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) {
          this.ref = 0;
        } else {
          this.ref = newRef;
        }
        return this.ref.toString();
      }
      sendHeartbeat() {
        if (this.pendingHeartbeatRef && !this.isConnected()) {
          return;
        }
        this.pendingHeartbeatRef = this.makeRef();
        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
        this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
      }
      flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
          this.sendBuffer.forEach((callback) => callback());
          this.sendBuffer = [];
        }
      }
      onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg) => {
          let { topic, event, payload, ref, join_ref } = msg;
          if (ref && ref === this.pendingHeartbeatRef) {
            this.clearHeartbeats();
            this.pendingHeartbeatRef = null;
            this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
          }
          if (this.hasLogger())
            this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
          for (let i4 = 0; i4 < this.channels.length; i4++) {
            const channel = this.channels[i4];
            if (!channel.isMember(topic, event, payload, join_ref)) {
              continue;
            }
            channel.trigger(event, payload, ref, join_ref);
          }
          for (let i4 = 0; i4 < this.stateChangeCallbacks.message.length; i4++) {
            let [, callback] = this.stateChangeCallbacks.message[i4];
            callback(msg);
          }
        });
      }
      leaveOpenTopic(topic) {
        let dupChannel = this.channels.find((c3) => c3.topic === topic && (c3.isJoined() || c3.isJoining()));
        if (dupChannel) {
          if (this.hasLogger())
            this.log("transport", `leaving duplicate topic "${topic}"`);
          dupChannel.leave();
        }
      }
    };
  }
});

// node_modules/core-js/modules/_iter-step.js
var require_iter_step2 = __commonJS({
  "node_modules/core-js/modules/_iter-step.js"(exports2, module2) {
    module2.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/modules/_iterators.js
var require_iterators2 = __commonJS({
  "node_modules/core-js/modules/_iterators.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/modules/_to-iobject.js
var require_to_iobject2 = __commonJS({
  "node_modules/core-js/modules/_to-iobject.js"(exports2, module2) {
    var IObject = require_iobject();
    var defined = require_defined();
    module2.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/modules/_to-absolute-index.js
var require_to_absolute_index2 = __commonJS({
  "node_modules/core-js/modules/_to-absolute-index.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }
});

// node_modules/core-js/modules/_array-includes.js
var require_array_includes2 = __commonJS({
  "node_modules/core-js/modules/_array-includes.js"(exports2, module2) {
    var toIObject = require_to_iobject2();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index2();
    module2.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIObject($this);
        var length = toLength(O3.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O3[index++];
          if (value != value) return true;
        }
        else for (; length > index; index++) if (IS_INCLUDES || index in O3) {
          if (O3[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/modules/_shared-key.js
var require_shared_key2 = __commonJS({
  "node_modules/core-js/modules/_shared-key.js"(exports2, module2) {
    var shared = require_shared()("keys");
    var uid = require_uid();
    module2.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/modules/_object-keys-internal.js
var require_object_keys_internal2 = __commonJS({
  "node_modules/core-js/modules/_object-keys-internal.js"(exports2, module2) {
    var has = require_has();
    var toIObject = require_to_iobject2();
    var arrayIndexOf = require_array_includes2()(false);
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    module2.exports = function(object, names) {
      var O3 = toIObject(object);
      var i4 = 0;
      var result = [];
      var key;
      for (key in O3) if (key != IE_PROTO) has(O3, key) && result.push(key);
      while (names.length > i4) if (has(O3, key = names[i4++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/modules/_enum-bug-keys.js
var require_enum_bug_keys2 = __commonJS({
  "node_modules/core-js/modules/_enum-bug-keys.js"(exports2, module2) {
    module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/modules/_object-keys.js
var require_object_keys2 = __commonJS({
  "node_modules/core-js/modules/_object-keys.js"(exports2, module2) {
    var $keys = require_object_keys_internal2();
    var enumBugKeys = require_enum_bug_keys2();
    module2.exports = Object.keys || function keys(O3) {
      return $keys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/modules/_object-dps.js
var require_object_dps2 = __commonJS({
  "node_modules/core-js/modules/_object-dps.js"(exports2, module2) {
    var dP = require_object_dp();
    var anObject = require_an_object();
    var getKeys = require_object_keys2();
    module2.exports = require_descriptors() ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject(O3);
      var keys = getKeys(Properties);
      var length = keys.length;
      var i4 = 0;
      var P3;
      while (length > i4) dP.f(O3, P3 = keys[i4++], Properties[P3]);
      return O3;
    };
  }
});

// node_modules/core-js/modules/_html.js
var require_html2 = __commonJS({
  "node_modules/core-js/modules/_html.js"(exports2, module2) {
    var document2 = require_global().document;
    module2.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/modules/_object-create.js
var require_object_create2 = __commonJS({
  "node_modules/core-js/modules/_object-create.js"(exports2, module2) {
    var anObject = require_an_object();
    var dPs = require_object_dps2();
    var enumBugKeys = require_enum_bug_keys2();
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    var Empty = function() {
    };
    var PROTOTYPE = "prototype";
    var createDict = function() {
      var iframe = require_dom_create()("iframe");
      var i4 = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html2().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i4--) delete createDict[PROTOTYPE][enumBugKeys[i4]];
      return createDict();
    };
    module2.exports = Object.create || function create2(O3, Properties) {
      var result;
      if (O3 !== null) {
        Empty[PROTOTYPE] = anObject(O3);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    };
  }
});

// node_modules/core-js/modules/_set-to-string-tag.js
var require_set_to_string_tag2 = __commonJS({
  "node_modules/core-js/modules/_set-to-string-tag.js"(exports2, module2) {
    var def = require_object_dp().f;
    var has = require_has();
    var TAG = require_wks()("toStringTag");
    module2.exports = function(it, tag, stat2) {
      if (it && !has(it = stat2 ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/modules/_iter-create.js
var require_iter_create2 = __commonJS({
  "node_modules/core-js/modules/_iter-create.js"(exports2, module2) {
    "use strict";
    var create2 = require_object_create2();
    var descriptor = require_property_desc();
    var setToStringTag = require_set_to_string_tag2();
    var IteratorPrototype = {};
    require_hide()(IteratorPrototype, require_wks()("iterator"), function() {
      return this;
    });
    module2.exports = function(Constructor, NAME, next) {
      Constructor.prototype = create2(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME + " Iterator");
    };
  }
});

// node_modules/core-js/modules/_object-gpo.js
var require_object_gpo2 = __commonJS({
  "node_modules/core-js/modules/_object-gpo.js"(exports2, module2) {
    var has = require_has();
    var toObject = require_to_object();
    var IE_PROTO = require_shared_key2()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module2.exports = Object.getPrototypeOf || function(O3) {
      O3 = toObject(O3);
      if (has(O3, IE_PROTO)) return O3[IE_PROTO];
      if (typeof O3.constructor == "function" && O3 instanceof O3.constructor) {
        return O3.constructor.prototype;
      }
      return O3 instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/modules/_iter-define.js
var require_iter_define2 = __commonJS({
  "node_modules/core-js/modules/_iter-define.js"(exports2, module2) {
    "use strict";
    var LIBRARY = require_library();
    var $export = require_export();
    var redefine = require_redefine();
    var hide = require_hide();
    var Iterators = require_iterators2();
    var $iterCreate = require_iter_create2();
    var setToStringTag = require_set_to_string_tag2();
    var getPrototypeOf = require_object_gpo2();
    var ITERATOR = require_wks()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next);
      var getMethod = function(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch (kind) {
          case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }
        return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto = Base.prototype;
      var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
      var $default = $native || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
        }
      }
      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
        hide(proto, ITERATOR, $default);
      }
      Iterators[NAME] = $default;
      Iterators[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto)) redefine(proto, key, methods[key]);
        }
        else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/modules/es6.array.iterator.js
var require_es6_array_iterator2 = __commonJS({
  "node_modules/core-js/modules/es6.array.iterator.js"(exports2, module2) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    var step = require_iter_step2();
    var Iterators = require_iterators2();
    var toIObject = require_to_iobject2();
    module2.exports = require_iter_define2()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O3 = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O3 || index >= O3.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys") return step(0, index);
      if (kind == "values") return step(0, O3[index]);
      return step(0, [index, O3[index]]);
    }, "values");
    Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/modules/web.dom.iterable.js
var require_web_dom_iterable2 = __commonJS({
  "node_modules/core-js/modules/web.dom.iterable.js"() {
    var $iterators = require_es6_array_iterator2();
    var getKeys = require_object_keys2();
    var redefine = require_redefine();
    var global2 = require_global();
    var hide = require_hide();
    var Iterators = require_iterators2();
    var wks = require_wks();
    var ITERATOR = wks("iterator");
    var TO_STRING_TAG = wks("toStringTag");
    var ArrayValues = Iterators.Array;
    var DOMIterables = {
      CSSRuleList: true,
      // TODO: Not spec compliant, should be false.
      CSSStyleDeclaration: false,
      CSSValueList: false,
      ClientRectList: false,
      DOMRectList: false,
      DOMStringList: false,
      DOMTokenList: true,
      DataTransferItemList: false,
      FileList: false,
      HTMLAllCollection: false,
      HTMLCollection: false,
      HTMLFormElement: false,
      HTMLSelectElement: false,
      MediaList: true,
      // TODO: Not spec compliant, should be false.
      MimeTypeArray: false,
      NamedNodeMap: false,
      NodeList: true,
      PaintRequestList: false,
      Plugin: false,
      PluginArray: false,
      SVGLengthList: false,
      SVGNumberList: false,
      SVGPathSegList: false,
      SVGPointList: false,
      SVGStringList: false,
      SVGTransformList: false,
      SourceBufferList: false,
      StyleSheetList: true,
      // TODO: Not spec compliant, should be false.
      TextTrackCueList: false,
      TextTrackList: false,
      TouchList: false
    };
    for (collections = getKeys(DOMIterables), i4 = 0; i4 < collections.length; i4++) {
      NAME = collections[i4];
      explicit = DOMIterables[NAME];
      Collection = global2[NAME];
      proto = Collection && Collection.prototype;
      if (proto) {
        if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
        if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = ArrayValues;
        if (explicit) {
          for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
        }
      }
    }
    var NAME;
    var explicit;
    var Collection;
    var proto;
    var key;
    var collections;
    var i4;
  }
});

// node_modules/core-js/modules/_strict-method.js
var require_strict_method = __commonJS({
  "node_modules/core-js/modules/_strict-method.js"(exports2, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(method, arg) {
      return !!method && fails(function() {
        arg ? method.call(null, function() {
        }, 1) : method.call(null);
      });
    };
  }
});

// node_modules/core-js/modules/es6.array.for-each.js
var require_es6_array_for_each = __commonJS({
  "node_modules/core-js/modules/es6.array.for-each.js"() {
    "use strict";
    var $export = require_export();
    var $forEach = require_array_methods()(0);
    var STRICT = require_strict_method()([].forEach, true);
    $export($export.P + $export.F * !STRICT, "Array", {
      // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
      forEach: function forEach(callbackfn) {
        return $forEach(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports2, module2) {
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i4 = 0, arr2 = new Array(arr.length); i4 < arr.length; i4++) {
          arr2[i4] = arr[i4];
        }
        return arr2;
      }
    }
    module2.exports = _arrayWithoutHoles;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports2, module2) {
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    module2.exports = _iterableToArray;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports2, module2) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    module2.exports = _nonIterableSpread;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray2 = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports2, module2) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
    }
    module2.exports = _toConsumableArray;
  }
});

// node_modules/core-js/modules/es6.array.map.js
var require_es6_array_map = __commonJS({
  "node_modules/core-js/modules/es6.array.map.js"() {
    "use strict";
    var $export = require_export();
    var $map = require_array_methods()(1);
    $export($export.P + $export.F * !require_strict_method()([].map, true), "Array", {
      // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/_string-at.js
var require_string_at2 = __commonJS({
  "node_modules/core-js/modules/_string-at.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var defined = require_defined();
    module2.exports = function(TO_STRING) {
      return function(that, pos) {
        var s3 = String(defined(that));
        var i4 = toInteger(pos);
        var l3 = s3.length;
        var a3, b;
        if (i4 < 0 || i4 >= l3) return TO_STRING ? "" : void 0;
        a3 = s3.charCodeAt(i4);
        return a3 < 55296 || a3 > 56319 || i4 + 1 === l3 || (b = s3.charCodeAt(i4 + 1)) < 56320 || b > 57343 ? TO_STRING ? s3.charAt(i4) : a3 : TO_STRING ? s3.slice(i4, i4 + 2) : (a3 - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/modules/_advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/modules/_advance-string-index.js"(exports2, module2) {
    "use strict";
    var at = require_string_at2()(true);
    module2.exports = function(S3, index, unicode) {
      return index + (unicode ? at(S3, index).length : 1);
    };
  }
});

// node_modules/core-js/modules/_classof.js
var require_classof2 = __commonJS({
  "node_modules/core-js/modules/_classof.js"(exports2, module2) {
    var cof = require_cof();
    var TAG = require_wks()("toStringTag");
    var ARG = cof(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (e3) {
      }
    };
    module2.exports = function(it) {
      var O3, T2, B4;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T2 = tryGet(O3 = Object(it), TAG)) == "string" ? T2 : ARG ? cof(O3) : (B4 = cof(O3)) == "Object" && typeof O3.callee == "function" ? "Arguments" : B4;
    };
  }
});

// node_modules/core-js/modules/_regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/modules/_regexp-exec-abstract.js"(exports2, module2) {
    "use strict";
    var classof = require_classof2();
    var builtinExec = RegExp.prototype.exec;
    module2.exports = function(R2, S3) {
      var exec = R2.exec;
      if (typeof exec === "function") {
        var result = exec.call(R2, S3);
        if (typeof result !== "object") {
          throw new TypeError("RegExp exec method returned something other than an Object or null");
        }
        return result;
      }
      if (classof(R2) !== "RegExp") {
        throw new TypeError("RegExp#exec called on incompatible receiver");
      }
      return builtinExec.call(R2, S3);
    };
  }
});

// node_modules/core-js/modules/_flags.js
var require_flags = __commonJS({
  "node_modules/core-js/modules/_flags.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.unicode) result += "u";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// node_modules/core-js/modules/_regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/modules/_regexp-exec.js"(exports2, module2) {
    "use strict";
    var regexpFlags = require_flags();
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = String.prototype.replace;
    var patchedExec = nativeExec;
    var LAST_INDEX = "lastIndex";
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/, re2 = /b*/g;
      nativeExec.call(re1, "a");
      nativeExec.call(re2, "a");
      return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
    }();
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match, i4;
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + re.source + "$(?!\\s)", regexpFlags.call(re));
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
        match = nativeExec.call(re, str);
        if (UPDATES_LAST_INDEX_WRONG && match) {
          re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          nativeReplace.call(match[0], reCopy, function() {
            for (i4 = 1; i4 < arguments.length - 2; i4++) {
              if (arguments[i4] === void 0) match[i4] = void 0;
            }
          });
        }
        return match;
      };
    }
    module2.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es6.regexp.exec.js
var require_es6_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es6.regexp.exec.js"() {
    "use strict";
    var regexpExec = require_regexp_exec();
    require_export()({
      target: "RegExp",
      proto: true,
      forced: regexpExec !== /./.exec
    }, {
      exec: regexpExec
    });
  }
});

// node_modules/core-js/modules/_fix-re-wks.js
var require_fix_re_wks = __commonJS({
  "node_modules/core-js/modules/_fix-re-wks.js"(exports2, module2) {
    "use strict";
    require_es6_regexp_exec();
    var redefine = require_redefine();
    var hide = require_hide();
    var fails = require_fails();
    var defined = require_defined();
    var wks = require_wks();
    var regexpExec = require_regexp_exec();
    var SPECIES = wks("species");
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length === 2 && result[0] === "a" && result[1] === "b";
    }();
    module2.exports = function(KEY, length, exec) {
      var SYMBOL = wks(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O3 = {};
        O3[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O3) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
        var execCalled = false;
        var re = /a/;
        re.exec = function() {
          execCalled = true;
          return null;
        };
        if (KEY === "split") {
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
        }
        re[SYMBOL]("");
        return !execCalled;
      }) : void 0;
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var fns = exec(
          defined,
          SYMBOL,
          ""[KEY],
          function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
            if (regexp.exec === regexpExec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
              }
              return { done: true, value: nativeMethod.call(str, regexp, arg2) };
            }
            return { done: false };
          }
        );
        var strfn = fns[0];
        var rxfn = fns[1];
        redefine(String.prototype, KEY, strfn);
        hide(
          RegExp.prototype,
          SYMBOL,
          length == 2 ? function(string, arg) {
            return rxfn.call(string, this, arg);
          } : function(string) {
            return rxfn.call(string, this);
          }
        );
      }
    };
  }
});

// node_modules/core-js/modules/es6.regexp.match.js
var require_es6_regexp_match = __commonJS({
  "node_modules/core-js/modules/es6.regexp.match.js"() {
    "use strict";
    var anObject = require_an_object();
    var toLength = require_to_length();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    require_fix_re_wks()("match", 1, function(defined, MATCH, $match, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O3 = defined(this);
          var fn = regexp == void 0 ? void 0 : regexp[MATCH];
          return fn !== void 0 ? fn.call(regexp, O3) : new RegExp(regexp)[MATCH](String(O3));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
        function(regexp) {
          var res = maybeCallNative($match, regexp, this);
          if (res.done) return res.value;
          var rx = anObject(regexp);
          var S3 = String(this);
          if (!rx.global) return regExpExec(rx, S3);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A3 = [];
          var n2 = 0;
          var result;
          while ((result = regExpExec(rx, S3)) !== null) {
            var matchStr = String(result[0]);
            A3[n2] = matchStr;
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S3, toLength(rx.lastIndex), fullUnicode);
            n2++;
          }
          return n2 === 0 ? null : A3;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/es6.array.some.js
var require_es6_array_some = __commonJS({
  "node_modules/core-js/modules/es6.array.some.js"() {
    "use strict";
    var $export = require_export();
    var $some = require_array_methods()(3);
    $export($export.P + $export.F * !require_strict_method()([].some, true), "Array", {
      // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
      some: function some(callbackfn) {
        return $some(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/_invoke.js
var require_invoke = __commonJS({
  "node_modules/core-js/modules/_invoke.js"(exports2, module2) {
    module2.exports = function(fn, args, that) {
      var un = that === void 0;
      switch (args.length) {
        case 0:
          return un ? fn() : fn.call(that);
        case 1:
          return un ? fn(args[0]) : fn.call(that, args[0]);
        case 2:
          return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
        case 3:
          return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
        case 4:
          return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
      }
      return fn.apply(that, args);
    };
  }
});

// node_modules/core-js/modules/_bind.js
var require_bind = __commonJS({
  "node_modules/core-js/modules/_bind.js"(exports2, module2) {
    "use strict";
    var aFunction = require_a_function();
    var isObject = require_is_object();
    var invoke = require_invoke();
    var arraySlice = [].slice;
    var factories = {};
    var construct = function(F2, len, args) {
      if (!(len in factories)) {
        for (var n2 = [], i4 = 0; i4 < len; i4++) n2[i4] = "a[" + i4 + "]";
        factories[len] = Function("F,a", "return new F(" + n2.join(",") + ")");
      }
      return factories[len](F2, args);
    };
    module2.exports = Function.bind || function bind(that) {
      var fn = aFunction(this);
      var partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype)) bound.prototype = fn.prototype;
      return bound;
    };
  }
});

// node_modules/core-js/modules/es6.function.bind.js
var require_es6_function_bind = __commonJS({
  "node_modules/core-js/modules/es6.function.bind.js"() {
    var $export = require_export();
    $export($export.P, "Function", { bind: require_bind() });
  }
});

// node_modules/@babel/runtime/helpers/newArrowCheck.js
var require_newArrowCheck2 = __commonJS({
  "node_modules/@babel/runtime/helpers/newArrowCheck.js"(exports2, module2) {
    function _newArrowCheck(innerThis, boundThis) {
      if (innerThis !== boundThis) {
        throw new TypeError("Cannot instantiate an arrow function");
      }
    }
    module2.exports = _newArrowCheck;
  }
});

// node_modules/@jumpn/utils-graphql/compat/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@jumpn/utils-graphql/compat/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    require_es6_array_map();
    require_es6_regexp_match();
    require_es6_array_some();
    require_es6_function_bind();
    var _newArrowCheck = _interopDefault(require_newArrowCheck2());
    var _this = void 0;
    var locationsToString = function locationsToString2(locations) {
      var _this2 = this;
      _newArrowCheck(this, _this);
      return locations.map(function(_ref) {
        var column = _ref.column, line = _ref.line;
        _newArrowCheck(this, _this2);
        return "".concat(line, ":").concat(column);
      }.bind(this)).join("; ");
    }.bind(void 0);
    var errorToString = function errorToString2(_ref2) {
      var message = _ref2.message, locations = _ref2.locations;
      _newArrowCheck(this, _this);
      return message + (locations ? " (".concat(locationsToString(locations), ")") : "");
    }.bind(void 0);
    var errorsToString = function errorsToString2(gqlErrors) {
      _newArrowCheck(this, _this);
      return gqlErrors.map(errorToString).join("\n");
    }.bind(void 0);
    var _this$1 = void 0;
    var operationTypeRe = /^\s*(query|mutation|subscription|\{)/;
    var getOperationTypeFromMatched = function getOperationTypeFromMatched2(matched) {
      _newArrowCheck(this, _this$1);
      return matched === "{" ? "query" : matched;
    }.bind(void 0);
    var getOperationType = function getOperationType2(operation) {
      _newArrowCheck(this, _this$1);
      var result = operation.match(operationTypeRe);
      if (!result) {
        throw new TypeError("Invalid operation:\n".concat(operation));
      }
      return getOperationTypeFromMatched(result[1]);
    }.bind(void 0);
    var _this$2 = void 0;
    var isSubscription = function isSubscription2(definition) {
      _newArrowCheck(this, _this$2);
      return definition.kind === "OperationDefinition" && definition.operation === "subscription";
    }.bind(void 0);
    var hasSubscription = function hasSubscription2(documentNode) {
      _newArrowCheck(this, _this$2);
      return documentNode.definitions.some(isSubscription);
    }.bind(void 0);
    var _this$3 = void 0;
    var requestFromCompat = function requestFromCompat2(_ref) {
      var operation = _ref.query, variables = _ref.variables;
      _newArrowCheck(this, _this$3);
      return variables ? {
        operation,
        variables
      } : {
        operation
      };
    }.bind(void 0);
    var _this$4 = void 0;
    var requestToCompat = function requestToCompat2(_ref) {
      var query = _ref.operation, variables = _ref.variables;
      _newArrowCheck(this, _this$4);
      return variables ? {
        query,
        variables
      } : {
        query
      };
    }.bind(void 0);
    exports2.errorsToString = errorsToString;
    exports2.getOperationType = getOperationType;
    exports2.hasSubscription = hasSubscription;
    exports2.requestFromCompat = requestFromCompat;
    exports2.requestToCompat = requestToCompat;
  }
});

// node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS({
  "node_modules/zen-observable/lib/Observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i4 = 0; i4 < props.length; i4++) {
          var descriptor = props[i4];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var hasSymbols = function() {
      return typeof Symbol === "function";
    };
    var hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    var SymbolIterator = getSymbol("iterator");
    var SymbolObservable = getSymbol("observable");
    var SymbolSpecies = getSymbol("species");
    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null) return void 0;
      if (typeof value !== "function") throw new TypeError(value + " is not a function");
      return value;
    }
    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== void 0) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = void 0;
        }
      }
      return ctor !== void 0 ? ctor : Observable;
    }
    function isObservable(x3) {
      return x3 instanceof Observable;
    }
    function hostReportError(e3) {
      if (hostReportError.log) {
        hostReportError.log(e3);
      } else {
        setTimeout(function() {
          throw e3;
        });
      }
    }
    function enqueue(fn) {
      Promise.resolve().then(function() {
        try {
          fn();
        } catch (e3) {
          hostReportError(e3);
        }
      });
    }
    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === void 0) return;
      subscription._cleanup = void 0;
      if (!cleanup) {
        return;
      }
      try {
        if (typeof cleanup === "function") {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, "unsubscribe");
          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e3) {
        hostReportError(e3);
      }
    }
    function closeSubscription(subscription) {
      subscription._observer = void 0;
      subscription._queue = void 0;
      subscription._state = "closed";
    }
    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = void 0;
      subscription._state = "ready";
      for (var i4 = 0; i4 < queue.length; ++i4) {
        notifySubscription(subscription, queue[i4].type, queue[i4].value);
        if (subscription._state === "closed") break;
      }
    }
    function notifySubscription(subscription, type, value) {
      subscription._state = "running";
      var observer = subscription._observer;
      try {
        var m3 = getMethod(observer, type);
        switch (type) {
          case "next":
            if (m3) m3.call(observer, value);
            break;
          case "error":
            closeSubscription(subscription);
            if (m3) m3.call(observer, value);
            else throw value;
            break;
          case "complete":
            closeSubscription(subscription);
            if (m3) m3.call(observer);
            break;
        }
      } catch (e3) {
        hostReportError(e3);
      }
      if (subscription._state === "closed") cleanupSubscription(subscription);
      else if (subscription._state === "running") subscription._state = "ready";
    }
    function onNotify(subscription, type, value) {
      if (subscription._state === "closed") return;
      if (subscription._state === "buffering") {
        subscription._queue.push({ type, value });
        return;
      }
      if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [{ type, value }];
        enqueue(function() {
          return flushSubscription(subscription);
        });
        return;
      }
      notifySubscription(subscription, type, value);
    }
    var Subscription = function() {
      function Subscription2(observer, subscriber) {
        _classCallCheck(this, Subscription2);
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e3) {
          subscriptionObserver.error(e3);
        }
        if (this._state === "initializing") this._state = "ready";
      }
      _createClass(Subscription2, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    var SubscriptionObserver = function() {
      function SubscriptionObserver2(subscription) {
        _classCallCheck(this, SubscriptionObserver2);
        this._subscription = subscription;
      }
      _createClass(SubscriptionObserver2, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, "next", value);
        }
      }, {
        key: "error",
        value: function error(value) {
          onNotify(this._subscription, "error", value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, "complete");
        }
      }, {
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    var Observable = exports2.Observable = function() {
      function Observable2(subscriber) {
        _classCallCheck(this, Observable2);
        if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      _createClass(Observable2, [{
        key: "subscribe",
        value: function subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          var _this = this;
          return new Promise(function(resolve5, reject) {
            if (typeof fn !== "function") {
              reject(new TypeError(fn + " is not a function"));
              return;
            }
            function done() {
              subscription.unsubscribe();
              resolve5();
            }
            var subscription = _this.subscribe({
              next: function(value) {
                try {
                  fn(value, done);
                } catch (e3) {
                  reject(e3);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve5
            });
          });
        }
      }, {
        key: "map",
        value: function map(fn) {
          var _this2 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            return _this2.subscribe({
              next: function(value) {
                try {
                  value = fn(value);
                } catch (e3) {
                  return observer.error(e3);
                }
                observer.next(value);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this3 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            return _this3.subscribe({
              next: function(value) {
                try {
                  if (!fn(value)) return;
                } catch (e3) {
                  return observer.error(e3);
                }
                observer.next(value);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this4 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C3(function(observer) {
            return _this4.subscribe({
              next: function(value) {
                var first = !hasValue;
                hasValue = true;
                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e3) {
                    return observer.error(e3);
                  }
                } else {
                  acc = value;
                }
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat() {
          var _this5 = this;
          for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            var subscription = void 0;
            var index = 0;
            function startNext(next) {
              subscription = next.subscribe({
                next: function(v3) {
                  observer.next(v3);
                },
                error: function(e3) {
                  observer.error(e3);
                },
                complete: function() {
                  if (index === sources.length) {
                    subscription = void 0;
                    observer.complete();
                  } else {
                    startNext(C3.from(sources[index++]));
                  }
                }
              });
            }
            startNext(_this5);
            return function() {
              if (subscription) {
                subscription.unsubscribe();
                subscription = void 0;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          var C3 = getSpecies(this);
          return new C3(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
              next: function(value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e3) {
                    return observer.error(e3);
                  }
                }
                var inner = C3.from(value).subscribe({
                  next: function(value2) {
                    observer.next(value2);
                  },
                  error: function(e3) {
                    observer.error(e3);
                  },
                  complete: function() {
                    var i4 = subscriptions.indexOf(inner);
                    if (i4 >= 0) subscriptions.splice(i4, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function(e3) {
                observer.error(e3);
              },
              complete: function() {
                completeIfDone();
              }
            });
            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0) observer.complete();
            }
            return function() {
              subscriptions.forEach(function(s3) {
                return s3.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function() {
          return this;
        }
      }], [{
        key: "from",
        value: function from(x3) {
          var C3 = typeof this === "function" ? this : Observable2;
          if (x3 == null) throw new TypeError(x3 + " is not an object");
          var method = getMethod(x3, SymbolObservable);
          if (method) {
            var observable = method.call(x3);
            if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C3) return observable;
            return new C3(function(observer) {
              return observable.subscribe(observer);
            });
          }
          if (hasSymbol("iterator")) {
            method = getMethod(x3, SymbolIterator);
            if (method) {
              return new C3(function(observer) {
                enqueue(function() {
                  if (observer.closed) return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = method.call(x3)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var item = _step.value;
                      observer.next(item);
                      if (observer.closed) return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  observer.complete();
                });
              });
            }
          }
          if (Array.isArray(x3)) {
            return new C3(function(observer) {
              enqueue(function() {
                if (observer.closed) return;
                for (var i4 = 0; i4 < x3.length; ++i4) {
                  observer.next(x3[i4]);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }
          throw new TypeError(x3 + " is not observable");
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }
          var C3 = typeof this === "function" ? this : Observable2;
          return new C3(function(observer) {
            enqueue(function() {
              if (observer.closed) return;
              for (var i4 = 0; i4 < items.length; ++i4) {
                observer.next(items[i4]);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable2;
    }();
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// node_modules/zen-observable/index.js
var require_zen_observable = __commonJS({
  "node_modules/zen-observable/index.js"(exports2, module2) {
    module2.exports = require_Observable().Observable;
  }
});

// node_modules/core-js/modules/es7.array.includes.js
var require_es7_array_includes = __commonJS({
  "node_modules/core-js/modules/es7.array.includes.js"() {
    "use strict";
    var $export = require_export();
    var $includes = require_array_includes2()(true);
    $export($export.P, "Array", {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()("includes");
  }
});

// node_modules/core-js/modules/_is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/modules/_is-regexp.js"(exports2, module2) {
    var isObject = require_is_object();
    var cof = require_cof();
    var MATCH = require_wks()("match");
    module2.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : cof(it) == "RegExp");
    };
  }
});

// node_modules/core-js/modules/_string-context.js
var require_string_context = __commonJS({
  "node_modules/core-js/modules/_string-context.js"(exports2, module2) {
    var isRegExp = require_is_regexp();
    var defined = require_defined();
    module2.exports = function(that, searchString, NAME) {
      if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
      return String(defined(that));
    };
  }
});

// node_modules/core-js/modules/_fails-is-regexp.js
var require_fails_is_regexp = __commonJS({
  "node_modules/core-js/modules/_fails-is-regexp.js"(exports2, module2) {
    var MATCH = require_wks()("match");
    module2.exports = function(KEY) {
      var re = /./;
      try {
        "/./"[KEY](re);
      } catch (e3) {
        try {
          re[MATCH] = false;
          return !"/./"[KEY](re);
        } catch (f3) {
        }
      }
      return true;
    };
  }
});

// node_modules/core-js/modules/es6.string.includes.js
var require_es6_string_includes = __commonJS({
  "node_modules/core-js/modules/es6.string.includes.js"() {
    "use strict";
    var $export = require_export();
    var context = require_string_context();
    var INCLUDES = "includes";
    $export($export.P + $export.F * require_fails_is_regexp()(INCLUDES), "String", {
      includes: function includes(searchString) {
        return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty2 = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports2, module2) {
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module2.exports = _defineProperty;
  }
});

// node_modules/@babel/runtime/helpers/objectSpread.js
var require_objectSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/objectSpread.js"(exports2, module2) {
    var defineProperty = require_defineProperty2();
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    module2.exports = _objectSpread;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports2, module2) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i4;
      for (i4 = 0; i4 < sourceKeys.length; i4++) {
        key = sourceKeys[i4];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    module2.exports = _objectWithoutPropertiesLoose;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties2 = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports2, module2) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i4;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
          key = sourceSymbolKeys[i4];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module2.exports = _objectWithoutProperties;
  }
});

// node_modules/core-js/modules/es6.array.index-of.js
var require_es6_array_index_of = __commonJS({
  "node_modules/core-js/modules/es6.array.index-of.js"() {
    "use strict";
    var $export = require_export();
    var $indexOf = require_array_includes2()(false);
    var $native = [].indexOf;
    var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
    $export($export.P + $export.F * (NEGATIVE_ZERO || !require_strict_method()($native)), "Array", {
      // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
      indexOf: function indexOf(searchElement) {
        return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
      }
    });
  }
});

// node_modules/@absinthe/socket/compat/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@absinthe/socket/compat/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    require_es6_array_find_index();
    require_es6_array_find();
    require_es6_function_name();
    var utilsComposite = require_cjs4();
    require_phoenix_cjs();
    require_web_dom_iterable2();
    require_es6_array_for_each();
    var _toConsumableArray = _interopDefault(require_toConsumableArray2());
    var utilsGraphql = require_cjs5();
    var Observable = _interopDefault(require_zen_observable());
    require_es7_array_includes();
    require_es6_string_includes();
    var _objectSpread = _interopDefault(require_objectSpread());
    var _objectWithoutProperties = _interopDefault(require_objectWithoutProperties2());
    require_es6_array_index_of();
    var utilsArray = require_cjs3();
    require_es6_function_bind();
    var _newArrowCheck = _interopDefault(require_newArrowCheck2());
    var _this = void 0;
    var cancel2 = function cancel3(_ref) {
      var activeObservers = _ref.activeObservers, canceledObservers = _ref.canceledObservers, rest = _objectWithoutProperties(_ref, ["activeObservers", "canceledObservers"]);
      _newArrowCheck(this, _this);
      return _objectSpread({}, rest, {
        isActive: false,
        activeObservers: [],
        canceledObservers: _toConsumableArray(activeObservers).concat(_toConsumableArray(canceledObservers))
      });
    }.bind(void 0);
    var _this$1 = void 0;
    var getNotifier = function getNotifier2(handlerName, payload) {
      var _this2 = this;
      _newArrowCheck(this, _this$1);
      return function(observer) {
        _newArrowCheck(this, _this2);
        return observer[handlerName] && observer[handlerName](payload);
      }.bind(this);
    }.bind(void 0);
    var getHandlerName = function getHandlerName2(_ref) {
      var name = _ref.name;
      _newArrowCheck(this, _this$1);
      return "on".concat(name);
    }.bind(void 0);
    var notifyAll = function notifyAll2(observers, event) {
      _newArrowCheck(this, _this$1);
      return observers.forEach(getNotifier(getHandlerName(event), event.payload));
    }.bind(void 0);
    var _this$2 = void 0;
    var notifyCanceled = function notifyCanceled2(notifier, event) {
      _newArrowCheck(this, _this$2);
      notifyAll(notifier.canceledObservers, event);
      return notifier;
    }.bind(void 0);
    var eventNames = {
      abort: "Abort",
      cancel: "Cancel",
      error: "Error",
      result: "Result",
      start: "Start"
    };
    var _this$3 = void 0;
    var createStartEvent = function createStartEvent2(payload) {
      _newArrowCheck(this, _this$3);
      return {
        payload,
        name: eventNames.start
      };
    }.bind(void 0);
    var createResultEvent = function createResultEvent2(payload) {
      _newArrowCheck(this, _this$3);
      return {
        payload,
        name: eventNames.result
      };
    }.bind(void 0);
    var createErrorEvent = function createErrorEvent2(payload) {
      _newArrowCheck(this, _this$3);
      return {
        payload,
        name: eventNames.error
      };
    }.bind(void 0);
    var createCancelEvent = function createCancelEvent2() {
      _newArrowCheck(this, _this$3);
      return {
        name: eventNames.cancel,
        payload: void 0
      };
    }.bind(void 0);
    var createAbortEvent = function createAbortEvent2(payload) {
      _newArrowCheck(this, _this$3);
      return {
        payload,
        name: eventNames.abort
      };
    }.bind(void 0);
    var _this$4 = void 0;
    var clearCanceled = function clearCanceled2(notifier) {
      _newArrowCheck(this, _this$4);
      return _objectSpread({}, notifier, {
        canceledObservers: []
      });
    }.bind(void 0);
    var flushCanceled = function flushCanceled2(notifier) {
      _newArrowCheck(this, _this$4);
      return notifier.canceledObservers.length > 0 ? clearCanceled(notifyCanceled(notifier, createCancelEvent())) : notifier;
    }.bind(void 0);
    var _this$5 = void 0;
    var findIndex = function findIndex2(notifiers, key, value) {
      _newArrowCheck(this, _this$5);
      return notifiers.findIndex(utilsComposite.hasIn([key], value));
    }.bind(void 0);
    var _this$6 = void 0;
    var refresh = function refresh2(notifier) {
      var _this2 = this;
      _newArrowCheck(this, _this$6);
      return function(notifiers) {
        _newArrowCheck(this, _this2);
        return utilsArray.replace(findIndex(notifiers, "request", notifier.request), [notifier], notifiers);
      }.bind(this);
    }.bind(void 0);
    var _this$7 = void 0;
    var remove = function remove2(notifier) {
      var _this2 = this;
      _newArrowCheck(this, _this$7);
      return function(notifiers) {
        _newArrowCheck(this, _this2);
        return utilsArray.remove(findIndex(notifiers, "request", notifier.request), 1, notifiers);
      }.bind(this);
    }.bind(void 0);
    var _this$8 = void 0;
    var updateNotifiers = function updateNotifiers2(absintheSocket, updater) {
      _newArrowCheck(this, _this$8);
      absintheSocket.notifiers = updater(absintheSocket.notifiers);
      return absintheSocket;
    }.bind(void 0);
    var _this$9 = void 0;
    var refreshNotifier = function refreshNotifier2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$9);
      updateNotifiers(absintheSocket, refresh(notifier));
      return notifier;
    }.bind(void 0);
    var requestStatuses = {
      canceled: "canceled",
      canceling: "canceling",
      pending: "pending",
      sent: "sent",
      sending: "sending"
    };
    var _this$a = void 0;
    var getObservers = function getObservers2(_ref) {
      var activeObservers = _ref.activeObservers, canceledObservers = _ref.canceledObservers;
      _newArrowCheck(this, _this$a);
      return _toConsumableArray(activeObservers).concat(_toConsumableArray(canceledObservers));
    }.bind(void 0);
    var notify = function notify2(notifier, event) {
      _newArrowCheck(this, _this$a);
      notifyAll(getObservers(notifier), event);
      return notifier;
    }.bind(void 0);
    var _this$b = void 0;
    var abortNotifier = function abortNotifier2(absintheSocket, notifier, error) {
      _newArrowCheck(this, _this$b);
      return updateNotifiers(absintheSocket, remove(notify(notifier, createAbortEvent(error))));
    }.bind(void 0);
    var _this$c = void 0;
    var find = function find2(notifiers, key, value) {
      _newArrowCheck(this, _this$c);
      return notifiers.find(utilsComposite.hasIn([key], value));
    }.bind(void 0);
    var _this$d = void 0;
    var notifyActive = function notifyActive2(notifier, event) {
      _newArrowCheck(this, _this$d);
      notifyAll(notifier.activeObservers, event);
      return notifier;
    }.bind(void 0);
    var _this$e = void 0;
    var notifyResultEvent = function notifyResultEvent2(notifier, result) {
      _newArrowCheck(this, _this$e);
      return notifyActive(notifier, createResultEvent(result));
    }.bind(void 0);
    var _this$f = void 0;
    var notifyStartEvent = function notifyStartEvent2(notifier) {
      _newArrowCheck(this, _this$f);
      return notifyActive(notifier, createStartEvent(notifier));
    }.bind(void 0);
    var _this$g = void 0;
    var reset = function reset2(notifier) {
      _newArrowCheck(this, _this$g);
      return flushCanceled(_objectSpread({}, notifier, {
        isActive: true,
        requestStatus: requestStatuses.pending,
        subscriptionId: void 0
      }));
    }.bind(void 0);
    var _this$h = void 0;
    var handlePush = function handlePush2(push, handler) {
      _newArrowCheck(this, _this$h);
      return push.receive("ok", handler.onSucceed).receive("error", handler.onError).receive("timeout", handler.onTimeout);
    }.bind(void 0);
    var _this$i = void 0;
    var getPushHandlerMethodGetter = function getPushHandlerMethodGetter2(absintheSocket, request) {
      var _this2 = this;
      _newArrowCheck(this, _this$i);
      return function(handle) {
        var _this3 = this;
        _newArrowCheck(this, _this2);
        return function() {
          _newArrowCheck(this, _this3);
          var notifier = find(absintheSocket.notifiers, "request", request);
          if (notifier) {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            handle.apply(void 0, [absintheSocket, notifier].concat(args));
          }
        }.bind(this);
      }.bind(this);
    }.bind(void 0);
    var getPushHandler = function getPushHandler2(absintheSocket, request, notifierPushHandler) {
      _newArrowCheck(this, _this$i);
      return utilsComposite.map(getPushHandlerMethodGetter(absintheSocket, request), notifierPushHandler);
    }.bind(void 0);
    var pushAbsintheEvent = function pushAbsintheEvent2(absintheSocket, request, notifierPushHandler, absintheEvent) {
      _newArrowCheck(this, _this$i);
      handlePush(absintheSocket.channel.push(absintheEvent.name, absintheEvent.payload), getPushHandler(absintheSocket, request, notifierPushHandler));
      return absintheSocket;
    }.bind(void 0);
    var absintheEventNames = {
      doc: "doc",
      unsubscribe: "unsubscribe"
    };
    var _this$j = void 0;
    var createAbsintheUnsubscribeEvent = function createAbsintheUnsubscribeEvent2(payload) {
      _newArrowCheck(this, _this$j);
      return {
        payload,
        name: absintheEventNames.unsubscribe
      };
    }.bind(void 0);
    var createAbsintheDocEvent = function createAbsintheDocEvent2(payload) {
      _newArrowCheck(this, _this$j);
      return {
        payload,
        name: absintheEventNames.doc
      };
    }.bind(void 0);
    var _this$k = void 0;
    var pushAbsintheDocEvent = function pushAbsintheDocEvent2(absintheSocket, _ref, notifierPushHandler) {
      var request = _ref.request;
      _newArrowCheck(this, _this$k);
      return pushAbsintheEvent(absintheSocket, request, notifierPushHandler, createAbsintheDocEvent(utilsGraphql.requestToCompat(request)));
    }.bind(void 0);
    var setNotifierRequestStatusSending = function setNotifierRequestStatusSending2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$k);
      return refreshNotifier(absintheSocket, _objectSpread({}, notifier, {
        requestStatus: requestStatuses.sending
      }));
    }.bind(void 0);
    var createRequestError = function createRequestError2(message) {
      _newArrowCheck(this, _this$k);
      return new Error("request: ".concat(message));
    }.bind(void 0);
    var onTimeout = function onTimeout2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$k);
      return notifyActive(notifier, createErrorEvent(createRequestError("timeout")));
    }.bind(void 0);
    var onError = function onError2(absintheSocket, notifier, errorMessage) {
      _newArrowCheck(this, _this$k);
      return abortNotifier(absintheSocket, notifier, createRequestError(errorMessage));
    }.bind(void 0);
    var getNotifierPushHandler = function getNotifierPushHandler2(onSucceed) {
      _newArrowCheck(this, _this$k);
      return {
        onError,
        onSucceed,
        onTimeout
      };
    }.bind(void 0);
    var pushRequestUsing = function pushRequestUsing2(absintheSocket, notifier, onSucceed) {
      _newArrowCheck(this, _this$k);
      return pushAbsintheDocEvent(absintheSocket, setNotifierRequestStatusSending(absintheSocket, notifier), getNotifierPushHandler(onSucceed));
    }.bind(void 0);
    var _this$l = void 0;
    var onUnsubscribeSucceedCanceled = function onUnsubscribeSucceedCanceled2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$l);
      return updateNotifiers(absintheSocket, remove(flushCanceled(notifier)));
    }.bind(void 0);
    var onUnsubscribeSucceedActive = function onUnsubscribeSucceedActive2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$l);
      return subscribe(absintheSocket, refreshNotifier(absintheSocket, reset(notifier)));
    }.bind(void 0);
    var createUnsubscribeError = function createUnsubscribeError2(message) {
      _newArrowCheck(this, _this$l);
      return new Error("unsubscribe: ".concat(message));
    }.bind(void 0);
    var unsubscribeHandler = {
      onError: function onError$$1(absintheSocket, notifier, errorMessage) {
        _newArrowCheck(this, _this$l);
        return abortNotifier(absintheSocket, notifier, createUnsubscribeError(errorMessage));
      }.bind(void 0),
      onTimeout: function onTimeout2(absintheSocket, notifier) {
        _newArrowCheck(this, _this$l);
        return notifyCanceled(notifier, createErrorEvent(createUnsubscribeError("timeout")));
      }.bind(void 0),
      onSucceed: function onSucceed(absintheSocket, notifier) {
        _newArrowCheck(this, _this$l);
        if (notifier.isActive) {
          onUnsubscribeSucceedActive(absintheSocket, notifier);
        } else {
          onUnsubscribeSucceedCanceled(absintheSocket, notifier);
        }
      }.bind(void 0)
    };
    var pushAbsintheUnsubscribeEvent = function pushAbsintheUnsubscribeEvent2(absintheSocket, _ref) {
      var request = _ref.request, subscriptionId = _ref.subscriptionId;
      _newArrowCheck(this, _this$l);
      return pushAbsintheEvent(absintheSocket, request, unsubscribeHandler, createAbsintheUnsubscribeEvent({
        subscriptionId
      }));
    }.bind(void 0);
    var unsubscribe = function unsubscribe2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$l);
      return pushAbsintheUnsubscribeEvent(absintheSocket, refreshNotifier(absintheSocket, _objectSpread({}, notifier, {
        requestStatus: requestStatuses.canceling
      })));
    }.bind(void 0);
    var onSubscribeSucceed = function onSubscribeSucceed2(absintheSocket, notifier, _ref2) {
      var subscriptionId = _ref2.subscriptionId;
      _newArrowCheck(this, _this$l);
      var subscribedNotifier = refreshNotifier(absintheSocket, _objectSpread({}, notifier, {
        subscriptionId,
        requestStatus: requestStatuses.sent
      }));
      if (subscribedNotifier.isActive) {
        notifyStartEvent(subscribedNotifier);
      } else {
        unsubscribe(absintheSocket, subscribedNotifier);
      }
    }.bind(void 0);
    var onSubscribe = function onSubscribe2(absintheSocket, notifier, response) {
      _newArrowCheck(this, _this$l);
      if (response.errors) {
        onError(absintheSocket, notifier, utilsGraphql.errorsToString(response.errors));
      } else {
        onSubscribeSucceed(absintheSocket, notifier, response);
      }
    }.bind(void 0);
    var subscribe = function subscribe2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$l);
      return pushRequestUsing(absintheSocket, notifier, onSubscribe);
    }.bind(void 0);
    var onDataMessage = function onDataMessage2(absintheSocket, _ref3) {
      var payload = _ref3.payload;
      _newArrowCheck(this, _this$l);
      var notifier = find(absintheSocket.notifiers, "subscriptionId", payload.subscriptionId);
      if (notifier) {
        notifyResultEvent(notifier, payload.result);
      }
    }.bind(void 0);
    var dataMessageEventName = "subscription:data";
    var isDataMessage = function isDataMessage2(message) {
      _newArrowCheck(this, _this$l);
      return message.event === dataMessageEventName;
    }.bind(void 0);
    var _this$m = void 0;
    var cancelQueryOrMutationSending = function cancelQueryOrMutationSending2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return updateNotifiers(absintheSocket, refresh(flushCanceled(cancel2(notifier))));
    }.bind(void 0);
    var cancelQueryOrMutationIfSending = function cancelQueryOrMutationIfSending2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.requestStatus === requestStatuses.sending ? cancelQueryOrMutationSending(absintheSocket, notifier) : absintheSocket;
    }.bind(void 0);
    var cancelPending = function cancelPending2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return updateNotifiers(absintheSocket, remove(flushCanceled(cancel2(notifier))));
    }.bind(void 0);
    var cancelQueryOrMutation = function cancelQueryOrMutation2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.requestStatus === requestStatuses.pending ? cancelPending(absintheSocket, notifier) : cancelQueryOrMutationIfSending(absintheSocket, notifier);
    }.bind(void 0);
    var unsubscribeIfNeeded = function unsubscribeIfNeeded2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.requestStatus === requestStatuses.sent ? unsubscribe(absintheSocket, notifier) : absintheSocket;
    }.bind(void 0);
    var cancelNonPendingSubscription = function cancelNonPendingSubscription2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return unsubscribeIfNeeded(absintheSocket, refreshNotifier(absintheSocket, cancel2(notifier)));
    }.bind(void 0);
    var cancelSubscription = function cancelSubscription2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.requestStatus === requestStatuses.pending ? cancelPending(absintheSocket, notifier) : cancelNonPendingSubscription(absintheSocket, notifier);
    }.bind(void 0);
    var cancelActive = function cancelActive2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.operationType === "subscription" ? cancelSubscription(absintheSocket, notifier) : cancelQueryOrMutation(absintheSocket, notifier);
    }.bind(void 0);
    var cancel$1 = function cancel$$1(absintheSocket, notifier) {
      _newArrowCheck(this, _this$m);
      return notifier.isActive ? cancelActive(absintheSocket, notifier) : absintheSocket;
    }.bind(void 0);
    var _this$n = void 0;
    var setNotifierRequestStatusSent = function setNotifierRequestStatusSent2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$n);
      return refreshNotifier(absintheSocket, _objectSpread({}, notifier, {
        requestStatus: requestStatuses.sent
      }));
    }.bind(void 0);
    var onQueryOrMutationSucceed = function onQueryOrMutationSucceed2(absintheSocket, notifier, response) {
      _newArrowCheck(this, _this$n);
      return updateNotifiers(absintheSocket, remove(notifyResultEvent(setNotifierRequestStatusSent(absintheSocket, notifier), response)));
    }.bind(void 0);
    var pushQueryOrMutation = function pushQueryOrMutation2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$n);
      return pushRequestUsing(absintheSocket, notifyStartEvent(notifier), onQueryOrMutationSucceed);
    }.bind(void 0);
    var pushRequest = function pushRequest2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$n);
      if (notifier.operationType === "subscription") {
        subscribe(absintheSocket, notifier);
      } else {
        pushQueryOrMutation(absintheSocket, notifier);
      }
    }.bind(void 0);
    var _this$o = void 0;
    var createChannelJoinError = function createChannelJoinError2(message) {
      _newArrowCheck(this, _this$o);
      return new Error("channel join: ".concat(message));
    }.bind(void 0);
    var notifyErrorToAllActive = function notifyErrorToAllActive2(absintheSocket, errorMessage) {
      var _this2 = this;
      _newArrowCheck(this, _this$o);
      return absintheSocket.notifiers.forEach(function(notifier) {
        _newArrowCheck(this, _this2);
        return notifyActive(notifier, createErrorEvent(createChannelJoinError(errorMessage)));
      }.bind(this));
    }.bind(void 0);
    var createChannelJoinHandler = function createChannelJoinHandler2(absintheSocket) {
      var _this3 = this;
      _newArrowCheck(this, _this$o);
      return {
        onError: function onError2(errorMessage) {
          _newArrowCheck(this, _this3);
          return notifyErrorToAllActive(absintheSocket, errorMessage);
        }.bind(this),
        onSucceed: function onSucceed() {
          var _this4 = this;
          _newArrowCheck(this, _this3);
          return absintheSocket.notifiers.forEach(function(notifier) {
            _newArrowCheck(this, _this4);
            return pushRequest(absintheSocket, notifier);
          }.bind(this));
        }.bind(this),
        onTimeout: function onTimeout2() {
          _newArrowCheck(this, _this3);
          return notifyErrorToAllActive(absintheSocket, "timeout");
        }.bind(this)
      };
    }.bind(void 0);
    var joinChannel = function joinChannel2(absintheSocket) {
      _newArrowCheck(this, _this$o);
      handlePush(absintheSocket.channel.join(), createChannelJoinHandler(absintheSocket));
      absintheSocket.channelJoinCreated = true;
      return absintheSocket;
    }.bind(void 0);
    var _this$p = void 0;
    var onMessage = function onMessage2(absintheSocket) {
      var _this2 = this;
      _newArrowCheck(this, _this$p);
      return function(message) {
        _newArrowCheck(this, _this2);
        if (isDataMessage(message)) {
          onDataMessage(absintheSocket, message);
        }
      }.bind(this);
    }.bind(void 0);
    var createConnectionCloseError = function createConnectionCloseError2() {
      _newArrowCheck(this, _this$p);
      return new Error("connection: close");
    }.bind(void 0);
    var notifyConnectionCloseError = function notifyConnectionCloseError2(notifier) {
      _newArrowCheck(this, _this$p);
      return notify(notifier, createErrorEvent(createConnectionCloseError()));
    }.bind(void 0);
    var notifierOnConnectionCloseCanceled = function notifierOnConnectionCloseCanceled2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$p);
      return updateNotifiers(absintheSocket, remove(notifyConnectionCloseError(notifier)));
    }.bind(void 0);
    var notifierOnConnectionCloseActive = function notifierOnConnectionCloseActive2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$p);
      if (notifier.operationType === "mutation") {
        abortNotifier(absintheSocket, notifier, createConnectionCloseError());
      } else {
        refreshNotifier(absintheSocket, reset(notifyConnectionCloseError(notifier)));
      }
    }.bind(void 0);
    var notifierOnConnectionClose = function notifierOnConnectionClose2(absintheSocket) {
      var _this3 = this;
      _newArrowCheck(this, _this$p);
      return function(notifier) {
        _newArrowCheck(this, _this3);
        if (notifier.isActive) {
          notifierOnConnectionCloseActive(absintheSocket, notifier);
        } else {
          notifierOnConnectionCloseCanceled(absintheSocket, notifier);
        }
      }.bind(this);
    }.bind(void 0);
    var onConnectionClose = function onConnectionClose2(absintheSocket) {
      var _this4 = this;
      _newArrowCheck(this, _this$p);
      return function() {
        _newArrowCheck(this, _this4);
        return absintheSocket.notifiers.forEach(notifierOnConnectionClose(absintheSocket));
      }.bind(this);
    }.bind(void 0);
    var shouldJoinChannel = function shouldJoinChannel2(absintheSocket) {
      _newArrowCheck(this, _this$p);
      return !absintheSocket.channelJoinCreated && absintheSocket.notifiers.length > 0;
    }.bind(void 0);
    var onConnectionOpen = function onConnectionOpen2(absintheSocket) {
      var _this5 = this;
      _newArrowCheck(this, _this$p);
      return function() {
        _newArrowCheck(this, _this5);
        if (shouldJoinChannel(absintheSocket)) {
          joinChannel(absintheSocket);
        }
      }.bind(this);
    }.bind(void 0);
    var absintheChannelName = "__absinthe__:control";
    var create2 = function create3(phoenixSocket) {
      _newArrowCheck(this, _this$p);
      var absintheSocket = {
        phoenixSocket,
        channel: phoenixSocket.channel(absintheChannelName),
        channelJoinCreated: false,
        notifiers: []
      };
      phoenixSocket.onOpen(onConnectionOpen(absintheSocket));
      phoenixSocket.onClose(onConnectionClose(absintheSocket));
      phoenixSocket.onMessage(onMessage(absintheSocket));
      return absintheSocket;
    }.bind(void 0);
    var _this$q = void 0;
    var observe2 = function observe3(_ref, observer) {
      var activeObservers = _ref.activeObservers, rest = _objectWithoutProperties(_ref, ["activeObservers"]);
      _newArrowCheck(this, _this$q);
      return _objectSpread({}, rest, {
        activeObservers: _toConsumableArray(activeObservers).concat([observer]),
        isActive: true
      });
    }.bind(void 0);
    var _this$r = void 0;
    var observe$1 = function observe$$1(absintheSocket, notifier, observer) {
      _newArrowCheck(this, _this$r);
      return refreshNotifier(absintheSocket, observe2(notifier, observer));
    }.bind(void 0);
    var _this$s = void 0;
    var createUsing = function createUsing2(request, operationType) {
      _newArrowCheck(this, _this$s);
      return {
        operationType,
        request,
        activeObservers: [],
        canceledObservers: [],
        isActive: true,
        requestStatus: requestStatuses.pending,
        subscriptionId: void 0
      };
    }.bind(void 0);
    var create$1 = function create3(request) {
      _newArrowCheck(this, _this$s);
      return createUsing(request, utilsGraphql.getOperationType(request.operation));
    }.bind(void 0);
    var _this$t = void 0;
    var reactivate = function reactivate2(notifier) {
      _newArrowCheck(this, _this$t);
      return notifier.isActive ? notifier : _objectSpread({}, notifier, {
        isActive: true
      });
    }.bind(void 0);
    var _this$u = void 0;
    var connectOrJoinChannel = function connectOrJoinChannel2(absintheSocket) {
      _newArrowCheck(this, _this$u);
      if (absintheSocket.phoenixSocket.isConnected()) {
        joinChannel(absintheSocket);
      } else {
        absintheSocket.phoenixSocket.connect();
      }
    }.bind(void 0);
    var sendNew = function sendNew2(absintheSocket, request) {
      _newArrowCheck(this, _this$u);
      var notifier = create$1(request);
      updateNotifiers(absintheSocket, utilsArray.append([notifier]));
      if (absintheSocket.channelJoinCreated) {
        pushRequest(absintheSocket, notifier);
      } else {
        connectOrJoinChannel(absintheSocket);
      }
      return notifier;
    }.bind(void 0);
    var updateCanceledReactivate = function updateCanceledReactivate2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$u);
      return refreshNotifier(absintheSocket, reactivate(notifier));
    }.bind(void 0);
    var updateCanceled = function updateCanceled2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$u);
      return notifier.requestStatus === requestStatuses.sending ? updateCanceledReactivate(absintheSocket, flushCanceled(notifier)) : updateCanceledReactivate(absintheSocket, notifier);
    }.bind(void 0);
    var updateIfCanceled = function updateIfCanceled2(absintheSocket, notifier) {
      _newArrowCheck(this, _this$u);
      return notifier.isActive ? notifier : updateCanceled(absintheSocket, notifier);
    }.bind(void 0);
    var getExistentIfAny = function getExistentIfAny2(absintheSocket, request) {
      _newArrowCheck(this, _this$u);
      var notifier = find(absintheSocket.notifiers, "request", request);
      return notifier && updateIfCanceled(absintheSocket, notifier);
    }.bind(void 0);
    var send2 = function send3(absintheSocket, request) {
      _newArrowCheck(this, _this$u);
      return getExistentIfAny(absintheSocket, request) || sendNew(absintheSocket, request);
    }.bind(void 0);
    var _this$v = void 0;
    var getUnsubscriber = function getUnsubscriber2(absintheSocket, _ref, observer, unsubscribe2) {
      var _this2 = this;
      var request = _ref.request;
      _newArrowCheck(this, _this$v);
      return function() {
        _newArrowCheck(this, _this2);
        var notifier = find(absintheSocket.notifiers, "request", request);
        unsubscribe2(absintheSocket, notifier, notifier ? observer : void 0);
      }.bind(this);
    }.bind(void 0);
    var onResult = function onResult2(_ref2, observableObserver) {
      var _this3 = this;
      var operationType = _ref2.operationType;
      _newArrowCheck(this, _this$v);
      return function(result) {
        _newArrowCheck(this, _this3);
        observableObserver.next(result);
        if (operationType !== "subscription") {
          observableObserver.complete();
        }
      }.bind(this);
    }.bind(void 0);
    var createObserver = function createObserver2(notifier, handlers, observableObserver) {
      _newArrowCheck(this, _this$v);
      return _objectSpread({}, handlers, {
        onAbort: observableObserver.error.bind(observableObserver),
        onResult: onResult(notifier, observableObserver)
      });
    }.bind(void 0);
    var toObservable = function toObservable2(absintheSocket, notifier) {
      var _this4 = this;
      var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, unsubscribe2 = _ref3.unsubscribe, handlers = _objectWithoutProperties(_ref3, ["unsubscribe"]);
      _newArrowCheck(this, _this$v);
      return new Observable(function(observableObserver) {
        _newArrowCheck(this, _this4);
        var observer = createObserver(notifier, handlers, observableObserver);
        observe$1(absintheSocket, notifier, observer);
        return unsubscribe2 && getUnsubscriber(absintheSocket, notifier, observer, unsubscribe2);
      }.bind(this));
    }.bind(void 0);
    var _this$w = void 0;
    var removeObserver = function removeObserver2(observers, observer) {
      _newArrowCheck(this, _this$w);
      return utilsArray.remove(observers.indexOf(observer), 1, observers);
    }.bind(void 0);
    var unobserve = function unobserve2(_ref, observer) {
      var activeObservers = _ref.activeObservers, rest = _objectWithoutProperties(_ref, ["activeObservers"]);
      _newArrowCheck(this, _this$w);
      return _objectSpread({}, rest, {
        activeObservers: removeObserver(activeObservers, observer)
      });
    }.bind(void 0);
    var _this$x = void 0;
    var ensureHasActiveObserver = function ensureHasActiveObserver2(notifier, observer) {
      _newArrowCheck(this, _this$x);
      if (notifier.activeObservers.includes(observer)) return notifier;
      throw new Error("Observer is not attached to notifier");
    }.bind(void 0);
    var unobserve$1 = function unobserve$$1(absintheSocket, notifier, observer) {
      _newArrowCheck(this, _this$x);
      return updateNotifiers(absintheSocket, refresh(unobserve(ensureHasActiveObserver(notifier, observer), observer)));
    }.bind(void 0);
    var _this$y = void 0;
    var doUnobserveOrCancel = function doUnobserveOrCancel2(absintheSocket, notifier, observer) {
      _newArrowCheck(this, _this$y);
      return notifier.activeObservers.length === 1 ? cancel$1(absintheSocket, notifier) : unobserve$1(absintheSocket, notifier, observer);
    }.bind(void 0);
    var unobserveOrCancel = function unobserveOrCancel2(absintheSocket, notifier, observer) {
      _newArrowCheck(this, _this$y);
      return notifier.isActive ? doUnobserveOrCancel(absintheSocket, notifier, observer) : absintheSocket;
    }.bind(void 0);
    exports2.cancel = cancel$1;
    exports2.create = create2;
    exports2.observe = observe$1;
    exports2.send = send2;
    exports2.toObservable = toObservable;
    exports2.unobserve = unobserve$1;
    exports2.unobserveOrCancel = unobserveOrCancel;
  }
});

// node_modules/@codesandbox/api/node_modules/class-states/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@codesandbox/api/node_modules/class-states/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.States = void 0;
    var States5 = class {
      constructor(initialState) {
        this._listeners = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        this._state = initialState;
        this.onTransition = this.onTransition.bind(this);
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get() {
        return this._state;
      }
      match(...args) {
        const matches = args[1] || args[0];
        const state = args.length === 2 ? args[0] : this._state;
        return matches[state.state] ? matches[state.state](state) : matches._();
      }
      set(state) {
        if (this._isDisposed) {
          return;
        }
        const prevState = this._state;
        this._state = state;
        this._listeners.forEach((listener) => listener(state, prevState));
        return state;
      }
      is(state) {
        return this._state.state === state;
      }
      onTransition(...args) {
        if (this._isDisposed) {
          return;
        }
        let listener;
        if (typeof args[0] === "string" && typeof args[1] === "function") {
          const state = args[0];
          listener = (currentState, prevState) => {
            if (currentState.state === state) {
              args[1](currentState, prevState);
            }
          };
        } else if (typeof args[0] === "function") {
          listener = args[0];
        } else {
          throw new Error("You are giving the wrong arguments");
        }
        this._listeners.add(listener);
        return () => {
          this._listeners.delete(listener);
        };
      }
      dispose() {
        this._listeners.clear();
        this._isDisposed = true;
      }
    };
    exports2.States = States5;
  }
});

// node_modules/humps/humps.js
var require_humps = __commonJS({
  "node_modules/humps/humps.js"(exports2, module2) {
    (function(global2) {
      var _processKeys = function(convert, obj, options) {
        if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
          return obj;
        }
        var output, i4 = 0, l3 = 0;
        if (_isArray(obj)) {
          output = [];
          for (l3 = obj.length; i4 < l3; i4++) {
            output.push(_processKeys(convert, obj[i4], options));
          }
        } else {
          output = {};
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              output[convert(key, options)] = _processKeys(convert, obj[key], options);
            }
          }
        }
        return output;
      };
      var separateWords = function(string, options) {
        options = options || {};
        var separator = options.separator || "_";
        var split = options.split || /(?=[A-Z])/;
        return string.split(split).join(separator);
      };
      var camelize2 = function(string) {
        if (_isNumerical(string)) {
          return string;
        }
        string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
          return chr ? chr.toUpperCase() : "";
        });
        return string.substr(0, 1).toLowerCase() + string.substr(1);
      };
      var pascalize = function(string) {
        var camelized = camelize2(string);
        return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
      };
      var decamelize2 = function(string, options) {
        return separateWords(string, options).toLowerCase();
      };
      var toString = Object.prototype.toString;
      var _isFunction = function(obj) {
        return typeof obj === "function";
      };
      var _isObject = function(obj) {
        return obj === Object(obj);
      };
      var _isArray = function(obj) {
        return toString.call(obj) == "[object Array]";
      };
      var _isDate = function(obj) {
        return toString.call(obj) == "[object Date]";
      };
      var _isRegExp = function(obj) {
        return toString.call(obj) == "[object RegExp]";
      };
      var _isBoolean = function(obj) {
        return toString.call(obj) == "[object Boolean]";
      };
      var _isNumerical = function(obj) {
        obj = obj - 0;
        return obj === obj;
      };
      var _processor = function(convert, options) {
        var callback = options && "process" in options ? options.process : options;
        if (typeof callback !== "function") {
          return convert;
        }
        return function(string, options2) {
          return callback(string, convert, options2);
        };
      };
      var humps2 = {
        camelize: camelize2,
        decamelize: decamelize2,
        pascalize,
        depascalize: decamelize2,
        camelizeKeys: function(object, options) {
          return _processKeys(_processor(camelize2, options), object);
        },
        decamelizeKeys: function(object, options) {
          return _processKeys(_processor(decamelize2, options), object, options);
        },
        pascalizeKeys: function(object, options) {
          return _processKeys(_processor(pascalize, options), object);
        },
        depascalizeKeys: function() {
          return this.decamelizeKeys.apply(this, arguments);
        }
      };
      if (typeof define === "function" && define.amd) {
        define(humps2);
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = humps2;
      } else {
        global2.humps = humps2;
      }
    })(exports2);
  }
});

// node_modules/class-states/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/class-states/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.States = void 0;
    var States5 = class {
      constructor(initialState) {
        this._listeners = /* @__PURE__ */ new Set();
        this._isDisposed = false;
        this._state = initialState;
        this.onTransition = this.onTransition.bind(this);
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get() {
        return this._state;
      }
      match(...args) {
        const matches = args[1] || args[0];
        const state = args.length === 2 ? args[0] : this._state;
        return matches[state.state] ? matches[state.state](state) : matches._();
      }
      set(state) {
        if (this._isDisposed) {
          return;
        }
        const prevState = this._state;
        this._state = state;
        this._listeners.forEach((listener) => listener(state, prevState));
        return state;
      }
      is(state) {
        return this._state.state === state;
      }
      onTransition(...args) {
        if (this._isDisposed) {
          return;
        }
        let listener;
        if (typeof args[0] === "string" && typeof args[1] === "function") {
          const state = args[0];
          listener = (currentState, prevState) => {
            if (currentState.state === state) {
              args[1](currentState, prevState);
            }
          };
        } else if (typeof args[0] === "function") {
          listener = args[0];
        } else {
          throw new Error("You are giving the wrong arguments");
        }
        this._listeners.add(listener);
        return () => {
          this._listeners.delete(listener);
        };
      }
      dispose() {
        this._listeners.clear();
        this._isDisposed = true;
      }
    };
    exports2.States = States5;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s3 = 1e3;
    var m3 = s3 * 60;
    var h3 = m3 * 60;
    var d2 = h3 * 24;
    var w4 = d2 * 7;
    var y3 = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y3;
        case "weeks":
        case "week":
        case "w":
          return n2 * w4;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms, msAbs, s3, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i4);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format3];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v3) => {
            enableOverride = v3;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m3;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r3;
      try {
        r3 = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v3) {
      try {
        return JSON.stringify(v3);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color3 = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var argv = process.argv;
    var terminator = argv.indexOf("--");
    var hasFlag = function(flag) {
      flag = "--" + flag;
      var pos = argv.indexOf(flag);
      return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
    };
    module2.exports = function() {
      if ("FORCE_COLOR" in process.env) {
        return true;
      }
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
        return false;
      }
      if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color3();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_3, k4) => {
        return k4.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug4) {
      debug4.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i4 = 0; i4 < keys.length; i4++) {
        debug4.inspectOpts[keys[i4]] = exports2.inspectOpts[keys[i4]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v3) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v3, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v3) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v3, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/constants.js
var require_constants3 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug4;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants3();
    var debug4 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t3 = exports2.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R2++;
      debug4(name, index, value);
      t3[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NUMERICIDENTIFIER]}|${src[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NUMERICIDENTIFIERLOOSE]}|${src[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
    createToken("FULL", `^${src[t3.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
    createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?(?:${src[t3.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t3.COERCE], true);
    createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})\\s+-\\s+(${src[t3.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t3.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a3, b) => {
      const anum = numeric.test(a3);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a3 = +a3;
        b = +b;
      }
      return a3 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a3, b) => compareIdentifiers(b, a3);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug4 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants3();
    var { safeRe: re, t: t3 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug4("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m3 = version.trim().match(options.loose ? re[t3.LOOSE] : re[t3.FULL]);
        if (!m3) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m3[1];
        this.minor = +m3[2];
        this.patch = +m3[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m3[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m3[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m3[5] ? m3[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug4("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i4 = 0;
        do {
          const a3 = this.prerelease[i4];
          const b = other.prerelease[i4];
          debug4("prerelease compare", i4, a3, b);
          if (a3 === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b) {
            continue;
          } else {
            return compareIdentifiers(a3, b);
          }
        } while (++i4);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i4 = 0;
        do {
          const a3 = this.build[i4];
          const b = other.build[i4];
          debug4("build compare", i4, a3, b);
          if (a3 === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b) {
            continue;
          } else {
            return compareIdentifiers(a3, b);
          }
        } while (++i4);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i4 = this.prerelease.length;
              while (--i4 >= 0) {
                if (typeof this.prerelease[i4] === "number") {
                  this.prerelease[i4]++;
                  i4 = -2;
                }
              }
              if (i4 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/parse.js
var require_parse4 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse4();
    var valid = (version, options) => {
      const v3 = parse(version, options);
      return v3 ? v3.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse4();
    var clean = (version, options) => {
      const s3 = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s3 ? s3.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse4();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v22 = parse(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a3, loose) => new SemVer(a3, loose).major;
    module2.exports = major;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a3, loose) => new SemVer(a3, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a3, loose) => new SemVer(a3, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse4();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare2 = (a3, b, loose) => new SemVer(a3, loose).compare(new SemVer(b, loose));
    module2.exports = compare2;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare2 = require_compare();
    var rcompare = (a3, b, loose) => compare2(b, a3, loose);
    module2.exports = rcompare;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare2 = require_compare();
    var compareLoose = (a3, b) => compare2(a3, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a3, b, loose) => {
      const versionA = new SemVer(a3, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a3, b) => compareBuild(a3, b, loose));
    module2.exports = sort;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a3, b) => compareBuild(b, a3, loose));
    module2.exports = rsort;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare2 = require_compare();
    var gt = (a3, b, loose) => compare2(a3, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare2 = require_compare();
    var lt = (a3, b, loose) => compare2(a3, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare2 = require_compare();
    var eq = (a3, b, loose) => compare2(a3, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare2 = require_compare();
    var neq = (a3, b, loose) => compare2(a3, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare2 = require_compare();
    var gte = (a3, b, loose) => compare2(a3, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare2 = require_compare();
    var lte = (a3, b, loose) => compare2(a3, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a3, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a3 === b;
        case "!==":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a3 !== b;
        case "":
        case "=":
        case "==":
          return eq(a3, b, loose);
        case "!=":
          return neq(a3, b, loose);
        case ">":
          return gt(a3, b, loose);
        case ">=":
          return gte(a3, b, loose);
        case "<":
          return lt(a3, b, loose);
        case "<=":
          return lte(a3, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse4();
    var { safeRe: re, t: t3 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t3.COERCEFULL] : re[t3.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t3.COERCERTLFULL] : re[t3.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c3) => c3.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c3) => !isNullSet(c3[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c3 of this.set) {
              if (c3.length === 1 && isAny(c3[0])) {
                this.set = [c3];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i4 = 0; i4 < this.set.length; i4++) {
            if (i4 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i4];
            for (let k4 = 0; k4 < comps.length; k4++) {
              if (k4 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k4].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t3.HYPHENRANGELOOSE] : re[t3.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug4("hyphen replace", range);
        range = range.replace(re[t3.COMPARATORTRIM], comparatorTrimReplace);
        debug4("comparator trim", range);
        range = range.replace(re[t3.TILDETRIM], tildeTrimReplace);
        debug4("tilde trim", range);
        range = range.replace(re[t3.CARETTRIM], caretTrimReplace);
        debug4("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug4("loose invalid filter", comp, this.options);
            return !!comp.match(re[t3.COMPARATORLOOSE]);
          });
        }
        debug4("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i4 = 0; i4 < this.set.length; i4++) {
          if (testSet(this.set[i4], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t3,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants3();
    var isNullSet = (c3) => c3.value === "<0.0.0-0";
    var isAny = (c3) => c3.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceTilde(c3, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r3 = options.loose ? re[t3.TILDELOOSE] : re[t3.TILDE];
      return comp.replace(r3, (_3, M2, m3, p2, pr) => {
        debug4("tilde", comp, _3, M2, m3, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M2}.${m3}.0 <${M2}.${+m3 + 1}.0-0`;
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m3}.${p2} <${M2}.${+m3 + 1}.0-0`;
        }
        debug4("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceCaret(c3, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug4("caret", comp, options);
      const r3 = options.loose ? re[t3.CARETLOOSE] : re[t3.CARET];
      const z4 = options.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_3, M2, m3, p2, pr) => {
        debug4("caret", comp, _3, M2, m3, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M2}.0.0${z4} <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M2 === "0") {
            ret = `>=${M2}.${m3}.0${z4} <${M2}.${+m3 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m3}.0${z4} <${+M2 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M2 === "0") {
            if (m3 === "0") {
              ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${m3}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m3}.${p2}-${pr} <${M2}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m3}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
          }
        } else {
          debug4("no pr");
          if (M2 === "0") {
            if (m3 === "0") {
              ret = `>=${M2}.${m3}.${p2}${z4} <${M2}.${m3}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m3}.${p2}${z4} <${M2}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m3}.${p2} <${+M2 + 1}.0.0-0`;
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c3) => replaceXRange(c3, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r3 = options.loose ? re[t3.XRANGELOOSE] : re[t3.XRANGE];
      return comp.replace(r3, (ret, gtlt, M2, m3, p2, pr) => {
        debug4("xRange", comp, ret, gtlt, M2, m3, p2, pr);
        const xM = isX(M2);
        const xm = xM || isX(m3);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M2 = +M2 + 1;
              m3 = 0;
              p2 = 0;
            } else {
              m3 = +m3 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M2 = +M2 + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M2}.${m3}.${p2}${pr}`;
        } else if (xm) {
          ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M2}.${m3}.0${pr} <${M2}.${+m3 + 1}.0-0`;
        }
        debug4("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(re[t3.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug4("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i4 = 0; i4 < set.length; i4++) {
        if (!set[i4].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i4 = 0; i4 < set.length; i4++) {
          debug4(set[i4].semver);
          if (set[i4].semver === Comparator.ANY) {
            continue;
          }
          if (set[i4].semver.prerelease.length > 0) {
            const allowed = set[i4].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug4("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug4("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re[t3.COMPARATORLOOSE] : re[t3.COMPARATOR];
        const m3 = comp.match(r3);
        if (!m3) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m3[1] !== void 0 ? m3[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m3[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m3[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug4("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t3 } = require_re();
    var cmp = require_cmp();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var Range = require_range2();
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range2();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range2();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c3) => c3.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v3) => {
        if (rangeObj.test(v3)) {
          if (!max || maxSV.compare(v3) === -1) {
            max = v3;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range2();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v3) => {
        if (rangeObj.test(v3)) {
          if (!min || minSV.compare(v3) === 1) {
            min = v3;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range2();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range2();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v3 = versions.sort((a3, b) => compare2(a3, b, options));
      for (const version of v3) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v3[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v3[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c3 of sub) {
        if (c3.operator === ">" || c3.operator === ">=") {
          gt = higherGT(gt, c3, options);
        } else if (c3.operator === "<" || c3.operator === "<=") {
          lt = lowerLT(lt, c3, options);
        } else {
          eqSet.add(c3.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c3 of dom) {
          if (!satisfies(eq, String(c3), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c3 of dom) {
        hasDomGT = hasDomGT || c3.operator === ">" || c3.operator === ">=";
        hasDomLT = hasDomLT || c3.operator === "<" || c3.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomGTPre.major && c3.semver.minor === needDomGTPre.minor && c3.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c3.operator === ">" || c3.operator === ">=") {
            higher = higherGT(gt, c3, options);
            if (higher === c3 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c3), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomLTPre.major && c3.semver.minor === needDomLTPre.minor && c3.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c3.operator === "<" || c3.operator === "<=") {
            lower = lowerLT(lt, c3, options);
            if (lower === c3 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c3), options)) {
            return false;
          }
        }
        if (!c3.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a3, b, options) => {
      if (!a3) {
        return b;
      }
      const comp = compare2(a3.semver, b.semver, options);
      return comp > 0 ? a3 : comp < 0 ? b : b.operator === ">" && a3.operator === ">=" ? b : a3;
    };
    var lowerLT = (a3, b, options) => {
      if (!a3) {
        return b;
      }
      const comp = compare2(a3.semver, b.semver, options);
      return comp < 0 ? a3 : comp > 0 ? b : b.operator === "<" && a3.operator === "<=" ? b : a3;
    };
    module2.exports = subset;
  }
});

// node_modules/@codesandbox/pitcher-client/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/@codesandbox/pitcher-client/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants3();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse4();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff2();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range2();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/ws/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants4();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i4 = 0; i4 < list.length; i4++) {
        const buf = list[i4];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i4 = 0; i4 < length; i4++) {
        output[offset + i4] = source[i4] ^ mask[i4 & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i4 = 0; i4 < buffer.length; i4++) {
        buffer[i4] ^= mask[i4 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e3) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants4();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants4();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i4 = 0;
      while (i4 < len) {
        if ((buf[i4] & 128) === 0) {
          i4++;
        } else if ((buf[i4] & 224) === 192) {
          if (i4 + 1 === len || (buf[i4 + 1] & 192) !== 128 || (buf[i4] & 254) === 192) {
            return false;
          }
          i4 += 2;
        } else if ((buf[i4] & 240) === 224) {
          if (i4 + 2 >= len || (buf[i4 + 1] & 192) !== 128 || (buf[i4 + 2] & 192) !== 128 || buf[i4] === 224 && (buf[i4 + 1] & 224) === 128 || // Overlong
          buf[i4] === 237 && (buf[i4 + 1] & 224) === 160) {
            return false;
          }
          i4 += 3;
        } else if ((buf[i4] & 248) === 240) {
          if (i4 + 3 >= len || (buf[i4 + 1] & 192) !== 128 || (buf[i4 + 2] & 192) !== 128 || (buf[i4 + 3] & 192) !== 128 || buf[i4] === 240 && (buf[i4 + 1] & 240) === 128 || // Overlong
          buf[i4] === 244 && buf[i4 + 1] > 143 || buf[i4] > 244) {
            return false;
          }
          i4 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e3) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants4();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n2) {
        this._bufferedBytes -= n2;
        if (n2 === this._buffers[0].length) return this._buffers.shift();
        if (n2 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n2,
            buf.length - n2
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n2);
        }
        const dst = Buffer.allocUnsafe(n2);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n2;
          if (n2 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n2,
              buf.length - n2
            );
          }
          n2 -= buf.length;
        } while (n2 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments2 = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments2, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments2, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments2);
          } else {
            data = fragments2;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments2, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants4();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_3, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i4 = 0; i4 < sender._queue.length; i4++) {
        const params = sender._queue[i4];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants4();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent2 = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent2.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent2.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent2.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent2("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent: CloseEvent2,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i4 = 0;
      for (; i4 < header.length; i4++) {
        code = header.charCodeAt(i4);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i4;
          } else if (i4 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i4;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i4}`);
            }
            if (end === -1) end = i4;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i4}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i4;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i4;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i4}`);
            }
            if (end === -1) end = i4;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i4);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i4}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i4}`);
            }
            if (start === -1) start = i4;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i4;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i4;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i4}`);
            }
          } else if (code === 34 && header.charCodeAt(i4 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i4;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i4;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i4}`);
            }
            if (end === -1) end = i4;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i4}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i4;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format3(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k4) => {
              let values = params[k4];
              if (!Array.isArray(values)) values = [values];
              return values.map((v3) => v3 === true ? k4 : `${k4}=${v3}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format3, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash: createHash2 } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants4();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format: format3, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e3) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format3({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol2 of protocols) {
          if (typeof protocol2 !== "string" || !subprotocolRegex.test(protocol2) || protocolSet.has(protocol2)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol2);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (e3) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream3 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i4 = 0;
      for (i4; i4 < header.length; i4++) {
        const code = header.charCodeAt(i4);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i4;
        } else if (i4 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i4;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i4}`);
          }
          if (end === -1) end = i4;
          const protocol3 = header.slice(start, end);
          if (protocols.has(protocol3)) {
            throw new SyntaxError(`The "${protocol3}" subprotocol is duplicated`);
          }
          protocols.add(protocol3);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i4}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol2 = header.slice(start, i4);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash: createHash2 } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants4();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol2 = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol2) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol2}`);
            ws._protocol = protocol2;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h3) => `${h3}: ${headers[h3]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream3();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/isomorphic-ws/node.js
var require_node3 = __commonJS({
  "node_modules/isomorphic-ws/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_3, m1, m22) => m1 + (m22.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_3, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_3, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_3, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_3, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path2, originalPath, doThrow) => {
      if (!isString(path2)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path2) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path2)) {
        const r3 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r3} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path2) => REGEX_TEST_INVALID_PATH.test(path2);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p2) => p2;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path2, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path2);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path2 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path2,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path2, cache, checkUnignored, slices);
      }
      _t(path2, cache, checkUnignored, slices) {
        if (path2 in cache) {
          return cache[path2];
        }
        if (!slices) {
          slices = path2.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path2] = this._testOne(path2, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path2] = parent.ignored ? parent : this._testOne(path2, checkUnignored);
      }
      ignores(path2) {
        return this._test(path2, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path2) => !this.ignores(path2);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path2) {
        return this._test(path2, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path2) => checkPath(path2 && checkPath.convert(path2), path2, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path2) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path2) || isNotRelative(path2);
    }
  }
});

// node_modules/yargs/lib/platform-shims/esm.mjs
var import_assert = require("assert");

// node_modules/cliui/build/lib/index.js
var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;
var UI = class {
  constructor(opts) {
    var _a3;
    this.width = opts.width;
    this.wrap = (_a3 = opts.wrap) !== null && _a3 !== void 0 ? _a3 : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split("\n").map((row) => row.split("	"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r3, i4) => {
        return {
          text: r3.trim(),
          padding: this.measurePadding(r3),
          width: i4 === 0 && columns.length > 1 ? leftColumnWidth : void 0
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r3) => {
      let str = "";
      rrow.forEach((col, c3) => {
        const { width } = row[c3];
        const wrapWidth = this.negatePadding(row[c3]);
        let ts = col;
        if (wrapWidth > mixin.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
        }
        if (row[c3].align && row[c3].align !== "left" && this.wrap) {
          const fn = align[row[c3].align];
          ts = fn(ts, wrapWidth);
          if (mixin.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
          }
        }
        const padding = row[c3].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c3], ts, "| ");
        str += ts;
        str += addBorder(row[c3], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r3 === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  // if the full 'source' can render in
  // the target line, do so.
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c3) => {
      col.width = widths[c3];
      if (this.wrap) {
        wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
      } else {
        wrapped = col.text.split("\n");
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r3) => {
        if (!rrows[r3]) {
          rrows.push([]);
        }
        const rrow = rrows[r3];
        for (let i4 = 0; i4 < c3; i4++) {
          if (rrow[i4] === void 0) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return void 0;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w4, i4) => {
      if (w4 === void 0) {
        return Math.max(unsetWidth, _minWidth(row[i4]));
      }
      return w4;
    });
  }
};
function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
}
function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}
function getWindowWidth() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}
function alignRight(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
}
function alignCenter(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
}
var mixin;
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
  });
}

// node_modules/cliui/build/lib/string-utils.js
var ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ["", ""];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i4 = 0; i4 < str.length; i4++) {
    if (i4 !== 0 && i4 % width === 0) {
      wrapped += "\n";
    }
    wrapped += str.charAt(i4);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}

// node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap
  });
}

// node_modules/escalade/sync/index.mjs
var import_path = require("path");
var import_fs = require("fs");
function sync_default(start, callback) {
  let dir = (0, import_path.resolve)(".", start);
  let tmp, stats = (0, import_fs.statSync)(dir);
  if (!stats.isDirectory()) {
    dir = (0, import_path.dirname)(dir);
  }
  while (true) {
    tmp = callback(dir, (0, import_fs.readdirSync)(dir));
    if (tmp) return (0, import_path.resolve)(dir, tmp);
    dir = (0, import_path.dirname)(tmp = dir);
    if (tmp === dir) break;
  }
}

// node_modules/yargs/lib/platform-shims/esm.mjs
var import_util3 = require("util");
var import_fs4 = require("fs");
var import_url = require("url");

// node_modules/yargs-parser/build/lib/index.js
var import_util = require("util");
var import_path2 = require("path");

// node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i4 = leadingHyphens ? leadingHyphens[0].length : 0; i4 < str.length; i4++) {
      let chr = str.charAt(i4);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i4 !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i4 = 0; i4 < str.length; i4++) {
    const chrLower = lowercase.charAt(i4);
    const chrString = str.charAt(i4);
    if (chrLower !== chrString && i4 > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i4)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x3) {
  if (x3 === null || x3 === void 0)
    return false;
  if (typeof x3 === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x3))
    return true;
  if (/^0[^.]/.test(x3))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x3);
}

// node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e3) => typeof e3 !== "string" ? e3 + "" : e3);
  }
  argString = argString.trim();
  let i4 = 0;
  let prevC = null;
  let c3 = null;
  let opening = null;
  const args = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c3;
    c3 = argString.charAt(ii);
    if (c3 === " " && !opening) {
      if (!(prevC === " ")) {
        i4++;
      }
      continue;
    }
    if (c3 === opening) {
      opening = null;
    } else if ((c3 === "'" || c3 === '"') && !opening) {
      opening = c3;
    }
    if (!args[i4])
      args[i4] = "";
    args[i4] += c3;
  }
  return args;
}

// node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// node_modules/yargs-parser/build/lib/yargs-parser.js
var mixin2;
var YargsParser = class {
  constructor(_mixin) {
    mixin2 = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: void 0,
      array: void 0,
      boolean: void 0,
      config: void 0,
      configObjects: void 0,
      configuration: void 0,
      coerce: void 0,
      count: void 0,
      default: void 0,
      envPrefix: void 0,
      narg: void 0,
      normalize: void 0,
      string: void 0,
      number: void 0,
      __: void 0,
      key: void 0
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = /* @__PURE__ */ Object.create(null);
    const defaulted = /* @__PURE__ */ Object.create(null);
    const __ = opts.__ || mixin2.format;
    const flags = {
      aliases: /* @__PURE__ */ Object.create(null),
      arrays: /* @__PURE__ */ Object.create(null),
      bools: /* @__PURE__ */ Object.create(null),
      strings: /* @__PURE__ */ Object.create(null),
      numbers: /* @__PURE__ */ Object.create(null),
      counts: /* @__PURE__ */ Object.create(null),
      normalize: /* @__PURE__ */ Object.create(null),
      configs: /* @__PURE__ */ Object.create(null),
      nargs: /* @__PURE__ */ Object.create(null),
      coercions: /* @__PURE__ */ Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        ;
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i4 = 0; i4 < args.length; i4++) {
      const arg = args[i4];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m3;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m3 = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m3 !== null && Array.isArray(m3) && m3.length >= 3) {
          if (checkAllAliases(m3[1], flags.arrays)) {
            i4 = eatArray(i4, m3[1], args, m3[2]);
          } else if (checkAllAliases(m3[1], flags.nargs) !== false) {
            i4 = eatNargs(i4, m3[1], args, m3[2]);
          } else {
            setArg(m3[1], m3[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m3 = arg.match(negatedBoolean);
        if (m3 !== null && Array.isArray(m3) && m3.length >= 2) {
          key = m3[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m3 = arg.match(/^--?(.+)/);
        if (m3 !== null && Array.isArray(m3) && m3.length >= 2) {
          key = m3[1];
          if (checkAllAliases(key, flags.arrays)) {
            i4 = eatArray(i4, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i4 = eatNargs(i4, key, args);
          } else {
            next = args[i4 + 1];
            if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i4++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i4++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m3 = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m3 !== null && Array.isArray(m3) && m3.length >= 3) {
          setArg(m3[1], m3[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i4 + 1];
        m3 = arg.match(/^-(.\..+)/);
        if (m3 !== null && Array.isArray(m3) && m3.length >= 2) {
          key = m3[1];
          if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i4++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j3 = 0; j3 < letters.length; j3++) {
          next = arg.slice(j3 + 2);
          if (letters[j3 + 1] && letters[j3 + 1] === "=") {
            value = arg.slice(j3 + 3);
            key = letters[j3];
            if (checkAllAliases(key, flags.arrays)) {
              i4 = eatArray(i4, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i4 = eatNargs(i4, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j3], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j3]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j3], next);
            broken = true;
            break;
          }
          if (letters[j3 + 1] && letters[j3 + 1].match(/\W/)) {
            setArg(letters[j3], next);
            broken = true;
            break;
          } else {
            setArg(letters[j3], defaultValue(letters[j3]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i4 = eatArray(i4, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i4 = eatNargs(i4, key, args);
          } else {
            next = args[i4 + 1];
            if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i4++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i4++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i4 + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i4);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      ;
      [].concat(...Object.keys(aliases).map((k4) => aliases[k4])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i4, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i4;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i4 + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i4 + 1; ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i4 + 1; ii < consumed + i4 + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i4 + consumed;
    }
    function eatArray(i4, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i4 + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== void 0) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i4 + 1; ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i4 = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i4;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x3) {
          const keyProperties = x3.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        ;
        (flags.aliases[splitKey[0]] || []).forEach(function(x3) {
          let keyProperties = x3.split(".");
          const a3 = [].concat(splitKey);
          a3.shift();
          keyProperties = keyProperties.concat(a3);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin2.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v3) {
        return maybeCoerceNumber(key, v3);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin2.normalize(val2);
          });
        else
          value = mixin2.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = /* @__PURE__ */ Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e3) {
                config = e3;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin2.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env2 = mixin2.env();
      Object.keys(env2).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i4) {
            if (i4 === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env2[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = /* @__PURE__ */ new Set();
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = void 0;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x3) {
            if (hasKey(obj, x3.split(".")))
              return;
            setKey(obj, x3.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o2 = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o2 = o2[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o2 !== "object")
        return false;
      else
        return key in o2;
    }
    function setKey(obj, keys, value) {
      let o2 = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o2 === "object" && o2[key2] === void 0) {
          o2[key2] = {};
        }
        if (typeof o2[key2] !== "object" || Array.isArray(o2[key2])) {
          if (Array.isArray(o2[key2])) {
            o2[key2].push({});
          } else {
            o2[key2] = [o2[key2], {}];
          }
          o2 = o2[key2][o2[key2].length - 1];
        } else {
          o2 = o2[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o2[key]) && flags.nargs[key] === 1 || Array.isArray(o2[key]) && o2[key].length === flags.nargs[key]) {
          o2[key] = void 0;
        }
      }
      if (value === increment()) {
        o2[key] = increment(o2[key]);
      } else if (Array.isArray(o2[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o2[key] = configuration["flatten-duplicate-arrays"] ? o2[key].concat(value) : (Array.isArray(o2[key][0]) ? o2[key] : [o2[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o2[key] = value;
        } else {
          o2[key] = o2[key].concat([value]);
        }
      } else if (o2[key] === void 0 && isTypeArray) {
        o2[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o2[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o2[key] = [o2[key], value];
      } else {
        o2[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x3) {
            if (/-/.test(x3) && configuration["camel-case-expansion"]) {
              const c3 = camelCase(x3);
              if (c3 !== key && flags.aliases[key].indexOf(c3) === -1) {
                flags.aliases[key].push(c3);
                newAliases[c3] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x3) {
            if (x3.length > 1 && /[A-Z]/.test(x3) && configuration["camel-case-expansion"]) {
              const c3 = decamelize(x3, "-");
              if (c3 !== key && flags.aliases[key].indexOf(c3) === -1) {
                flags.aliases[key].push(c3);
                newAliases[c3] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x3) {
            flags.aliases[x3] = [key].concat(flags.aliases[key].filter(function(y3) {
              return x3 !== y3;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k4) => flags[k4]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j3 = 0; j3 < letters.length; j3++) {
        next = arg.slice(j3 + 2);
        if (!hasAnyFlag(letters[j3])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j3 + 1] && letters[j3 + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j3]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j3 + 1] && letters[j3 + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType2(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: void 0,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType2(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === void 0;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
};
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = /* @__PURE__ */ Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i4 = 0; i4 < aliasArrays.length; i4++) {
      for (let ii = i4 + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i4].filter(function(v3) {
          return aliasArrays[ii].indexOf(v3) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i4] = aliasArrays[i4].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v3, i4, self2) {
      return self2.indexOf(v3) === i4;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== void 0 && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}

// node_modules/yargs-parser/build/lib/index.js
var import_fs2 = require("fs");
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format: import_util.format,
  normalize: import_path2.normalize,
  resolve: import_path2.resolve,
  // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
  // we can exercise all the lines below:
  require: (path2) => {
    if (typeof require !== "undefined") {
      return require(path2);
    } else if (path2.match(/\.json$/)) {
      return JSON.parse((0, import_fs2.readFileSync)(path2, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
var yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// node_modules/yargs/lib/platform-shims/esm.mjs
var import_path4 = require("path");

// node_modules/yargs/build/lib/utils/process-argv.js
function getProcessArgvBinIndex() {
  if (isBundledElectronApp())
    return 0;
  return 1;
}
function isBundledElectronApp() {
  return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
  return !!process.versions.electron;
}
function hideBin(argv) {
  return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// node_modules/yargs/build/lib/yerror.js
var YError = class _YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _YError);
    }
  }
};

// node_modules/y18n/build/lib/platform-shims/node.js
var import_fs3 = require("fs");
var import_util2 = require("util");
var import_path3 = require("path");
var node_default = {
  fs: {
    readFileSync: import_fs3.readFileSync,
    writeFile: import_fs3.writeFile
  },
  format: import_util2.format,
  resolve: import_path3.resolve,
  exists: (file) => {
    try {
      return (0, import_fs3.statSync)(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

// node_modules/y18n/build/lib/index.js
var shim;
var Y18N = class {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = /* @__PURE__ */ Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i4) {
      const arg = args[i4 + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim.exists(file);
  }
};
function y18n(opts, _shim) {
  shim = _shim;
  const y18n3 = new Y18N(opts);
  return {
    __: y18n3.__.bind(y18n3),
    __n: y18n3.__n.bind(y18n3),
    setLocale: y18n3.setLocale.bind(y18n3),
    getLocale: y18n3.getLocale.bind(y18n3),
    updateLocale: y18n3.updateLocale.bind(y18n3),
    locale: y18n3.locale
  };
}

// node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// node_modules/yargs/lib/platform-shims/esm.mjs
var import_meta = {};
var REQUIRE_ERROR = "require is not supported by ESM";
var REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
var __dirname;
try {
  __dirname = (0, import_url.fileURLToPath)(import_meta.url);
} catch (e3) {
  __dirname = process.cwd();
}
var mainFilename = __dirname.substring(0, __dirname.lastIndexOf("node_modules"));
var esm_default = {
  assert: {
    notStrictEqual: import_assert.notStrictEqual,
    strictEqual: import_assert.strictEqual
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect: import_util3.inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename: import_path4.basename,
    dirname: import_path4.dirname,
    extname: import_path4.extname,
    relative: import_path4.relative,
    resolve: import_path4.resolve
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: import_fs4.readFileSync,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: (0, import_path4.resolve)(__dirname, "../../../locales"),
    updateFiles: false
  })
};

// node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim3, message) {
  shim3.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim3) {
  shim3.assert.strictEqual(typeof actual, "string");
}
function objectKeys(object) {
  return Object.keys(object);
}

// node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
}

// node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand)
    throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ""),
    demanded: [],
    optional: []
  };
  splitCommand.forEach((cmd2, i4) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, "");
    if (/\.+[\]>]/.test(cmd2) && i4 === splitCommand.length - 1)
      variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    }
  });
  return parsedCommand;
}

// node_modules/yargs/build/lib/argsert.js
var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [
      parseCommand(`cmd ${arg1}`),
      arg2,
      arg3
    ];
  }
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === void 0)
      args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0)
        return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
function guessType(arg) {
  if (Array.isArray(arg)) {
    return "array";
  } else if (arg === null) {
    return "null";
  }
  return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
  throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
}

// node_modules/yargs/build/lib/middleware.js
var GlobalMiddleware = class {
  constructor(yargs) {
    this.globalMiddleware = [];
    this.frozens = [];
    this.yargs = yargs;
  }
  addMiddleware(callback, applyBeforeValidation, global2 = true, mutates = false) {
    argsert("<array|function> [boolean] [boolean] [boolean]", [callback, applyBeforeValidation, global2], arguments.length);
    if (Array.isArray(callback)) {
      for (let i4 = 0; i4 < callback.length; i4++) {
        if (typeof callback[i4] !== "function") {
          throw Error("middleware must be a function");
        }
        const m3 = callback[i4];
        m3.applyBeforeValidation = applyBeforeValidation;
        m3.global = global2;
      }
      Array.prototype.push.apply(this.globalMiddleware, callback);
    } else if (typeof callback === "function") {
      const m3 = callback;
      m3.applyBeforeValidation = applyBeforeValidation;
      m3.global = global2;
      m3.mutates = mutates;
      this.globalMiddleware.push(callback);
    }
    return this.yargs;
  }
  addCoerceMiddleware(callback, option) {
    const aliases = this.yargs.getAliases();
    this.globalMiddleware = this.globalMiddleware.filter((m3) => {
      const toCheck = [...aliases[option] || [], option];
      if (!m3.option)
        return true;
      else
        return !toCheck.includes(m3.option);
    });
    callback.option = option;
    return this.addMiddleware(callback, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    if (frozen !== void 0)
      this.globalMiddleware = frozen;
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((m3) => m3.global);
  }
};
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware)
    return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied)
        return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result = middleware(acc, yargs);
      return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
    }
  }, argv);
}

// node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
  throw err;
}) {
  try {
    const result = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result) ? result.then((result2) => resultHandler(result2)) : resultHandler(result);
  } catch (err) {
    return errorHandler(err);
  }
}
function isFunction(arg) {
  return typeof arg === "function";
}

// node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (typeof require === "undefined")
    return null;
  for (let i4 = 0, files = Object.keys(require.cache), mod; i4 < files.length; i4++) {
    mod = require.cache[files[i4]];
    if (mod.exports === exported)
      return mod;
  }
  return null;
}

// node_modules/yargs/build/lib/command.js
var DEFAULT_MARKER = /(^\*)|(^\$0)/;
var CommandInstance = class {
  constructor(usage2, validation2, globalMiddleware, shim3) {
    this.requireCache = /* @__PURE__ */ new Set();
    this.handlers = {};
    this.aliasMap = {};
    this.frozens = [];
    this.shim = shim3;
    this.usage = usage2;
    this.globalMiddleware = globalMiddleware;
    this.validation = validation2;
  }
  addDirectory(dir, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== "boolean")
      opts.recurse = false;
    if (!Array.isArray(opts.extensions))
      opts.extensions = ["js"];
    const parentVisit = typeof opts.visit === "function" ? opts.visit : (o2) => o2;
    opts.visit = (obj, joined, filename) => {
      const visited = parentVisit(obj, joined, filename);
      if (visited) {
        if (this.requireCache.has(joined))
          return visited;
        else
          this.requireCache.add(joined);
        this.addHandler(visited);
      }
      return visited;
    };
    this.shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
  }
  addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    let aliases = [];
    const middlewares = commandMiddlewareFactory(commandMiddleware);
    handler = handler || (() => {
    });
    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        [cmd, ...aliases] = cmd;
      } else {
        for (const command2 of cmd) {
          this.addHandler(command2);
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : this.moduleName(cmd);
      if (cmd.aliases)
        command2 = [].concat(command2).concat(cmd.aliases);
      this.addHandler(command2, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
      return;
    }
    if (typeof cmd === "string") {
      const parsedCommand = parseCommand(cmd);
      aliases = aliases.map((alias) => parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c3) => {
        if (DEFAULT_MARKER.test(c3)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault)
        parsedAliases.push("$0");
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        this.aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        this.usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      this.handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault)
        this.defaultCommand = this.handlers[parsedCommand.cmd];
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(command2, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
    const commandHandler = this.handlers[command2] || this.handlers[this.aliasMap[command2]] || this.defaultCommand;
    const currentContext = yargs.getInternalMethods().getContext();
    const parentCommands = currentContext.commands.slice();
    const isDefaultCommand = !command2;
    if (command2) {
      currentContext.commands.push(command2);
      currentContext.fullCommands.push(commandHandler.original);
    }
    const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
    return isPromise(builderResult) ? builderResult.then((result) => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
  }
  applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
    const builder = commandHandler.builder;
    let innerYargs = yargs;
    if (isCommandBuilderCallback(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
      if (isPromise(builderOutput)) {
        return builderOutput.then((output) => {
          innerYargs = isYargsInstance(output) ? output : yargs;
          return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
        });
      }
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      innerYargs = yargs.getInternalMethods().reset(aliases);
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, builder[key]);
      });
    }
    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
  }
  parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
    if (isDefaultCommand)
      innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
    if (this.shouldUpdateUsage(innerYargs)) {
      innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
    }
    const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, commandIndex, helpOnly);
    return isPromise(innerArgv) ? innerArgv.then((argv) => ({
      aliases: innerYargs.parsed.aliases,
      innerArgv: argv
    })) : {
      aliases: innerYargs.parsed.aliases,
      innerArgv
    };
  }
  shouldUpdateUsage(yargs) {
    return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
  }
  usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    const c3 = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
    const pc = parentCommands.filter((c4) => {
      return !DEFAULT_MARKER.test(c4);
    });
    pc.push(c3);
    return `$0 ${pc.join(" ")}`;
  }
  handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
    if (!yargs.getInternalMethods().getHasOutput()) {
      const validation2 = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        validation2(result);
        return result;
      });
    }
    if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
      yargs.getInternalMethods().setHasOutput();
      const populateDoubleDash = !!yargs.getOptions().configuration["populate--"];
      yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        const handlerResult = commandHandler.handler(result);
        return isPromise(handlerResult) ? handlerResult.then(() => result) : result;
      });
      if (!isDefaultCommand) {
        yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
      }
      if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
        innerArgv.catch((error) => {
          try {
            yargs.getInternalMethods().getUsageInstance().fail(null, error);
          } catch (_err) {
          }
        });
      }
    }
    if (!isDefaultCommand) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }
    return innerArgv;
  }
  applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
    let positionalMap = {};
    if (helpOnly)
      return innerArgv;
    if (!yargs.getInternalMethods().getHasOutput()) {
      positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }
    const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
    const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
    return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv) => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
  }
  populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length);
    const demanded = commandHandler.demanded.slice(0);
    const optional = commandHandler.optional.slice(0);
    const positionalMap = {};
    this.validation.positionalCount(demanded.length, argv._.length);
    while (demanded.length) {
      const demand = demanded.shift();
      this.populatePositional(demand, argv, positionalMap);
    }
    while (optional.length) {
      const maybe = optional.shift();
      this.populatePositional(maybe, argv, positionalMap);
    }
    argv._ = context.commands.concat(argv._.map((a3) => "" + a3));
    this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
    return positionalMap;
  }
  populatePositional(positional, argv, positionalMap) {
    const cmd = positional.cmd[0];
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length)
        positionalMap[cmd] = [String(argv._.shift())];
    }
  }
  cmdToParseOptions(cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    };
    const parsed = parseCommand(cmdString);
    parsed.demanded.forEach((d2) => {
      const [cmd, ...aliases] = d2.cmd;
      if (d2.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach((o2) => {
      const [cmd, ...aliases] = o2.cmd;
      if (o2.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  }
  postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
    const options = Object.assign({}, yargs.getOptions());
    options.default = Object.assign(parseOptions.default, options.default);
    for (const key of Object.keys(parseOptions.alias)) {
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }
    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    const unparsed = [];
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value) => {
        if (options.configuration["unknown-options-as-args"])
          options.key[key] = true;
        unparsed.push(`--${key}`);
        unparsed.push(value);
      });
    });
    if (!unparsed.length)
      return;
    const config = Object.assign({}, options.configuration, {
      "populate--": false
    });
    const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
      configuration: config
    }));
    if (parsed.error) {
      yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      const positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach((key) => {
        positionalKeys.push(...parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.includes(key)) {
          if (!positionalMap[key])
            positionalMap[key] = parsed.argv[key];
          if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
            argv[key] = [].concat(argv[key], parsed.argv[key]);
          } else {
            argv[key] = parsed.argv[key];
          }
        }
      });
    }
  }
  isDefaulted(yargs, key) {
    const { default: defaults } = yargs.getOptions();
    return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
  }
  isInConfigs(yargs, key) {
    const { configObjects } = yargs.getOptions();
    return configObjects.some((c3) => Object.prototype.hasOwnProperty.call(c3, key)) || configObjects.some((c3) => Object.prototype.hasOwnProperty.call(c3, this.shim.Parser.camelCase(key)));
  }
  runDefaultBuilderOn(yargs) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(yargs)) {
      const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
    }
    const builder = this.defaultCommand.builder;
    if (isCommandBuilderCallback(builder)) {
      return builder(yargs, true);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key]);
      });
    }
    return void 0;
  }
  moduleName(obj) {
    const mod = whichModule(obj);
    if (!mod)
      throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
    return this.commandFromFilename(mod.filename);
  }
  commandFromFilename(filename) {
    return this.shim.path.basename(filename, this.shim.path.extname(filename));
  }
  extractDesc({ describe, description, desc }) {
    for (const test of [describe, description, desc]) {
      if (typeof test === "string" || test === false)
        return test;
      assertNotStrictEqual(test, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    });
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    assertNotStrictEqual(frozen, void 0, this.shim);
    ({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    } = frozen);
  }
  reset() {
    this.handlers = {};
    this.aliasMap = {};
    this.defaultCommand = void 0;
    this.requireCache = /* @__PURE__ */ new Set();
    return this;
  }
};
function command(usage2, validation2, globalMiddleware, shim3) {
  return new CommandInstance(usage2, validation2, globalMiddleware, shim3);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
}
function isCommandAndAliases(cmd) {
  return cmd.every((c3) => typeof c3 === "string");
}
function isCommandBuilderCallback(builder) {
  return typeof builder === "function";
}
function isCommandBuilderOptionDefinitions(builder) {
  return typeof builder === "object";
}
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === "object" && !Array.isArray(cmd);
}

// node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}

// node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === "undefined")
    return;
  [process.stdout, process.stderr].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
      stream._handle.setBlocking(blocking);
    }
  });
}

// node_modules/yargs/build/lib/usage.js
function isBoolean(fail) {
  return typeof fail === "boolean";
}
function usage(yargs, shim3) {
  const __ = shim3.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = function failFn(f3) {
    fails.push(f3);
  };
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  };
  let failureOutput = false;
  self2.fail = function fail(msg, err) {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i4 = fails.length - 1; i4 >= 0; --i4) {
        const fail2 = fails[i4];
        if (isBoolean(fail2)) {
          if (err)
            throw err;
          else if (msg)
            throw Error(msg);
        } else {
          fail2(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess())
        setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp("error");
          logger.error();
        }
        if (msg || err)
          logger.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err)
            logger.error("");
          logger.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([msg, description || ""]);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __("Positionals:");
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([cmd, description || ""]);
  };
  let commands = [];
  self2.command = function command2(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([cmd, description || "", isDefault, aliases, deprecated]);
  };
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k4) => {
        self2.describe(k4, desc);
      });
    } else if (typeof keyOrKeys === "object") {
      Object.keys(keyOrKeys).forEach((k4) => {
        self2.describe(k4, keyOrKeys[k4]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim3.getEnv("YARGS_DISABLE_WRAP")) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = "__yargsString__:";
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = function help() {
    if (cachedHelpMessage)
      return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim3.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== "_")
        acc[key] = true;
      return acc;
    }, {}));
    const theWrap = self2.getWrap();
    const ui2 = shim3.cliui({
      width: theWrap,
      wrap: !!theWrap
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({ text: `${usage2[0].replace(/\$0/g, base$0)}` });
          if (usage2[1]) {
            ui2.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u4 = null;
        if (demandedCommands._) {
          u4 = `${base$0} <${__("command")}>
`;
        } else {
          u4 = `${base$0} [${__("command")}]
`;
        }
        ui2.div(`${u4}`);
      }
    }
    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui2.div(__("Commands:"));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
      if (yargs.getInternalMethods().getParserConfiguration()["sort-commands"] === true) {
        commands = commands.sort((a3, b) => a3[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : "";
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
        ui2.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
        }, { text: command2[1] });
        const hints = [];
        if (command2[2])
          hints.push(`[${__("default")}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === "string") {
            hints.push(`[${__("deprecated: %s", command2[4])}]`);
          } else {
            hints.push(`[${__("deprecated")}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(" "),
            padding: [0, 0, 0, 2],
            align: "right"
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
    const defaultGroup = __("Options:");
    if (!groups[defaultGroup])
      groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = (sw) => /^--/.test(getText(sw));
    const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (aliasKeys.includes(key))
          return key;
        for (let i4 = 0, aliasKey; (aliasKey = aliasKeys[i4]) !== void 0; i4++) {
          if ((options.alias[aliasKey] || []).includes(key))
            return aliasKey;
        }
        return key;
      });
      return { groupName, normalizedKeys };
    }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
          if (groupName === self2.getPositionalGroupName())
            return sw;
          else {
            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
          }
        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
        return acc;
      }, {});
      return { groupName, normalizedKeys, switches };
    });
    const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
    if (shortSwitchesUsed) {
      displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
        normalizedKeys.forEach((key) => {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], "-x, ".length);
          }
        });
      });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || "";
        let type = null;
        if (desc.includes(deferY18nLookupPrefix))
          desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key))
          type = `[${__("boolean")}]`;
        if (options.count.includes(key))
          type = `[${__("count")}]`;
        if (options.string.includes(key))
          type = `[${__("string")}]`;
        if (options.normalize.includes(key))
          type = `[${__("string")}]`;
        if (options.array.includes(key))
          type = `[${__("array")}]`;
        if (options.number.includes(key))
          type = `[${__("number")}]`;
        const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__("required")}]` : null,
          options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(" ");
        ui2.span({
          text: getText(kswitch),
          padding: [0, 2, 0, 2 + getIndentation(kswitch)],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
        if (extra && !shouldHideOptionExtras)
          ui2.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
        else
          ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__("Examples:"));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === "") {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e3 = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
      ui2.div(`${e3}
`);
    }
    return ui2.toString().replace(/\s*$/, "");
  };
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v3) => [v3]);
    }
    table.forEach((v3) => {
      width = Math.max(shim3.stringWidth(modifier ? `${modifier} ${getText(v3[0])}` : getText(v3[0])) + getIndentation(v3[0]), width);
    });
    if (theWrap)
      width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias])
          self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions)
          yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias))
          yargs.boolean(key);
        if (options.count.includes(alias))
          yargs.count(key);
        if (options.string.includes(alias))
          yargs.string(key);
        if (options.normalize.includes(alias))
          yargs.normalize(key);
        if (options.array.includes(alias))
          yargs.array(key);
        if (options.number.includes(alias))
          yargs.number(key);
      });
    });
  }
  let cachedHelpMessage;
  self2.cacheHelpMessage = function() {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function() {
    cachedHelpMessage = void 0;
  };
  self2.hasCachedHelpMessage = function() {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key]);
      if (!toCheck.some((k4) => groupedKeys.indexOf(k4) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }
  self2.showHelp = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim3.Parser.decamelize(fn.name, "-") : __("generated-value");
    return ["(", description, ")"].join("");
  };
  self2.stringifiedValues = function stringifiedValues(values, separator) {
    let string = "";
    const sep = separator || ", ";
    const array = [].concat(values);
    if (!values || !array.length)
      return string;
    array.forEach((value) => {
      if (string.length)
        string += sep;
      string += JSON.stringify(value);
    });
    return string;
  };
  function defaultString(value, defaultDescription) {
    let string = `[${__("default:")} `;
    if (value === void 0 && !defaultDescription)
      return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value) {
        case "string":
          string += `"${value}"`;
          break;
        case "object":
          string += JSON.stringify(value);
          break;
        default:
          string += value;
      }
    }
    return `${string}]`;
  }
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim3.process.stdColumns) {
      return Math.min(maxWidth2, shim3.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  let version = null;
  self2.version = (ver) => {
    version = ver;
  };
  self2.showVersion = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(version);
  };
  self2.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k4) => !localLookup[k4]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions
    });
  };
  self2.unfreeze = function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen)
      return;
    if (defaultCommand) {
      descriptions = { ...frozen.descriptions, ...descriptions };
      commands = [...frozen.commands, ...commands];
      usages = [...frozen.usages, ...usages];
      examples = [...frozen.examples, ...examples];
      epilogs = [...frozen.epilogs, ...epilogs];
    } else {
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      } = frozen);
    }
  };
  return self2;
}
function isIndentedText(text) {
  return typeof text === "object";
}
function addIndentation(text, indent) {
  return isIndentedText(text) ? { text: text.text, indentation: text.indentation + indent } : { text, indentation: indent };
}
function getIndentation(text) {
  return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
  return isIndentedText(text) ? text.text : text;
}

// node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
var completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

// node_modules/yargs/build/lib/completion.js
var Completion = class {
  constructor(yargs, usage2, command2, shim3) {
    var _a3, _b2, _c2;
    this.yargs = yargs;
    this.usage = usage2;
    this.command = command2;
    this.shim = shim3;
    this.completionKey = "get-yargs-completions";
    this.aliases = null;
    this.customCompletionFunction = null;
    this.indexAfterLastReset = 0;
    this.zshShell = (_c2 = ((_a3 = this.shim.getEnv("SHELL")) === null || _a3 === void 0 ? void 0 : _a3.includes("zsh")) || ((_b2 = this.shim.getEnv("ZSH_NAME")) === null || _b2 === void 0 ? void 0 : _b2.includes("zsh"))) !== null && _c2 !== void 0 ? _c2 : false;
  }
  defaultCompletion(args, argv, current, done) {
    const handlers = this.command.getCommandHandlers();
    for (let i4 = 0, ii = args.length; i4 < ii; ++i4) {
      if (handlers[args[i4]] && handlers[args[i4]].builder) {
        const builder = handlers[args[i4]].builder;
        if (isCommandBuilderCallback(builder)) {
          this.indexAfterLastReset = i4 + 1;
          const y3 = this.yargs.getInternalMethods().reset();
          builder(y3, true);
          return y3.argv;
        }
      }
    }
    const completions = [];
    this.commandCompletions(completions, args, current);
    this.optionCompletions(completions, args, argv, current);
    this.choicesFromOptionsCompletions(completions, args, argv, current);
    this.choicesFromPositionalsCompletions(completions, args, argv, current);
    done(null, completions);
  }
  commandCompletions(completions, args, current) {
    const parentCommands = this.yargs.getInternalMethods().getContext().commands;
    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
      this.usage.getCommands().forEach((usageCommand) => {
        const commandName = parseCommand(usageCommand[0]).cmd;
        if (args.indexOf(commandName) === -1) {
          if (!this.zshShell) {
            completions.push(commandName);
          } else {
            const desc = usageCommand[1] || "";
            completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
          }
        }
      });
    }
  }
  optionCompletions(completions, args, argv, current) {
    if ((current.match(/^-/) || current === "" && completions.length === 0) && !this.previousArgHasChoices(args)) {
      const options = this.yargs.getOptions();
      const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(options.key).forEach((key) => {
        const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
        const isPositionalKey = positionalKeys.includes(key);
        if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) {
          this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
        }
      });
    }
  }
  choicesFromOptionsCompletions(completions, args, argv, current) {
    if (this.previousArgHasChoices(args)) {
      const choices = this.getPreviousArgChoices(args);
      if (choices && choices.length > 0) {
        completions.push(...choices.map((c3) => c3.replace(/:/g, "\\:")));
      }
    }
  }
  choicesFromPositionalsCompletions(completions, args, argv, current) {
    if (current === "" && completions.length > 0 && this.previousArgHasChoices(args)) {
      return;
    }
    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
    const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
    const positionalKey = positionalKeys[argv._.length - offset - 1];
    if (!positionalKey) {
      return;
    }
    const choices = this.yargs.getOptions().choices[positionalKey] || [];
    for (const choice of choices) {
      if (choice.startsWith(current)) {
        completions.push(choice.replace(/:/g, "\\:"));
      }
    }
  }
  getPreviousArgChoices(args) {
    if (args.length < 1)
      return;
    let previousArg = args[args.length - 1];
    let filter = "";
    if (!previousArg.startsWith("-") && args.length > 1) {
      filter = previousArg;
      previousArg = args[args.length - 2];
    }
    if (!previousArg.startsWith("-"))
      return;
    const previousArgKey = previousArg.replace(/^-+/, "");
    const options = this.yargs.getOptions();
    const possibleAliases = [
      previousArgKey,
      ...this.yargs.getAliases()[previousArgKey] || []
    ];
    let choices;
    for (const possibleAlias of possibleAliases) {
      if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
        choices = options.choices[possibleAlias];
        break;
      }
    }
    if (choices) {
      return choices.filter((choice) => !filter || choice.startsWith(filter));
    }
  }
  previousArgHasChoices(args) {
    const choices = this.getPreviousArgChoices(args);
    return choices !== void 0 && choices.length > 0;
  }
  argsContainKey(args, key, negable) {
    const argsContains = (s3) => args.indexOf((/^[^0-9]$/.test(s3) ? "-" : "--") + s3) !== -1;
    if (argsContains(key))
      return true;
    if (negable && argsContains(`no-${key}`))
      return true;
    if (this.aliases) {
      for (const alias of this.aliases[key]) {
        if (argsContains(alias))
          return true;
      }
    }
    return false;
  }
  completeOptionKey(key, completions, current, negable) {
    var _a3, _b2, _c2, _d;
    let keyWithDesc = key;
    if (this.zshShell) {
      const descs = this.usage.getDescriptions();
      const aliasKey = (_b2 = (_a3 = this === null || this === void 0 ? void 0 : this.aliases) === null || _a3 === void 0 ? void 0 : _a3[key]) === null || _b2 === void 0 ? void 0 : _b2.find((alias) => {
        const desc2 = descs[alias];
        return typeof desc2 === "string" && desc2.length > 0;
      });
      const descFromAlias = aliasKey ? descs[aliasKey] : void 0;
      const desc = (_d = (_c2 = descs[key]) !== null && _c2 !== void 0 ? _c2 : descFromAlias) !== null && _d !== void 0 ? _d : "";
      keyWithDesc = `${key.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const startsByTwoDashes = (s3) => /^--/.test(s3);
    const isShortOption = (s3) => /^[^0-9]$/.test(s3);
    const dashes = !startsByTwoDashes(current) && isShortOption(key) ? "-" : "--";
    completions.push(dashes + keyWithDesc);
    if (negable) {
      completions.push(dashes + "no-" + keyWithDesc);
    }
  }
  customCompletion(args, argv, current, done) {
    assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
    if (isSyncCompletionFunction(this.customCompletionFunction)) {
      const result = this.customCompletionFunction(current, argv);
      if (isPromise(result)) {
        return result.then((list) => {
          this.shim.process.nextTick(() => {
            done(null, list);
          });
        }).catch((err) => {
          this.shim.process.nextTick(() => {
            done(err, void 0);
          });
        });
      }
      return done(null, result);
    } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
      return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), (completions) => {
        done(null, completions);
      });
    } else {
      return this.customCompletionFunction(current, argv, (completions) => {
        done(null, completions);
      });
    }
  }
  getCompletion(args, done) {
    const current = args.length ? args[args.length - 1] : "";
    const argv = this.yargs.parse(args, true);
    const completionFunction = this.customCompletionFunction ? (argv2) => this.customCompletion(args, argv2, current, done) : (argv2) => this.defaultCompletion(args, argv2, current, done);
    return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
  }
  generateCompletionScript($0, cmd) {
    let script = this.zshShell ? completionZshTemplate : completionShTemplate;
    const name = this.shim.path.basename($0);
    if ($0.match(/\.js$/))
      $0 = `./${$0}`;
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  }
  registerFunction(fn) {
    this.customCompletionFunction = fn;
  }
  setParsed(parsed) {
    this.aliases = parsed.aliases;
  }
};
function completion(yargs, usage2, command2, shim3) {
  return new Completion(yargs, usage2, command2, shim3);
}
function isSyncCompletionFunction(completionFunction) {
  return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
  return completionFunction.length > 3;
}

// node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a3, b) {
  if (a3.length === 0)
    return b.length;
  if (b.length === 0)
    return a3.length;
  const matrix = [];
  let i4;
  for (i4 = 0; i4 <= b.length; i4++) {
    matrix[i4] = [i4];
  }
  let j3;
  for (j3 = 0; j3 <= a3.length; j3++) {
    matrix[0][j3] = j3;
  }
  for (i4 = 1; i4 <= b.length; i4++) {
    for (j3 = 1; j3 <= a3.length; j3++) {
      if (b.charAt(i4 - 1) === a3.charAt(j3 - 1)) {
        matrix[i4][j3] = matrix[i4 - 1][j3 - 1];
      } else {
        if (i4 > 1 && j3 > 1 && b.charAt(i4 - 2) === a3.charAt(j3 - 1) && b.charAt(i4 - 1) === a3.charAt(j3 - 2)) {
          matrix[i4][j3] = matrix[i4 - 2][j3 - 2] + 1;
        } else {
          matrix[i4][j3] = Math.min(matrix[i4 - 1][j3 - 1] + 1, Math.min(matrix[i4][j3 - 1] + 1, matrix[i4 - 1][j3] + 1));
        }
      }
    }
  }
  return matrix[b.length][a3.length];
}

// node_modules/yargs/build/lib/validation.js
var specialKeys = ["$0", "--", "_"];
function validation(yargs, usage2, shim3) {
  const __ = shim3.y18n.__;
  const __n = shim3.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = function nonOptionCount(argv) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== void 0) {
          usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== void 0) {
          usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  };
  self2.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
    }
  };
  self2.requiredArguments = function requiredArguments(argv, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
      usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
    }
  };
  self2.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
    var _a3;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach((key) => {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });
    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded = ((_a3 = demandedCommands._) === null || _a3 === void 0 ? void 0 : _a3.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv._.length) {
        argv._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.map((s3) => s3.trim() ? s3 : `"${s3}"`).join(", ")));
    }
  };
  self2.unknownCommands = function unknownCommands(argv) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
      return true;
    } else {
      return false;
    }
  };
  self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [key, ...aliases[key]].some((a3) => !Object.prototype.hasOwnProperty.call(newAliases, a3) || !newAliases[key]);
  };
  self2.limitedChoices = function limitedChoices(argv) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length)
      return;
    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach((value) => {
          if (options.choices[key].indexOf(value) === -1 && value !== void 0) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length)
      return;
    let msg = __("Invalid values:");
    invalidKeys.forEach((key) => {
      msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  };
  let implied = {};
  self2.implies = function implies(key, value) {
    argsert("<string|object> [array|number|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k4) => {
        self2.implies(k4, key[k4]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i4) => self2.implies(key, i4));
      } else {
        assertNotStrictEqual(value, void 0, shim3);
        implied[key].push(value);
      }
    }
  };
  self2.getImplied = function getImplied() {
    return implied;
  };
  function keyExists(argv, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === "number") {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }
    return val;
  }
  self2.implications = function implications(argv) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value) => {
        let key2 = origKey;
        const origValue = value;
        key2 = keyExists(argv, key2);
        value = keyExists(argv, value);
        if (key2 && !value) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__("Implications failed:")}
`;
      implyFail.forEach((value) => {
        msg += value;
      });
      usage2.fail(msg);
    }
  };
  let conflicting = {};
  self2.conflicts = function conflicts(key, value) {
    argsert("<string|object> [array|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k4) => {
        self2.conflicts(k4, key[k4]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i4) => self2.conflicts(key, i4));
      } else {
        conflicting[key].push(value);
      }
    }
  };
  self2.getConflicting = () => conflicting;
  self2.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value) => {
          if (value && argv[key] !== void 0 && argv[value] !== void 0) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()["strip-dashed"]) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value) => {
          if (value && argv[shim3.Parser.camelCase(key)] !== void 0 && argv[shim3.Parser.camelCase(value)] !== void 0) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      });
    }
  };
  self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a3, b) => b.length - a3.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i4 = 0, candidate; (candidate = potentialCommands[i4]) !== void 0; i4++) {
      const d2 = levenshtein(cmd, candidate);
      if (d2 <= threshold && d2 < bestDistance) {
        bestDistance = d2;
        recommended = candidate;
      }
    }
    if (recommended)
      usage2.fail(__("Did you mean %s?", recommended));
  };
  self2.reset = function reset(localLookup) {
    implied = objFilter(implied, (k4) => !localLookup[k4]);
    conflicting = objFilter(conflicting, (k4) => !localLookup[k4]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      implied,
      conflicting
    });
  };
  self2.unfreeze = function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, void 0, shim3);
    ({ implied, conflicting } = frozen);
  };
  return self2;
}

// node_modules/yargs/build/lib/utils/apply-extends.js
var previouslyVisitedConfigs = [];
var shim2;
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim2 = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, "extends")) {
    if (typeof config.extends !== "string")
      return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath ? JSON.parse(shim2.readFileSync(pathToDefault, "utf8")) : require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(defaultConfig, shim2.path.dirname(pathToDefault), mergeExtends, shim2);
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
  return shim2.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
  const target = {};
  function isObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject(config2[key]) && isObject(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
}

// node_modules/yargs/build/lib/yargs-factory.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f3) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _YargsInstance_command;
var _YargsInstance_cwd;
var _YargsInstance_context;
var _YargsInstance_completion;
var _YargsInstance_completionCommand;
var _YargsInstance_defaultShowHiddenOpt;
var _YargsInstance_exitError;
var _YargsInstance_detectLocale;
var _YargsInstance_emittedWarnings;
var _YargsInstance_exitProcess;
var _YargsInstance_frozens;
var _YargsInstance_globalMiddleware;
var _YargsInstance_groups;
var _YargsInstance_hasOutput;
var _YargsInstance_helpOpt;
var _YargsInstance_isGlobalContext;
var _YargsInstance_logger;
var _YargsInstance_output;
var _YargsInstance_options;
var _YargsInstance_parentRequire;
var _YargsInstance_parserConfig;
var _YargsInstance_parseFn;
var _YargsInstance_parseContext;
var _YargsInstance_pkgs;
var _YargsInstance_preservedGroups;
var _YargsInstance_processArgs;
var _YargsInstance_recommendCommands;
var _YargsInstance_shim;
var _YargsInstance_strict;
var _YargsInstance_strictCommands;
var _YargsInstance_strictOptions;
var _YargsInstance_usage;
var _YargsInstance_usageConfig;
var _YargsInstance_versionOpt;
var _YargsInstance_validation;
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, "argv", {
      get: () => {
        return yargs.parse();
      },
      enumerable: true
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
var kCopyDoubleDash = Symbol("copyDoubleDash");
var kCreateLogger = Symbol("copyDoubleDash");
var kDeleteFromParserHintObject = Symbol("deleteFromParserHintObject");
var kEmitWarning = Symbol("emitWarning");
var kFreeze = Symbol("freeze");
var kGetDollarZero = Symbol("getDollarZero");
var kGetParserConfiguration = Symbol("getParserConfiguration");
var kGetUsageConfiguration = Symbol("getUsageConfiguration");
var kGuessLocale = Symbol("guessLocale");
var kGuessVersion = Symbol("guessVersion");
var kParsePositionalNumbers = Symbol("parsePositionalNumbers");
var kPkgUp = Symbol("pkgUp");
var kPopulateParserHintArray = Symbol("populateParserHintArray");
var kPopulateParserHintSingleValueDictionary = Symbol("populateParserHintSingleValueDictionary");
var kPopulateParserHintArrayDictionary = Symbol("populateParserHintArrayDictionary");
var kPopulateParserHintDictionary = Symbol("populateParserHintDictionary");
var kSanitizeKey = Symbol("sanitizeKey");
var kSetKey = Symbol("setKey");
var kUnfreeze = Symbol("unfreeze");
var kValidateAsync = Symbol("validateAsync");
var kGetCommandInstance = Symbol("getCommandInstance");
var kGetContext = Symbol("getContext");
var kGetHasOutput = Symbol("getHasOutput");
var kGetLoggerInstance = Symbol("getLoggerInstance");
var kGetParseContext = Symbol("getParseContext");
var kGetUsageInstance = Symbol("getUsageInstance");
var kGetValidationInstance = Symbol("getValidationInstance");
var kHasParseCallback = Symbol("hasParseCallback");
var kIsGlobalContext = Symbol("isGlobalContext");
var kPostProcess = Symbol("postProcess");
var kRebase = Symbol("rebase");
var kReset = Symbol("reset");
var kRunYargsParserAndExecuteCommands = Symbol("runYargsParserAndExecuteCommands");
var kRunValidation = Symbol("runValidation");
var kSetHasOutput = Symbol("setHasOutput");
var kTrackManuallySetKeys = Symbol("kTrackManuallySetKeys");
var YargsInstance = class {
  constructor(processArgs = [], cwd, parentRequire, shim3) {
    this.customScriptName = false;
    this.parsed = false;
    _YargsInstance_command.set(this, void 0);
    _YargsInstance_cwd.set(this, void 0);
    _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
    _YargsInstance_completion.set(this, null);
    _YargsInstance_completionCommand.set(this, null);
    _YargsInstance_defaultShowHiddenOpt.set(this, "show-hidden");
    _YargsInstance_exitError.set(this, null);
    _YargsInstance_detectLocale.set(this, true);
    _YargsInstance_emittedWarnings.set(this, {});
    _YargsInstance_exitProcess.set(this, true);
    _YargsInstance_frozens.set(this, []);
    _YargsInstance_globalMiddleware.set(this, void 0);
    _YargsInstance_groups.set(this, {});
    _YargsInstance_hasOutput.set(this, false);
    _YargsInstance_helpOpt.set(this, null);
    _YargsInstance_isGlobalContext.set(this, true);
    _YargsInstance_logger.set(this, void 0);
    _YargsInstance_output.set(this, "");
    _YargsInstance_options.set(this, void 0);
    _YargsInstance_parentRequire.set(this, void 0);
    _YargsInstance_parserConfig.set(this, {});
    _YargsInstance_parseFn.set(this, null);
    _YargsInstance_parseContext.set(this, null);
    _YargsInstance_pkgs.set(this, {});
    _YargsInstance_preservedGroups.set(this, {});
    _YargsInstance_processArgs.set(this, void 0);
    _YargsInstance_recommendCommands.set(this, false);
    _YargsInstance_shim.set(this, void 0);
    _YargsInstance_strict.set(this, false);
    _YargsInstance_strictCommands.set(this, false);
    _YargsInstance_strictOptions.set(this, false);
    _YargsInstance_usage.set(this, void 0);
    _YargsInstance_usageConfig.set(this, {});
    _YargsInstance_versionOpt.set(this, null);
    _YargsInstance_validation.set(this, void 0);
    __classPrivateFieldSet(this, _YargsInstance_shim, shim3, "f");
    __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
    __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
    __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
    __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
    this.$0 = this[kGetDollarZero]();
    this[kReset]();
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
  }
  addHelpOpt(opt, msg) {
    const defaultHelpOpt = "help";
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
      __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
    }
    if (opt === false && msg === void 0)
      return this;
    __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === "string" ? opt : defaultHelpOpt, "f");
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show help"));
    return this;
  }
  help(opt, msg) {
    return this.addHelpOpt(opt, msg);
  }
  addShowHiddenOpt(opt, msg) {
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (opt === false && msg === void 0)
      return this;
    const showHiddenOpt = typeof opt === "string" ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    this.boolean(showHiddenOpt);
    this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show hidden options"));
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
    return this;
  }
  showHidden(opt, msg) {
    return this.addShowHiddenOpt(opt, msg);
  }
  alias(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.alias.bind(this), "alias", key, value);
    return this;
  }
  array(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("array", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  boolean(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("boolean", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  check(f3, global2) {
    argsert("<function> [boolean]", [f3, global2], arguments.length);
    this.middleware((argv, _yargs) => {
      return maybeAsyncResult(() => {
        return f3(argv, _yargs.getOptions());
      }, (result) => {
        if (!result) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__("Argument check failed: %s", f3.toString()));
        } else if (typeof result === "string" || result instanceof Error) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
        }
        return argv;
      }, (err) => {
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
        return argv;
      });
    }, false, global2);
    return this;
  }
  choices(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.choices.bind(this), "choices", key, value);
    return this;
  }
  coerce(keys, value) {
    argsert("<object|string|array> [function]", [keys, value], arguments.length);
    if (Array.isArray(keys)) {
      if (!value) {
        throw new YError("coerce callback must be provided");
      }
      for (const key of keys) {
        this.coerce(key, value);
      }
      return this;
    } else if (typeof keys === "object") {
      for (const key of Object.keys(keys)) {
        this.coerce(key, keys[key]);
      }
      return this;
    }
    if (!value) {
      throw new YError("coerce callback must be provided");
    }
    __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs) => {
      let aliases;
      const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
      if (!shouldCoerce) {
        return argv;
      }
      return maybeAsyncResult(() => {
        aliases = yargs.getAliases();
        return value(argv[keys]);
      }, (result) => {
        argv[keys] = result;
        const stripAliased = yargs.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (aliases[keys] && stripAliased !== true) {
          for (const alias of aliases[keys]) {
            argv[alias] = result;
          }
        }
        return argv;
      }, (err) => {
        throw new YError(err.message);
      });
    }, keys);
    return this;
  }
  conflicts(key1, key2) {
    argsert("<string|object> [string|array]", [key1, key2], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
    return this;
  }
  config(key = "config", msg, parseFn) {
    argsert("[object|string] [string|function] [function]", [key, msg, parseFn], arguments.length);
    if (typeof key === "object" && !Array.isArray(key)) {
      key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
      return this;
    }
    if (typeof msg === "function") {
      parseFn = msg;
      msg = void 0;
    }
    this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Path to JSON config file"));
    (Array.isArray(key) ? key : [key]).forEach((k4) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k4] = parseFn || true;
    });
    return this;
  }
  completion(cmd, desc, fn) {
    argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
    if (typeof desc === "function") {
      fn = desc;
      desc = void 0;
    }
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion", "f");
    if (!desc && desc !== false) {
      desc = "generate completion script";
    }
    this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
    if (fn)
      __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
    return this;
  }
  command(cmd, description, builder, handler, middlewares, deprecated) {
    argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
    return this;
  }
  commands(cmd, description, builder, handler, middlewares, deprecated) {
    return this.command(cmd, description, builder, handler, middlewares, deprecated);
  }
  commandDir(dir, opts) {
    argsert("<string> [object]", [dir, opts], arguments.length);
    const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
    return this;
  }
  count(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("count", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  default(key, value, defaultDescription) {
    argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
    if (defaultDescription) {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
    }
    if (typeof value === "function") {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key])
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
      value = value.call();
    }
    this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), "default", key, value);
    return this;
  }
  defaults(key, value, defaultDescription) {
    return this.default(key, value, defaultDescription);
  }
  demandCommand(min = 1, max, minMsg, maxMsg) {
    argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
    if (typeof max !== "number") {
      minMsg = max;
      max = Infinity;
    }
    this.global("_", false);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg
    };
    return this;
  }
  demand(keys, max, msg) {
    if (Array.isArray(max)) {
      max.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
      max = Infinity;
    } else if (typeof max !== "number") {
      msg = max;
      max = Infinity;
    }
    if (typeof keys === "number") {
      assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      this.demandCommand(keys, max, msg, msg);
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
    } else {
      if (typeof msg === "string") {
        this.demandOption(keys, msg);
      } else if (msg === true || typeof msg === "undefined") {
        this.demandOption(keys);
      }
    }
    return this;
  }
  demandOption(keys, msg) {
    argsert("<object|string|array> [string]", [keys, msg], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), "demandedOptions", keys, msg);
    return this;
  }
  deprecateOption(option, message) {
    argsert("<string> [string|boolean]", [option, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
    return this;
  }
  describe(keys, description) {
    argsert("<object|string|array> [string]", [keys, description], arguments.length);
    this[kSetKey](keys, true);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
    return this;
  }
  detectLocale(detect) {
    argsert("<boolean>", [detect], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
    return this;
  }
  env(prefix) {
    argsert("[string|boolean]", [prefix], arguments.length);
    if (prefix === false)
      delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    else
      __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || "";
    return this;
  }
  epilogue(msg) {
    argsert("<string>", [msg], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
    return this;
  }
  epilog(msg) {
    return this.epilogue(msg);
  }
  example(cmd, description) {
    argsert("<string|array> [string]", [cmd, description], arguments.length);
    if (Array.isArray(cmd)) {
      cmd.forEach((exampleParams) => this.example(...exampleParams));
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
    }
    return this;
  }
  exit(code, err) {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
  }
  exitProcess(enabled = true) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
    return this;
  }
  fail(f3) {
    argsert("<function|boolean>", [f3], arguments.length);
    if (typeof f3 === "boolean" && f3 !== false) {
      throw new YError("Invalid first argument. Expected function or boolean 'false'");
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f3);
    return this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(args, done) {
    argsert("<array> [function]", [args, done], arguments.length);
    if (!done) {
      return new Promise((resolve5, reject) => {
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
          if (err)
            reject(err);
          else
            resolve5(completions);
        });
      });
    } else {
      return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
    }
  }
  getDemandedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
  }
  getDemandedCommands() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
  }
  getExitProcess() {
    return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
  }
  getGroups() {
    return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
  }
  getHelp() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
        if (isPromise(parse)) {
          return parse.then(() => {
            return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
          });
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        return builderResponse.then(() => {
          return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
        });
      }
    }
    return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
  }
  getOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_options, "f");
  }
  getStrict() {
    return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
  }
  getStrictCommands() {
    return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
  }
  getStrictOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
  }
  global(globals, global2) {
    argsert("<string|array> [boolean]", [globals, global2], arguments.length);
    globals = [].concat(globals);
    if (global2 !== false) {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l3) => globals.indexOf(l3) === -1);
    } else {
      globals.forEach((g) => {
        if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g))
          __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
      });
    }
    return this;
  }
  group(opts, groupName) {
    argsert("<string|array> <string>", [opts, groupName], arguments.length);
    const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
    if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
      delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
    }
    const seen = {};
    __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key) => {
      if (seen[key])
        return false;
      return seen[key] = true;
    });
    return this;
  }
  hide(key) {
    argsert("<string>", [key], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
    return this;
  }
  implies(key, value) {
    argsert("<string|object> [number|string|array]", [key, value], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
    return this;
  }
  locale(locale) {
    argsert("[string]", [locale], arguments.length);
    if (locale === void 0) {
      this[kGuessLocale]();
      return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
    }
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
    return this;
  }
  middleware(callback, applyBeforeValidation, global2) {
    return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global2);
  }
  nargs(key, value) {
    argsert("<string|object|array> [number]", [key, value], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), "narg", key, value);
    return this;
  }
  normalize(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("normalize", keys);
    return this;
  }
  number(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("number", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  option(key, opt) {
    argsert("<string|object> [object]", [key, opt], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k4) => {
        this.options(k4, key[k4]);
      });
    } else {
      if (typeof opt !== "object") {
        opt = {};
      }
      this[kTrackManuallySetKeys](key);
      if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === "version" || (opt === null || opt === void 0 ? void 0 : opt.alias) === "version")) {
        this[kEmitWarning]([
          '"version" is a reserved word.',
          "Please do one of the following:",
          '- Disable version with `yargs.version(false)` if using "version" as an option',
          "- Use the built-in `yargs.version` method instead (if applicable)",
          "- Use a different option key",
          "https://yargs.js.org/docs/#api-reference-version"
        ].join("\n"), void 0, "versionWarning");
      }
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
      if (opt.alias)
        this.alias(key, opt.alias);
      const deprecate = opt.deprecate || opt.deprecated;
      if (deprecate) {
        this.deprecateOption(key, deprecate);
      }
      const demand = opt.demand || opt.required || opt.require;
      if (demand) {
        this.demand(key, demand);
      }
      if (opt.demandOption) {
        this.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
      }
      if (opt.conflicts) {
        this.conflicts(key, opt.conflicts);
      }
      if ("default" in opt) {
        this.default(key, opt.default);
      }
      if (opt.implies !== void 0) {
        this.implies(key, opt.implies);
      }
      if (opt.nargs !== void 0) {
        this.nargs(key, opt.nargs);
      }
      if (opt.config) {
        this.config(key, opt.configParser);
      }
      if (opt.normalize) {
        this.normalize(key);
      }
      if (opt.choices) {
        this.choices(key, opt.choices);
      }
      if (opt.coerce) {
        this.coerce(key, opt.coerce);
      }
      if (opt.group) {
        this.group(key, opt.group);
      }
      if (opt.boolean || opt.type === "boolean") {
        this.boolean(key);
        if (opt.alias)
          this.boolean(opt.alias);
      }
      if (opt.array || opt.type === "array") {
        this.array(key);
        if (opt.alias)
          this.array(opt.alias);
      }
      if (opt.number || opt.type === "number") {
        this.number(key);
        if (opt.alias)
          this.number(opt.alias);
      }
      if (opt.string || opt.type === "string") {
        this.string(key);
        if (opt.alias)
          this.string(opt.alias);
      }
      if (opt.count || opt.type === "count") {
        this.count(key);
      }
      if (typeof opt.global === "boolean") {
        this.global(key, opt.global);
      }
      if (opt.defaultDescription) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
      }
      if (opt.skipValidation) {
        this.skipValidation(key);
      }
      const desc = opt.describe || opt.description || opt.desc;
      const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
      if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === "string") {
        this.describe(key, desc);
      }
      if (opt.hidden) {
        this.hide(key);
      }
      if (opt.requiresArg) {
        this.requiresArg(key);
      }
    }
    return this;
  }
  options(key, opt) {
    return this.option(key, opt);
  }
  parse(args, shortCircuit, _parseFn) {
    argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
    this[kFreeze]();
    if (typeof args === "undefined") {
      args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    }
    if (typeof shortCircuit === "object") {
      __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
      shortCircuit = _parseFn;
    }
    if (typeof shortCircuit === "function") {
      __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
      shortCircuit = false;
    }
    if (!shortCircuit)
      __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
      __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
    const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
    const tmpParsed = this.parsed;
    __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
    if (isPromise(parsed)) {
      return parsed.then((argv) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        return argv;
      }).catch((err) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        }
        throw err;
      }).finally(() => {
        this[kUnfreeze]();
        this.parsed = tmpParsed;
      });
    } else {
      if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
        __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
      this[kUnfreeze]();
      this.parsed = tmpParsed;
    }
    return parsed;
  }
  parseAsync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
  }
  parseSync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    if (isPromise(maybePromise)) {
      throw new YError(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    }
    return maybePromise;
  }
  parserConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
    return this;
  }
  pkgConf(key, rootPath) {
    argsert("<string> [string]", [key, rootPath], arguments.length);
    let conf = null;
    const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
    if (obj[key] && typeof obj[key] === "object") {
      conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
    }
    return this;
  }
  positional(key, opts) {
    argsert("<string> <object>", [key, opts], arguments.length);
    const supportedOpts = [
      "default",
      "defaultDescription",
      "implies",
      "normalize",
      "choices",
      "conflicts",
      "coerce",
      "type",
      "describe",
      "desc",
      "description",
      "alias"
    ];
    opts = objFilter(opts, (k4, v3) => {
      if (k4 === "type" && !["string", "number", "boolean"].includes(v3))
        return false;
      return supportedOpts.includes(k4);
    });
    const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
    const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    };
    objectKeys(parseOptions).forEach((pk) => {
      const parseOption = parseOptions[pk];
      if (Array.isArray(parseOption)) {
        if (parseOption.indexOf(key) !== -1)
          opts[pk] = true;
      } else {
        if (parseOption[key] && !(pk in opts))
          opts[pk] = parseOption[key];
      }
    });
    this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
    return this.option(key, opts);
  }
  recommendCommands(recommend = true) {
    argsert("[boolean]", [recommend], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
    return this;
  }
  required(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  require(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  requiresArg(keys) {
    argsert("<array|string|object> [number]", [keys], arguments.length);
    if (typeof keys === "string" && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
      return this;
    } else {
      this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), "narg", keys, NaN);
    }
    return this;
  }
  showCompletionScript($0, cmd) {
    argsert("[string] [string]", [$0, cmd], arguments.length);
    $0 = $0 || this.$0;
    __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion"));
    return this;
  }
  showHelp(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
        if (isPromise(parse)) {
          parse.then(() => {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
          });
          return this;
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        builderResponse.then(() => {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        });
        return this;
      }
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
    return this;
  }
  scriptName(scriptName) {
    this.customScriptName = true;
    this.$0 = scriptName;
    return this;
  }
  showHelpOnFail(enabled, message) {
    argsert("[boolean|string] [string]", [enabled, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
    return this;
  }
  showVersion(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
    return this;
  }
  skipValidation(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("skipValidation", keys);
    return this;
  }
  strict(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
    return this;
  }
  strictCommands(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
    return this;
  }
  strictOptions(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
    return this;
  }
  string(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("string", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  terminalWidth() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
  }
  updateLocale(obj) {
    return this.updateStrings(obj);
  }
  updateStrings(obj) {
    argsert("<object>", [obj], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
    return this;
  }
  usage(msg, description, builder, handler) {
    argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
    if (description !== void 0) {
      assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if ((msg || "").match(/^\$0( |$)/)) {
        return this.command(msg, description, builder, handler);
      } else {
        throw new YError(".usage() description must start with $0 if being used as alias for .command()");
      }
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
      return this;
    }
  }
  usageConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
    return this;
  }
  version(opt, msg, ver) {
    const defaultVersionOpt = "version";
    argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(void 0);
      __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
    }
    if (arguments.length === 0) {
      ver = this[kGuessVersion]();
      opt = defaultVersionOpt;
    } else if (arguments.length === 1) {
      if (opt === false) {
        return this;
      }
      ver = opt;
      opt = defaultVersionOpt;
    } else if (arguments.length === 2) {
      ver = msg;
      msg = void 0;
    }
    __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === "string" ? opt : defaultVersionOpt, "f");
    msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show version number");
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || void 0);
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
    return this;
  }
  wrap(cols) {
    argsert("<number|null|undefined>", [cols], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
    return this;
  }
  [(_YargsInstance_command = /* @__PURE__ */ new WeakMap(), _YargsInstance_cwd = /* @__PURE__ */ new WeakMap(), _YargsInstance_context = /* @__PURE__ */ new WeakMap(), _YargsInstance_completion = /* @__PURE__ */ new WeakMap(), _YargsInstance_completionCommand = /* @__PURE__ */ new WeakMap(), _YargsInstance_defaultShowHiddenOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_exitError = /* @__PURE__ */ new WeakMap(), _YargsInstance_detectLocale = /* @__PURE__ */ new WeakMap(), _YargsInstance_emittedWarnings = /* @__PURE__ */ new WeakMap(), _YargsInstance_exitProcess = /* @__PURE__ */ new WeakMap(), _YargsInstance_frozens = /* @__PURE__ */ new WeakMap(), _YargsInstance_globalMiddleware = /* @__PURE__ */ new WeakMap(), _YargsInstance_groups = /* @__PURE__ */ new WeakMap(), _YargsInstance_hasOutput = /* @__PURE__ */ new WeakMap(), _YargsInstance_helpOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_isGlobalContext = /* @__PURE__ */ new WeakMap(), _YargsInstance_logger = /* @__PURE__ */ new WeakMap(), _YargsInstance_output = /* @__PURE__ */ new WeakMap(), _YargsInstance_options = /* @__PURE__ */ new WeakMap(), _YargsInstance_parentRequire = /* @__PURE__ */ new WeakMap(), _YargsInstance_parserConfig = /* @__PURE__ */ new WeakMap(), _YargsInstance_parseFn = /* @__PURE__ */ new WeakMap(), _YargsInstance_parseContext = /* @__PURE__ */ new WeakMap(), _YargsInstance_pkgs = /* @__PURE__ */ new WeakMap(), _YargsInstance_preservedGroups = /* @__PURE__ */ new WeakMap(), _YargsInstance_processArgs = /* @__PURE__ */ new WeakMap(), _YargsInstance_recommendCommands = /* @__PURE__ */ new WeakMap(), _YargsInstance_shim = /* @__PURE__ */ new WeakMap(), _YargsInstance_strict = /* @__PURE__ */ new WeakMap(), _YargsInstance_strictCommands = /* @__PURE__ */ new WeakMap(), _YargsInstance_strictOptions = /* @__PURE__ */ new WeakMap(), _YargsInstance_usage = /* @__PURE__ */ new WeakMap(), _YargsInstance_usageConfig = /* @__PURE__ */ new WeakMap(), _YargsInstance_versionOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_validation = /* @__PURE__ */ new WeakMap(), kCopyDoubleDash)](argv) {
    if (!argv._ || !argv["--"])
      return argv;
    argv._.push.apply(argv._, argv["--"]);
    try {
      delete argv["--"];
    } catch (_err) {
    }
    return argv;
  }
  [kCreateLogger]() {
    return {
      log: (...args) => {
        if (!this[kHasParseCallback]())
          console.log(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      },
      error: (...args) => {
        if (!this[kHasParseCallback]())
          console.error(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      }
    };
  }
  [kDeleteFromParserHintObject](optionKey) {
    objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey) => {
      if (/* @__PURE__ */ ((key) => key === "configObjects")(hintKey))
        return;
      const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
      if (Array.isArray(hint)) {
        if (hint.includes(optionKey))
          hint.splice(hint.indexOf(optionKey), 1);
      } else if (typeof hint === "object") {
        delete hint[optionKey];
      }
    });
    delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
  }
  [kEmitWarning](warning, type, deduplicationId) {
    if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
      __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
    }
  }
  [kFreeze]() {
    __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
      options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
      configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
      exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
      groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
      strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
      strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
      strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
      completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
      output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
      exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
      hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
      parsed: this.parsed,
      parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
      parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
    });
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
  }
  [kGetDollarZero]() {
    let $0 = "";
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
    } else {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
    }
    $0 = default$0.map((x3) => {
      const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x3);
      return x3.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x3.length ? b : x3;
    }).join(" ").trim();
    if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_") && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_")) {
      $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_").replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, "");
    }
    return $0;
  }
  [kGetParserConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
  }
  [kGetUsageConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
  }
  [kGuessLocale]() {
    if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f"))
      return;
    const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_ALL") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_MESSAGES") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANG") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(locale.replace(/[.:].*/, ""));
  }
  [kGuessVersion]() {
    const obj = this[kPkgUp]();
    return obj.version || "unknown";
  }
  [kParsePositionalNumbers](argv) {
    const args = argv["--"] ? argv["--"] : argv._;
    for (let i4 = 0, arg; (arg = args[i4]) !== void 0; i4++) {
      if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
        args[i4] = Number(arg);
      }
    }
    return argv;
  }
  [kPkgUp](rootPath) {
    const npath = rootPath || "*";
    if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath])
      return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    let obj = {};
    try {
      let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
      if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
        startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
      }
      const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
        if (names.includes("package.json")) {
          return "package.json";
        } else {
          return void 0;
        }
      });
      assertNotStrictEqual(pkgJsonPath, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, "utf8"));
    } catch (_noop) {
    }
    __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
    return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
  }
  [kPopulateParserHintArray](type, keys) {
    keys = [].concat(keys);
    keys.forEach((key) => {
      key = this[kSanitizeKey](key);
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
    });
  }
  [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = value2;
    });
  }
  [kPopulateParserHintArrayDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] || []).concat(value2);
    });
  }
  [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
    if (Array.isArray(key)) {
      key.forEach((k4) => {
        builder(k4, value);
      });
    } else if (/* @__PURE__ */ ((key2) => typeof key2 === "object")(key)) {
      for (const k4 of objectKeys(key)) {
        builder(k4, key[k4]);
      }
    } else {
      singleKeyHandler(type, this[kSanitizeKey](key), value);
    }
  }
  [kSanitizeKey](key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  [kSetKey](key, set) {
    this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), "key", key, set);
    return this;
  }
  [kUnfreeze]() {
    var _a3, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
    assertNotStrictEqual(frozen, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
    let configObjects;
    _a3 = this, _b2 = this, _c2 = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, {
      options: { set value(_o) {
        __classPrivateFieldSet(_a3, _YargsInstance_options, _o, "f");
      } }.value,
      configObjects,
      exitProcess: { set value(_o) {
        __classPrivateFieldSet(_b2, _YargsInstance_exitProcess, _o, "f");
      } }.value,
      groups: { set value(_o) {
        __classPrivateFieldSet(_c2, _YargsInstance_groups, _o, "f");
      } }.value,
      output: { set value(_o) {
        __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
      } }.value,
      exitError: { set value(_o) {
        __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
      } }.value,
      hasOutput: { set value(_o) {
        __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
      } }.value,
      parsed: this.parsed,
      strict: { set value(_o) {
        __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
      } }.value,
      strictCommands: { set value(_o) {
        __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
      } }.value,
      strictOptions: { set value(_o) {
        __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
      } }.value,
      completionCommand: { set value(_o) {
        __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
      } }.value,
      parseFn: { set value(_o) {
        __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
      } }.value,
      parseContext: { set value(_o) {
        __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
      } }.value
    } = frozen;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
  }
  [kValidateAsync](validation2, argv) {
    return maybeAsyncResult(argv, (result) => {
      validation2(result);
      return result;
    });
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[kGetCommandInstance].bind(this),
      getContext: this[kGetContext].bind(this),
      getHasOutput: this[kGetHasOutput].bind(this),
      getLoggerInstance: this[kGetLoggerInstance].bind(this),
      getParseContext: this[kGetParseContext].bind(this),
      getParserConfiguration: this[kGetParserConfiguration].bind(this),
      getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
      getUsageInstance: this[kGetUsageInstance].bind(this),
      getValidationInstance: this[kGetValidationInstance].bind(this),
      hasParseCallback: this[kHasParseCallback].bind(this),
      isGlobalContext: this[kIsGlobalContext].bind(this),
      postProcess: this[kPostProcess].bind(this),
      reset: this[kReset].bind(this),
      runValidation: this[kRunValidation].bind(this),
      runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
      setHasOutput: this[kSetHasOutput].bind(this)
    };
  }
  [kGetCommandInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_command, "f");
  }
  [kGetContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_context, "f");
  }
  [kGetHasOutput]() {
    return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
  }
  [kGetLoggerInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
  }
  [kGetParseContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
  }
  [kGetUsageInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
  }
  [kGetValidationInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
  }
  [kHasParseCallback]() {
    return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
  }
  [kIsGlobalContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
  }
  [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
    if (calledFromCommand)
      return argv;
    if (isPromise(argv))
      return argv;
    if (!populateDoubleDash) {
      argv = this[kCopyDoubleDash](argv);
    }
    const parsePositionalNumbers = this[kGetParserConfiguration]()["parse-positional-numbers"] || this[kGetParserConfiguration]()["parse-positional-numbers"] === void 0;
    if (parsePositionalNumbers) {
      argv = this[kParsePositionalNumbers](argv);
    }
    if (runGlobalMiddleware) {
      argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
    }
    return argv;
  }
  [kReset](aliases = {}) {
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
    const tmpOptions = {};
    tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
    tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
    const localLookup = {};
    tmpOptions.local.forEach((l3) => {
      localLookup[l3] = true;
      (aliases[l3] || []).forEach((a3) => {
        localLookup[a3] = true;
      });
    });
    Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
      const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key) => !(key in localLookup));
      if (keys.length > 0) {
        acc[groupName] = keys;
      }
      return acc;
    }, {}));
    __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
    const arrayOptions = [
      "array",
      "boolean",
      "string",
      "skipValidation",
      "count",
      "normalize",
      "number",
      "hiddenOptions"
    ];
    const objectOptions = [
      "narg",
      "key",
      "alias",
      "default",
      "defaultDescription",
      "config",
      "choices",
      "demandedOptions",
      "demandedCommands",
      "deprecatedOptions"
    ];
    arrayOptions.forEach((k4) => {
      tmpOptions[k4] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k4] || []).filter((k5) => !localLookup[k5]);
    });
    objectOptions.forEach((k4) => {
      tmpOptions[k4] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k4], (k5) => !localLookup[k5]);
    });
    tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f"))
      __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_output, "", "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
    this.parsed = false;
    return this;
  }
  [kRebase](base, dir) {
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
  }
  [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
    let skipValidation = !!calledFromCommand || helpOnly;
    args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
    const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration["populate--"];
    const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
      "populate--": true
    });
    const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
      configuration: { "parse-positional-numbers": false, ...config }
    }));
    const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
    let argvPromise = void 0;
    const aliases = parsed.aliases;
    let helpOptSet = false;
    let versionOptSet = false;
    Object.keys(argv).forEach((key) => {
      if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
        helpOptSet = true;
      } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
        versionOptSet = true;
      }
    });
    argv.$0 = this.$0;
    this.parsed = parsed;
    if (commandIndex === 0) {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
    }
    try {
      this[kGuessLocale]();
      if (shortCircuit) {
        return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
        const helpCmds = [__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k4) => k4.length > 1);
        if (helpCmds.includes("" + argv._[argv._.length - 1])) {
          argv._.pop();
          helpOptSet = true;
        }
      }
      __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
      const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
      const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
      const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand;
          for (let i4 = commandIndex || 0, cmd; argv._[i4] !== void 0; i4++) {
            cmd = String(argv._[i4]);
            if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i4 + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
              return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              firstUnknownCommand = cmd;
              break;
            }
          }
          if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
          }
        }
        if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          this.showCompletionScript();
          this.exit(0);
        }
      }
      if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
        const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (requestCompletions) {
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
          setBlocking(true);
        args = [].concat(args);
        const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
          if (err)
            throw new YError(err.message);
          (completions || []).forEach((completion2) => {
            __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion2);
          });
          this.exit(0);
        });
        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
      }
      if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
        if (helpOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          this.showHelp("log");
          this.exit(0);
        } else if (versionOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion("log");
          this.exit(0);
        }
      }
      if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
        skipValidation = Object.keys(argv).some((key) => __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
      }
      if (!skipValidation) {
        if (parsed.error)
          throw new YError(parsed.error.message);
        if (!requestCompletions) {
          const validation2 = this[kRunValidation](aliases, {}, parsed.error);
          if (!calledFromCommand) {
            argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
          }
          argvPromise = this[kValidateAsync](validation2, argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv);
          if (isPromise(argvPromise) && !calledFromCommand) {
            argvPromise = argvPromise.then(() => {
              return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
            });
          }
        }
      }
    } catch (err) {
      if (err instanceof YError)
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
      else
        throw err;
    }
    return this[kPostProcess](argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
  }
  [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
    const demandedOptions = { ...this.getDemandedOptions() };
    return (argv) => {
      if (parseErrors)
        throw new YError(parseErrors.message);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
      let failedStrictCommands = false;
      if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
        failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
      } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
      }
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
    };
  }
  [kSetHasOutput]() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
  }
  [kTrackManuallySetKeys](keys) {
    if (typeof keys === "string") {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    } else {
      for (const k4 of keys) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k4] = true;
      }
    }
  }
};
function isYargsInstance(y3) {
  return !!y3 && typeof y3.getInternalMethods === "function";
}

// node_modules/yargs/index.mjs
var Yargs = YargsFactory(esm_default);
var yargs_default = Yargs;

// src/bin/commands/build.ts
var import_fs6 = require("fs");
var import_path7 = __toESM(require("path"));
var import_pitcher_common35 = __toESM(require_dist3());

// node_modules/@hey-api/client-fetch/dist/index.js
var U = /\{[^{}]+\}/g;
var S = ({ allowReserved: n2, name: t3, value: r3 }) => {
  if (r3 == null) return "";
  if (typeof r3 == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
  return `${t3}=${n2 ? r3 : encodeURIComponent(r3)}`;
};
var $ = (n2) => {
  switch (n2) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var D = (n2) => {
  switch (n2) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var _ = (n2) => {
  switch (n2) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var C = ({ allowReserved: n2, explode: t3, name: r3, style: o2, value: a3 }) => {
  if (!t3) {
    let e3 = (n2 ? a3 : a3.map((s3) => encodeURIComponent(s3))).join(D(o2));
    switch (o2) {
      case "label":
        return `.${e3}`;
      case "matrix":
        return `;${r3}=${e3}`;
      case "simple":
        return e3;
      default:
        return `${r3}=${e3}`;
    }
  }
  let c3 = $(o2), i4 = a3.map((e3) => o2 === "label" || o2 === "simple" ? n2 ? e3 : encodeURIComponent(e3) : S({ allowReserved: n2, name: r3, value: e3 })).join(c3);
  return o2 === "label" || o2 === "matrix" ? c3 + i4 : i4;
};
var A = ({ allowReserved: n2, explode: t3, name: r3, style: o2, value: a3 }) => {
  if (a3 instanceof Date) return `${r3}=${a3.toISOString()}`;
  if (o2 !== "deepObject" && !t3) {
    let e3 = [];
    Object.entries(a3).forEach(([u4, g]) => {
      e3 = [...e3, u4, n2 ? g : encodeURIComponent(g)];
    });
    let s3 = e3.join(",");
    switch (o2) {
      case "form":
        return `${r3}=${s3}`;
      case "label":
        return `.${s3}`;
      case "matrix":
        return `;${r3}=${s3}`;
      default:
        return s3;
    }
  }
  let c3 = _(o2), i4 = Object.entries(a3).map(([e3, s3]) => S({ allowReserved: n2, name: o2 === "deepObject" ? `${r3}[${e3}]` : e3, value: s3 })).join(c3);
  return o2 === "label" || o2 === "matrix" ? c3 + i4 : i4;
};
var k = ({ path: n2, url: t3 }) => {
  let r3 = t3, o2 = t3.match(U);
  if (o2) for (let a3 of o2) {
    let c3 = false, i4 = a3.substring(1, a3.length - 1), e3 = "simple";
    i4.endsWith("*") && (c3 = true, i4 = i4.substring(0, i4.length - 1)), i4.startsWith(".") ? (i4 = i4.substring(1), e3 = "label") : i4.startsWith(";") && (i4 = i4.substring(1), e3 = "matrix");
    let s3 = n2[i4];
    if (s3 == null) continue;
    if (Array.isArray(s3)) {
      r3 = r3.replace(a3, C({ explode: c3, name: i4, style: e3, value: s3 }));
      continue;
    }
    if (typeof s3 == "object") {
      r3 = r3.replace(a3, A({ explode: c3, name: i4, style: e3, value: s3 }));
      continue;
    }
    if (e3 === "matrix") {
      r3 = r3.replace(a3, `;${S({ name: i4, value: s3 })}`);
      continue;
    }
    let u4 = encodeURIComponent(e3 === "label" ? `.${s3}` : s3);
    r3 = r3.replace(a3, u4);
  }
  return r3;
};
var R = ({ allowReserved: n2, array: t3, object: r3 } = {}) => (a3) => {
  let c3 = [];
  if (a3 && typeof a3 == "object") for (let i4 in a3) {
    let e3 = a3[i4];
    if (e3 != null) {
      if (Array.isArray(e3)) {
        c3 = [...c3, C({ allowReserved: n2, explode: true, name: i4, style: "form", value: e3, ...t3 })];
        continue;
      }
      if (typeof e3 == "object") {
        c3 = [...c3, A({ allowReserved: n2, explode: true, name: i4, style: "deepObject", value: e3, ...r3 })];
        continue;
      }
      c3 = [...c3, S({ allowReserved: n2, name: i4, value: e3 })];
    }
  }
  return c3.join("&");
};
var w = (n2) => {
  if (!n2) return;
  let t3 = n2.split(";")[0].trim();
  if (t3.startsWith("application/json") || t3.endsWith("+json")) return "json";
  if (t3 === "multipart/form-data") return "formData";
  if (["application/", "audio/", "image/", "video/"].some((r3) => t3.startsWith(r3))) return "blob";
  if (t3.startsWith("text/")) return "text";
};
var P = ({ baseUrl: n2, path: t3, query: r3, querySerializer: o2, url: a3 }) => {
  let c3 = a3.startsWith("/") ? a3 : `/${a3}`, i4 = n2 + c3;
  t3 && (i4 = k({ path: t3, url: i4 }));
  let e3 = r3 ? o2(r3) : "";
  return e3.startsWith("?") && (e3 = e3.substring(1)), e3 && (i4 += `?${e3}`), i4;
};
var O = (n2, t3) => {
  let r3 = { ...n2, ...t3 };
  return r3.baseUrl?.endsWith("/") && (r3.baseUrl = r3.baseUrl.substring(0, r3.baseUrl.length - 1)), r3.headers = x(n2.headers, t3.headers), r3;
};
var x = (...n2) => {
  let t3 = new Headers();
  for (let r3 of n2) {
    if (!r3 || typeof r3 != "object") continue;
    let o2 = r3 instanceof Headers ? r3.entries() : Object.entries(r3);
    for (let [a3, c3] of o2) if (c3 === null) t3.delete(a3);
    else if (Array.isArray(c3)) for (let i4 of c3) t3.append(a3, i4);
    else c3 !== void 0 && t3.set(a3, typeof c3 == "object" ? JSON.stringify(c3) : c3);
  }
  return t3;
};
var y = class {
  _fns;
  constructor() {
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(t3) {
    return this._fns.indexOf(t3) !== -1;
  }
  eject(t3) {
    let r3 = this._fns.indexOf(t3);
    r3 !== -1 && (this._fns = [...this._fns.slice(0, r3), ...this._fns.slice(r3 + 1)]);
  }
  use(t3) {
    this._fns = [...this._fns, t3];
  }
};
var E = () => ({ error: new y(), request: new y(), response: new y() });
var I = { bodySerializer: (n2) => JSON.stringify(n2) };
var N = R({ allowReserved: false, array: { explode: true, style: "form" }, object: { explode: true, style: "deepObject" } });
var B = { "Content-Type": "application/json" };
var z = (n2 = {}) => ({ ...I, baseUrl: "", headers: B, parseAs: "auto", querySerializer: N, ...n2 });
var L = (n2 = {}) => {
  let t3 = O(z(), n2), r3 = () => ({ ...t3 }), o2 = (e3) => (t3 = O(t3, e3), r3()), a3 = (e3) => P({ baseUrl: e3.baseUrl ?? "", path: e3.path, query: e3.query, querySerializer: typeof e3.querySerializer == "function" ? e3.querySerializer : R(e3.querySerializer), url: e3.url }), c3 = E(), i4 = async (e3) => {
    let s3 = { ...t3, ...e3, fetch: e3.fetch ?? t3.fetch ?? globalThis.fetch, headers: x(t3.headers, e3.headers) };
    s3.body && s3.bodySerializer && (s3.body = s3.bodySerializer(s3.body)), s3.body || s3.headers.delete("Content-Type");
    let u4 = a3(s3), g = { redirect: "follow", ...s3 }, f3 = new Request(u4, g);
    for (let p2 of c3.request._fns) f3 = await p2(f3, s3);
    let T2 = s3.fetch, l3 = await T2(f3);
    for (let p2 of c3.response._fns) l3 = await p2(l3, f3, s3);
    let m3 = { request: f3, response: l3 };
    if (l3.ok) {
      if (l3.status === 204 || l3.headers.get("Content-Length") === "0") return { data: {}, ...m3 };
      if (s3.parseAs === "stream") return { data: l3.body, ...m3 };
      let p2 = (s3.parseAs === "auto" ? w(l3.headers.get("Content-Type")) : s3.parseAs) ?? "json", b = await l3[p2]();
      return p2 === "json" && s3.responseTransformer && (b = await s3.responseTransformer(b)), { data: b, ...m3 };
    }
    let h3 = await l3.text();
    try {
      h3 = JSON.parse(h3);
    } catch {
    }
    let d2 = h3;
    for (let p2 of c3.error._fns) d2 = await p2(h3, l3, f3, s3);
    if (d2 = d2 || {}, s3.throwOnError) throw d2;
    return { error: d2, ...m3 };
  };
  return { buildUrl: a3, connect: (e3) => i4({ ...e3, method: "CONNECT" }), delete: (e3) => i4({ ...e3, method: "DELETE" }), get: (e3) => i4({ ...e3, method: "GET" }), getConfig: r3, head: (e3) => i4({ ...e3, method: "HEAD" }), interceptors: c3, options: (e3) => i4({ ...e3, method: "OPTIONS" }), patch: (e3) => i4({ ...e3, method: "PATCH" }), post: (e3) => i4({ ...e3, method: "POST" }), put: (e3) => i4({ ...e3, method: "PUT" }), request: i4, setConfig: o2, trace: (e3) => i4({ ...e3, method: "TRACE" }) };
};

// src/bin/commands/build.ts
var import_ora = __toESM(require_ora());

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var import_pitcher_common32 = __toESM(require_dist3());
var protocol = __toESM(require_src());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/MemoryFS.js
var import_pitcher_common = __toESM(require_dist3());
var MemoryFS = class {
  constructor() {
    this.pendingOperations = /* @__PURE__ */ new Map();
    this.revertOperations = /* @__PURE__ */ new Map();
    this.messageId = 0;
    this.incomingOperations = /* @__PURE__ */ new Set();
    this.remoteClock = 0;
    this.tree = new import_pitcher_common.bedrockFS.Tree();
  }
  populateTreeFromJSON(payload) {
    this.remoteClock = payload.clock;
    this.tree = import_pitcher_common.bedrockFS.Tree.fromJSON(payload.treeNodes);
    this.syncFSTree([]);
  }
  /** Applies an operation and returns the inverse operation */
  applyOperation(op) {
    switch (op.type) {
      case "create": {
        const parentNode = this.tree.getNodeById(op.parentId);
        if (!parentNode?.isDirNode())
          return false;
        switch (op.newEntry.type) {
          case import_pitcher_common.bedrockFS.NodeType.File:
            parentNode.createFileWithId(op.newEntry.id, op.newEntry.name);
            break;
          case import_pitcher_common.bedrockFS.NodeType.Directory:
            parentNode.createDirectoryWithId(op.newEntry.id, op.newEntry.name);
            break;
        }
        return {
          type: "delete",
          id: op.newEntry.id
        };
      }
      case "delete": {
        const nodeToDelete = this.tree.getNodeById(op.id);
        if (!nodeToDelete?.parentId)
          return false;
        this.tree.deleteNode(op.id);
        return {
          type: "create",
          parentId: nodeToDelete.parentId,
          newEntry: {
            id: nodeToDelete.id,
            type: nodeToDelete.type,
            // Typescript complains otherwise... but this should be fine
            name: nodeToDelete.name ?? ""
          }
        };
      }
      case "move": {
        const nodeToMove = this.tree.getNodeById(op.id);
        if (!nodeToMove)
          return false;
        const reverseOp = {
          type: "move",
          id: op.id
        };
        reverseOp.parentId = nodeToMove.parentId;
        if (op.name) {
          reverseOp.name = nodeToMove.name;
        }
        const parentId = op.parentId ?? nodeToMove.parentId;
        if (!parentId) {
          throw new Error("Move requires a parentId");
        }
        this.tree.moveNode(op.id, parentId, op.name);
        return reverseOp;
      }
    }
  }
  /** Apply a client-side created operation, these get added to a queue and synced to pitcher */
  applyPendingOperation(op) {
    this.messageId++;
    this.pendingOperations.set(this.messageId, op);
    const reverseOp = this.applyOperation(op);
    if (!reverseOp) {
      this.pendingOperations.delete(this.messageId);
      return false;
    }
    this.revertOperations.set(this.messageId, reverseOp);
    return this.messageId;
  }
  /**
   * received an operation notification from the server
   *
   * This can be:
   * - Operation created by other client
   * - Confirmation for a pending operation this client created
   */
  receiveNotification(evt) {
    this.incomingOperations.add(evt);
  }
  /**
   * sync the fs tree, dropping operations that have been processed by the server
   * @param pendingOpsToDrop the list of operations that have been processed by the server
   * @returns the amount of operations that have been applied
   */
  syncFSTree(pendingOpsToDrop) {
    let opCount = 0;
    const sortedEvents = [...this.incomingOperations].sort((a3, b) => a3.clock - b.clock);
    for (const op of this.revertOperations.values()) {
      this.applyOperation(op);
    }
    let nextClock = this.remoteClock + 1;
    for (const fsEvent of sortedEvents) {
      if (fsEvent.clock < nextClock) {
        this.incomingOperations.delete(fsEvent);
      } else if (fsEvent.clock === nextClock) {
        this.applyOperation(fsEvent.operation);
        this.incomingOperations.delete(fsEvent);
        this.remoteClock = fsEvent.clock;
        opCount++;
      }
      nextClock++;
    }
    for (const msgIdx of pendingOpsToDrop) {
      this.pendingOperations.delete(msgIdx);
      this.revertOperations.delete(msgIdx);
    }
    for (const msgId of this.pendingOperations.keys()) {
      const op = this.pendingOperations.get(msgId);
      if (op) {
        const reverseOp = this.applyOperation(op);
        if (!reverseOp) {
          this.revertOperations.delete(msgId);
          this.pendingOperations.delete(msgId);
        } else {
          this.revertOperations.set(msgId, reverseOp);
          opCount++;
        }
      }
    }
    return opCount;
  }
  getPathFromId(id) {
    const node = this.tree.getNodeById(id);
    if (node) {
      return node.path;
    }
  }
  getIdFromPath(path2) {
    return this.tree.getIdFromPath(path2);
  }
  getNodeById(id) {
    return this.tree.getNodeById(id);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/common/PendingPitcherMessage.js
var import_pitcher_common2 = __toESM(require_dist3());
var import_pitcher_protocol = __toESM(require_src());
var PITCHER_MESSAGE_TIMEOUT_MS = 9e4;
var PitcherMessageError = class _PitcherMessageError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  static match(error) {
    return error instanceof _PitcherMessageError;
  }
  static matchCode(error, code) {
    return error instanceof _PitcherMessageError && error.code === code;
  }
};
var PendingPitcherMessage = class extends import_pitcher_common2.Disposable {
  constructor(id, request, timeoutMs = PITCHER_MESSAGE_TIMEOUT_MS) {
    super();
    this._hasResolved = false;
    this.id = id;
    const data = {
      ...request,
      id
    };
    this.method = request.method;
    this.message = (0, import_pitcher_protocol.createRequestPayload)(data);
    this.timeoutRef = setTimeout(() => this.dispose(`Pitcher message ${this.method} timed out`), timeoutMs);
    this.onWillDispose(() => {
      if (this.timeoutRef) {
        clearTimeout(this.timeoutRef);
        this.timeoutRef = void 0;
      }
    });
    this.promise = new Promise((_resolve, _reject) => {
      this._resolve = _resolve;
      this._reject = _reject;
    }).then((response) => {
      if (response.status === import_pitcher_protocol.PitcherResponseStatus.RESOLVED) {
        return response.result;
      }
      const err = new PitcherMessageError(response.error.message, response.error.code);
      err.data = response.error.data;
      throw err;
    });
  }
  resolve(response) {
    if (!this.isDisposed && this._resolve) {
      this._resolve(response);
      this._hasResolved = true;
    }
    this.dispose();
  }
  reject(error) {
    if (!this.isDisposed && this._reject) {
      this._reject(error);
      this._hasResolved = true;
    }
    this.dispose();
  }
  unwrap() {
    return this.promise;
  }
  dispose(message) {
    if (!this._hasResolved && this._reject) {
      this._reject(new Error(message ?? `Pitcher message ${this.method} has been disposed`));
    }
    super.dispose();
    if (this.timeoutRef) {
      clearTimeout(this.timeoutRef);
      this.timeoutRef = void 0;
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/common/Rc.js
var import_pitcher_common3 = __toESM(require_dist3());
var RcRef = class extends import_pitcher_common3.Disposable {
  constructor(rc, onDrop) {
    super();
    this.rc = rc;
    this.onWillDispose(() => {
      if (!this.isDisposed) {
        onDrop();
      }
    });
  }
  get object() {
    return this.rc.object;
  }
};
var shouldTrace = false;
try {
  shouldTrace = typeof window !== "undefined" && localStorage.getItem("CSB_RC_DEBUG") === "ENABLED";
} catch {
}
if (shouldTrace) {
  window.RC_DEBUG = {
    traceLog: [],
    counters: /* @__PURE__ */ new Map()
  };
}
var nextRefId = 0;
var Rc = class _Rc extends import_pitcher_common3.Disposable {
  static trace(event, ref) {
    if (!shouldTrace) {
      return;
    }
    try {
      throw new Error("RC_TRACE");
    } catch (error) {
      if (error instanceof Error) {
        const stack = (error.stack || "").split("\n").filter((entry) => !entry.includes("node_modules") && !entry.includes("Rc.js") && !entry.includes("RC_TRACE") && entry.match(/[a-zA-Z0-9_-]+/));
        const location2 = stack[0] || "";
        const debug4 = window.RC_DEBUG;
        const logItem = {
          id: ref instanceof _Rc ? ref.id : null,
          event,
          ref: ref instanceof _Rc ? ref.object : ref,
          count: ref instanceof _Rc ? ref.count : 0,
          location: "..." + location2.substring(location2.length - 50),
          stack
        };
        debug4.traceLog.push(logItem);
        if (!(ref instanceof _Rc)) {
          return;
        }
        const counter = debug4.counters.get(ref.object);
        if (counter) {
          counter.push(logItem);
        } else {
          debug4.counters.set(ref.object, [logItem]);
        }
      }
    }
  }
  constructor(object, handleDispose) {
    super();
    this.object = object;
    this.count = 0;
    this.id = `REF-` + nextRefId++;
    this.onWillDispose(handleDispose);
    _Rc.trace("rc.create", this);
  }
  acquire() {
    if (this.isDisposed) {
      throw new Error("Cannot re-acquire a destroyed Rc");
    }
    this.count += 1;
    _Rc.trace("rc.acquire", this);
    return new RcRef(this, () => {
      this.count -= 1;
      _Rc.trace("rc.drop", this);
      if (this.count === 0) {
        _Rc.trace("rc.dispose", this);
        return super.dispose();
      }
    });
  }
  dispose() {
    throw new Error("Cannot call dispose directly, need to use the RcRef");
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/browser/clients/port/Sandpack.js
var import_pitcher_common4 = __toESM(require_dist3());
var import_BedrockFS = __toESM(require_BedrockFS());

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var import_pitcher_common33 = __toESM(require_dist3());

// node_modules/@codesandbox/api/dist/esm/GQLApi.js
var withAbsintheSocket = __toESM(require_cjs6());

// node_modules/@codesandbox/create-gql-api/dist/esm/typeUtils.js
var InlineFragmentSymbol = Symbol("INLINE_FRAGMENT");

// node_modules/@codesandbox/create-gql-api/dist/esm/utils.js
var createQueryUtils = (enums2, argumentsByField) => {
  function createQueryArgumentsString(fieldKey, args, detectedVariableTypes, variables) {
    return `(${Object.keys(args).reduce((aggr, key) => {
      const val = args[key];
      const isVariable = typeof val === "string" && val[0] === "$";
      const isEnum = typeof val === "string" && enums2.includes(val);
      if (val === void 0) {
        return aggr;
      }
      if (isVariable) {
        detectedVariableTypes[val] = argumentsByField[fieldKey][key];
      }
      return isVariable && variables && variables[val.substring(1)] === void 0 ? aggr : aggr.concat(`${key}: ${isVariable || isEnum ? val : typeof val === "string" ? `"${val}"` : val}`);
    }, []).join(", ")})`;
  }
  function isObjectQueryDefinition(queryDefinition) {
    return Array.isArray(queryDefinition) && queryDefinition.length === 2;
  }
  function isFieldQueryDefinition(queryDefinition) {
    return Array.isArray(queryDefinition) && queryDefinition.length === 1;
  }
  function createQueryBodyString(queryDefinitions, detectedVariableTypes, includeTypeNames, variables, level = 1) {
    let string = " {\n";
    if (level > 1 && includeTypeNames) {
      string += "  ".repeat(level) + "__typename\n" + ("id" in queryDefinitions ? "" : "  ".repeat(level) + "id\n");
    }
    const topLevelUnionField = queryDefinitions[InlineFragmentSymbol];
    if (topLevelUnionField) {
      for (const key in queryDefinitions) {
        string += "  ".repeat(level) + `... on ${key}`;
        string += createQueryBodyString(
          // eslint-disable-next-line
          // @ts-ignore
          queryDefinitions[key],
          detectedVariableTypes,
          includeTypeNames,
          variables,
          level + 1
        );
      }
      string += "  ".repeat(level - 1) + "}\n";
      return string;
    }
    for (let field in queryDefinitions) {
      const value = queryDefinitions[field];
      if (value === false || value === void 0) {
        continue;
      }
      const aliasTuple = field.split(":");
      const aliasPrefix = aliasTuple[1] ? ":" + aliasTuple[1] : "";
      field = aliasTuple[0];
      string += "  ".repeat(level) + field;
      if (value === void 0) {
        throw new Error("Got an undefined, that should not be possible!");
      }
      if (value === true) {
        string += "\n";
      } else if (isFieldQueryDefinition(value)) {
        string += createQueryArgumentsString(aliasTuple[1] || aliasTuple[0], value[0], detectedVariableTypes, variables) + "\n";
      } else if (isObjectQueryDefinition(value)) {
        string += aliasPrefix + createQueryArgumentsString(aliasTuple[1] || aliasTuple[0], value[0], detectedVariableTypes, variables) + createQueryBodyString(value[1], detectedVariableTypes, includeTypeNames, variables, level + 1);
      } else {
        const unionFieldType = value[InlineFragmentSymbol];
        if (unionFieldType) {
          string += aliasPrefix + " {\n";
          for (const key in value) {
            string += "  ".repeat(level + 1) + `... on ${key}`;
            string += createQueryBodyString(
              // eslint-disable-next-line
              // @ts-ignore
              value[key],
              detectedVariableTypes,
              includeTypeNames,
              variables,
              level + 2
            );
          }
          string += "}\n";
        } else {
          string += aliasPrefix + createQueryBodyString(value, detectedVariableTypes, includeTypeNames, variables, level + 1);
        }
      }
    }
    string += "  ".repeat(level - 1) + "}\n";
    return string;
  }
  function createVariablesString(variables, detectedVariableTypes) {
    return Object.keys(variables).reduce((aggr, key) => {
      if (variables[key] === void 0) {
        return aggr;
      }
      const varKey = `$${key}`;
      const gqlType = detectedVariableTypes[varKey];
      if (!gqlType) {
        throw new Error(`Unable to detect variable type for key ${key}`);
      }
      return aggr.concat(`${varKey}: ${gqlType.isList ? "[" : ""}${gqlType.type}${gqlType.isNonNull ? "!" : ""}${gqlType.isList ? "]" : ""}`);
    }, []).join(", ");
  }
  function createQueryStringFactory(type) {
    return function createQueryString2(name, query, variables, includeTypeNames) {
      const detectedVariableTypes = {};
      const queryBodyString = createQueryBodyString(query, detectedVariableTypes, includeTypeNames, variables);
      return `${type} ${name} ${variables ? `(${createVariablesString(variables, detectedVariableTypes)})` : ""}${queryBodyString}`;
    };
  }
  const createQueryString = createQueryStringFactory("query");
  const createMutationString = createQueryStringFactory("mutation");
  const createSubscriptionString = createQueryStringFactory("subscription");
  return {
    createMutation: (name, cb) => (request, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? cb(Object.keys(variables || {}).reduce((aggr, key) => {
        aggr[key] = "$" + key;
        return aggr;
      }, {})) : (
        // eslint-disable-next-line
        cb
      );
      return request(createMutationString(name, query, variables ? variables : void 0, includeTypeNames), variables ? Object.keys(variables).reduce((aggr, key) => {
        aggr[key] = variables[key];
        return aggr;
      }, {}) : {});
    },
    createQuery: (name, cb) => (request, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? (
        // eslint-disable-next-line
        cb(Object.keys(variables || {}).reduce((aggr, key) => {
          aggr[key] = "$" + key;
          return aggr;
        }, {}))
      ) : (
        // eslint-disable-next-line
        cb
      );
      return request(createQueryString(name, query, variables ? variables : void 0, includeTypeNames), variables ? Object.keys(variables).reduce((aggr, key) => {
        aggr[key] = variables[key];
        return aggr;
      }, {}) : {});
    },
    createSubscription: (name, cb) => (subscribe, onMessage, variables, { includeTypeNames }) => {
      const query = typeof cb === "function" ? cb(Object.keys(variables || {}).reduce((aggr, key) => {
        aggr[key] = "$" + key;
        return aggr;
      }, {})) : (
        // eslint-disable-next-line
        cb
      );
      return subscribe(
        createSubscriptionString(name, query, variables ? variables : void 0, includeTypeNames),
        // eslint-disable-next-line
        onMessage,
        variables ? Object.keys(variables).reduce((aggr, key) => {
          aggr[key] = variables[key];
          return aggr;
        }, {}) : {}
      );
    }
  };
};

// node_modules/@codesandbox/api/dist/esm/generated_gql.js
var enums = [
  "COMMENT",
  "NONE",
  "OWNER",
  "READ",
  "WRITE_CODE",
  "WRITE_PROJECT",
  "BASIC",
  "BEARER",
  "ASC",
  "DESC",
  "COLLABORATOR",
  "CONTRIBUTOR",
  "FIRST_TIMER",
  "FIRST_TIME_CONTRIBUTOR",
  "MANNEQUIN",
  "MEMBER",
  "ADMIN",
  "WRITE",
  "MERGE",
  "REBASE",
  "SQUASH",
  "APPROVE",
  "REQUEST_CHANGES",
  "LEFT",
  "RIGHT",
  "FILE",
  "LINE",
  "GITHUB",
  "CREATED",
  "JOINED",
  "SET_DEFAULT_PERMISSION",
  "SET_GUEST_PERMISSION",
  "STARTED",
  "STOPPED",
  "APPLE",
  "GOOGLE",
  "DELETED",
  "EDITED",
  "CLOSED",
  "CONVERTED_TO_DRAFT",
  "OPENED",
  "READY_FOR_REVIEW",
  "REVIEW_REQUEST_REMOVED",
  "REVIEW_REQUESTED",
  "DISMISSED",
  "SUBMITTED",
  "APPROVED",
  "CHANGES_REQUESTED",
  "COMMENTED",
  "CUSTOM",
  "NPM",
  "MONTHLY",
  "YEARLY",
  "LEGACY",
  "PATRON",
  "PILOT",
  "STRIPE",
  "ACTIVE",
  "CANCELLED",
  "INCOMPLETE",
  "INCOMPLETE_EXPIRED",
  "PAUSED",
  "TRIALING",
  "UNKNOWN",
  "UNPAID",
  "PERSONAL_PRO",
  "TEAM_PRO",
  "IMMEDIATELY",
  "NEXT_BILL_DATE",
  "PERSONAL",
  "TEAM",
  "ORGANIZATION_MEMBER",
  "FULL_NAME",
  "PUSHED",
  "UPDATED"
];
var Authorization = {
  COMMENT: enums[0],
  NONE: enums[1],
  OWNER: enums[2],
  READ: enums[3],
  WRITE_CODE: enums[4],
  WRITE_PROJECT: enums[5]
};
var AuthType = {
  BASIC: enums[6],
  BEARER: enums[7]
};
var Direction = {
  ASC: enums[8],
  DESC: enums[9]
};
var GitHubAuthorAssociation = {
  COLLABORATOR: enums[10],
  CONTRIBUTOR: enums[11],
  FIRST_TIMER: enums[12],
  FIRST_TIME_CONTRIBUTOR: enums[13],
  MANNEQUIN: enums[14],
  MEMBER: enums[15],
  NONE: enums[1],
  OWNER: enums[2]
};
var GithubPermission = {
  ADMIN: enums[16],
  NONE: enums[1],
  READ: enums[3],
  WRITE: enums[17]
};
var GitHubPullRequestMergeMethod = {
  MERGE: enums[18],
  REBASE: enums[19],
  SQUASH: enums[20]
};
var GitHubPullRequestReviewAction = {
  APPROVE: enums[21],
  COMMENT: enums[0],
  REQUEST_CHANGES: enums[22]
};
var GitHubPullRequestReviewCommentSide = {
  LEFT: enums[23],
  RIGHT: enums[24]
};
var GitHubPullRequestReviewCommentSubjectType = {
  FILE: enums[25],
  LINE: enums[26]
};
var GithubRepoAuthorization = {
  READ: enums[3],
  WRITE: enums[17]
};
var GitProvider = {
  GITHUB: enums[27]
};
var InstallationEventAction = {
  CREATED: enums[28]
};
var LiveSessionEventAction = {
  JOINED: enums[29],
  SET_DEFAULT_PERMISSION: enums[30],
  SET_GUEST_PERMISSION: enums[31],
  STARTED: enums[32],
  STOPPED: enums[33]
};
var LiveSessionPermission = {
  READ: enums[3],
  WRITE: enums[17]
};
var ProjectAuthorization = {
  ADMIN: enums[16],
  NONE: enums[1],
  READ: enums[3],
  WRITE: enums[17]
};
var ProviderName = {
  APPLE: enums[34],
  GITHUB: enums[27],
  GOOGLE: enums[35]
};
var PullRequestCommentEventAction = {
  CREATED: enums[28],
  DELETED: enums[36],
  EDITED: enums[37]
};
var PullRequestEventAction = {
  CLOSED: enums[38],
  CONVERTED_TO_DRAFT: enums[39],
  OPENED: enums[40],
  READY_FOR_REVIEW: enums[41],
  REVIEW_REQUEST_REMOVED: enums[42],
  REVIEW_REQUESTED: enums[43]
};
var PullRequestReviewCommentEventAction = {
  CREATED: enums[28],
  DELETED: enums[36],
  EDITED: enums[37]
};
var PullRequestReviewEventAction = {
  DISMISSED: enums[44],
  EDITED: enums[37],
  SUBMITTED: enums[45]
};
var PullRequestReviewState = {
  APPROVED: enums[46],
  CHANGES_REQUESTED: enums[47],
  COMMENTED: enums[48],
  DISMISSED: enums[44]
};
var RegistryType = {
  CUSTOM: enums[49],
  GITHUB: enums[27],
  NPM: enums[50]
};
var SubscriptionInterval = {
  MONTHLY: enums[51],
  YEARLY: enums[52]
};
var SubscriptionOrigin = {
  LEGACY: enums[53],
  PATRON: enums[54],
  PILOT: enums[55]
};
var SubscriptionPaymentProvider = {
  STRIPE: enums[56]
};
var SubscriptionStatus = {
  ACTIVE: enums[57],
  CANCELLED: enums[58],
  INCOMPLETE: enums[59],
  INCOMPLETE_EXPIRED: enums[60],
  PAUSED: enums[61],
  TRIALING: enums[62],
  UNKNOWN: enums[63],
  UNPAID: enums[64]
};
var SubscriptionType = {
  PERSONAL_PRO: enums[65],
  TEAM_PRO: enums[66]
};
var SubscriptionUpdateMoment = {
  IMMEDIATELY: enums[67],
  NEXT_BILL_DATE: enums[68]
};
var TeamMemberAuthorization = {
  ADMIN: enums[16],
  READ: enums[3],
  WRITE: enums[17]
};
var TeamType = {
  PERSONAL: enums[69],
  TEAM: enums[70]
};
var UserRepoAffiliation = {
  COLLABORATOR: enums[10],
  ORGANIZATION_MEMBER: enums[71],
  OWNER: enums[2]
};
var UserRepoSort = {
  CREATED: enums[28],
  FULL_NAME: enums[72],
  PUSHED: enums[73],
  UPDATED: enums[74]
};
var _a2 = createQueryUtils(enums, {
  "collection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "collections": {
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "githubRepos": {
    "affiliation": {
      "isNonNull": true,
      "type": "UserRepoAffiliation",
      "isList": true
    },
    "page": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "perPage": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sort": {
      "isNonNull": false,
      "type": "UserRepoSort",
      "isList": false
    }
  },
  "notifications": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    },
    "type": {
      "isNonNull": false,
      "type": "String",
      "isList": true
    }
  },
  "recentBranches": {
    "contribution": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "recentProjects": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    }
  },
  "recentlyAccessedSandboxes": {
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "recentlyUsedTemplates": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "sandboxes": {
    "hasOriginalGit": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    },
    "showDeleted": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "alwaysOn": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "authorId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "team": {
    "id": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "templates": {
    "showAll": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "baseGitSandboxes": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "originalGitSandboxes": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "branchByName": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "acceptTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "addCollaborator": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "addSandboxesToAlbum": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "addToCollection": {
    "collectionPath": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": false,
      "type": "ID",
      "isList": true
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "addToCollectionOrTeam": {
    "collectionPath": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": false,
      "type": "ID",
      "isList": true
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "archiveNotification": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "bookmarkTemplate": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "templateId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "changeCollaboratorAuthorization": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "changeSandboxInvitationAuthorization": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "invitationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "changeTeamMemberAuthorizations": {
    "memberAuthorizations": {
      "isNonNull": true,
      "type": "MemberAuthorization",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "convertToUsageBilling": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "createAlbum": {
    "description": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "title": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "createBranch": {
    "branch": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "from": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "createCodeComment": {
    "anchorReference": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": false
    },
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createCollection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "createComment": {
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createContributionBranch": {
    "from": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "createGithubPullRequestReview": {
    "body": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "comments": {
      "isNonNull": true,
      "type": "GithubPullRequestReviewCommentInput",
      "isList": true
    },
    "commitId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "event": {
      "isNonNull": true,
      "type": "GitHubPullRequestReviewAction",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "createOrUpdatePrivateNpmRegistry": {
    "authType": {
      "isNonNull": false,
      "type": "AuthType",
      "isList": false
    },
    "enabledScopes": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "limitToScopes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "proxyEnabled": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "registryAuthKey": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "registryType": {
      "isNonNull": true,
      "type": "RegistryType",
      "isList": false
    },
    "registryUrl": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "sandpackTrustedDomains": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "createPreviewComment": {
    "anchorReference": {
      "isNonNull": true,
      "type": "PreviewReference",
      "isList": false
    },
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "content": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "parentCommentId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "createSandboxInvitation": {
    "authorization": {
      "isNonNull": true,
      "type": "Authorization",
      "isList": false
    },
    "email": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "createTeam": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pilot": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "deleteAlbum": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteBranch": {
    "id": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "deleteCollection": {
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "deleteComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteCurrentUser": {
    "confirm": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "deleteGithubPullRequestReviewComment": {
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "deletePrivateNpmRegistry": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "deleteProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteProjectById": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "deleteSandboxes": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "deleteWorkspace": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "dismissGithubPullRequestReview": {
    "message": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "pullRequestReviewId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "importBranch": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "importProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "team": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "importReadOnlyBranch": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "importReadOnlyProject": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "incrementSandboxVersion": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "inviteToTeam": {
    "authorization": {
      "isNonNull": false,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "inviteToTeamViaEmail": {
    "authorization": {
      "isNonNull": false,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "email": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "joinEligibleWorkspace": {
    "workspaceId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "joinLiveSession": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "joinUsageBillingBeta": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "leaveTeam": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "makeSandboxesTemplates": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "markNotificationAsRead": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "mergeGithubPullRequest": {
    "mergeMethod": {
      "isNonNull": false,
      "type": "GitHubPullRequestMergeMethod",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "permanentlyDeleteSandboxes": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "previewConvertToUsageBilling": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "previewUpdateSubscriptionBillingInterval": {
    "billingInterval": {
      "isNonNull": true,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "previewUpdateUsageSubscriptionPlan": {
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "reactivateSubscription": {
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "redeemSandboxInvitation": {
    "invitationToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "redeemTeamInviteToken": {
    "inviteToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "rejectTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "removeCollaborator": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "removeFromTeam": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "removeRequestedGithubPullRequestReviewers": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "reviewers": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    }
  },
  "removeSandboxesFromAlbum": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "renameCollection": {
    "newPath": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "newTeamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    }
  },
  "renameSandbox": {
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "title": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "replyToGithubPullRequestReview": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "requestGithubPullRequestReviewers": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "reviewers": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    }
  },
  "requestTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "resolveComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "revokeSandboxInvitation": {
    "invitationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "revokeTeamInvitation": {
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setBranchProtection": {
    "branchId": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "protected": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "setDefaultTeamMemberAuthorization": {
    "defaultAuthorization": {
      "isNonNull": true,
      "type": "TeamMemberAuthorization",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setLiveSessionDefaultPermission": {
    "permission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "setLiveSessionGuestPermission": {
    "permission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "userId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "setPreventSandboxesExport": {
    "preventSandboxExport": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setPreventSandboxesLeavingWorkspace": {
    "preventSandboxLeaving": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setPrimaryWorkspace": {
    "primaryWorkspaceId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setSandboxesFrozen": {
    "isFrozen": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setSandboxesPrivacy": {
    "privacy": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "setTeamAiConsent": {
    "privateRepositories": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "privateSandboxes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "publicRepositories": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "publicSandboxes": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamDescription": {
    "description": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamLimits": {
    "onDemandSpendingLimit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamMetadata": {
    "metadata": {
      "isNonNull": true,
      "type": "TeamMetadataInput",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setTeamMinimumPrivacy": {
    "minimumPrivacy": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "updateDrafts": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "setTeamName": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "setWorkspaceSandboxSettings": {
    "preventSandboxExport": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "preventSandboxLeaving": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "softCancelSubscription": {
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "startLiveSession": {
    "defaultPermission": {
      "isNonNull": true,
      "type": "LiveSessionPermission",
      "isList": false
    },
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "stopLiveSession": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "unbookmarkTemplate": {
    "teamId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "templateId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "unmakeSandboxesTemplates": {
    "sandboxIds": {
      "isNonNull": true,
      "type": "ID",
      "isList": true
    }
  },
  "unresolveComment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "updateAlbum": {
    "description": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "id": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "title": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    }
  },
  "updateComment": {
    "codeReferences": {
      "isNonNull": true,
      "type": "CodeReference",
      "isList": true
    },
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "content": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "imageReferences": {
      "isNonNull": true,
      "type": "ImageReference",
      "isList": true
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    },
    "userReferences": {
      "isNonNull": true,
      "type": "UserReference",
      "isList": true
    }
  },
  "updateCurrentUser": {
    "bio": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "socialLinks": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "updateGithubPullRequestReview": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "pullRequestNumber": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "pullRequestReviewId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "updateGithubPullRequestReviewComment": {
    "body": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "commentId": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    },
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "updateNotificationPreferences": {
    "emailCommentMention": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailCommentReply": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailMarketing": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailNewComment": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailSandboxInvite": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailTeamInvite": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "emailTeamRequest": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "inAppPrReviewReceived": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "inAppPrReviewRequest": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "updateNotificationReadStatus": {
    "notificationId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "read": {
      "isNonNull": true,
      "type": "Boolean",
      "isList": false
    }
  },
  "updateProjectSettings": {
    "aiConsent": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "projectId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateProjectVmTier": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "projectId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "vmTier": {
      "isNonNull": true,
      "type": "Int",
      "isList": false
    }
  },
  "updateSandboxSettings": {
    "aiConsent": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    },
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "updateSubscription": {
    "quantity": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateSubscriptionBillingInterval": {
    "billingInterval": {
      "isNonNull": true,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "subscriptionId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateUsageSubscription": {
    "addons": {
      "isNonNull": true,
      "type": "String",
      "isList": true
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "updateUsageSubscriptionPlan": {
    "billingInterval": {
      "isNonNull": false,
      "type": "SubscriptionInterval",
      "isList": false
    },
    "plan": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "teamId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "album": {
    "albumId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "albums": {
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "branchById": {
    "id": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "getLiveSession": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "git": {
    "branch": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "path": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "username": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "githubOrganizationRepos": {
    "organization": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "page": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "perPage": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "sort": {
      "isNonNull": false,
      "type": "UserRepoSort",
      "isList": false
    }
  },
  "githubRepo": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "project": {
    "gitProvider": {
      "isNonNull": false,
      "type": "GitProvider",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "team": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "projects": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    },
    "syncData": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  },
  "recentTeamsByRepository": {
    "name": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "provider": {
      "isNonNull": true,
      "type": "GitProvider",
      "isList": false
    }
  },
  "sandbox": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "sandboxEligibleWorkspace": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "teamByToken": {
    "inviteToken": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "branchEvents": {
    "branchName": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "collaboratorAdded": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "collaboratorChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "collaboratorRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentAdded": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "commentRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "githubEvents": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "invitationChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "invitationCreated": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "invitationRemoved": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "liveSessionEvents": {
    "vmId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "projectCommits": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectConnections": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectEvents": {
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "projectStatus": {
    "branchId": {
      "isNonNull": false,
      "type": "String",
      "isList": false
    },
    "owner": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    },
    "repo": {
      "isNonNull": true,
      "type": "String",
      "isList": false
    }
  },
  "sandboxChanged": {
    "sandboxId": {
      "isNonNull": true,
      "type": "ID",
      "isList": false
    }
  },
  "teamEvents": {
    "teamId": {
      "isNonNull": false,
      "type": "ID",
      "isList": false
    }
  },
  "comment": {
    "commentId": {
      "isNonNull": true,
      "type": "UUID4",
      "isList": false
    }
  },
  "drafts": {
    "authorId": {
      "isNonNull": false,
      "type": "UUID4",
      "isList": false
    },
    "limit": {
      "isNonNull": false,
      "type": "Int",
      "isList": false
    },
    "orderBy": {
      "isNonNull": false,
      "type": "OrderBy",
      "isList": false
    }
  },
  "subscription": {
    "includeCancelled": {
      "isNonNull": false,
      "type": "Boolean",
      "isList": false
    }
  }
});
var createQuery = _a2.createQuery;
var createMutation = _a2.createMutation;
var createSubscription = _a2.createSubscription;
var createFragment = function(fragment) {
  return fragment;
};
var fragments = new Proxy({}, {
  get: function() {
    return createFragment;
  }
});
var createInlineFragment = function(type, fragment) {
  var _a3;
  return Object.assign(fragment, (_a3 = {}, _a3[InlineFragmentSymbol] = type, _a3));
};
var inlineFragments = new Proxy({}, {
  get: function(target, prop) {
    return createInlineFragment.bind(target, prop);
  }
});

// node_modules/@codesandbox/api/dist/esm/constants.js
var DAY = 1e3 * 60 * 60 * 24;

// node_modules/@codesandbox/api/dist/esm/SessionApi.js
var import_class_states = __toESM(require_dist5());

// node_modules/preact/dist/preact.mjs
var n;
var l;
var u;
var t;
var i;
var r;
var o;
var e;
var f;
var c;
var s;
var a;
var h;
var p = {};
var v = [];
var y2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var d = Array.isArray;
function w2(n2, l3) {
  for (var u4 in l3) n2[u4] = l3[u4];
  return n2;
}
function _2(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function m(n2, t3, i4, r3, o2) {
  var e3 = { type: n2, props: t3, key: i4, ref: r3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o2 ? ++u : o2, __i: -1, __u: 0 };
  return null == o2 && null != l.vnode && l.vnode(e3), e3;
}
function k2(n2) {
  return n2.children;
}
function x2(n2, l3) {
  this.props = n2, this.context = l3;
}
function C2(n2, l3) {
  if (null == l3) return n2.__ ? C2(n2.__, n2.__i + 1) : null;
  for (var u4; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) return u4.__e;
  return "function" == typeof n2.type ? C2(n2) : null;
}
function S2(n2) {
  var l3, u4;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) {
      n2.__e = n2.__c.base = u4.__e;
      break;
    }
    return S2(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !P2.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(P2);
}
function P2() {
  var n2, u4, t3, r3, o2, f3, c3, s3;
  for (i.sort(e); n2 = i.shift(); ) n2.__d && (u4 = i.length, r3 = void 0, f3 = (o2 = (t3 = n2).__v).__e, c3 = [], s3 = [], t3.__P && ((r3 = w2({}, o2)).__v = o2.__v + 1, l.vnode && l.vnode(r3), j(t3.__P, r3, o2, t3.__n, t3.__P.namespaceURI, 32 & o2.__u ? [f3] : null, c3, null == f3 ? C2(o2) : f3, !!(32 & o2.__u), s3), r3.__v = o2.__v, r3.__.__k[r3.__i] = r3, z2(c3, r3, s3), r3.__e != f3 && S2(r3)), i.length > u4 && i.sort(e));
  P2.__r = 0;
}
function $2(n2, l3, u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, y3, d2, w4, _3, g = t3 && t3.__k || v, m3 = l3.length;
  for (f3 = I2(u4, l3, g, f3, m3), a3 = 0; a3 < m3; a3++) null != (y3 = u4.__k[a3]) && (h3 = -1 === y3.__i ? p : g[y3.__i] || p, y3.__i = a3, _3 = j(n2, y3, h3, i4, r3, o2, e3, f3, c3, s3), d2 = y3.__e, y3.ref && h3.ref != y3.ref && (h3.ref && V(h3.ref, null, y3), s3.push(y3.ref, y3.__c || d2, y3)), null == w4 && null != d2 && (w4 = d2), 4 & y3.__u || h3.__k === y3.__k ? f3 = A2(y3, f3, n2) : "function" == typeof y3.type && void 0 !== _3 ? f3 = _3 : d2 && (f3 = d2.nextSibling), y3.__u &= -7);
  return u4.__e = w4, f3;
}
function I2(n2, l3, u4, t3, i4) {
  var r3, o2, e3, f3, c3, s3 = u4.length, a3 = s3, h3 = 0;
  for (n2.__k = new Array(i4), r3 = 0; r3 < i4; r3++) null != (o2 = l3[r3]) && "boolean" != typeof o2 && "function" != typeof o2 ? (f3 = r3 + h3, (o2 = n2.__k[r3] = "string" == typeof o2 || "number" == typeof o2 || "bigint" == typeof o2 || o2.constructor == String ? m(null, o2, null, null, null) : d(o2) ? m(k2, { children: o2 }, null, null, null) : void 0 === o2.constructor && o2.__b > 0 ? m(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : o2).__ = n2, o2.__b = n2.__b + 1, e3 = null, -1 !== (c3 = o2.__i = L2(o2, u4, f3, a3)) && (a3--, (e3 = u4[c3]) && (e3.__u |= 2)), null == e3 || null === e3.__v ? (-1 == c3 && h3--, "function" != typeof o2.type && (o2.__u |= 4)) : c3 != f3 && (c3 == f3 - 1 ? h3-- : c3 == f3 + 1 ? h3++ : (c3 > f3 ? h3-- : h3++, o2.__u |= 4))) : n2.__k[r3] = null;
  if (a3) for (r3 = 0; r3 < s3; r3++) null != (e3 = u4[r3]) && 0 == (2 & e3.__u) && (e3.__e == t3 && (t3 = C2(e3)), q(e3, e3));
  return t3;
}
function A2(n2, l3, u4) {
  var t3, i4;
  if ("function" == typeof n2.type) {
    for (t3 = n2.__k, i4 = 0; t3 && i4 < t3.length; i4++) t3[i4] && (t3[i4].__ = n2, l3 = A2(t3[i4], l3, u4));
    return l3;
  }
  n2.__e != l3 && (l3 && n2.type && !u4.contains(l3) && (l3 = C2(n2)), u4.insertBefore(n2.__e, l3 || null), l3 = n2.__e);
  do {
    l3 = l3 && l3.nextSibling;
  } while (null != l3 && 8 == l3.nodeType);
  return l3;
}
function L2(n2, l3, u4, t3) {
  var i4, r3, o2 = n2.key, e3 = n2.type, f3 = l3[u4];
  if (null === f3 || f3 && o2 == f3.key && e3 === f3.type && 0 == (2 & f3.__u)) return u4;
  if (t3 > (null != f3 && 0 == (2 & f3.__u) ? 1 : 0)) for (i4 = u4 - 1, r3 = u4 + 1; i4 >= 0 || r3 < l3.length; ) {
    if (i4 >= 0) {
      if ((f3 = l3[i4]) && 0 == (2 & f3.__u) && o2 == f3.key && e3 === f3.type) return i4;
      i4--;
    }
    if (r3 < l3.length) {
      if ((f3 = l3[r3]) && 0 == (2 & f3.__u) && o2 == f3.key && e3 === f3.type) return r3;
      r3++;
    }
  }
  return -1;
}
function T(n2, l3, u4) {
  "-" == l3[0] ? n2.setProperty(l3, null == u4 ? "" : u4) : n2[l3] = null == u4 ? "" : "number" != typeof u4 || y2.test(l3) ? u4 : u4 + "px";
}
function F(n2, l3, u4, t3, i4) {
  var r3;
  n: if ("style" == l3) if ("string" == typeof u4) n2.style.cssText = u4;
  else {
    if ("string" == typeof t3 && (n2.style.cssText = t3 = ""), t3) for (l3 in t3) u4 && l3 in u4 || T(n2.style, l3, "");
    if (u4) for (l3 in u4) t3 && u4[l3] === t3[l3] || T(n2.style, l3, u4[l3]);
  }
  else if ("o" == l3[0] && "n" == l3[1]) r3 = l3 != (l3 = l3.replace(f, "$1")), l3 = l3.toLowerCase() in n2 || "onFocusOut" == l3 || "onFocusIn" == l3 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u4, u4 ? t3 ? u4.u = t3.u : (u4.u = c, n2.addEventListener(l3, r3 ? a : s, r3)) : n2.removeEventListener(l3, r3 ? a : s, r3);
  else {
    if ("http://www.w3.org/2000/svg" == i4) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l3 && "height" != l3 && "href" != l3 && "list" != l3 && "form" != l3 && "tabIndex" != l3 && "download" != l3 && "rowSpan" != l3 && "colSpan" != l3 && "role" != l3 && "popover" != l3 && l3 in n2) try {
      n2[l3] = null == u4 ? "" : u4;
      break n;
    } catch (n3) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && "-" != l3[4] ? n2.removeAttribute(l3) : n2.setAttribute(l3, "popover" == l3 && 1 == u4 ? "" : u4));
  }
}
function O2(n2) {
  return function(u4) {
    if (this.l) {
      var t3 = this.l[u4.type + n2];
      if (null == u4.t) u4.t = c++;
      else if (u4.t < t3.u) return;
      return t3(l.event ? l.event(u4) : u4);
    }
  };
}
function j(n2, u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, p2, v3, y3, g, m3, b, C3, S3, M2, P3, I3, A3, H, L3, T2, F2 = u4.type;
  if (void 0 !== u4.constructor) return null;
  128 & t3.__u && (c3 = !!(32 & t3.__u), o2 = [f3 = u4.__e = t3.__e]), (a3 = l.__b) && a3(u4);
  n: if ("function" == typeof F2) try {
    if (b = u4.props, C3 = "prototype" in F2 && F2.prototype.render, S3 = (a3 = F2.contextType) && i4[a3.__c], M2 = a3 ? S3 ? S3.props.value : a3.__ : i4, t3.__c ? m3 = (h3 = u4.__c = t3.__c).__ = h3.__E : (C3 ? u4.__c = h3 = new F2(b, M2) : (u4.__c = h3 = new x2(b, M2), h3.constructor = F2, h3.render = B2), S3 && S3.sub(h3), h3.props = b, h3.state || (h3.state = {}), h3.context = M2, h3.__n = i4, p2 = h3.__d = true, h3.__h = [], h3._sb = []), C3 && null == h3.__s && (h3.__s = h3.state), C3 && null != F2.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = w2({}, h3.__s)), w2(h3.__s, F2.getDerivedStateFromProps(b, h3.__s))), v3 = h3.props, y3 = h3.state, h3.__v = u4, p2) C3 && null == F2.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), C3 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
    else {
      if (C3 && null == F2.getDerivedStateFromProps && b !== v3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(b, M2), !h3.__e && (null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(b, h3.__s, M2) || u4.__v == t3.__v)) {
        for (u4.__v != t3.__v && (h3.props = b, h3.state = h3.__s, h3.__d = false), u4.__e = t3.__e, u4.__k = t3.__k, u4.__k.some(function(n3) {
          n3 && (n3.__ = u4);
        }), P3 = 0; P3 < h3._sb.length; P3++) h3.__h.push(h3._sb[P3]);
        h3._sb = [], h3.__h.length && e3.push(h3);
        break n;
      }
      null != h3.componentWillUpdate && h3.componentWillUpdate(b, h3.__s, M2), C3 && null != h3.componentDidUpdate && h3.__h.push(function() {
        h3.componentDidUpdate(v3, y3, g);
      });
    }
    if (h3.context = M2, h3.props = b, h3.__P = n2, h3.__e = false, I3 = l.__r, A3 = 0, C3) {
      for (h3.state = h3.__s, h3.__d = false, I3 && I3(u4), a3 = h3.render(h3.props, h3.state, h3.context), H = 0; H < h3._sb.length; H++) h3.__h.push(h3._sb[H]);
      h3._sb = [];
    } else do {
      h3.__d = false, I3 && I3(u4), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
    } while (h3.__d && ++A3 < 25);
    h3.state = h3.__s, null != h3.getChildContext && (i4 = w2(w2({}, i4), h3.getChildContext())), C3 && !p2 && null != h3.getSnapshotBeforeUpdate && (g = h3.getSnapshotBeforeUpdate(v3, y3)), f3 = $2(n2, d(L3 = null != a3 && a3.type === k2 && null == a3.key ? a3.props.children : a3) ? L3 : [L3], u4, t3, i4, r3, o2, e3, f3, c3, s3), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && e3.push(h3), m3 && (h3.__E = h3.__ = null);
  } catch (n3) {
    if (u4.__v = null, c3 || null != o2) if (n3.then) {
      for (u4.__u |= c3 ? 160 : 128; f3 && 8 == f3.nodeType && f3.nextSibling; ) f3 = f3.nextSibling;
      o2[o2.indexOf(f3)] = null, u4.__e = f3;
    } else for (T2 = o2.length; T2--; ) _2(o2[T2]);
    else u4.__e = t3.__e, u4.__k = t3.__k;
    l.__e(n3, u4, t3);
  }
  else null == o2 && u4.__v == t3.__v ? (u4.__k = t3.__k, u4.__e = t3.__e) : f3 = u4.__e = N2(t3.__e, u4, t3, i4, r3, o2, e3, c3, s3);
  return (a3 = l.diffed) && a3(u4), 128 & u4.__u ? void 0 : f3;
}
function z2(n2, u4, t3) {
  for (var i4 = 0; i4 < t3.length; i4++) V(t3[i4], t3[++i4], t3[++i4]);
  l.__c && l.__c(u4, n2), n2.some(function(u5) {
    try {
      n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
        n3.call(u5);
      });
    } catch (n3) {
      l.__e(n3, u5.__v);
    }
  });
}
function N2(u4, t3, i4, r3, o2, e3, f3, c3, s3) {
  var a3, h3, v3, y3, w4, g, m3, b = i4.props, k4 = t3.props, x3 = t3.type;
  if ("svg" == x3 ? o2 = "http://www.w3.org/2000/svg" : "math" == x3 ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), null != e3) {
    for (a3 = 0; a3 < e3.length; a3++) if ((w4 = e3[a3]) && "setAttribute" in w4 == !!x3 && (x3 ? w4.localName == x3 : 3 == w4.nodeType)) {
      u4 = w4, e3[a3] = null;
      break;
    }
  }
  if (null == u4) {
    if (null == x3) return document.createTextNode(k4);
    u4 = document.createElementNS(o2, x3, k4.is && k4), c3 && (l.__m && l.__m(t3, e3), c3 = false), e3 = null;
  }
  if (null === x3) b === k4 || c3 && u4.data === k4 || (u4.data = k4);
  else {
    if (e3 = e3 && n.call(u4.childNodes), b = i4.props || p, !c3 && null != e3) for (b = {}, a3 = 0; a3 < u4.attributes.length; a3++) b[(w4 = u4.attributes[a3]).name] = w4.value;
    for (a3 in b) if (w4 = b[a3], "children" == a3) ;
    else if ("dangerouslySetInnerHTML" == a3) v3 = w4;
    else if (!(a3 in k4)) {
      if ("value" == a3 && "defaultValue" in k4 || "checked" == a3 && "defaultChecked" in k4) continue;
      F(u4, a3, null, w4, o2);
    }
    for (a3 in k4) w4 = k4[a3], "children" == a3 ? y3 = w4 : "dangerouslySetInnerHTML" == a3 ? h3 = w4 : "value" == a3 ? g = w4 : "checked" == a3 ? m3 = w4 : c3 && "function" != typeof w4 || b[a3] === w4 || F(u4, a3, w4, b[a3], o2);
    if (h3) c3 || v3 && (h3.__html === v3.__html || h3.__html === u4.innerHTML) || (u4.innerHTML = h3.__html), t3.__k = [];
    else if (v3 && (u4.innerHTML = ""), $2(u4, d(y3) ? y3 : [y3], t3, i4, r3, "foreignObject" == x3 ? "http://www.w3.org/1999/xhtml" : o2, e3, f3, e3 ? e3[0] : i4.__k && C2(i4, 0), c3, s3), null != e3) for (a3 = e3.length; a3--; ) _2(e3[a3]);
    c3 || (a3 = "value", "progress" == x3 && null == g ? u4.removeAttribute("value") : void 0 !== g && (g !== u4[a3] || "progress" == x3 && !g || "option" == x3 && g !== b[a3]) && F(u4, a3, g, b[a3], o2), a3 = "checked", void 0 !== m3 && m3 !== u4[a3] && F(u4, a3, m3, b[a3], o2));
  }
  return u4;
}
function V(n2, u4, t3) {
  try {
    if ("function" == typeof n2) {
      var i4 = "function" == typeof n2.__u;
      i4 && n2.__u(), i4 && null == u4 || (n2.__u = n2(u4));
    } else n2.current = u4;
  } catch (n3) {
    l.__e(n3, t3);
  }
}
function q(n2, u4, t3) {
  var i4, r3;
  if (l.unmount && l.unmount(n2), (i4 = n2.ref) && (i4.current && i4.current !== n2.__e || V(i4, null, u4)), null != (i4 = n2.__c)) {
    if (i4.componentWillUnmount) try {
      i4.componentWillUnmount();
    } catch (n3) {
      l.__e(n3, u4);
    }
    i4.base = i4.__P = null;
  }
  if (i4 = n2.__k) for (r3 = 0; r3 < i4.length; r3++) i4[r3] && q(i4[r3], u4, t3 || "function" != typeof n2.type);
  t3 || _2(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function B2(n2, l3, u4) {
  return this.constructor(n2, u4);
}
n = v.slice, l = { __e: function(n2, l3, u4, t3) {
  for (var i4, r3, o2; l3 = l3.__; ) if ((i4 = l3.__c) && !i4.__) try {
    if ((r3 = i4.constructor) && null != r3.getDerivedStateFromError && (i4.setState(r3.getDerivedStateFromError(n2)), o2 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n2, t3 || {}), o2 = i4.__d), o2) return i4.__E = i4;
  } catch (l4) {
    n2 = l4;
  }
  throw n2;
} }, u = 0, t = function(n2) {
  return null != n2 && null == n2.constructor;
}, x2.prototype.setState = function(n2, l3) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = w2({}, this.state), "function" == typeof n2 && (n2 = n2(w2({}, u4), this.props)), n2 && w2(u4, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), M(this));
}, x2.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x2.prototype.render = k2, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l3) {
  return n2.__v.__b - l3.__v.__b;
}, P2.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = O2(false), a = O2(true), h = 0;

// node_modules/preact/jsx-runtime/dist/jsxRuntime.mjs
var i2 = Array.isArray;

// node_modules/preact/hooks/dist/hooks.mjs
var t2;
var r2;
var u3;
var i3;
var f2 = [];
var c2 = l;
var e2 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l2 = c2.__c;
var m2 = c2.unmount;
var s2 = c2.__;
function j2() {
  for (var n2; n2 = f2.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z3), n2.__H.__h.forEach(B3), n2.__H.__h = [];
  } catch (t3) {
    n2.__H.__h = [], c2.__e(t3, n2.__v);
  }
}
c2.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, c2.__ = function(n2, t3) {
  n2 && t3.__k && t3.__k.__m && (n2.__m = t3.__k.__m), s2 && s2(n2, t3);
}, c2.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i4 = (r2 = n2.__c).__H;
  i4 && (u3 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.i = n3.__N = void 0;
  })) : (i4.__h.forEach(z3), i4.__h.forEach(B3), i4.__h = [], t2 = 0)), u3 = r2;
}, c2.diffed = function(n2) {
  v2 && v2(n2);
  var t3 = n2.__c;
  t3 && t3.__H && (t3.__H.__h.length && (1 !== f2.push(t3) && i3 === c2.requestAnimationFrame || ((i3 = c2.requestAnimationFrame) || w3)(j2)), t3.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.i = void 0;
  })), u3 = r2 = null;
}, c2.__c = function(n2, t3) {
  t3.some(function(n3) {
    try {
      n3.__h.forEach(z3), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B3(n4);
      });
    } catch (r3) {
      t3.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t3 = [], c2.__e(r3, n3.__v);
    }
  }), l2 && l2(n2, t3);
}, c2.unmount = function(n2) {
  m2 && m2(n2);
  var t3, r3 = n2.__c;
  r3 && r3.__H && (r3.__H.__.forEach(function(n3) {
    try {
      z3(n3);
    } catch (n4) {
      t3 = n4;
    }
  }), r3.__H = void 0, t3 && c2.__e(t3, r3.__v));
};
var k3 = "function" == typeof requestAnimationFrame;
function w3(n2) {
  var t3, r3 = function() {
    clearTimeout(u4), k3 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u4 = setTimeout(r3, 100);
  k3 && (t3 = requestAnimationFrame(r3));
}
function z3(n2) {
  var t3 = r2, u4 = n2.__c;
  "function" == typeof u4 && (n2.__c = void 0, u4()), r2 = t3;
}
function B3(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@codesandbox/api/dist/esm/utils.js
var import_humps = __toESM(require_humps());
var import_node_fetch = __toESM(require_lib2());
var { camelizeKeys, camelize } = import_humps.default;
var ApiResponseError = class extends Error {
  constructor(status, message, parsedErrorMessage) {
    super(`(${status}) ${message}`);
    this.type = "ERROR";
    this.parsedErrorMessage = parsedErrorMessage;
    if (status === 404 || message.toLowerCase().includes("not found")) {
      this.type = "NOT_FOUND";
    } else if (status === 402) {
      this.type = "WORKSPACE_FROZEN";
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/index.js
var import_pitcher_common31 = __toESM(require_dist3());
var import_pitcher_protocol5 = __toESM(require_src());
var import_class_states4 = __toESM(require_dist6());
var import_debug3 = __toESM(require_src2());
var import_semver = __toESM(require_semver2());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/retryPromise.js
var import_pitcher_common5 = __toESM(require_dist3());
var import_event = __toESM(require_event());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/sleep.js
function sleep(ms) {
  let timeoutId = void 0;
  const promise = new Promise((resolve5) => {
    timeoutId = setTimeout(resolve5, ms);
  });
  promise.dispose = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };
  return promise;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/common/retryPromise.js
var CancellationToken = class extends import_pitcher_common5.Disposable {
  constructor() {
    super();
    this.onCancellationRequestedEmitter = this.addDisposable(new import_pitcher_common5.Emitter());
    this.onCancellationRequested = this.onCancellationRequestedEmitter.event;
    this.cancellationRequested = false;
    this.onWillDispose(() => {
      this.requestCancellation();
    });
  }
  isCancellationRequested() {
    return this.cancellationRequested;
  }
  requestCancellation() {
    this.cancellationRequested = true;
    this.onCancellationRequestedEmitter.fire();
  }
  throwErrorIfCancelled(cleanup) {
    if (this.cancellationRequested) {
      cleanup?.();
      throw new CancellationError();
    }
  }
};
var CancellationError = class extends Error {
  constructor(sourceError) {
    super("Cancelled");
    this.sourceError = sourceError;
  }
};
var TIMEOUT_SYMBOL = Symbol("TIMEOUT_SYMBOL");
async function retryPromise(cb, tries, delayMs, timeoutMs) {
  let cancellationToken;
  let result;
  for (let i4 = 0; i4 < tries; i4++) {
    cancellationToken = new CancellationToken();
    try {
      const sleepRef = sleep(timeoutMs);
      const raceResult = await Promise.race([
        cb(cancellationToken),
        // Since callbacks can return undefined, we need a recognizeable symbol to evaluate
        // if we hit the timeout
        sleepRef.then(() => TIMEOUT_SYMBOL),
        (0, import_event.listenOnce)(cancellationToken.onCancellationRequested)
      ]);
      sleepRef.dispose();
      if (cancellationToken.isCancellationRequested()) {
        throw new CancellationError();
      }
      if (raceResult === TIMEOUT_SYMBOL) {
        cancellationToken.requestCancellation();
        throw new Error("Timed out after " + timeoutMs + "ms");
      }
      result = raceResult;
      break;
    } catch (e3) {
      if (e3 instanceof CancellationError) {
        throw e3.sourceError || e3;
      }
      const isLastRetry = i4 === tries - 1;
      if (isLastRetry) {
        throw e3;
      }
      await sleep(delayMs);
    }
  }
  return result;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/common/versions.js
var PitcherFeatureToVersionMap = {
  GIT_BRANCH_OUT_OF_SYNC: "0.209.11",
  SANDBOX_TO_REPOSITORY: "0.209.9",
  VM_METRICS: "0.212.0",
  GIT_LOGS_ON_PROTECTED_BRANCHES: "0.233.0",
  REMOTE_BRANCH_PRESENCE_DETECTION: "0.242.0",
  SET_BRANCH_PROTECTION: "0.248.4",
  SHELL_RENAME: "0.254.0",
  SEARCH_CASE_SENSITIVITY: "0.308.6",
  SETUP_ENV_DEVTOOL: "0.313.0"
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/PitcherMessageHandler.js
var import_pitcher_common6 = __toESM(require_dist3());
var import_pitcher_protocol2 = __toESM(require_src());
var PitcherMessageHandler = class {
  constructor(onSendRequest, seamlessFork) {
    this.onSendRequest = onSendRequest;
    this.seamlessFork = seamlessFork;
    this.nextMessageId = 0;
    this.awaitReconnectQueue = [];
    this.pendingMessages = /* @__PURE__ */ new Map();
    this.isRequestingInstanceChange = false;
    this.onInstanceChangeRequiredEmitter = new import_pitcher_common6.Emitter();
    this.onInstanceChangeRequired = this.onInstanceChangeRequiredEmitter.event;
    this.notificationListeners = {};
    this.messageEmitter = new import_pitcher_common6.Emitter();
    this.onMessage = this.messageEmitter.event;
    this.errorEmitter = new import_pitcher_common6.Emitter();
    this.onError = this.errorEmitter.event;
  }
  toggleSeamlessFork(value) {
    this.seamlessFork = value;
  }
  onNotification(method, cb) {
    let listeners = this.notificationListeners[method];
    if (!listeners) {
      listeners = this.notificationListeners[method] = new import_pitcher_common6.SliceList();
    }
    const idx = listeners.add(cb);
    return () => {
      this.notificationListeners[method]?.remove(idx);
    };
  }
  receiveMessage(blob) {
    const payload = (0, import_pitcher_protocol2.decodeMessage)(blob);
    this.messageEmitter.fire(payload);
    const method = payload.method;
    if ((0, import_pitcher_protocol2.isNotificationPayload)(payload)) {
      const listeners = this.notificationListeners[method];
      if (listeners) {
        for (const cb of listeners.values()) {
          cb(payload.params);
        }
      }
      return;
    }
    let response;
    if ((0, import_pitcher_protocol2.isErrorPayload)(payload)) {
      response = {
        status: import_pitcher_protocol2.PitcherResponseStatus.REJECTED,
        error: {
          code: payload.error.code,
          data: payload.error.data,
          message: payload.error.message
        },
        method
      };
    } else if ((0, import_pitcher_protocol2.isResultPayload)(payload)) {
      response = {
        status: import_pitcher_protocol2.PitcherResponseStatus.RESOLVED,
        result: payload.result,
        method
      };
    } else {
      throw new Error("Unable to identify message type");
    }
    const messageToResolve = this.pendingMessages.get(payload.id);
    if (messageToResolve) {
      messageToResolve.resolve(response);
    }
  }
  /**
   * Replaces the current sending message handler with a new one, bound to a new connection. We do this instead of emitting an event
   * as we want to deal with any errors
   */
  setOnSendRequest(onSendRequest) {
    this.onSendRequest = onSendRequest;
  }
  request(pitcherRequest, options = {}) {
    const { timeoutMs, queueForReconnect = true, seamlessForkStrategy } = options;
    const request = this.createRequest(pitcherRequest, timeoutMs);
    if (this.seamlessFork && (seamlessForkStrategy === "queue" || seamlessForkStrategy === "dispose")) {
      if (seamlessForkStrategy === "queue") {
        this.awaitReconnectQueue.push(request);
      } else {
        request.dispose();
      }
      if (!this.isRequestingInstanceChange) {
        this.isRequestingInstanceChange = true;
        this.onInstanceChangeRequiredEmitter.fire(pitcherRequest.method);
      }
      return request.unwrap();
    }
    if (this.seamlessFork && this.isRequestingInstanceChange && seamlessForkStrategy === "queueDuringFork") {
      this.awaitReconnectQueue.push(request);
      return request.unwrap();
    }
    try {
      this.onSendRequest(request);
      return request.unwrap();
    } catch (error) {
      if (queueForReconnect) {
        this.awaitReconnectQueue.push(request);
        return request.unwrap();
      }
      this.errorEmitter.fire({
        message: error.message,
        extras: {
          source: "pitcher-message-handler",
          type: "send-request",
          request: pitcherRequest
        }
      });
      return Promise.reject(error);
    }
  }
  createRequest(request, timeoutMs) {
    const id = this.nextMessageId++;
    const pitcherMessage = new PendingPitcherMessage(id, request, timeoutMs);
    this.pendingMessages.set(id, pitcherMessage);
    pitcherMessage.onDidDispose(() => this.pendingMessages.delete(id));
    return pitcherMessage;
  }
  getPendingMessages() {
    return this.pendingMessages;
  }
  disposePendingMessages(exceptions) {
    this.pendingMessages.forEach((pendingMessage) => {
      if (!exceptions || !exceptions.includes(pendingMessage.message)) {
        pendingMessage.dispose();
      }
    });
  }
  disableSeamlessFork() {
    this.seamlessFork = false;
    this.isRequestingInstanceChange = false;
  }
  async flushReconnectQueue() {
    try {
      await Promise.all(this.awaitReconnectQueue.map((message) => this.onSendRequest(message)));
      this.awaitReconnectQueue.length = 0;
    } catch {
    }
  }
  dispose() {
    this.onSendRequest = () => {
    };
    this.disposePendingMessages();
    this.pendingMessages.clear();
    this.notificationListeners = {};
    this.errorEmitter.dispose();
    this.messageEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/WebSocketClient/index.js
var import_pitcher_common7 = __toESM(require_dist3());
var import_debug = __toESM(require_src2());
var import_isomorphic_ws = __toESM(require_node3());
var debug = (0, import_debug.default)("csb:vm:ws");
var WEBSOCKET_PING_OFFSET = 2e3;
var INIT_DETECT_PONG_TIMEOUT = 2e4;
var readyStateToString = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
if (typeof process !== "undefined" && process.env.NODE_ENV === "test") {
  WEBSOCKET_PING_OFFSET = 20;
  INIT_DETECT_PONG_TIMEOUT = 200;
}
var WebSocketClient = class extends import_pitcher_common7.Disposable {
  // It receives a connected websocket connection
  constructor(ws) {
    super();
    this.bufferQueue = new import_pitcher_common7.SerialQueue("websocket-buffer-queue");
    this.pongDetectionTimeout = INIT_DETECT_PONG_TIMEOUT;
    this.onMessageEmitter = new import_pitcher_common7.Emitter();
    this.onDisconnectedEmitter = new import_pitcher_common7.Emitter();
    this.onMessage = this.onMessageEmitter.event;
    this.onDisconnected = this.onDisconnectedEmitter.event;
    this.lastActivity = Date.now();
    if (ws.readyState !== ws.OPEN) {
      throw new Error("Requires an OPEN websocket connection");
    }
    debug("[websocket]: OPEN");
    this.ws = ws;
    this.lastActivity = Date.now();
    const onHeartbeatInterval = () => {
      const timeSinceActivity = Date.now() - this.lastActivity;
      if (timeSinceActivity > this.pingTimeout) {
        this.ping();
      }
    };
    const heartbeatInterval = setInterval(onHeartbeatInterval, this.pingTimeout);
    const onMessageListener = (event) => {
      this.lastActivity = Date.now();
      const data = event.data;
      clearTimeout(this.detectDisconnectByPongTimeout);
      if (typeof window !== "undefined" && data instanceof window.Blob) {
        this.bufferQueue.add(async () => {
          this.emitMessage(new Uint8Array(await data.arrayBuffer()));
        });
        return;
      }
      if (typeof data !== "string") {
        this.emitMessage(data);
        return;
      }
    };
    const onErrorListener = () => {
      if (this.isClosingOrClosed()) {
        this.onDisconnectedEmitter.fire({
          code: -1,
          reason: "Error listener - " + readyStateToString[ws.readyState],
          wasClean: false
        });
      }
    };
    const onCloseListener = ({ wasClean, code, reason }) => this.onDisconnectedEmitter.fire({
      wasClean,
      code,
      reason: "Close listener - " + reason
    });
    ws.addEventListener("message", onMessageListener);
    ws.addEventListener("close", onCloseListener);
    ws.addEventListener("error", onErrorListener);
    this.onWillDispose(() => {
      clearInterval(heartbeatInterval);
      clearTimeout(this.pongDetectionTimeout);
      clearTimeout(this.detectDisconnectByPongTimeout);
      ws.removeEventListener("close", onCloseListener);
      ws.removeEventListener("message", onMessageListener);
      ws.removeEventListener("error", onErrorListener);
      this.onMessageEmitter.dispose();
      this.onDisconnectedEmitter.dispose();
      this.ws.close();
    });
  }
  isClosingOrClosed() {
    return this.ws.readyState === this.ws.CLOSING || this.ws.readyState === this.ws.CLOSED;
  }
  emitMessage(message) {
    this.onMessageEmitter.fire(message);
  }
  get pingTimeout() {
    return this.pongDetectionTimeout + WEBSOCKET_PING_OFFSET;
  }
  setPongDetectionTimeout(ms) {
    this.pongDetectionTimeout = ms;
  }
  /**
   We use "PING" to both keep the session alive, but also detect disconnects. Certain interactions, like
   focusing the application should trigger an immediate "ping", which is why this is a public method. An optional
   pong timeout can be set. This is useful to detect disconnects faster for example when focusing the application
   */
  ping(pongTimeout) {
    clearTimeout(this.detectDisconnectByPongTimeout);
    this.detectDisconnectByPongTimeout = setTimeout(() => {
      this.onDisconnectedEmitter.fire({
        code: -1,
        reason: "Pong response not detected",
        wasClean: false
      });
    }, pongTimeout || this.pongDetectionTimeout);
    try {
      this.send("");
    } catch {
    }
  }
  send(data) {
    if (this.isClosingOrClosed()) {
      this.onDisconnectedEmitter.fire({
        code: -1,
        reason: "WebSocket not in an open state",
        wasClean: false
      });
      throw new Error("Could not send message in " + readyStateToString[this.ws.readyState] + " state");
    }
    this.ws.send(data);
  }
  /**
   * Closes the connection, triggering a disconnected event
   */
  close() {
    this.ws.close();
  }
  /**
   * Keep connection alive, but do not trigger any events. Used with seamless forking
   */
  silence() {
    this.onDisconnectedEmitter.dispose();
  }
  dispose(reason) {
    if (this.isDisposed) {
      return;
    }
    if (!reason) {
      reason = "DISPOSED";
    }
    debug("[websocket]: Disposed", readyStateToString[this.ws.readyState], reason);
    super.dispose();
  }
};
var createWebSocketClient = (url) => new Promise((resolve5, reject) => {
  const ws = new import_isomorphic_ws.default(url);
  const openListener = () => {
    cleanInitialListeners();
    resolve5(new WebSocketClient(ws));
  };
  const errorListener = ({ message }) => {
    cleanInitialListeners();
    reject(new Error(message));
  };
  const closeListener = () => {
    cleanInitialListeners();
    reject(new Error("Connection closed before it was opened"));
  };
  const cleanInitialListeners = () => {
    ws.removeEventListener("open", openListener);
    ws.removeEventListener("error", errorListener);
    ws.removeEventListener("close", closeListener);
  };
  ws.addEventListener("open", openListener);
  ws.addEventListener("error", errorListener);
  ws.addEventListener("close", closeListener);
});

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/index.js
var import_pitcher_common10 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/AiChat.js
var import_pitcher_common8 = __toESM(require_dist3());
var AiChatMessageStream = class extends import_pitcher_common8.Disposable {
  constructor(id, role, username) {
    super();
    this.id = id;
    this.role = role;
    this.username = username;
    this.progressEmitter = new import_pitcher_common8.Emitter();
    this.onProgress = this.progressEmitter.event;
    this.doneEmitter = new import_pitcher_common8.Emitter();
    this.onDone = this.doneEmitter.event;
  }
  handleProgress(content) {
    this.progressEmitter.fire(content);
  }
  handleDone() {
    this.doneEmitter.fire();
  }
};
var AiChat = class extends import_pitcher_common8.Disposable {
  constructor(chatId, title, isUpToDate, messageHandler, aiClient) {
    super();
    this.messageHandler = messageHandler;
    this.aiClient = aiClient;
    this.historyPromise = null;
    this.entries = [];
    this.isStreamingReply = false;
    this.chatMessageEmitter = new import_pitcher_common8.Emitter();
    this.onChatMessage = this.chatMessageEmitter.event;
    this.chatMessageStartedEmitter = new import_pitcher_common8.Emitter();
    this.onChatMessageStarted = this.chatMessageStartedEmitter.event;
    this.chatTitleChangeEmitter = new import_pitcher_common8.Emitter();
    this.onChatTitleChange = this.chatTitleChangeEmitter.event;
    this.chatId = chatId;
    this.title = title;
    this.isUpToDate = isUpToDate;
    const disposeNotificationListener = this.messageHandler.onNotification("ai/chatMessage", (evt) => {
      if (evt.chatId === this.chatId) {
        const stream = new AiChatMessageStream(evt.messageId, evt.role, evt.username);
        this.chatMessageStartedEmitter.fire(stream);
        if (evt.isFinished || !evt.messageId) {
          this.addChatMessage(evt, true);
          this.chatMessageEmitter.fire(evt);
          stream.handleProgress(evt.message);
          stream.handleDone();
        } else {
          this.isStreamingReply = true;
          const disposable = this.aiClient.subscribeToMessage(evt.messageId, (newContent, isFinished) => {
            stream.handleProgress(newContent);
            if (isFinished) {
              const message = { ...evt, message: newContent };
              this.addChatMessage(message, true);
              this.isStreamingReply = false;
              this.chatMessageEmitter.fire(message);
              disposable.dispose();
              stream.handleDone();
            }
          });
        }
      }
    });
    this.onWillDispose(() => disposeNotificationListener());
  }
  addChatMessage(message, checkHistory) {
    if (checkHistory && this.entries.length) {
      const lastMsgIdx = this.entries[this.entries.length - 1]?.idx ?? 0;
      if (lastMsgIdx !== message.idx - 1) {
        console.warn("Chat message got lost", this, message);
        this.fetchHistory();
      }
    }
    this.entries.push({
      idx: message.idx,
      role: message.role,
      username: message.username,
      message: message.message,
      context: message.context
    });
  }
  fetchHistory() {
    if (!this.historyPromise) {
      this.historyPromise = this.messageHandler.request({
        method: "ai/chatHistory",
        params: {
          chatId: this.chatId
        }
      }).then((res) => {
        this.isUpToDate = true;
        this.entries = res.entries;
        return this.entries;
      }).catch((err) => {
        if (!err.message?.includes("not found")) {
          console.error(err);
        }
        return [];
      }).finally(() => {
        this.historyPromise = null;
      });
    }
    return this.historyPromise;
  }
  getHistory() {
    if (!this.isUpToDate) {
      return this.fetchHistory();
    } else {
      return Promise.resolve(this.entries);
    }
  }
  getHistorySync() {
    return this.entries;
  }
  async sendMessage(params) {
    if (this.isStreamingReply) {
      throw new Error("Cannot sent another request while we are waiting on a response");
    }
    const messageId = (0, import_pitcher_common8.newId)();
    const result = await this.messageHandler.request({
      method: "ai/chatMessage",
      params: {
        ...params,
        messageId,
        chatId: this.chatId
      }
    });
    if (result.title !== this.title) {
      this.title = result.title;
      this.chatTitleChangeEmitter.fire(this.title);
    }
    const chatMessage = {
      ...params,
      chatId: this.chatId,
      role: "user",
      idx: this.entries.length
    };
    this.addChatMessage(chatMessage, true);
  }
  async refresh() {
    await this.fetchHistory();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/MessageStream.js
var import_pitcher_common9 = __toESM(require_dist3());
var AiMessageStream = class extends import_pitcher_common9.Disposable {
  constructor(id, aiClient) {
    super();
    this.id = id;
    this.progressEmitter = new import_pitcher_common9.Emitter();
    this.onProgress = this.progressEmitter.event;
    this.doneEmitter = new import_pitcher_common9.Emitter();
    this.onDone = this.doneEmitter.event;
    const disposable = aiClient.subscribeToMessage(id, (newContent, isFinished) => {
      this.progressEmitter.fire(newContent);
      if (isFinished) {
        this.doneEmitter.fire();
      }
    });
    this.addDisposable(disposable);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/AiClient/index.js
var AiClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.chats = /* @__PURE__ */ new Map();
    this.messageStates = /* @__PURE__ */ new Map();
    this.messageProgressEmitter = new import_pitcher_common10.Emitter();
    this.onMessageProgress = this.messageProgressEmitter.event;
    this.chatsUpdatedEmitter = new import_pitcher_common10.Emitter();
    this.onChatsUpdated = this.chatsUpdatedEmitter.event;
    this.chatsErrorEmitter = new import_pitcher_common10.Emitter();
    this.onChatsError = this.chatsErrorEmitter.event;
    this.chatCreatedEmitter = new import_pitcher_common10.Emitter();
    this.onChatCreated = this.chatCreatedEmitter.event;
    this.chatMessageEmitter = new import_pitcher_common10.Emitter();
    this.onChatMessage = this.chatMessageEmitter.event;
    messageHandler.onNotification("ai/messageProgress", ({ messageId, chunk, isFinished }) => {
      const state = this.messageStates.get(messageId) ?? {
        isFinished,
        content: ""
      };
      state.content += chunk;
      state.isFinished = isFinished;
      this.messageStates.set(messageId, state);
      this.messageProgressEmitter.fire(messageId);
    });
    messageHandler.onNotification("ai/chatCreated", (evt) => {
      const chat = new AiChat(evt.chatId, evt.title, true, messageHandler, this);
      chat.entries = evt.entries;
      this.chats.set(chat.chatId, chat);
      this.chatCreatedEmitter.fire(chat);
      this.chatsUpdatedEmitter.fire(this.chats);
    });
    messageHandler.onNotification("ai/chatMessage", (message) => {
      this.chatMessageEmitter.fire(message);
    });
  }
  subscribeToMessage(messageId, callback) {
    const disposable = this.onMessageProgress((evtId) => {
      if (evtId === messageId) {
        const state2 = this.messageStates.get(messageId);
        if (state2) {
          callback(state2.content, state2.isFinished);
        }
      }
    });
    const state = this.messageStates.get(messageId);
    if (state) {
      callback(state.content, state.isFinished);
    }
    return disposable;
  }
  fetchChats() {
    this.messageHandler.request({
      method: "ai/chats",
      params: {}
    }).then((v3) => {
      for (const c3 of v3.chats) {
        const existingChat = this.chats.get(c3.chatId);
        if (!existingChat) {
          const chatInstance = new AiChat(c3.chatId, c3.title, false, this.messageHandler, this);
          this.chats.set(c3.chatId, chatInstance);
          chatInstance.refresh();
        }
        this.chatsUpdatedEmitter.fire(this.chats);
      }
    }).catch((err) => {
      this.chatsErrorEmitter.fire(err.message);
    });
  }
  resync() {
    this.fetchChats();
  }
  suggestCommit(params) {
    if (!params.files.length) {
      throw new Error("Need to provide at least 1 file");
    }
    return this.messageHandler.request({
      method: "ai/suggestCommit",
      params
    });
  }
  raw(params) {
    return this.messageHandler.request({
      method: "ai/raw",
      params
    });
  }
  async stream(params) {
    const result = await this.messageHandler.request({
      method: "ai/stream",
      params
    });
    const stream = new AiMessageStream(result.messageId, this);
    return stream;
  }
  async getChat({ id = (0, import_pitcher_common10.newId)() }) {
    let chat = this.chats.get(id);
    if (chat) {
      return chat;
    }
    chat = new AiChat(id, "New chat", true, this.messageHandler, this);
    this.chats.set(chat.chatId, chat);
    this.chatsUpdatedEmitter.fire(this.chats);
    await chat.getHistory();
    return chat;
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/Channel.js
var import_pitcher_common11 = __toESM(require_dist3());
var Channel = class extends import_pitcher_common11.Disposable {
  constructor(name, messageHandler) {
    super();
    this.name = name;
    this.messageHandler = messageHandler;
    this.onErrorEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onJoinEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onLeaveEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.onMessageEmitter = this.addDisposable(new import_pitcher_common11.Emitter());
    this.state = {
      hasSubscribed: false
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.onError = this.onErrorEmitter.event;
    this.onSubscribe = this.onJoinEmitter.event;
    this.onUnsubscribe = this.onLeaveEmitter.event;
    this.onMessage = this.onMessageEmitter.event;
    this.onWillDispose(() => {
      this.unsubscribe();
      this.subscribers = /* @__PURE__ */ new Set();
      if (this.state.hasSubscribed) {
        this.state.disposeNotificationListeners();
      }
    });
  }
  listenToNotifications() {
    const onMessageDisposer = this.messageHandler.onNotification("channel/message", (message) => {
      if (message.name === this.name) {
        this.onMessageEmitter.fire({
          clientId: message.clientId,
          data: message.data,
          isUser: message.isUser
        });
      }
    });
    const onSubscribedDisposer = this.messageHandler.onNotification("channel/subscribed", (message) => {
      if (message.name === this.name) {
        this.subscribers = new Set(message.subscribers);
        this.onJoinEmitter.fire(message.clientId);
      }
    });
    const onUnsubscribedDisposer = this.messageHandler.onNotification("channel/unsubscribed", (message) => {
      if (message.name === this.name) {
        this.subscribers = new Set(message.subscribers);
        this.onLeaveEmitter.fire(message.clientId);
      }
    });
    return () => {
      onMessageDisposer();
      onSubscribedDisposer();
      onUnsubscribedDisposer();
    };
  }
  async subscribe() {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.state.hasSubscribed === true) {
      return;
    }
    const disposeNotificationListeners = this.listenToNotifications();
    try {
      const result = await this.messageHandler.request({
        method: "channel/subscribe",
        params: {
          name: this.name
        }
      });
      this.subscribers = new Set(result.subscribers);
      this.state = {
        hasSubscribed: true,
        disposeNotificationListeners
      };
    } catch (err) {
      const error = err;
      disposeNotificationListeners();
      this.onErrorEmitter.fire({
        code: error.code,
        message: error.message
      });
      throw new Error(error.message);
    }
  }
  async unsubscribe() {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.state.hasSubscribed === false) {
      return;
    }
    this.state.disposeNotificationListeners();
    this.state = {
      hasSubscribed: false
    };
    try {
      await this.messageHandler.request({
        method: "channel/unsubscribe",
        params: {
          name: this.name
        }
      });
      this.subscribers = /* @__PURE__ */ new Set();
      this.state = {
        hasSubscribed: false
      };
    } catch (err) {
      const dispose = this.listenToNotifications();
      const error = err;
      this.state = {
        hasSubscribed: true,
        disposeNotificationListeners: dispose
      };
      this.onErrorEmitter.fire({
        code: error.code,
        message: error.message
      });
      throw new Error(error.message);
    }
  }
  sendAll(data) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.messageHandler.request({
      method: "channel/message",
      params: {
        data,
        name: this.name
      }
    });
  }
  send(subscribers, data) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.messageHandler.request({
      method: "channel/message",
      params: {
        data,
        name: this.name,
        clients: Array.from(subscribers)
      }
    });
  }
  resync() {
    if (this.state.hasSubscribed) {
      this.state.disposeNotificationListeners();
      this.state = {
        hasSubscribed: false
      };
      this.subscribe();
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/CommandChannel.js
var import_pitcher_common12 = __toESM(require_dist3());
var import_class_states2 = __toESM(require_dist6());
var CommandChannel = class extends import_pitcher_common12.Disposable {
  constructor({ name, currentClient, clientClient, messageHandler }) {
    super();
    this.state = new import_class_states2.States({
      state: "SOLO"
    });
    this.name = name;
    this.hostChannel = new Channel(`${name}-${currentClient.clientId}`, messageHandler);
    this.hostChannel.subscribe();
    this.messageHandler = messageHandler;
    this.currentClient = currentClient;
    this.addDisposable(clientClient.onClientsUpdated((clients) => this.updateChannels(clients)));
    this.updateChannels(clientClient.getClients());
    this.onWillDispose(() => {
      this.hostChannel.dispose();
      this.state.match({
        MULTIPLAYER: ({ channels }) => {
          for (const clientId in channels) {
            channels[clientId]?.dispose();
          }
        },
        SOLO: () => {
        }
      });
    });
  }
  updateChannels(clients) {
    const clientIdsOfUser = clients.filter((client2) => client2.clientId !== this.currentClient.clientId && client2.username && client2.username === this.currentClient.username).map((client2) => client2.clientId);
    const channels = this.state.match({
      SOLO: () => this.state.set({
        state: "MULTIPLAYER",
        channels: {}
      }).channels,
      MULTIPLAYER: ({ channels: channels2 }) => channels2
    });
    clientIdsOfUser.forEach((clientId) => {
      if (!channels[clientId]) {
        const channel = new Channel(`${this.name}-${clientId}`, this.messageHandler);
        channels[clientId] = channel;
        channel.subscribe();
      }
    });
    for (const clientId in channels) {
      const channel = channels[clientId];
      if (channel && !clientIdsOfUser.includes(clientId)) {
        channel.dispose();
        delete channels[clientId];
      }
    }
  }
  /**
   * Messages from your other clients
   */
  onMessage(cb) {
    return this.hostChannel.onMessage((message) => {
      if (message.isUser) {
        cb(message);
      }
    });
  }
  /**
   * Send to your other clients
   */
  send(message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    this.state.match({
      MULTIPLAYER: ({ channels }) => {
        const channelValues = Object.values(channels);
        channelValues.forEach((channel) => channel.sendAll(message));
      },
      SOLO: () => {
      }
    });
  }
  resync() {
    this.hostChannel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/FollowChannel.js
var import_pitcher_common13 = __toESM(require_dist3());
var import_class_states3 = __toESM(require_dist6());
var FollowChannel = class extends import_pitcher_common13.Disposable {
  constructor(name, messageHandler, currentClient) {
    super();
    this.name = name;
    this.messageHandler = messageHandler;
    this.currentClient = currentClient;
    this.onFollowMessageEmitter = this.addDisposable(new import_pitcher_common13.Emitter());
    this.onFollowMessage = this.onFollowMessageEmitter.event;
    this.onUnfollowMessageEmitter = this.addDisposable(new import_pitcher_common13.Emitter());
    this.onUnfollow = this.onUnfollowMessageEmitter.event;
    this.state = {
      following: new import_class_states3.States({
        state: "NOT_FOLLOWING"
      }),
      followers: new import_class_states3.States({
        state: "NO_FOLLOWERS"
      })
    };
    this.hostChannel = new Channel(`${name}-${currentClient.clientId}`, messageHandler);
    this.hostChannel.subscribe();
    this.onFollowerJoin = this.hostChannel.onSubscribe;
    this.onFollowerLeave = this.hostChannel.onUnsubscribe;
    this.hostChannel.onSubscribe((clientId) => {
      const followingState = this.state.following.get();
      if (followingState.state === "FOLLOWING" && followingState.clientId === clientId) {
        this.unfollow();
      }
      this.state.followers.match({
        FOLLOWERS: ({ clientIds }) => this.state.followers.set({
          state: "FOLLOWERS",
          clientIds: clientIds.concat(clientId)
        }),
        NO_FOLLOWERS: () => this.state.followers.set({
          state: "FOLLOWERS",
          clientIds: [clientId]
        })
      });
    });
    this.hostChannel.onUnsubscribe((clientId) => {
      this.state.followers.match({
        FOLLOWERS: ({ clientIds }) => {
          const updatedFollowers = clientIds.filter((currentClientId) => currentClientId !== clientId);
          if (updatedFollowers.length) {
            this.state.followers.set({
              state: "FOLLOWERS",
              clientIds: updatedFollowers
            });
          } else {
            this.state.followers.set({
              state: "NO_FOLLOWERS"
            });
          }
        },
        NO_FOLLOWERS: () => {
        }
      });
    });
    this.onWillDispose(() => {
      this.hostChannel.dispose();
      this.followChannel?.dispose();
    });
  }
  sendAllFollowers(message) {
    if (this.hostChannel.subscribers.size > 1) {
      return this.hostChannel.sendAll(message);
    }
  }
  sendFollower(clientId, message) {
    if (this.hostChannel.subscribers.has(clientId)) {
      return this.hostChannel.send(/* @__PURE__ */ new Set([clientId]), message);
    }
  }
  // We do not deal with the host leaving and joining, this is something the consuming client
  // can handle by subscribing to the client updates
  follow(clientId) {
    if (clientId === this.currentClient.clientId) {
      return;
    }
    if (this.followChannel) {
      this.followChannel.unsubscribe();
    }
    this.followChannel = new Channel(`${this.name}-${clientId}`, this.messageHandler);
    this.followChannel.subscribe();
    this.followChannel.onMessage((message) => {
      this.onFollowMessageEmitter.fire(message);
    });
    this.state.following.set({
      state: "FOLLOWING",
      clientId
    });
  }
  unfollow() {
    if (this.followChannel) {
      this.followChannel.dispose();
      delete this.followChannel;
      this.onUnfollowMessageEmitter.fire();
      this.state.following.set({
        state: "NOT_FOLLOWING"
      });
    }
  }
  resync() {
    this.followChannel?.resync();
    this.hostChannel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/SharedChannel.js
var import_pitcher_common14 = __toESM(require_dist3());
var SharedChannel = class extends import_pitcher_common14.Disposable {
  constructor(name, messageHandler) {
    super();
    this.channel = new Channel(name, messageHandler);
    this.channel.subscribe();
    this.onWillDispose(() => {
      this.channel.dispose();
    });
  }
  onJoin(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onSubscribe(cb);
  }
  onLeave(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onUnsubscribe(cb);
  }
  sendAll(message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.channel.subscribers.size > 1) {
      return this.channel.sendAll(message);
    }
  }
  send(clientId, message) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    if (this.channel.subscribers.has(clientId)) {
      this.channel.send(/* @__PURE__ */ new Set([clientId]), message);
    }
  }
  onMessage(cb) {
    if (this.isDisposed) {
      throw new Error("Channel is disposed");
    }
    return this.channel.onMessage(cb);
  }
  resync() {
    this.channel.resync();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ChannelClient/index.js
var ChannelClient = class {
  constructor({ messageHandler, currentClient, clientClient }) {
    this.channels = {
      raw: {},
      command: {},
      follow: {},
      shared: {}
    };
    this.currentClient = currentClient;
    this.messageHandler = messageHandler;
    this.clientClient = clientClient;
  }
  getChannel(name) {
    return this.channels.raw[name] = this.channels.raw[name] || new Channel(name, this.messageHandler);
  }
  getFollowChannel(name) {
    return this.channels.follow[name] = this.channels.follow[name] || new FollowChannel(name, this.messageHandler, this.currentClient);
  }
  getCommandChannel(name) {
    return this.channels.command[name] = this.channels.command[name] || new CommandChannel({
      name,
      clientClient: this.clientClient,
      currentClient: this.currentClient,
      messageHandler: this.messageHandler
    });
  }
  getSharedChannel(name) {
    return this.channels.shared[name] = this.channels.shared[name] || new SharedChannel(name, this.messageHandler);
  }
  resync() {
    for (const channels of Object.values(this.channels)) {
      for (const channelId in channels) {
        channels[channelId].resync();
      }
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ClientClient.js
var import_pitcher_common16 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/common/AsyncValueStore.js
var import_pitcher_common15 = __toESM(require_dist3());
var AsyncValueStore = class {
  constructor(initialValue, getValue, opts = {}) {
    this.changeEmitter = new import_pitcher_common15.Emitter();
    this.onChange = this.changeEmitter.event;
    this.errorEmitter = new import_pitcher_common15.Emitter();
    this.onError = this.errorEmitter.event;
    this.value = initialValue;
    this.getValue = getValue;
    if (opts.fetchEagerly) {
      this.get();
    }
  }
  get() {
    if (!this.initialValuePromise) {
      this.initialValuePromise = this.getValue().then((initialValue) => {
        this.value = initialValue;
        this.changeEmitter.fire({
          value: this.value,
          prevValue: this.value
        });
      }).catch((error) => {
        this.errorEmitter.fire(error.message);
      });
    }
    return this.value;
  }
  getInitPromise() {
    return this.initialValuePromise;
  }
  set(newValue) {
    const prevValue = this.value;
    this.value = newValue;
    this.changeEmitter.fire({
      value: this.value,
      prevValue
    });
    return this.value;
  }
  update(cb) {
    const prevValue = this.value;
    this.value = cb(this.value);
    this.changeEmitter.fire({
      value: this.value,
      prevValue
    });
    return this.value;
  }
  refresh() {
    this.getValue().then((value) => this.set(value));
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ClientClient.js
var ClientClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.clientConnectedEmitter = new import_pitcher_common16.Emitter();
    this.onClientConnected = this.clientConnectedEmitter.event;
    this.clientDisconnectedEmitter = new import_pitcher_common16.Emitter();
    this.onClientDisconnected = this.clientDisconnectedEmitter.event;
    this.clientUpdatedEmitter = new import_pitcher_common16.Emitter();
    this.onClientUpdated = this.clientUpdatedEmitter.event;
    this.clientPermissionsEmitter = new import_pitcher_common16.Emitter();
    this.onClientPermissionsUpdated = this.clientPermissionsEmitter.event;
    this.clientsUpdatedEmitter = new import_pitcher_common16.Emitter();
    this.onClientsUpdated = this.clientsUpdatedEmitter.event;
    this.clientsErrorEmitter = new import_pitcher_common16.Emitter();
    this.onClientsError = this.clientsErrorEmitter.event;
    this.clients = this.createClientsValue();
    messageHandler.onNotification("client/connected", (connectedClient) => {
      this.clients.update((existingValue) => {
        const existingClient = existingValue.find((client2) => client2.clientId === connectedClient.clientId);
        if (existingClient) {
          return existingValue.map((client2) => client2.clientId === connectedClient.clientId ? (
            // We might already have the client in the list, in that case we use the new connected client, but
            // we rather use the avatar url from the stale client as this is lazily resolved and we do not want flicker
            { ...connectedClient, avatarUrl: client2.avatarUrl }
          ) : client2);
        }
        return existingValue.concat(connectedClient);
      });
      this.clientConnectedEmitter.fire(connectedClient);
    });
    messageHandler.onNotification("client/disconnected", ({ clientId, reason }) => {
      if (clientId === this.currentClientId) {
        return;
      }
      this.clients.update((existingValue) => existingValue.filter((client2) => client2.clientId !== clientId));
      this.clientDisconnectedEmitter.fire({ clientId, reason });
    });
    messageHandler.onNotification("client/updated", (updatedClient) => {
      this.clients.update((existingValue) => existingValue.map((client2) => client2.clientId === updatedClient.clientId ? updatedClient : client2));
      this.clientUpdatedEmitter.fire(updatedClient);
    });
    messageHandler.onNotification("client/permissions", (updatedPermissions) => {
      this.clientPermissionsEmitter.fire(updatedPermissions);
    });
  }
  createClientsValue() {
    const clients = new AsyncValueStore([], () => this.messageHandler.request({
      method: "client/list",
      params: {}
    }));
    clients.onChange(({ value }) => this.clientsUpdatedEmitter.fire(value));
    clients.onError((error) => this.clientsErrorEmitter.fire(error));
    return clients;
  }
  async join(params) {
    const joinResult = await this.messageHandler.request({
      method: "client/join",
      params
    }, {
      // 1 hour timeout
      timeoutMs: 36e5,
      queueForReconnect: false
    });
    const joinedClient = joinResult.client;
    this.currentClientId = joinResult.client.clientId;
    this.clients.update((existingValue) => {
      const existingClient = existingValue.find((client2) => client2.clientId === joinedClient.clientId);
      if (existingClient) {
        return [{ ...joinedClient, avatarUrl: existingClient.avatarUrl }];
      }
      return [joinedClient];
    });
    return joinResult;
  }
  getClients() {
    return this.clients.get();
  }
  resync() {
    return this.clients.refresh();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/CommandClient.js
var import_pitcher_common17 = __toESM(require_dist3());
var CommandClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.commandsUpdatedEmitter = new import_pitcher_common17.Emitter();
    this.onCommandsUpdated = this.commandsUpdatedEmitter.event;
    this.commandsErrorEmitter = new import_pitcher_common17.Emitter();
    this.onCommandsError = this.commandsErrorEmitter.event;
    this.commands = this.createCommandsValue();
    messageHandler.onNotification("command/changed", ({ commands }) => {
      this.commands.set(commands);
    });
  }
  createCommandsValue() {
    const commands = new AsyncValueStore([], () => this.messageHandler.request({
      method: "command/list",
      params: {}
    }).then(({ commands: commands2 }) => {
      return commands2;
    }));
    commands.onChange(({ value }) => this.commandsUpdatedEmitter.fire(value));
    commands.onError((error) => this.commandsErrorEmitter.fire(error));
    return commands;
  }
  getCommands() {
    return this.commands.get();
  }
  resync() {
    return this.commands.refresh();
  }
  async executeCommand(commandId) {
    await this.messageHandler.request({
      method: "command/execute",
      params: { commandId }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ContainerClient.js
var import_pitcher_common18 = __toESM(require_dist3());
var ContainerClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.openDevToolEmitter = new import_pitcher_common18.Emitter();
    this.onOpenSetupDevTool = this.openDevToolEmitter.event;
    messageHandler.onNotification("container/openSetupDevtool", ({ dependencies }) => {
      this.openDevToolEmitter.fire({ dependencies });
    });
  }
  async runSetupContainer(params) {
    return await this.messageHandler.request({
      method: "container/setup",
      params
    }, { seamlessForkStrategy: "queue" });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FSClient/index.js
var import_path5 = require("path");
var import_pitcher_common19 = __toESM(require_dist3());
var import_pitcher_protocol3 = __toESM(require_src());
var USER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/project\/home\/[a-zA-Z0-9 -_]+\/workspace/gm);
var DOCKER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/workspace/gm);
var PITCHER_HOST_WORKSPACE_PATH_REGEXP = new RegExp(/^\/project\/.*?\//gm);
var DEVCONTAINER_WORKSPACE_PATH_REGEXP = new RegExp(/^\/workspaces\/.*?\//gm);
var workspacePaths = [
  DEVCONTAINER_WORKSPACE_PATH_REGEXP,
  DOCKER_WORKSPACE_PATH_REGEXP,
  USER_WORKSPACE_PATH_REGEXP,
  PITCHER_HOST_WORKSPACE_PATH_REGEXP
];
function removeWorkspacePath(path2) {
  for (const relativeRegex of workspacePaths) {
    if (relativeRegex.test(path2)) {
      return path2.replace(relativeRegex, "");
    }
  }
  return path2;
}
var FSClient = class {
  constructor(workspacePath, userWorkspacePath, messageHandler) {
    this.workspacePath = workspacePath;
    this.userWorkspacePath = userWorkspacePath;
    this.messageHandler = messageHandler;
    this.memoryFS = new MemoryFS();
    this.operationQueue = new import_pitcher_common19.SerialQueue("fs-client");
    this.onFSErrorEmitter = new import_pitcher_common19.Emitter();
    this.onFSError = this.onFSErrorEmitter.event;
    this.onFSSyncEmitter = new import_pitcher_common19.Emitter();
    this.onFSSync = this.onFSSyncEmitter.event;
    this.onPendingOperationsChangeEmitter = new import_pitcher_common19.Emitter();
    this.onPendingOperationsChange = this.onPendingOperationsChangeEmitter.event;
    this.getPathFromId = this.memoryFS.getPathFromId.bind(this.memoryFS);
    this.getIdFromPath = this.memoryFS.getIdFromPath.bind(this.memoryFS);
    messageHandler.onNotification("fs/operations", ({ operations }) => {
      for (const evt of operations) {
        this.memoryFS.receiveNotification(evt);
        const opCount = this.memoryFS.syncFSTree([]);
        this.onFSSyncEmitter.fire({
          opCount
        });
      }
    });
    this.readyPromise = this.readFs();
  }
  /**
   * When you have a path you know is relative, but you want to to ensure the correct format with
   * prefixed "/" and type safety
   */
  asRelativeWorkspacePath(path2) {
    return (0, import_path5.join)("/", path2);
  }
  /**
   * When you know you have an absolute path, but want to ensure it to be this users workspace and have type safety
   */
  asAbsoluteWorkspacePath(path2) {
    return (0, import_path5.join)(this.workspacePath, removeWorkspacePath(path2));
  }
  /**
   * When you have a type safe absolute path and want to make it relative
   */
  absoluteToRelativeWorkspacePath(path2) {
    return (0, import_path5.join)("/", removeWorkspacePath(path2));
  }
  /**
   * When you have a tpe safe relative path and want to make it absolute to this users workspace path
   */
  relativeToAbsoluteWorkspacePath(path2) {
    return (0, import_path5.join)(this.workspacePath, path2);
  }
  // When you are not sure about the path being relative or absolute, but you want a relative representation.
  // NOTE! This does a best guess as there is a risk the path passed is actually relative to the workspace, but
  // contains the path to the workspace itself, meaning it will be removed
  resolveRelativeWorkspacePath(path2) {
    return (0, import_path5.join)("/", removeWorkspacePath(path2));
  }
  // When you are not sure about the path being relative or absolute, but you want an absolute representation for this
  // users workspace path.
  // NOTE! This does a best guess as there is a risk the path passed is actually relative to the workspace, but
  // contains the path to the workspace itself, meaning it will be removed
  resolveAbsoluteWorkspacePath(path2) {
    return this.asAbsoluteWorkspacePath(path2);
  }
  getPendingOperations() {
    return Array.from(this.memoryFS["pendingOperations"].values());
  }
  readFs() {
    return this.messageHandler.request({
      method: "fs/read",
      params: null
    }).then((result) => {
      return this.memoryFS.populateTreeFromJSON(result);
    });
  }
  async resync() {
    return this.readFs().catch(console.error);
  }
  applyFSOperation(operation) {
    const operationId = this.memoryFS.applyPendingOperation(operation);
    if (operationId === false) {
      return Promise.resolve();
    }
    this.onPendingOperationsChangeEmitter.fire(this.getPendingOperations());
    return this.operationQueue.add(() => {
      return this.messageHandler.request({
        method: "fs/operation",
        params: {
          operation
        }
      }, {
        seamlessForkStrategy: "queue"
      }).then((result) => {
        if (result.code === import_pitcher_protocol3.fs.FSOperationResponseCode.Success) {
          this.memoryFS.receiveNotification({
            clock: result.clock,
            operation
          });
        }
      }).catch((error) => {
        this.onFSErrorEmitter.fire({
          message: error.message
        });
      }).finally(() => {
        const opCount = this.memoryFS.syncFSTree([operationId]);
        this.onFSSyncEmitter.fire({
          opCount
        });
        this.onPendingOperationsChangeEmitter.fire(this.getPendingOperations());
      });
    });
  }
  createParentDirs(parts, parentId) {
    let previousNode = this.memoryFS.tree.getNodeById(parentId);
    if (!previousNode || !previousNode.isDirNode()) {
      throw new Error(previousNode ? `${previousNode.path} is not a directory` : "Parent directory not found");
    }
    for (const part of parts) {
      const foundDirectory = previousNode.children.find((c3) => c3.name === part);
      if (!foundDirectory) {
        const dirId = this.createNewDirectory(part, previousNode.id);
        previousNode = this.memoryFS.tree.getNodeById(dirId);
      } else {
        if (!foundDirectory.isDirNode()) {
          throw new Error(`${foundDirectory.path} already exists but is not a directory`);
        }
        previousNode = foundDirectory;
      }
    }
    return previousNode;
  }
  /**
   * Create a file with the provided name within the directory of the given
   * parent id.
   * */
  async createFile(name, parentId) {
    const parts = name.split("/").filter(Boolean);
    const filename = parts.pop();
    if (!filename) {
      throw new Error("File name is undefined");
    }
    const parentDirNode = this.createParentDirs(parts, parentId);
    const id = (0, import_pitcher_common19.newId)();
    await this.applyFSOperation({
      type: "create",
      parentId: parentDirNode.id,
      newEntry: {
        id,
        type: import_pitcher_common19.bedrockFS.NodeType.File,
        name: filename
      }
      // eslint-disable-next-line
    }).catch(console.error);
    return {
      id,
      filepath: this.getPathFromId(id)
    };
  }
  isFile(id) {
    const node = this.memoryFS.getNodeById(id);
    return node ? node.isFile() : false;
  }
  createNewDirectory(name, parentId) {
    const id = (0, import_pitcher_common19.newId)();
    this.applyFSOperation({
      type: "create",
      parentId,
      newEntry: {
        id,
        type: import_pitcher_common19.bedrockFS.NodeType.Directory,
        name
      }
      // eslint-disable-next-line
    }).catch(console.error);
    return id;
  }
  /**
   * Create a directory with the provided name within the directory of the
   * given parent id.
   * */
  createDirectory(name, parentId) {
    const parts = name.split("/").filter(Boolean);
    if (!parts.length) {
      throw new Error("Directory name is undefined");
    }
    const dirNode = this.createParentDirs(parts, parentId);
    return dirNode.id;
  }
  /**
   * delete a node from the FS
   * */
  deleteNode(id) {
    this.applyFSOperation({
      type: "delete",
      id
      // eslint-disable-next-line
    }).catch(console.error);
  }
  /**
   * rename a node from the FS
   * */
  move(id, opts) {
    const { newName, newParentId } = opts;
    this.applyFSOperation({
      type: "move",
      id,
      parentId: newParentId,
      name: newName
      // eslint-disable-next-line
    }).catch(console.error);
  }
  /**
   * Searches for a string literal within the files of a workspace.
   * Doesn't search the contents of gitignored files.
   */
  async search(params) {
    const result = await this.messageHandler.request({
      method: "fs/search",
      params
    });
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return result.map((result2) => {
      const originalMatches = result2.submatches;
      const newSubmatches = [];
      const lineText = result2.lines.text;
      if (originalMatches.length > 0) {
        const buffer = encoder.encode(lineText);
        for (const submatch of originalMatches) {
          const substring = decoder.decode(buffer.slice(0, submatch.start));
          const actualStart = substring.length;
          const actualEnd = actualStart + submatch.match.text.length;
          newSubmatches.push({
            ...submatch,
            start: actualStart,
            end: actualEnd
          });
        }
      } else {
        newSubmatches.push({
          start: 0,
          end: 1,
          match: { text: lineText[0] ?? "" }
        });
      }
      return { ...result2, submatches: newSubmatches };
    });
  }
  /**
   * Searches for a string literal within the files of a workspace.
   * Doesn't search the contents of gitignored files.
   */
  async streamingSearch(params, onMatches, abort) {
    const searchId = (0, import_pitcher_common19.newId)();
    let promiseResolver;
    let promiseRejector;
    const completionPromise = new Promise((resolve5, reject) => {
      promiseResolver = resolve5;
      promiseRejector = reject;
    });
    const disposables = [];
    const dispose = () => {
      for (const disposable of disposables) {
        disposable();
      }
    };
    const abortDisposable = abort.onDidDispose(() => {
      dispose();
      promiseResolver({ hitLimit: false });
      this.messageHandler.request({
        method: "fs/cancelStreamingSearch",
        params: {
          searchId
        }
      }).catch((err) => {
        promiseRejector(err);
      });
    });
    disposables.push(() => abortDisposable.dispose());
    const disposeSearchMatchesNotif = this.messageHandler.onNotification("fs/searchMatches", ({ searchId: notificationSearchId, matches }) => {
      if (searchId !== notificationSearchId) {
        return;
      }
      const encoder = new TextEncoder();
      const decoder = new TextDecoder();
      const remappedMatches = matches.map((result) => {
        const originalMatches = result.submatches;
        const newSubmatches = [];
        const lineText = result.lines.text;
        if (originalMatches.length > 0) {
          const buffer = encoder.encode(lineText);
          for (const submatch of originalMatches) {
            const substring = decoder.decode(buffer.slice(0, submatch.start));
            const actualStart = substring.length;
            const actualEnd = actualStart + submatch.match.text.length;
            newSubmatches.push({
              ...submatch,
              start: actualStart,
              end: actualEnd
            });
          }
        } else {
          newSubmatches.push({
            start: 0,
            end: 1,
            match: { text: lineText[0] ?? "" }
          });
        }
        return { ...result, submatches: newSubmatches };
      });
      onMatches(remappedMatches);
    });
    disposables.push(disposeSearchMatchesNotif);
    const disposeSearchCompletionNotif = this.messageHandler.onNotification("fs/searchFinished", ({ searchId: notificationSearchId, hitLimit }) => {
      if (searchId !== notificationSearchId) {
        return;
      }
      promiseResolver({ hitLimit });
    });
    disposables.push(disposeSearchCompletionNotif);
    await this.messageHandler.request({
      method: "fs/streamingSearch",
      params: {
        ...params,
        searchId
      }
    }).catch((err) => {
      dispose();
      promiseRejector(err);
    });
    return completionPromise.finally(() => dispose());
  }
  /**
   * Searches for a filepath within the project
   * Query can be a literal string or a unix-like pattern e.g. *.test.ts
   */
  pathSearch(params) {
    return this.messageHandler.request({
      method: "fs/pathSearch",
      params
    });
  }
  async uploadFile(name, content, parentId) {
    const parts = name.split("/").filter(Boolean);
    const filename = parts.pop();
    if (!filename) {
      throw new Error("File name is undefined");
    }
    const parentDirNode = this.createParentDirs(parts, parentId);
    const result = await this.messageHandler.request({
      method: "fs/upload",
      params: {
        parentId: parentDirNode.id,
        filename,
        content
      }
    }, {
      seamlessForkStrategy: "queue"
    });
    return {
      id: result.fileId,
      filepath: this.getPathFromId(result.fileId)
    };
  }
  async download(path2) {
    const result = await this.messageHandler.request({
      method: "fs/download",
      params: {
        path: path2 || this.workspacePath
      }
    }, {});
    return {
      downloadUrl: result.downloadUrl
    };
  }
  isInWorkspacePath(path2) {
    return path2.startsWith(this.workspacePath + "/") || path2.startsWith(this.userWorkspacePath + "/");
  }
  async readFile(path2) {
    return this.handleRawFsResponse("fs/readFile", { path: path2 });
  }
  async readdir(path2) {
    return this.handleRawFsResponse("fs/readdir", { path: path2 });
  }
  async writeFile(path2, content, create2 = false, overwrite = false) {
    return this.handleRawFsResponse("fs/writeFile", {
      path: path2,
      content,
      create: create2,
      overwrite
    }, !this.isInWorkspacePath(path2));
  }
  async stat(path2) {
    return this.handleRawFsResponse("fs/stat", { path: path2 });
  }
  async copy(from, to, recursive = false, overwrite = false) {
    return this.handleRawFsResponse("fs/copy", {
      from,
      to,
      recursive,
      overwrite
    }, !this.isInWorkspacePath(from) && !this.isInWorkspacePath(to));
  }
  async rename(from, to, overwrite = false) {
    return this.handleRawFsResponse("fs/rename", { from, to, overwrite }, !this.isInWorkspacePath(from) && !this.isInWorkspacePath(to));
  }
  async remove(path2, recursive = false) {
    return this.handleRawFsResponse("fs/remove", { path: path2, recursive }, !this.isInWorkspacePath(path2));
  }
  async mkdir(path2, recursive = false) {
    return this.handleRawFsResponse("fs/mkdir", { path: path2, recursive }, !this.isInWorkspacePath(path2));
  }
  async watch(path2, options, onEvent) {
    const response = await this.handleRawFsResponse("fs/watch", {
      path: path2,
      recursive: options.recursive,
      // @ts-expect-error angry about using readonly here
      excludes: options.excludes
    });
    if (response.type === "error") {
      return response;
    }
    const watchId = response.result.watchId;
    this.messageHandler.onNotification("fs/watchEvent", (params) => {
      if (params.watchId === watchId) {
        params.events.forEach(onEvent);
      }
    });
    return {
      type: "success",
      dispose: () => {
        this.handleRawFsResponse("fs/unwatch", { watchId });
      }
    };
  }
  async handleRawFsResponse(method, params, skipSeamlessFork = false) {
    try {
      const isModifyingRawOperation = method === "fs/copy" || method === "fs/mkdir" || method === "fs/writeFile" || method === "fs/remove" || method === "fs/rename";
      const result = await this.messageHandler.request({
        method,
        params
      }, isModifyingRawOperation && !skipSeamlessFork ? {
        seamlessForkStrategy: "queue",
        queueForReconnect: true
      } : {
        queueForReconnect: true
      });
      return { type: "ok", result };
    } catch (e3) {
      const err = e3;
      if ("code" in err) {
        if (err.code === import_pitcher_protocol3.PitcherErrorCode.RAWFS_ERROR) {
          return {
            type: "error",
            error: err.message,
            errno: err.data.errno
          };
        }
        return { type: "error", error: err.message, errno: null };
      }
      if (err instanceof Error) {
        return { type: "error", error: err.message, errno: null };
      }
      return { type: "error", error: "unknown error", errno: null };
    }
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/index.js
var import_pitcher_common22 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/File.js
var import_pitcher_common21 = __toESM(require_dist3());

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/Document.js
var import_pitcher_common20 = __toESM(require_dist3());
var import_pitcher_protocol4 = __toESM(require_src());
var Document = class {
  constructor(file, doc, messageHandler) {
    this.onIncomingOperationEmitter = new import_pitcher_common20.Emitter();
    this.onIncomingOperation = this.onIncomingOperationEmitter.event;
    this.onSendOperationEmitter = new import_pitcher_common20.Emitter();
    this.onSendOperation = this.onSendOperationEmitter.event;
    this.onOperationAckEmitter = new import_pitcher_common20.Emitter();
    this.onOperationAck = this.onOperationAckEmitter.event;
    this.onSelectionEmitter = new import_pitcher_common20.Emitter();
    this.onSelection = this.onSelectionEmitter.event;
    this.onErrorEmitter = new import_pitcher_common20.Emitter();
    this.onError = this.onErrorEmitter.event;
    this.onResyncEmitter = new import_pitcher_common20.Emitter();
    this.onResync = this.onResyncEmitter.event;
    this.clientSelections = /* @__PURE__ */ new Map();
    this.syncState = "SYNCED";
    this.file = file;
    this.messageHandler = messageHandler;
    this.clientSelections = new Map(Object.entries(doc.clients).map(([clientId, selection]) => {
      return [clientId, selection];
    }));
    this.file.onWillClientJoin(({ clientId }) => {
      this.clientSelections.set(clientId, null);
    });
    this.file.onWillClientLeave(({ clientId }) => {
      this.clientSelections.delete(clientId);
    });
    this.otClient = this.createOTClient(this.file.content, doc.revision);
    function isResolvedDocumentOperationResult(message) {
      return (0, import_pitcher_protocol4.isResultPayload)(message) && message.method === "file/documentOperation" && message.status === import_pitcher_protocol4.PitcherResponseStatus.RESOLVED;
    }
    messageHandler.onMessage((message) => {
      if (isResolvedDocumentOperationResult(message) && // This is for backwards compatability
      Boolean("id" in message.result ? message.result.id === this.file.id : true)) {
        this.otClient.serverAck();
      }
    });
    messageHandler.onNotification("file/documentOperation", ({ id, operation, revision, reason }) => {
      if (id !== this.file.id || this.syncState === "RESYNCING")
        return;
      try {
        const op = import_pitcher_common20.ot.TextOperation.fromJSON(operation);
        this.otClient.applyServerOperation(op, reason);
      } catch (err) {
        this.syncState = "RESYNCING";
        this.file.resync().catch((err2) => {
          this.onErrorEmitter.fire({
            error: err2.message,
            metadata: {
              type: "ot-resync-error"
            }
          });
        });
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-received-invalid-operation",
            operation: JSON.stringify(operation, null, 2),
            revision
          }
        });
      }
    });
    messageHandler.onNotification("file/documentSelection", ({ id, selections, reason }) => {
      if (id !== this.file.id)
        return;
      Object.entries(selections).forEach(([clientId, selection]) => {
        if (this.clientSelections.has(clientId)) {
          this.clientSelections.set(clientId, selection);
        }
      });
      this.onSelectionEmitter.fire({
        clientSelections: this.clientSelections,
        reason
      });
    });
  }
  createOTClient(content, revision) {
    const otClient = new import_pitcher_common20.ot.Client(content, revision, (revision2, operation) => {
      this.sendDocumentOperation(operation, revision2).catch((err) => {
        if (this.syncState === "RESYNCING" || !(err instanceof PitcherMessageError)) {
          return;
        }
        this.syncState = "RESYNCING";
        this.file.resync().catch((err2) => {
          this.onErrorEmitter.fire({
            error: err2.message,
            metadata: {
              type: "ot-resync-error"
            }
          });
        });
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-send-document-operation",
            operation: JSON.stringify(operation.toJSON(), null, 2),
            code: err.code,
            revision: revision2
          }
        });
      });
    }, async (revision2) => {
      try {
        await this.sendDocumentAck(revision2);
      } catch (err) {
        this.onErrorEmitter.fire({
          error: err.message,
          metadata: {
            type: "ot-send-document-ack",
            revision: revision2
          }
        });
      }
    });
    otClient.onDocumentChange(({ newContent }) => {
      this.file.updateContent(newContent);
    });
    otClient.onIncomingOperation((evt) => {
      this.onIncomingOperationEmitter.fire({
        revision: evt.revision,
        clientSelections: this.clientSelections,
        operation: evt.operation,
        reason: evt.reason
      });
    });
    otClient.onOperationAck(({ revision: revision2 }) => {
      this.onOperationAckEmitter.fire({
        clientSelections: this.clientSelections,
        revision: revision2
      });
    });
    return otClient;
  }
  /**
   * Resync is used when there is an internal issue with the OT Document, which means we can gracefully recover
   * changes made on the server with any pending/queued operations from the client
   */
  resync(content, revision) {
    const didChange = content !== this.file.content;
    this.otClient.syncServerDocument(content, revision);
    this.syncState = "SYNCED";
    this.onResyncEmitter.fire(didChange);
  }
  /**
   * In extreme cases we want to be able to reset the otClient to the server state. We do this when the code editor
   * is not able to apply its operations to the OT Document or it has problems applying server operations to the code editor. There
   * is not good way to recover from this and it should really never happen. But if it does happen we can completely reset the OTClient with
   * the current server document and its revision
   */
  reset(content, revision) {
    this.otClient.dispose();
    this.otClient = this.createOTClient(content, revision);
  }
  sendDocumentAck(revision) {
    return this.messageHandler.request({
      method: "file/documentAck",
      params: {
        id: this.file.id,
        revision
      }
    });
  }
  sendDocumentOperation(operation, revision) {
    this.onSendOperationEmitter.fire({ operation, revision });
    return this.messageHandler.request(
      {
        method: "file/documentOperation",
        params: {
          id: this.file.id,
          operation: operation.toJSON(),
          revision
        }
      },
      // OT Operations should never be queued. When they fail the OT Client will resend them on resync. On seamless
      // fork we just dispose of the message immediately as a resync happens after the fork is done
      {
        seamlessForkStrategy: "dispose",
        queueForReconnect: false
      }
    );
  }
  /**
   * Apply a text operation to the ot-client
   *
   * @param operation the operation to apply
   */
  applyClient(operation) {
    this.otClient.applyClientOperation(operation);
  }
  sendSelection(selection, reason) {
    return this.messageHandler.request(
      {
        method: "file/documentSelection",
        params: {
          id: this.file.id,
          selection,
          reason
        }
      },
      // Selections happens so often and are immutable, so we do not need to queue them
      {
        queueForReconnect: false
      }
    ).then(() => {
      return;
    }).catch(() => {
    });
  }
  dispose() {
    this.onIncomingOperationEmitter.dispose();
    this.onOperationAckEmitter.dispose();
    this.onErrorEmitter.dispose();
    this.onSelectionEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/File.js
var File = class extends import_pitcher_common21.Disposable {
  get isDirty() {
    return this.contentHash !== this.savedHash;
  }
  constructor(path2, fileData, messageHandler) {
    super();
    this.onDidSaveEmitter = new import_pitcher_common21.Emitter();
    this.onDidSave = this.onDidSaveEmitter.event;
    this.onDidContentChangeEmitter = new import_pitcher_common21.Emitter();
    this.onDidContentChange = this.onDidContentChangeEmitter.event;
    this.onWillClientJoinEmitter = new import_pitcher_common21.Emitter();
    this.onWillClientJoin = this.onWillClientJoinEmitter.event;
    this.onDidClientJoinEmitter = new import_pitcher_common21.Emitter();
    this.onDidClientJoin = this.onDidClientJoinEmitter.event;
    this.onWillClientLeaveEmitter = new import_pitcher_common21.Emitter();
    this.onWillClientLeave = this.onWillClientLeaveEmitter.event;
    this.onDidClientLeaveEmitter = new import_pitcher_common21.Emitter();
    this.onDidClientLeave = this.onDidClientLeaveEmitter.event;
    this.onDidMoveEmitter = new import_pitcher_common21.Emitter();
    this.onDidMove = this.onDidMoveEmitter.event;
    this.clients = {};
    this.document = null;
    this.path = path2;
    this.id = fileData.id;
    this.savedHash = fileData.savedHash;
    this.messageHandler = messageHandler;
    this.content = fileData.content;
    this.isBinary = fileData.isBinary;
    this.clients = fileData.clients;
    this.contentHash = typeof fileData.content === "string" ? (0, import_pitcher_common21.murmur)(fileData.content) : fileData.savedHash;
    if (fileData.document) {
      this.document = new Document(this, fileData.document, messageHandler);
    }
    messageHandler.onNotification("file/save", ({ id, savedHash }) => {
      if (id !== this.id) {
        return;
      }
      this.savedHash = savedHash;
      this.onDidSaveEmitter.fire({
        savedHash
      });
    });
    messageHandler.onNotification("file/join", ({ id, username, clientId }) => {
      if (id !== this.id) {
        return;
      }
      this.onWillClientJoinEmitter.fire({
        clientId,
        username
      });
      this.clients[clientId] = {
        username
      };
      this.onDidClientJoinEmitter.fire({
        clientId,
        username,
        clients: this.clients
      });
    });
    messageHandler.onNotification("file/leave", ({ id, clientId, username }) => {
      if (id !== this.id) {
        return;
      }
      this.onWillClientLeaveEmitter.fire({
        clientId,
        username
      });
      delete this.clients[clientId];
      this.onDidClientLeaveEmitter.fire({
        clientId,
        username,
        clients: this.clients
      });
    });
    this.onWillDispose(() => {
      this.onDidSaveEmitter.dispose();
      this.onDidContentChangeEmitter.dispose();
      this.onWillClientJoinEmitter.dispose();
      this.onDidClientJoinEmitter.dispose();
      this.onWillClientLeaveEmitter.dispose();
      this.onDidClientLeaveEmitter.dispose();
      this.document?.dispose();
    });
  }
  updatePath(newPath) {
    this.path = newPath;
    this.onDidMoveEmitter.fire(newPath);
  }
  async resync() {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // Resync is a result of reconnecting, so we do not queue here
      {
        queueForReconnect: false
      }
    );
    this.savedHash = readResult.savedHash;
    if (readResult.document && typeof readResult.content === "string") {
      this.document.resync(readResult.content, readResult.document.revision);
    }
  }
  /**
   * Will get the current content of the document in Pitcher and reset the otClient to that state.
   * It returns the current contents which should be updated in the code editor
   */
  async resetFromServer() {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // In this context we do not want any queuing as a failed resync would mean we would call this again
      {
        queueForReconnect: false
      }
    );
    if (readResult.document && typeof readResult.content === "string") {
      this.document.reset(readResult.content, readResult.document.revision);
      return readResult.content;
    }
  }
  /**
   * Will get the current content of the document in Pitcher, reset the otClient to that state and
   * apply the current editor contents as a diff operation on top
   */
  async resetFromClient(content) {
    if (!this.document) {
      return;
    }
    const readResult = await this.messageHandler.request(
      {
        method: "file/open",
        params: {
          id: this.id,
          isResync: true
        }
      },
      // In this context we do not want any queuing as a failed resync would mean we would call this again
      {
        queueForReconnect: false
      }
    );
    if (readResult.document && typeof readResult.content === "string") {
      this.document.reset(readResult.content, readResult.document.revision);
      this.document.otClient.applyClientDocument(content);
    }
  }
  updateContent(newContent) {
    this.content = newContent;
    this.contentHash = (0, import_pitcher_common21.murmur)(newContent);
    this.onDidContentChangeEmitter.fire({
      contentHash: this.contentHash,
      newContent: this.content
    });
  }
  async save(write = true) {
    const hasPendingOperations = () => this.document && (this.document.otClient.hasPendingOperation || this.document?.otClient.hasQueuedOperation);
    while (hasPendingOperations()) {
      await (0, import_pitcher_common21.sleep)(50);
    }
    return this.messageHandler.request({
      method: "file/save",
      params: {
        id: this.id,
        write
      }
    }, {
      seamlessForkStrategy: "queue"
    }).then(() => {
      return;
    });
  }
  /** Do not call this directly, should be called by the wrapping Rc */
  internalClose() {
    this.dispose();
    return this.messageHandler.request({
      method: "file/close",
      params: {
        id: this.id
      }
    }).then(() => {
      return;
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/FileClient/index.js
var WAIT_TO_CLOSE_FILE_MS = 1e3;
var FileClient = class {
  constructor(messageHandler, fs2, workspacePath) {
    this.messageHandler = messageHandler;
    this.fs = fs2;
    this.workspacePath = workspacePath;
    this.onFileOpenEmitter = new import_pitcher_common22.Emitter();
    this.onFileOpen = this.onFileOpenEmitter.event;
    this.onFileJoinEmitter = new import_pitcher_common22.Emitter();
    this.onFileJoin = this.onFileJoinEmitter.event;
    this.onFileLeaveEmitter = new import_pitcher_common22.Emitter();
    this.onFileLeave = this.onFileLeaveEmitter.event;
    this.onFileSaveEmitter = new import_pitcher_common22.Emitter();
    this.onFileSave = this.onFileSaveEmitter.event;
    this.onFileMoveEmitter = new import_pitcher_common22.Emitter();
    this.onFileMove = this.onFileMoveEmitter.event;
    this.onFileDeleteEmitter = new import_pitcher_common22.Emitter();
    this.onFileDelete = this.onFileDeleteEmitter.event;
    this.openedPaths = new import_pitcher_common22.BidirectionalMap();
    this.openFiles = /* @__PURE__ */ new Map();
    this.pendingFiles = /* @__PURE__ */ new Map();
    messageHandler.onNotification("file/join", (data) => {
      this.onFileJoinEmitter.fire(data);
    });
    messageHandler.onNotification("file/save", (data) => {
      this.onFileSaveEmitter.fire({
        ...data,
        path: fs2.getPathFromId(data.id)
      });
    });
    messageHandler.onNotification("file/leave", (data) => {
      this.onFileLeaveEmitter.fire(data);
    });
    fs2.onFSSync(() => {
      for (const fileRc of this.openFiles.values()) {
        const file = fileRc.object;
        const fileId = file.id;
        if (this.openedPaths.getKey(fileId)) {
          continue;
        }
        const foundPath = fs2.getPathFromId(fileId);
        if (!foundPath) {
          this.onFileDeleteEmitter.fire({
            id: fileId,
            path: file.path
          });
        } else if (file.path !== foundPath) {
          this.onFileMoveEmitter.fire({
            id: fileId,
            newPath: foundPath,
            oldPath: file.path
          });
          file.updatePath(foundPath);
        }
      }
    });
  }
  hasDirtyFiles() {
    for (const [, openFile] of this.openFiles) {
      if (openFile.object.isDirty) {
        return true;
      }
    }
    return false;
  }
  registerFile(path2, result) {
    const id = result.id;
    const foundFile = this.openFiles.get(id);
    if (foundFile) {
      return foundFile;
    }
    const f3 = new File(path2, result, this.messageHandler);
    const file = new Rc(f3, () => {
      this.openFiles.delete(fileId);
      this.openedPaths.deleteByValue(fileId);
      this.pendingFiles.set(f3.path, {
        state: "AWAITING_CLOSE",
        promise: (0, import_pitcher_common22.sleep)(WAIT_TO_CLOSE_FILE_MS).then(() => {
          if (this.pendingFiles.get(f3.path)?.state === "AWAITING_CLOSE")
            this.pendingFiles.set(f3.path, {
              state: "CLOSING",
              promise: f3["internalClose"]().finally(() => {
                this.pendingFiles.delete(f3.path);
              })
            });
        })
      });
    });
    const fileId = file.object.id;
    this.openFiles.set(fileId, file);
    this.onFileOpenEmitter.fire(file.object);
    return file;
  }
  getFileIdFromPath(filepath) {
    const fileId = this.fs.getIdFromPath(filepath);
    if (!fileId || !this.fs.isFile(fileId)) {
      return this.openedPaths.getValue(filepath);
    }
    return fileId;
  }
  getPathFromFileId(fileId) {
    return this.openedPaths.getKey(fileId) ?? this.fs.getPathFromId(fileId);
  }
  getOpenedFile(fileId) {
    const openFile = this.openFiles.get(fileId);
    if (openFile) {
      return openFile.object;
    }
  }
  getOpenFiles() {
    return Array.from(this.openFiles.values());
  }
  async openFile(fileId) {
    const openFile = this.openFiles.get(fileId);
    if (openFile) {
      return Promise.resolve(openFile.acquire());
    }
    const filePath = this.getPathFromFileId(fileId);
    const existingPendingFile = this.pendingFiles.get(filePath);
    let pendingFilePromise;
    if (existingPendingFile?.state === "CLOSING") {
      await existingPendingFile.promise;
    }
    if (existingPendingFile?.state === "OPENING") {
      pendingFilePromise = existingPendingFile.promise;
    } else {
      pendingFilePromise = this.messageHandler.request({
        method: "file/open",
        params: {
          id: fileId
        }
      }).then((result) => this.registerFile(this.getPathFromFileId(result.id), result)).finally(() => {
        this.pendingFiles.delete(filePath);
      });
      this.pendingFiles.set(filePath, {
        state: "OPENING",
        promise: pendingFilePromise
      });
    }
    return pendingFilePromise.then((rcFile) => rcFile.acquire());
  }
  async openFileByPath(filepath) {
    const fileId = this.getFileIdFromPath(filepath);
    if (fileId) {
      return this.openFile(fileId);
    }
    const existingPendingFile = this.pendingFiles.get(filepath);
    let pendingFilePromise;
    if (existingPendingFile?.state === "CLOSING") {
      await existingPendingFile.promise;
    }
    if (existingPendingFile?.state === "OPENING") {
      pendingFilePromise = existingPendingFile.promise;
    } else {
      pendingFilePromise = this.messageHandler.request({
        method: "file/openByPath",
        params: {
          path: filepath
        }
      }).then((result) => {
        this.openedPaths.set(filepath, result.id);
        return this.registerFile(filepath, result);
      }).finally(() => {
        this.pendingFiles.delete(filepath);
      });
      this.pendingFiles.set(filepath, {
        state: "OPENING",
        promise: pendingFilePromise
      });
    }
    return pendingFilePromise.then((f3) => f3.acquire());
  }
  createDocumentOperationFromDiff(originalText, modifiedText) {
    return import_pitcher_common22.ot.createDiffTextOperation(originalText, modifiedText);
  }
  async resync() {
    await Promise.all(Array.from(this.openFiles.values()).map((f3) => f3.object.resync()));
  }
  getIdFromWorkspaceUriString(uriString) {
    const absolutePath = this.fs.asAbsoluteWorkspacePath(uriString.replace(/^.*:\/\//, ""));
    return this.getFileIdFromPath(this.fs.absoluteToRelativeWorkspacePath(absolutePath));
  }
  dispose() {
    this.onFileJoinEmitter.dispose();
    this.onFileLeaveEmitter.dispose();
    this.onFileSaveEmitter.dispose();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/GitClient.js
var import_pitcher_common23 = __toESM(require_dist3());
var GitClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.statusUpdatedEmitter = new import_pitcher_common23.Emitter();
    this.onStatusUpdated = this.statusUpdatedEmitter.event;
    this.checkoutPreventedEmitter = new import_pitcher_common23.Emitter();
    this.onCheckoutPrevented = this.checkoutPreventedEmitter.event;
    this.remotesUpdatedEmitter = new import_pitcher_common23.Emitter();
    this.onRemotesUpdated = this.remotesUpdatedEmitter.event;
    this.remotesErrorEmitter = new import_pitcher_common23.Emitter();
    this.onRemotesError = this.remotesErrorEmitter.event;
    this.pullStartedEmitter = new import_pitcher_common23.Emitter();
    this.onPullStarted = this.pullStartedEmitter.event;
    this.pullFinishedEmitter = new import_pitcher_common23.Emitter();
    this.onPullFinished = this.pullFinishedEmitter.event;
    this.commitStartedEmitter = new import_pitcher_common23.Emitter();
    this.onCommitStarted = this.commitStartedEmitter.event;
    this.commitFinishedEmitter = new import_pitcher_common23.Emitter();
    this.onCommitFinished = this.commitFinishedEmitter.event;
    this.branchRenamedEmitter = new import_pitcher_common23.Emitter();
    this.onBranchRenamed = this.branchRenamedEmitter.event;
    messageHandler.onNotification("git/status", (gitStatus) => {
      this.cachedGitStatus = gitStatus;
      this.statusUpdatedEmitter.fire(gitStatus);
    });
    this.remotes = this.createRemotesValue();
    messageHandler.onNotification("git/checkoutPrevented", ({ branch }) => {
      this.checkoutPreventedEmitter.fire(branch);
    });
    messageHandler.onNotification("git/pullStarted", () => {
      this.pullStartedEmitter.fire();
    });
    messageHandler.onNotification("git/remotes", (remotes) => {
      this.remotes.set(remotes);
    });
    messageHandler.onNotification("git/pullFinished", () => {
      this.pullFinishedEmitter.fire();
    });
    messageHandler.onNotification("git/commitStarted", (notification) => {
      this.commitStartedEmitter.fire(notification);
    });
    messageHandler.onNotification("git/commitFinished", (notification) => {
      this.commitFinishedEmitter.fire(notification);
    });
    messageHandler.onNotification("git/renameBranch", (msg) => {
      this.branchRenamedEmitter.fire(msg);
    });
  }
  createRemotesValue() {
    const remotes = new AsyncValueStore(
      // TODO: Empty value, the initial state will be fetched later
      { origin: "", upstream: "" },
      () => this.messageHandler.request({
        method: "git/remotes",
        params: {}
      })
    );
    remotes.onChange(({ value }) => this.remotesUpdatedEmitter.fire(value));
    remotes.onError((error) => this.remotesErrorEmitter.fire(error));
    remotes.get();
    return remotes;
  }
  pushToRemote(url, branch, squashAllCommits = false) {
    return this.messageHandler.request({
      method: "git/pushToRemote",
      params: {
        url,
        branch,
        squashAllCommits
      }
    });
  }
  resetLocalWithRemote() {
    return this.messageHandler.request({
      method: "git/resetLocalWithRemote",
      params: {}
    });
  }
  getStatus() {
    if (this.cachedGitStatus) {
      return Promise.resolve(this.cachedGitStatus);
    }
    return this.messageHandler.request({
      method: "git/status",
      params: {}
    }).then((gitStatus) => {
      this.cachedGitStatus = gitStatus;
      return gitStatus;
    });
  }
  getRemotes() {
    return this.remotes.get();
  }
  getTargetDiffStatus(baseBranch) {
    return this.messageHandler.request({
      method: "git/diffStatus",
      params: {
        base: `origin/${baseBranch}`,
        head: "HEAD"
      }
    });
  }
  resync() {
    delete this.cachedGitStatus;
    this.remotes.refresh();
    return this.getStatus().then((updatedStatus) => {
      this.statusUpdatedEmitter.fire(updatedStatus);
    });
  }
  compare(branch) {
    return this.messageHandler.request({
      method: "git/targetDiff",
      params: {
        branch
      }
    });
  }
  pull(branch, force) {
    return this.messageHandler.request({
      method: "git/pull",
      params: {
        branch,
        force
      }
    });
  }
  commit(message, paths, push = true) {
    return this.messageHandler.request({
      method: "git/commit",
      params: {
        message,
        paths,
        push
      }
    });
  }
  push() {
    return this.messageHandler.request({ method: "git/push", params: null });
  }
  discard(paths) {
    return this.messageHandler.request({
      method: "git/discard",
      params: {
        paths
      }
    }).then(({ paths: paths2 }) => paths2);
  }
  renameBranch(oldBranch, newBranch) {
    return this.messageHandler.request({
      method: "git/renameBranch",
      params: {
        oldBranch,
        newBranch
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  remoteContent({ reference, filepath }) {
    return this.messageHandler.request({
      method: "git/remoteContent",
      params: {
        reference,
        path: filepath
      }
    });
  }
  checkoutInitialBranch() {
    return this.messageHandler.request({
      method: "git/checkoutInitialBranch",
      params: {}
    });
  }
  transposeLines(lines) {
    return this.messageHandler.request({
      // eslint-disable-next-line
      // @ts-ignore
      method: "git/transposeLines",
      params: lines
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/LanguageClient.js
var import_pitcher_common24 = __toESM(require_dist3());
var import_debug2 = __toESM(require_src2());
var debug2 = (0, import_debug2.default)("pitcher:language-client");
var LanguageClient = class {
  constructor(messageHandler, fileClient) {
    this.messageHandler = messageHandler;
    this.fileClient = fileClient;
    this.globCache = new import_pitcher_common24.GlobCache();
    this.initializeMessages = {};
    this.lspNotificationEmitter = new import_pitcher_common24.Emitter();
    this.onLspNotification = this.lspNotificationEmitter.event;
    this.lspServerRequestEmitter = new import_pitcher_common24.Emitter();
    this.onLspServerRequest = this.lspServerRequestEmitter.event;
    this.languagesUpdatedEmitter = new import_pitcher_common24.Emitter();
    this.onLanguagesUpdated = this.languagesUpdatedEmitter.event;
    this.languagesErrorEmitter = new import_pitcher_common24.Emitter();
    this.onLanguagesError = this.languagesErrorEmitter.event;
    this.languages = this.createLanguagesValue();
    messageHandler.onNotification("language/lspNotification", (msg) => {
      this.lspNotificationEmitter.fire(msg);
    });
    messageHandler.onNotification("language/lspServerRequest", (msg) => {
      this.lspServerRequestEmitter.fire(msg);
    });
  }
  createLanguagesValue() {
    const languages = new AsyncValueStore([], () => this.messageHandler.request({
      method: "language/list",
      params: {}
    }).then(({ languages: languages2 }) => languages2));
    languages.onChange(({ value }) => {
      this.globCache.clear();
      this.languagesUpdatedEmitter.fire(value);
    });
    languages.onError((error) => this.languagesErrorEmitter.fire(error));
    return languages;
  }
  getLanguages() {
    return this.languages.get();
  }
  resync() {
    this.languages.refresh();
    for (const serverId in this.initializeMessages) {
      this.sendLSPRequest(this.initializeMessages[serverId]);
    }
  }
  // eslint-disable-next-line
  async sendLSPRequest(params) {
    const now = Date.now();
    const file = this.getLSPRelatedFile(params.message);
    if (params.message.method === "initialize") {
      this.initializeMessages[params.languageId] = params;
    }
    if (file?.document?.otClient.hasQueuedOperation) {
      const barrier = new import_pitcher_common24.Barrier();
      const disposable = file.document.onSendOperation(() => {
        if (!file?.document?.otClient.hasQueuedOperation) {
          disposable.dispose();
          barrier.open();
        }
      });
      await barrier.wait();
    }
    try {
      const result = await this.messageHandler.request({
        method: "language/lspRequest",
        params
      }, {
        queueForReconnect: params.message.method === "initialize",
        // We use a less aggressive timeout as LSPs can sometimes take very long to respond, and sometimes
        // we even need to wait for the container to be built before we get a response.
        timeoutMs: 10 * 60 * 1e3,
        seamlessForkStrategy: params.message.method === "textDocument/formatting" ? "queue" : "queueDuringFork"
      });
      debug2('LSP request "%s" took %dms', params.message.method, Date.now() - now);
      return {
        type: "ok",
        // @ts-expect-error unknown to any
        result
      };
    } catch (e3) {
      return { type: "error", error: e3 };
    }
  }
  sendLSPServerResponse(params) {
    return new Promise((resolve5, reject) => {
      this.messageHandler.request({
        method: "language/lspServerResponse",
        params
      }).then(resolve5).catch(reject);
    });
  }
  getLanguageId(filepath) {
    for (const language of this.languages.get()) {
      for (const pattern of language.globs) {
        const regex = this.globCache.get(pattern);
        if (filepath.match(regex)) {
          return language.id;
        }
      }
    }
    return "text";
  }
  isLSPDocumentMessage(message) {
    return Boolean(message.params && message.params.textDocument);
  }
  getLSPRelatedFile(message) {
    if (!this.isLSPDocumentMessage(message)) {
      return;
    }
    const id = this.fileClient.getIdFromWorkspaceUriString(message.params.textDocument.uri);
    if (!id) {
      return;
    }
    const file = this.fileClient.getOpenedFile(id);
    if (!file) {
      return;
    }
    return file;
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/NotificationClient.js
var import_pitcher_common25 = __toESM(require_dist3());
var NotificationClient = class extends import_pitcher_common25.Disposable {
  constructor(messageHandler) {
    super();
    this.onNotificationEmitter = new import_pitcher_common25.Emitter();
    this.onNotification = this.onNotificationEmitter.event;
    this.notifications = {};
    this.onDismissNotificationEmitter = new import_pitcher_common25.Emitter();
    this.onDismissNotification = this.onDismissNotificationEmitter.event;
    this.addDisposable(messageHandler.onMessage((message) => {
      if (message.method === "notification/notify") {
        const notification = new Notification(message.params);
        this.notifications[notification.id] = notification;
        this.addDisposable(notification.onNotificationResponse((response) => {
          delete this.notifications[notification.id];
          messageHandler.request({
            method: "notification/notifyResponse",
            params: {
              notificationId: notification.id,
              response
            }
          });
        }));
        this.onNotificationEmitter.fire(notification);
      } else if (message.method === "notification/dismiss") {
        const notification = this.notifications[message.params.notificationId];
        if (notification) {
          notification.dismiss();
          delete this.notifications[notification.id];
          this.onDismissNotificationEmitter.fire(message.params);
        }
      }
    }));
  }
};
var Notification = class extends import_pitcher_common25.Disposable {
  constructor(notification) {
    super();
    this.onNotificationResponseEmitter = this.addDisposable(new import_pitcher_common25.Emitter());
    this.onNotificationResponse = this.onNotificationResponseEmitter.event;
    this.onNotificationDismissEmitter = this.addDisposable(new import_pitcher_common25.Emitter());
    this.onNotificationDismiss = this.onNotificationDismissEmitter.event;
    this.id = notification.notificationId;
    this.type = notification.type;
    this.message = notification.message;
    this.actions = notification.actions;
  }
  /**
   * Called when Pitcher wants to dismiss the notification, this should not be used
   * by clients that implement the pitcher-client. To listen to dismiss events, use
   * the `onNotificationDismiss` event instead.
   */
  dismiss() {
    this.onNotificationDismissEmitter.fire();
  }
  respond(label) {
    this.onNotificationResponseEmitter.fire(label);
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/PortClient.js
var import_pitcher_common26 = __toESM(require_dist3());
var PortClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.portsUpdatedEmitter = new import_pitcher_common26.Emitter();
    this.onPortsUpdated = this.portsUpdatedEmitter.event;
    this.portsErrorEmitter = new import_pitcher_common26.Emitter();
    this.onPortsError = this.portsErrorEmitter.event;
    this.ports = this.createPortsValue();
    this.readyPromise = this.ports.getInitPromise();
    messageHandler.onNotification("port/changed", ({ list }) => {
      this.ports.set(list);
    });
  }
  createPortsValue() {
    const ports = new AsyncValueStore([], () => this.messageHandler.request({
      method: "port/list",
      params: {}
    }).then(({ list }) => list), { fetchEagerly: true });
    ports.onChange(({ value }) => this.portsUpdatedEmitter.fire(value));
    ports.onError((error) => this.portsErrorEmitter.fire(error));
    return ports;
  }
  getPorts() {
    return this.ports.get();
  }
  resync() {
    return this.ports.refresh();
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/SetupClient.js
var import_pitcher_common27 = __toESM(require_dist3());
var SetupClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.setupProgressUpdateEmitter = new import_pitcher_common27.Emitter();
    this.onSetupProgressUpdate = this.setupProgressUpdateEmitter.event;
    this.setupProgressErrorEmitter = new import_pitcher_common27.Emitter();
    this.onSetupProgressError = this.setupProgressErrorEmitter.event;
    this.setupProgress = this.createSetupProgressValue();
    this.readyPromise = this.setupProgress.getInitPromise();
    messageHandler.onNotification("setup/progress", (progress) => (
      // This will emit the progress event
      this.setupProgress.set(progress)
    ));
  }
  createSetupProgressValue() {
    const setupProgress = new AsyncValueStore({
      state: "IDLE",
      currentStepIndex: 0,
      steps: []
    }, () => this.messageHandler.request({
      method: "setup/get",
      params: {}
    }), { fetchEagerly: true });
    setupProgress.onChange(({ value }) => this.setupProgressUpdateEmitter.fire(value));
    setupProgress.onError((error) => this.setupProgressErrorEmitter.fire(error));
    return setupProgress;
  }
  getProgress() {
    return this.setupProgress.get();
  }
  resync() {
    return this.setupProgress.refresh();
  }
  /**
   * Skip the currently running step. We expect you to send the current step as a verification for Pitcher
   * to know whether you'd like to skip the current step.
   */
  skipStep(stepIndexToSkip) {
    return this.messageHandler.request({
      method: "setup/skip",
      params: {
        stepIndexToSkip
      }
    });
  }
  /**
   * Skip the entire remaining progress. Current step is finished as SKIPPED, rest of the steps are ignored
   */
  skipAll() {
    return this.messageHandler.request({
      method: "setup/skipAll",
      params: null
    });
  }
  /**
   * Sets the current step, allows you to go back in time again
   */
  setStep(stepIndex) {
    return this.messageHandler.request({
      method: "setup/setStep",
      params: {
        stepIndex
      }
    });
  }
  disable() {
    this.messageHandler.request({
      method: "setup/disable",
      params: null
    });
  }
  enable() {
    this.messageHandler.request({
      method: "setup/enable",
      params: null
    });
  }
  init() {
    return this.messageHandler.request({
      method: "setup/init",
      params: null
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/ShellClient.js
var import_pitcher_common28 = __toESM(require_dist3());
var ShellClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.openShells = /* @__PURE__ */ new Map();
    this.shellCreatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellCreated = this.shellCreatedEmitter.event;
    this.shellRestartedEmitter = new import_pitcher_common28.Emitter();
    this.onShellRestarted = this.shellRestartedEmitter.event;
    this.shellTerminatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellTerminated = this.shellTerminatedEmitter.event;
    this.shellNameChangeEmitter = new import_pitcher_common28.Emitter();
    this.onShellNameChange = this.shellNameChangeEmitter.event;
    this.shellExitedEmitter = new import_pitcher_common28.Emitter();
    this.onShellExited = this.shellExitedEmitter.event;
    this.shellsUpdatedEmitter = new import_pitcher_common28.Emitter();
    this.onShellsUpdated = this.shellsUpdatedEmitter.event;
    this.shellsErrorEmitter = new import_pitcher_common28.Emitter();
    this.onShellsError = this.shellsErrorEmitter.event;
    this.shellOutEmitter = new import_pitcher_common28.Emitter();
    this.onShellOut = this.shellOutEmitter.event;
    this.shells = this.createShellsValue();
    this.readyPromise = this.shells.getInitPromise();
    messageHandler.onNotification("shell/terminate", ({ shellId, author }) => {
      this.shellTerminatedEmitter.fire({ shellId, author });
      this.deleteShell(shellId);
    });
    messageHandler.onNotification("shell/exit", ({ shellId, shellType, exitCode }) => {
      this.shellExitedEmitter.fire({ shellId, exitCode });
      if (shellType === "TERMINAL") {
        this.deleteShell(shellId);
      }
    });
    messageHandler.onNotification("shell/create", (shell) => {
      this.shellCreatedEmitter.fire(shell);
      this.shells.update((shells) => shells.concat(shell));
    });
    messageHandler.onNotification("shell/restart", ({ shellId }) => this.shellRestartedEmitter.fire({ shellId }));
    messageHandler.onNotification("shell/out", (params) => this.shellOutEmitter.fire(params));
    messageHandler.onNotification("shell/rename", ({ shell }) => {
      this.shells.update((shells) => [
        ...shells.filter((item) => item.shellId !== shell.shellId),
        shell
      ]);
      this.shellNameChangeEmitter.fire({ shellId: shell.shellId });
    });
  }
  createShellsValue() {
    const shells = new AsyncValueStore([], () => this.messageHandler.request({
      method: "shell/list",
      params: {}
    }).then(({ shells: shells2 }) => shells2), { fetchEagerly: true });
    shells.onChange(({ value }) => this.shellsUpdatedEmitter.fire(value));
    shells.onError((error) => this.shellsErrorEmitter.fire(error));
    return shells;
  }
  closeShell(shellId) {
    this.openShells.delete(shellId);
  }
  deleteShell(shellId) {
    this.shells.update((shells) => shells.filter((shell) => shell.shellId !== shellId));
    this.closeShell(shellId);
  }
  getShells() {
    return this.shells.get();
  }
  getShellName(id) {
    const name = this.shells.get().find((shell) => shell.shellId === id)?.name || null;
    return name;
  }
  resync() {
    this.shells.refresh();
    Array.from(this.openShells.entries()).forEach(([shellId, shellSize]) => this.open(shellId, shellSize).catch(() => {
      this.shellTerminatedEmitter.fire({
        shellId,
        author: "connection loss"
      });
    }));
  }
  create(projectPath, size, command2, type, isSystemShell) {
    return this.messageHandler.request({
      method: "shell/create",
      params: {
        projectPath,
        command: command2,
        size,
        type,
        isSystemShell
      }
    }).then((response) => {
      this.openShells.set(response.shellId, size);
      return response;
    });
  }
  open(shellId, size) {
    return this.messageHandler.request({
      method: "shell/open",
      params: {
        shellId,
        size
      }
    }).then((response) => {
      this.openShells.set(response.shellId, size);
      return response;
    });
  }
  close(shellId) {
    return this.messageHandler.request({
      method: "shell/close",
      params: {
        shellId
      }
    }).then((response) => {
      this.closeShell(shellId);
      return response;
    });
  }
  restart(shellId) {
    return this.messageHandler.request({
      method: "shell/restart",
      params: {
        shellId
      }
    });
  }
  delete(shellId) {
    return this.messageHandler.request({
      method: "shell/terminate",
      params: {
        shellId
      }
    }).then((response) => {
      this.deleteShell(shellId);
      return response;
    });
  }
  send(shellId, input, size) {
    return this.messageHandler.request({
      method: "shell/in",
      params: {
        shellId,
        input,
        size
      }
    });
  }
  resize(shellId, size) {
    return this.messageHandler.request({
      method: "shell/resize",
      params: {
        shellId,
        size
      }
    }, {
      // This is immutable and can be triggered very often
      queueForReconnect: false
    }).then((response) => {
      this.openShells.set(shellId, size);
      return response;
    });
  }
  rename(shellId, name) {
    return this.messageHandler.request({
      method: "shell/rename",
      params: {
        shellId,
        name
      }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/SystemClient.js
var import_pitcher_common29 = __toESM(require_dist3());
var SystemClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.hibernateEmitter = new import_pitcher_common29.Emitter();
    this.onHibernate = this.hibernateEmitter.event;
    this.metricsEmitter = new import_pitcher_common29.Emitter();
    this.onMetricsUpdated = this.metricsEmitter.event;
    this.initStatusEmitter = new import_pitcher_common29.Emitter();
    this.onInitStatusUpdate = this.initStatusEmitter.event;
    this.metrics = this.createMetricsValue();
    messageHandler.onNotification("system/hibernate", () => {
      this.hibernateEmitter.fire({});
    });
    messageHandler.onNotification("system/metrics", (metrics) => {
      this.metrics.set(metrics);
    });
    messageHandler.onNotification("system/initStatus", (statusUpdate) => {
      this.initStatusEmitter.fire(statusUpdate);
    });
  }
  createMetricsValue() {
    const metrics = new AsyncValueStore(void 0, () => this.messageHandler.request({
      method: "system/metrics",
      params: {}
    }).then((metrics2) => metrics2));
    metrics.onChange(({ value }) => this.metricsEmitter.fire(value));
    return metrics;
  }
  getMetrics() {
    return this.metrics.get();
  }
  startMetricsPollingAtInterval(interval = 5e3) {
    const update = () => {
      this.messageHandler.request({
        method: "system/metrics",
        params: {}
      }, {
        // As this is an immutable request and it happens quite often we do not queue them
        queueForReconnect: false
      }).then((m3) => this.metrics.set(m3)).catch(() => {
      });
    };
    update();
    const intervalRef = setInterval(update, interval);
    return () => {
      clearInterval(intervalRef);
    };
  }
  resync() {
    return;
  }
  update() {
    return this.messageHandler.request({
      method: "system/update",
      params: {}
    });
  }
  hibernate() {
    return this.messageHandler.request({
      method: "system/hibernate",
      params: {}
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/clients/TaskClient.js
var import_pitcher_common30 = __toESM(require_dist3());
var TaskClient = class {
  constructor(messageHandler) {
    this.messageHandler = messageHandler;
    this.taskListUpdateEmitter = new import_pitcher_common30.Emitter();
    this.onTaskListUpdate = this.taskListUpdateEmitter.event;
    this.taskUpdateEmitter = new import_pitcher_common30.Emitter();
    this.onTaskUpdate = this.taskUpdateEmitter.event;
    this.taskPortOpenedEmitter = new import_pitcher_common30.Emitter();
    this.onTaskPortOpened = this.taskPortOpenedEmitter.event;
    this.taskStartedEmitter = new import_pitcher_common30.Emitter();
    this.onTaskStarted = this.taskStartedEmitter.event;
    this.unassignedPortOpenedEmitter = new import_pitcher_common30.Emitter();
    this.onUnassignedPortOpened = this.unassignedPortOpenedEmitter.event;
    this.unassignedPortClosedEmitter = new import_pitcher_common30.Emitter();
    this.onUnassignedPortClosed = this.unassignedPortClosedEmitter.event;
    this.configParseErrorEmitter = new import_pitcher_common30.Emitter();
    this.onConfigParseError = this.configParseErrorEmitter.event;
    this.tasksValue = this.createTasksValue();
    this.readyPromise = this.tasksValue.getInitPromise();
    messageHandler.onNotification("task/listUpdate", (value) => {
      this.tasksValue.set(value);
    });
    messageHandler.onNotification("task/update", (task) => {
      const taskId = task.id;
      const oldTask = this.tasksValue.get().tasks[taskId];
      this.tasksValue.update((crtValue) => ({
        ...crtValue,
        tasks: {
          ...crtValue.tasks,
          [taskId]: task
        }
      }));
      this.taskUpdateEmitter.fire(task);
      if (oldTask?.shell?.status !== "RUNNING" && task.shell?.status === "RUNNING") {
        this.taskStartedEmitter.fire({ taskId });
      }
      if (oldTask) {
        task.ports.forEach((p2) => {
          const portIsNew = !oldTask.ports.some((tp) => tp.port === p2.port);
          if (portIsNew) {
            this.taskPortOpenedEmitter.fire({ taskId, port: p2 });
          }
        });
      }
    });
    messageHandler.onNotification("shell/exit", ({ shellId, exitCode }) => {
      const tasks = this.tasksValue.get().tasks;
      const taskToUpdate = Object.values(tasks).find((t3) => t3.shell?.shellId === shellId);
      if (!taskToUpdate || taskToUpdate.shell === null) {
        return;
      }
      const updatedTask = {
        ...taskToUpdate,
        shell: {
          ...taskToUpdate.shell,
          status: exitCode > 0 ? "ERROR" : "FINISHED",
          exitCode
        }
      };
      this.tasksValue.update((crtValue) => ({
        ...crtValue,
        tasks: {
          ...crtValue.tasks,
          [updatedTask.id]: updatedTask
        }
      }));
      this.taskUpdateEmitter.fire(updatedTask);
    });
    messageHandler.onNotification("task/unassignedPortOpened", (value) => {
      this.unassignedPortOpenedEmitter.fire(value);
    });
    messageHandler.onNotification("task/unassignedPortClosed", (value) => {
      this.unassignedPortClosedEmitter.fire(value);
    });
    messageHandler.onNotification("task/configParseError", ({ error }) => {
      this.configParseErrorEmitter.fire(error);
    });
  }
  createTasksValue() {
    const value = new AsyncValueStore({
      tasks: {},
      setupTasks: [],
      validationErrors: []
    }, () => this.messageHandler.request({
      method: "task/list",
      params: {}
    }).then((value2) => {
      return value2;
    }), { fetchEagerly: true });
    value.onChange(({ value: value2 }) => {
      this.taskListUpdateEmitter.fire(value2);
    });
    return value;
  }
  getTasks() {
    return this.tasksValue.get();
  }
  getTask(taskId) {
    const tasks = this.tasksValue.get().tasks;
    return tasks[taskId];
  }
  resync() {
    return this.tasksValue.refresh();
  }
  runTask(taskId) {
    const task = this.tasksValue.get().tasks[taskId];
    if (task && task.shell?.status === "KILLED") {
      task.shell = null;
    }
    return this.messageHandler.request({
      method: "task/run",
      params: {
        taskId
      }
    }, {
      queueForReconnect: true
    });
  }
  runCommand(command2, saveToConfig, name) {
    return this.messageHandler.request({
      method: "task/runCommand",
      params: {
        command: command2,
        name,
        saveToConfig
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  stopTask(taskId) {
    return this.messageHandler.request({
      method: "task/stop",
      params: {
        taskId
      }
    }, {
      queueForReconnect: true
    });
  }
  updateTask(taskId, taskFields) {
    return this.messageHandler.request({
      method: "task/update",
      params: {
        taskId,
        taskFields
      }
    }, {
      seamlessForkStrategy: "queue"
    });
  }
  async createTask(taskFields, startTask = false) {
    const tasks = await this.messageHandler.request({
      method: "task/create",
      params: {
        taskFields,
        startTask
      }
    }, {
      seamlessForkStrategy: "queue"
    });
    this.tasksValue.set(tasks);
    const tasksObject = this.tasksValue.get().tasks;
    const createdTask = Object.values(tasksObject).find((task) => task.command === taskFields.command);
    if (!createdTask) {
      throw new Error(`Cannot find the task running '${taskFields.command}'`);
    }
    return createdTask;
  }
  saveToConfig(taskId) {
    return this.messageHandler.request({
      method: "task/saveToConfig",
      params: {
        taskId
      }
    });
  }
  generateConfigFile() {
    return new Promise((resolve5, reject) => {
      const unsubscribe = this.messageHandler.onNotification("fs/operations", ({ operations }) => {
        const createOperation = operations.map((ev) => ev.operation).find((op) => op.type === "create" && op.newEntry.name === "tasks.json");
        if (!createOperation || createOperation.type !== "create") {
          return;
        }
        const fileId = createOperation.newEntry.id;
        resolve5(fileId);
        unsubscribe();
      });
      setTimeout(() => {
        reject(new Error("Config file was not generated"));
        unsubscribe();
      }, 5e3);
      this.messageHandler.request({
        method: "task/generateConfig",
        params: {}
      }).catch((err) => {
        reject(err);
        unsubscribe();
      });
    });
  }
  createSetupTasks(tasks) {
    return this.messageHandler.request({
      method: "task/createSetupTasks",
      params: { tasks }
    });
  }
};

// node_modules/@codesandbox/pitcher-client/dist/esm/vm/index.js
var vmD = (0, import_debug3.default)("csb:vm");
var INITIAL_MAX_CONNECTION_TRIES = 3;
var INITIAL_CONNECTION_DELAY_MS = 500;
var INITIAL_CONNECTION_TIMEOUT_MS = 9e4;
var RECONNECT_MAX_CONNECTION_TRIES = 3;
var RECONNECT_CONNECTION_DELAY_MS = 500;
var RECONNECT_CONNECTION_TIMEOUT_MS = 1e4;
var PONG_DETECTION_TIMEOUT = 15e3;
var FOCUS_PONG_DETECTION_TIMEOUT = 5e3;
if (typeof process !== "undefined" && process.env.NODE_ENV === "test") {
  vmD("Using test timeouts");
  PONG_DETECTION_TIMEOUT = 200;
  INITIAL_MAX_CONNECTION_TRIES = 3;
  INITIAL_CONNECTION_DELAY_MS = 10;
  INITIAL_CONNECTION_TIMEOUT_MS = 1e3;
}
function createConnectionString(hostResponse, reconnectToken) {
  return `${hostResponse.pitcherURL}/?token=${hostResponse.pitcherToken}${reconnectToken ? `&reconnectToken=${reconnectToken}` : ""}`;
}
var PitcherVMClient = class extends import_pitcher_common31.Disposable {
  get bootupType() {
    return this.hostResponse.bootupType;
  }
  get currentClient() {
    return this.joinResult.client;
  }
  get capabilities() {
    return this.joinResult.capabilities;
  }
  get permissions() {
    return this.joinResult.permissions;
  }
  get pitcherVersion() {
    return this.joinResult.version;
  }
  get pitcherManagerVersion() {
    return this.hostResponse.pitcherManagerVersion;
  }
  get pitcherProtocolVersion() {
    return this.joinResult.protocolVersion;
  }
  get workspacePath() {
    return this.hostResponse.workspacePath;
  }
  get userWorkspacePath() {
    return this.hostResponse.userWorkspacePath;
  }
  get cluster() {
    return this.hostResponse.cluster;
  }
  get reconnectToken() {
    return this.joinResult.reconnectToken;
  }
  constructor(opts) {
    super();
    this.type = "vm";
    this.lastFocusTimestamp = Date.now();
    this.isFocused = true;
    this.state = new import_class_states4.States({
      // We always instantiate with a connected connection
      state: "CONNECTED",
      lastActivity: Date.now(),
      lastFocus: Date.now(),
      connectedAt: Date.now()
    });
    this.onStateChange = this.state.onTransition;
    this.onReconnectedEmitter = new import_pitcher_common31.Emitter();
    this.onReconnected = this.onReconnectedEmitter.event;
    this.onInstanceChangedEmitter = new import_pitcher_common31.Emitter();
    this.onInstanceChanged = this.onInstanceChangedEmitter.event;
    this.sessionStartTime = Date.now();
    this.instanceId = opts.instanceId;
    this.hostResponse = opts.hostResponse;
    this.joinResult = opts.joinResult;
    this.messageHandler = opts.messageHandler;
    this.onFocusChange = opts.onFocusChange;
    this.onInstanceChangeRequired = this.messageHandler.onInstanceChangeRequired;
    this.appId = opts.appId;
    this.subscriptions = opts.subscriptions;
    this.requestPitcherInstance = opts.requestPitcherInstance;
    this.hostResponse = opts.hostResponse;
    this.subscribeConnection(opts.initialConnection);
    this.connection = opts.initialConnection;
    const fsClient = new FSClient(this.workspacePath, this.userWorkspacePath, this.messageHandler);
    const fileClient = new FileClient(this.messageHandler, fsClient, this.workspacePath);
    const clientClient = new ClientClient(this.messageHandler);
    this.clients = {
      fs: fsClient,
      client: clientClient,
      shell: new ShellClient(this.messageHandler),
      port: new PortClient(this.messageHandler),
      file: fileClient,
      language: new LanguageClient(this.messageHandler, fileClient),
      git: new GitClient(this.messageHandler),
      setup: new SetupClient(this.messageHandler),
      channel: new ChannelClient({
        clientClient,
        currentClient: this.currentClient,
        messageHandler: this.messageHandler
      }),
      task: new TaskClient(this.messageHandler),
      system: new SystemClient(this.messageHandler),
      command: new CommandClient(this.messageHandler),
      notification: new NotificationClient(this.messageHandler),
      ai: new AiClient(this.messageHandler),
      container: new ContainerClient(this.messageHandler)
    };
    this.onMessageError = this.messageHandler.onError;
    this.onMessage = (cb) => this.messageHandler.onMessage(cb);
    this.messageHandler.onInstanceChangeRequired(() => {
      this.messageHandler.setOnSendRequest(() => {
        throw new Error("Instance change required");
      });
    });
    this.clients.system.onHibernate(() => {
      this.state.set({
        state: "HIBERNATED",
        wasFocused: this.isFocused,
        disconnectedAt: Date.now()
      });
      this.connection.dispose("Hibernation");
    });
    this.clients.client.onClientsUpdated((clients) => {
      const currentClient = clients.find((client2) => client2.clientId === this.currentClient.clientId);
      if (currentClient && (this.currentClient.name !== currentClient.name || !this.currentClient.avatarUrl)) {
        this.currentClient.name = currentClient.name;
        this.currentClient.avatarUrl = currentClient.avatarUrl;
      }
    });
    this.onFocusChangeDisposer = this.onFocusChange((isFocused) => {
      this.isFocused = isFocused;
      const state = this.state.get();
      if (isFocused) {
        this.lastFocusTimestamp = Date.now();
      }
      if (isFocused && state.state === "CONNECTED") {
        this.connection.ping(FOCUS_PONG_DETECTION_TIMEOUT);
      } else if (isFocused && (state.state === "DISCONNECTED" || state.state === "HIBERNATED")) {
        this.attemptReconnect({
          disconnectReason: state.state === "DISCONNECTED" ? state.reason : "HIBERNATED",
          disconnectedAt: state.disconnectedAt
        }).catch(() => {
        });
      }
    });
  }
  subscribeConnection(ws) {
    const onMessageDisposer = ws.onMessage((message) => {
      this.messageHandler.receiveMessage(message);
    });
    this.messageHandler.setOnSendRequest((request) => {
      const state = this.state.get();
      if (state.state === "CONNECTED" || request.method === "client/join") {
        ws.send(request.message);
        return;
      }
      if (this.isFocused && (state.state === "DISCONNECTED" || state.state === "HIBERNATED")) {
        this.attemptReconnect({
          disconnectReason: state.state === "DISCONNECTED" ? state.reason : "HIBERNATED",
          disconnectedAt: state.disconnectedAt
        }).catch(() => {
        });
      }
      throw new Error("Not able to send message in state " + state.state);
    });
    const onDisconnectedDisposer = ws.onDisconnected(({ reason, code, wasClean }) => {
      const state = this.state.get();
      if (this.isFocused && state.state === "CONNECTED") {
        this.attemptReconnect({
          disconnectReason: reason,
          disconnectedAt: Date.now()
        }).catch(() => {
        });
      } else {
        this.state.set({
          state: "DISCONNECTED",
          reason,
          code,
          wasClean,
          wasFocused: this.isFocused,
          disconnectedAt: Date.now()
        });
      }
    });
    ws.onWillDispose(() => {
      onMessageDisposer.dispose();
      onDisconnectedDisposer.dispose();
    });
  }
  async resolveCurrentConnection() {
    this.subscribeConnection(this.connection);
    vmD("[pitcher-client]: Joining");
    this.joinResult = await this.clients.client.join({
      clientInfo: {
        protocolVersion: import_pitcher_protocol5.version,
        appId: this.appId
      },
      asyncProgress: false,
      subscriptions: this.subscriptions
    });
    this.state.set({
      state: "CONNECTED",
      lastActivity: this.connection.lastActivity,
      lastFocus: this.lastFocusTimestamp,
      connectedAt: Date.now()
    });
  }
  async reconnect() {
    return this.state.match({
      DISCONNECTED: ({ reason, disconnectedAt }) => this.attemptReconnect({
        disconnectReason: reason,
        disconnectedAt
      }),
      CONNECTED: () => this.attemptReconnect({
        disconnectReason: "MANUAL_RECONNECT",
        disconnectedAt: Date.now()
      }),
      _: () => {
      }
    });
  }
  async attemptReconnect({ disconnectReason, disconnectedAt }) {
    if (this.isDisposed) {
      return;
    }
    if (this.state.is("RECONNECTING")) {
      return Promise.reject("Already reconnecting");
    }
    vmD("[pitcher-client]: Attempting reconnect");
    this.connection.dispose(disconnectReason);
    this.messageHandler.getPendingMessages().forEach((message) => {
      message.reject(new Error("Attempting reconnect"));
    });
    let attempt = 1;
    const wasFocused = this.isFocused;
    try {
      await retryPromise(async (cancellationToken) => {
        this.addDisposable(cancellationToken);
        this.state.set({
          state: "RECONNECTING",
          disconnectReason,
          wasFocused,
          attempt: attempt++,
          lastActivity: this.connection.lastActivity,
          disconnectedAt,
          lastFocus: this.lastFocusTimestamp
        });
        vmD("[pitcher-client]: Resolving instance");
        try {
          this.hostResponse = await this.requestPitcherInstance(this.instanceId);
        } catch (error) {
          if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
            throw new CancellationError(error);
          }
          throw error;
        }
        cancellationToken.throwErrorIfCancelled();
        vmD("[pitcher-client]: Connecting to instance");
        const connection = await createWebSocketClient(createConnectionString(this.hostResponse, this.reconnectToken));
        cancellationToken.throwErrorIfCancelled(() => {
          connection.dispose("Reconnect timed out");
        });
        this.connection = connection;
        await this.resolveCurrentConnection();
        cancellationToken.throwErrorIfCancelled(() => {
          connection.dispose("Reconnect timed out");
        });
        vmD("[pitcher-client]: Connected, resyncing ");
      }, RECONNECT_MAX_CONNECTION_TRIES, RECONNECT_CONNECTION_DELAY_MS, RECONNECT_CONNECTION_TIMEOUT_MS);
      await this.messageHandler.flushReconnectQueue();
      await Promise.all([
        this.clients.client.resync(),
        // TODO: We should not use permission here, but capability. But currently Pitcher returns true on
        // this, even though it does not handle it
        this.permissions.git?.status ? this.clients.git.resync() : Promise.resolve(),
        this.clients.port.resync(),
        this.clients.setup.resync(),
        this.clients.shell.resync(),
        this.clients.language.resync(),
        this.clients.task.resync(),
        this.clients.system.resync(),
        this.clients.command.resync(),
        this.clients.fs.resync(),
        this.clients.file.resync(),
        this.clients.channel.resync()
      ]);
      vmD("[pitcher-client]: Resynced ");
      this.onReconnectedEmitter.fire();
    } catch (error) {
      vmD("[pitcher-client]: Unable to connect - " + String(error));
      this.state.set({
        state: "DISCONNECTED",
        code: -1,
        disconnectedAt,
        reason: String(error),
        wasClean: false,
        wasFocused: this.isFocused
      });
      throw error;
    }
  }
  hasFeature(feature) {
    const result = (0, import_semver.compare)(this.pitcherVersion, PitcherFeatureToVersionMap[feature]);
    return result === -1 ? false : true;
  }
  revertSeamlessFork() {
    this.onInstanceChangedEmitter.fire({ instanceId: this.instanceId });
  }
  toggleSeamlessFork(value) {
    this.messageHandler.toggleSeamlessFork(value);
  }
  async changeInstance(instanceId) {
    return this.state.match({
      CONNECTED: async () => {
        this.connection.silence();
        this.instanceId = instanceId;
        await retryPromise(async (cancellationToken) => {
          this.addDisposable(cancellationToken);
          try {
            this.hostResponse = await this.requestPitcherInstance(instanceId);
          } catch (error) {
            if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
              throw new CancellationError(error);
            }
            throw error;
          }
          cancellationToken.throwErrorIfCancelled();
          this.connection.dispose("Seamless forking");
          const connection = await createWebSocketClient(createConnectionString(this.hostResponse, this.reconnectToken));
          cancellationToken.throwErrorIfCancelled(() => {
            connection.dispose("Seamless connection timed out");
          });
          this.connection = connection;
          await this.resolveCurrentConnection();
          cancellationToken.throwErrorIfCancelled(() => {
            connection.dispose("Seamless connection timed out");
          });
        }, RECONNECT_MAX_CONNECTION_TRIES, RECONNECT_CONNECTION_DELAY_MS, RECONNECT_CONNECTION_TIMEOUT_MS);
        this.connection.setPongDetectionTimeout(PONG_DETECTION_TIMEOUT);
        this.messageHandler.disableSeamlessFork();
        await Promise.all([
          this.clients.file.resync().then(() => this.messageHandler.flushReconnectQueue()),
          // We need to wait for the new git status or we show that the branch is out of sync
          // TODO: We should not use permission here, but capability. But currently Pitcher returns true on
          // this, even though it does not handle it
          this.permissions.git?.status ? this.clients.git.resync() : Promise.resolve()
        ]);
        this.clients.task.resync();
        this.clients.port.resync();
        this.clients.client.resync();
        this.clients.shell.resync();
        this.clients.language.resync();
        this.clients.channel.resync();
        this.onInstanceChangedEmitter.fire({ instanceId: this.instanceId });
      },
      _: () => {
        throw new Error("You can not change instance when: " + this.state.get().state);
      }
    });
  }
  isUpToDate() {
    return this.hostResponse.pitcherVersion === this.hostResponse.latestPitcherVersion;
  }
  disconnect() {
    this.state.set({
      state: "DISCONNECTED",
      code: -1,
      disconnectedAt: Date.now(),
      reason: "Manual disconnect",
      wasClean: true,
      wasFocused: this.isFocused
    });
    this.connection.dispose("Manual disconnect");
  }
  dispose() {
    this.onFocusChangeDisposer();
    this.messageHandler.dispose();
    this.state.dispose();
    this.connection.dispose("Dispose");
  }
};
var INIT_PROGRESS_START = 60;
function offsetPitcherInitProgress(oldProgress) {
  return oldProgress * (100 - INIT_PROGRESS_START) / 100 + INIT_PROGRESS_START;
}
async function initPitcherClient(opts, initStatusCb, hostResponseCb) {
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Connecting to pitcher");
  }
  let hasEmittedConnectingStatus = false;
  const { connection, hostResponse } = await retryPromise(async (cancellationToken) => {
    let hostResponse2;
    try {
      hostResponse2 = await opts.requestPitcherInstance(opts.instanceId);
      hostResponseCb?.(hostResponse2);
    } catch (error) {
      if (error instanceof ApiResponseError && error.type === "WORKSPACE_FROZEN") {
        throw new CancellationError(error);
      }
      throw error;
    }
    cancellationToken.throwErrorIfCancelled();
    if (!hasEmittedConnectingStatus) {
      hasEmittedConnectingStatus = true;
      initStatusCb({
        message: "MicroVM started, connecting...",
        // We give 5 percent to connect to VM, where Pitcher init messages
        // will start at INIT_PROGRESS_START
        progress: INIT_PROGRESS_START - 5,
        nextProgress: INIT_PROGRESS_START
      });
    }
    const connection2 = await createWebSocketClient(createConnectionString(hostResponse2));
    cancellationToken.throwErrorIfCancelled(() => {
      connection2.dispose("Initial connection timed out");
    });
    return { connection: connection2, hostResponse: hostResponse2 };
  }, INITIAL_MAX_CONNECTION_TRIES, INITIAL_CONNECTION_DELAY_MS, INITIAL_CONNECTION_TIMEOUT_MS);
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Setting up message handler and clients");
  }
  const messageHandler = new PitcherMessageHandler((request) => {
    connection.send(request.message);
  }, Boolean(opts.seamlessFork));
  const onMessageDisposer = connection.onMessage((message) => {
    messageHandler.receiveMessage(message);
  });
  const clientClient = new ClientClient(messageHandler);
  const systemClient = new SystemClient(messageHandler);
  const initStatusUpdateDisposer = systemClient.onInitStatusUpdate((status) => {
    status.progress = offsetPitcherInitProgress(status.progress);
    status.nextProgress = offsetPitcherInitProgress(status.nextProgress);
    initStatusCb(status);
  });
  const joinResult = await clientClient.join({
    clientInfo: {
      protocolVersion: import_pitcher_protocol5.version,
      appId: opts.appId
    },
    asyncProgress: true,
    subscriptions: opts.subscriptions
  });
  initStatusUpdateDisposer.dispose();
  onMessageDisposer.dispose();
  const client2 = new PitcherVMClient({
    instanceId: opts.instanceId,
    appId: opts.appId,
    subscriptions: opts.subscriptions,
    requestPitcherInstance: opts.requestPitcherInstance,
    onFocusChange: opts.onFocusChange,
    seamlessFork: opts.seamlessFork,
    messageHandler,
    joinResult,
    initialConnection: connection,
    hostResponse
  });
  if (globalThis.__CSB__SHOW_PITCHER_MESSAGES) {
    vmD("[pitcher-client]: Awaiting fs initialization");
  }
  await Promise.all([
    client2.clients.fs.readyPromise,
    client2.clients.port.readyPromise,
    client2.clients.task.readyPromise,
    client2.clients.setup.readyPromise,
    client2.clients.shell.readyPromise
  ]);
  connection.setPongDetectionTimeout(PONG_DETECTION_TIMEOUT);
  if (typeof window !== "undefined") {
    window._DEBUG_PITCHER_CLIENT = client2;
  }
  return client2;
}

// node_modules/@codesandbox/pitcher-client/dist/esm/index.js
var AsyncDocument = class extends import_pitcher_common32.ot.AsyncDocument {
};

// src/client/sdk.gen.ts
var client = L(z());
var sandboxCreate = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/sandbox"
  });
};
var sandboxFork = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/sandbox/{id}/fork"
  });
};
var vmHibernate = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/hibernate"
  });
};
var vmShutdown = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/shutdown"
  });
};
var vmStart = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/start"
  });
};
var vmUpdateSpecs = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/vm/{id}/update_specs"
  });
};

// src/utils/event.ts
var Emitter28 = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Set();
  }
  get event() {
    if (!this._event) {
      this._event = (listener) => {
        this.registeredListeners.add(listener);
        return Disposable16.create(() => {
          this.registeredListeners.delete(listener);
        });
      };
    }
    return this._event;
  }
  /** Invoke all listeners registered to this event. */
  fire(event) {
    this.registeredListeners.forEach((listener) => {
      listener(event);
    });
  }
  dispose() {
    this.registeredListeners = /* @__PURE__ */ new Set();
  }
};

// src/utils/disposable.ts
var Disposable16 = class _Disposable {
  constructor() {
    this.onWillDisposeEmitter = new Emitter28();
    this.onWillDispose = this.onWillDisposeEmitter.event;
    this.onDidDisposeEmitter = new Emitter28();
    this.onDidDispose = this.onDidDisposeEmitter.event;
    this.toDispose = [];
    this.isDisposed = false;
  }
  addDisposable(disposable) {
    this.toDispose.push(disposable);
    return disposable;
  }
  onDispose(cb) {
    this.toDispose.push(_Disposable.create(cb));
  }
  dispose() {
    if (this.isDisposed) return;
    this.onWillDisposeEmitter.fire(null);
    this.isDisposed = true;
    this.toDispose.forEach((disposable) => {
      disposable.dispose();
    });
    this.onDidDisposeEmitter.fire(null);
    this.onWillDisposeEmitter.dispose();
    this.onDidDisposeEmitter.dispose();
  }
  static is(arg) {
    return typeof arg === "object" && arg !== null && "dispose" in arg && typeof arg.dispose === "function";
  }
  static create(cb) {
    return {
      dispose: cb
    };
  }
};
var DisposableStore = class _DisposableStore {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set();
    this._isDisposed = false;
  }
  static {
    this.DISABLE_DISPOSED_WARNING = true;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.clear();
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    try {
      for (const disposable of this._toDispose.values()) {
        disposable.dispose();
      }
    } finally {
      this._toDispose.clear();
    }
  }
  add(o2) {
    if (!o2) {
      return o2;
    }
    if (o2 === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    if (this._isDisposed) {
      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(
          new Error(
            "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!"
          ).stack
        );
      }
    } else {
      this._toDispose.add(o2);
    }
    return o2;
  }
};

// src/filesystem.ts
var FileSystem = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
  }
  /**
   * Write a file.
   *
   * @param path - The path to write to.
   * @param content - The content to write.
   * @param opts - The options for the write.
   */
  async writeFile(path2, content, opts = {}) {
    const result = await this.pitcherClient.clients.fs.writeFile(
      path2,
      content,
      opts.create ?? true,
      opts.overwrite ?? true
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Write a file as a string.
   *
   * @param path - The path to write to.
   * @param content - The content to write.
   * @param opts - The options for the write.
   */
  async writeTextFile(path2, content, opts = {}) {
    return this.writeFile(path2, new TextEncoder().encode(content), opts);
  }
  /**
   * Create a directory.
   *
   * @param path - The path to create.
   * @param recursive - Whether to create the directory recursively.
   */
  async mkdir(path2, recursive = false) {
    const result = await this.pitcherClient.clients.fs.mkdir(path2, recursive);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Read a directory.
   *
   * @param path - The path to read.
   * @returns The entries in the directory.
   */
  async readdir(path2) {
    const result = await this.pitcherClient.clients.fs.readdir(path2);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return result.result.entries.map((entry) => ({
      ...entry,
      type: entry.type === 0 ? "file" : "directory"
    }));
  }
  /**
   * Read a file
   *
   * @param path - The path to read.
   * @returns The content of the file as a Uint8Array.
   */
  async readFile(path2) {
    const result = await this.pitcherClient.clients.fs.readFile(path2);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return result.result.content;
  }
  /**
   * Read a file as a string.
   *
   * @param path - The path to read.
   * @returns The content of the file as a string.
   */
  async readTextFile(path2) {
    return await this.readFile(path2).then(
      (content) => new TextDecoder("utf-8").decode(content)
    );
  }
  /**
   * Get the stat of a file or directory.
   *
   * @param path - The path to get the stat of.
   * @returns The stat of the file or directory.
   */
  async stat(path2) {
    const result = await this.pitcherClient.clients.fs.stat(path2);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    return {
      ...result.result,
      type: result.result.type === 0 ? "file" : "directory"
    };
  }
  /**
   * Copy a file or directory.
   *
   * @param from - The path to copy from.
   * @param to - The path to copy to.
   * @param recursive - Whether to copy the directory recursively.
   * @param overwrite - Whether to overwrite the destination if it exists.
   */
  async copy(from, to, recursive = false, overwrite = false) {
    const result = await this.pitcherClient.clients.fs.copy(
      from,
      to,
      recursive,
      overwrite
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Rename a file or directory.
   *
   * @param from - The path to rename from.
   * @param to - The path to rename to.
   * @param overwrite - Whether to overwrite the destination if it exists.
   */
  async rename(from, to, overwrite = false) {
    const result = await this.pitcherClient.clients.fs.rename(
      from,
      to,
      overwrite
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Remove a file or directory.
   *
   * @param path - The path to remove.
   * @param recursive - Whether to remove the directory recursively.
   */
  async remove(path2, recursive = false) {
    const result = await this.pitcherClient.clients.fs.remove(path2, recursive);
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
  }
  /**
   * Watch for changes in the filesystem.
   *
   * ```ts
   * const watcher = await sandbox.fs.watch("/path/to/watch");
   * watcher.onEvent((event) => {
   *   console.log(event);
   * });
   *
   * // When done
   * watcher.dispose();
   * ```
   *
   * @param path - The path to watch.
   * @param options - The options for the watch.
   * @returns A watcher that can be disposed to stop the watch.
   */
  async watch(path2, options = {}) {
    const emitter = new Emitter28();
    const result = await this.pitcherClient.clients.fs.watch(
      path2,
      options,
      (event) => emitter.fire(event)
    );
    if (result.type === "error") {
      throw new Error(`${result.errno}: ${result.error}`);
    }
    const watcher = {
      dispose: () => {
        result.dispose();
        emitter.dispose();
      },
      onEvent: emitter.event
    };
    this.addDisposable(watcher);
    return watcher;
  }
  /**
   * Download a file or folder from the filesystem, can only be used to download
   * from within the workspace directory.
   *
   * @param path - The path to download.
   * @returns A download URL that's valid for 5 minutes.
   */
  async download(path2) {
    const result = await this.pitcherClient.clients.fs.download(path2);
    return result;
  }
};

// src/ports.ts
var PortInfo = class {
  constructor(port, hostname) {
    this.port = port;
    this.hostname = hostname;
  }
  getPreviewUrl(protocol2 = "https://") {
    return `${protocol2}${this.hostname}`;
  }
};
var Ports = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.onDidPortOpenEmitter = this.addDisposable(new Emitter28());
    this.onDidPortCloseEmitter = this.addDisposable(new Emitter28());
    this.lastOpenedPorts = /* @__PURE__ */ new Set();
    pitcherClient.clients.port.getPorts().forEach((port) => {
      this.lastOpenedPorts.add(port.port);
    });
    this.addDisposable(
      pitcherClient.clients.port.onPortsUpdated((ports) => {
        const openedPorts = ports.filter((port) => !this.lastOpenedPorts.has(port.port)).map((port) => new PortInfo(port.port, port.url));
        const closedPorts = [...this.lastOpenedPorts].filter(
          (port) => !ports.some((p2) => p2.port === port)
        );
        if (openedPorts.length) {
          for (const port of openedPorts) {
            this.onDidPortOpenEmitter.fire(port);
          }
        }
        if (closedPorts.length) {
          for (const port of closedPorts) {
            this.onDidPortCloseEmitter.fire(port);
          }
        }
        this.lastOpenedPorts = new Set(ports.map((port) => port.port));
      })
    );
  }
  get onDidPortOpen() {
    return this.onDidPortOpenEmitter.event;
  }
  get onDidPortClose() {
    return this.onDidPortCloseEmitter.event;
  }
  getOpenedPort(port) {
    return this.getOpenedPorts().find((p2) => p2.port === port);
  }
  getOpenedPorts() {
    return this.pitcherClient.clients.port.getPorts().map((port) => new PortInfo(port.port, port.url));
  }
  getPreviewUrl(port, protocol2 = "https://") {
    const hostname = this.pitcherClient.clients.port.getPorts().find((p2) => p2.port === port)?.url;
    return hostname ? `${protocol2}${hostname}` : void 0;
  }
  /**
   * Wait for a port to be opened.
   *
   * @param port - The port to wait for.
   * @returns A promise that resolves when the port is opened.
   */
  async waitForPort(port) {
    await this.pitcherClient.clients.port.readyPromise;
    return new Promise((resolve5) => {
      const portInfo = this.getOpenedPorts().find((p2) => p2.port === port);
      if (portInfo) {
        resolve5(portInfo);
        return;
      }
      const disposable = this.addDisposable(
        this.onDidPortOpen((portInfo2) => {
          if (portInfo2.port === port) {
            resolve5(portInfo2);
            disposable.dispose();
          }
        })
      );
    });
  }
};

// src/setup.ts
var import_event5 = __toESM(require_event());
var Setup = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.onSetupProgressUpdateEmitter = this.addDisposable(
      new Emitter28()
    );
    /**
     * Emitted when the setup progress is updated.
     */
    this.onSetupProgressUpdate = this.onSetupProgressUpdateEmitter.event;
    this.addDisposable(
      pitcherClient.clients.setup.onSetupProgressUpdate((progress) => {
        this.onSetupProgressUpdateEmitter.fire(progress);
      })
    );
  }
  /**
   * Run the setup tasks, this will prepare the docker image, and run the user defined
   * setup steps. This will automatically run when a sandbox is started.
   */
  async run() {
    return this.pitcherClient.clients.setup.init();
  }
  /**
   * Returns the current progress of the setup tasks.
   */
  async getProgress() {
    await this.pitcherClient.clients.setup.readyPromise;
    return this.pitcherClient.clients.setup.getProgress();
  }
  async waitForFinish() {
    const progress = await this.getProgress();
    if (progress.state === "FINISHED") {
      return Promise.resolve(progress);
    }
    return (0, import_event5.listenOnce)(this.onSetupProgressUpdate, (progress2) => {
      return progress2.state === "FINISHED";
    });
  }
};

// src/shells.ts
var import_pitcher_common34 = __toESM(require_dist3());
var DEFAULT_SHELL_SIZE = { cols: 128, rows: 24 };
var Shells = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    this.js = new LanguageInterpreter(this.pitcherClient, {
      runtime: "node",
      extension: "js",
      env: { NO_COLOR: "true" }
    });
    this.python = new LanguageInterpreter(this.pitcherClient, {
      runtime: "python",
      extension: "py",
      env: {}
    });
  }
  /**
   * Creates a shell that can run commands, will return output as data is sent to stdin.
   *
   * ## Example
   *
   * ```ts
   * const shell = await sandbox.shell.create();
   *
   * const disposable = shell.onShellOut((data) => {
   *   console.log(data);
   * });
   *
   * // Write to the shell
   * shell.write("echo 'Hello, world!'");
   *
   * // Stop listening to the shell
   * disposable.dispose();
   *
   * // Kill the shell
   * await shell.kill();
   * ```
   *
   * @param command - The command to run in the shell.
   * @param shellSize - The size of the shell.
   * @returns A disposable shell instance.
   */
  async create(command2 = "bash", opts) {
    const shell = await this.pitcherClient.clients.shell.create(
      this.pitcherClient.workspacePath,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE,
      command2,
      "TERMINAL",
      true
    );
    return new ShellInstance(shell, this.pitcherClient);
  }
  /**
   * Opens an existing shell.
   */
  async open(shellId, opts) {
    const shell = await this.pitcherClient.clients.shell.open(
      shellId,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE
    );
    return new ShellInstance(shell, this.pitcherClient);
  }
  /**
   * Runs the given command, and can be listened to for streaming output. To get all
   * output, you can optionally await the returned promise.
   *
   * ## Example
   *
   * ```ts
   * const shell = await sandbox.shell.runCommand("echo 'Hello, world!'");
   *
   * shell.onOutput((data) => {
   *   console.log(data);
   * });
   *
   * const result = await shell;
   *
   * console.log(result.output, result.exitCode);
   * ```
   */
  run(command2, opts) {
    const shell = runCommandAsUser(
      this.pitcherClient,
      command2,
      opts?.ptySize ?? DEFAULT_SHELL_SIZE,
      void 0,
      void 0,
      opts?.shellName
    );
    return shell;
  }
  /**
   * Gets all shells that are running or have ran before in the current sandbox.
   */
  async getShells() {
    const shells = this.pitcherClient.clients.shell.getShells();
    return shells.map((shell) => new ShellInstance(shell, this.pitcherClient));
  }
};
function getRandomString() {
  return Math.random().toString(36).substring(7);
}
var LanguageInterpreter = class {
  constructor(pitcherClient, opts) {
    this.pitcherClient = pitcherClient;
    this.opts = opts;
  }
  async run(code) {
    const randomString = getRandomString();
    const tmpFileName = `/tmp/tmp.${randomString}.${this.opts.extension}`;
    const command2 = `${this.opts.runtime} ${tmpFileName}`;
    const result = runCommandAsUser(
      this.pitcherClient,
      command2,
      DEFAULT_SHELL_SIZE,
      async () => {
        const tmpFile = await this.pitcherClient.clients.fs.writeFile(
          tmpFileName,
          new TextEncoder().encode(code),
          true,
          true
        );
        if (tmpFile.type === "error") {
          throw new Error(`${tmpFile.errno}: ${tmpFile.error}`);
        }
      },
      this.opts.env
    );
    return result;
  }
};
var ShellInstance = class extends Disposable16 {
  constructor(shell, pitcherClient) {
    super();
    this.shell = shell;
    this.pitcherClient = pitcherClient;
    // TODO: differentiate between stdout and stderr, also send back bytes instead of
    // strings
    this.onShellOutputEmitter = this.addDisposable(new Emitter28());
    this.onOutput = this.onShellOutputEmitter.event;
    this.onShellUpdatedEmitter = this.addDisposable(new Emitter28());
    this.onShellUpdated = this.onShellUpdatedEmitter.event;
    this.output = this.shell.buffer || [];
    this.addDisposable(
      pitcherClient.clients.shell.onShellsUpdated((shells) => {
        const updatedShell = shells.find(
          (s3) => s3.shellId === this.shell.shellId
        );
        if (updatedShell) {
          this.shell = { ...updatedShell, buffer: [] };
          this.onShellUpdatedEmitter.fire();
        }
      })
    );
    this.addDisposable(
      this.pitcherClient.clients.shell.onShellOut(({ shellId, out }) => {
        if (shellId === this.shell.shellId) {
          this.onShellOutputEmitter.fire(out);
          this.output.push(out);
          if (this.output.length > 1e3) {
            this.output.shift();
          }
        }
      })
    );
    this.onWillDispose(async () => {
      try {
        await this.pitcherClient.clients.shell.close(this.shell.shellId);
      } catch (e3) {
      }
    });
  }
  /**
   * Gets the ID of the shell. Can be used to open the shell again.
   */
  get id() {
    return this.shell.shellId;
  }
  /**
   * Gets the name of the shell.
   */
  get name() {
    return this.shell.name;
  }
  get exitCode() {
    return this.shell.exitCode;
  }
  /**
   * Gets the status of the shell.
   */
  get status() {
    return this.shell.status;
  }
  async write(input) {
    await this.pitcherClient.clients.shell.send(this.shell.shellId, input, {
      cols: 80,
      rows: 24
    });
  }
  // TODO: allow for kill signals
  async kill() {
    await this.pitcherClient.clients.shell.delete(this.shell.shellId);
  }
  /**
   * @returns The total output of the shell
   */
  getOutput() {
    return this.output.join("\n");
  }
};
function runCommandAsUser(pitcher, command2, shellSize = DEFAULT_SHELL_SIZE, runPreCommand, env2, shellName) {
  const disposableStore = new import_pitcher_common34.DisposableStore();
  const onOutput = new Emitter28();
  disposableStore.add(onOutput);
  let shell;
  const resultPromise = (async () => {
    if (runPreCommand) {
      await runPreCommand();
    }
    const commandWithEnv = `env ${Object.entries(env2 ?? {}).map(([key, value]) => `${key}=${value}`).join(" ")} ${command2}`;
    shell = await pitcher.clients.shell.create(
      pitcher.workspacePath,
      shellSize,
      commandWithEnv,
      "TERMINAL",
      true
    );
    if (shellName) {
      pitcher.clients.shell.rename(shell.shellId, shellName);
    }
    if (shell.status === "FINISHED") {
      return {
        output: shell.buffer.join("\n").trim(),
        exitCode: shell.exitCode
      };
    }
    let combinedOut = shell.buffer.join("\n");
    if (combinedOut) {
      onOutput.fire(combinedOut);
    }
    const barrier = new import_pitcher_common34.Barrier();
    disposableStore.add(
      pitcher.clients.shell.onShellOut(({ shellId, out }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        onOutput.fire(out);
        combinedOut += out;
      })
    );
    disposableStore.add(
      pitcher.clients.shell.onShellExited(({ shellId, exitCode }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        barrier.open({ exitCode });
      })
    );
    disposableStore.add(
      pitcher.clients.shell.onShellTerminated(({ shellId }) => {
        if (shellId !== shell.shellId) {
          return;
        }
        barrier.open({ exitCode: void 0 });
      })
    );
    const result = await barrier.wait();
    disposableStore.dispose();
    if (result.status === "disposed") {
      throw new Error("Shell was disposed");
    }
    return {
      output: combinedOut.trim(),
      exitCode: result.value.exitCode
    };
  })();
  resultPromise.kill = () => {
    disposableStore.dispose();
    if (shell) {
      pitcher.clients.shell.delete(shell.shellId);
    }
  };
  resultPromise.onOutput = onOutput.event;
  return resultPromise;
}

// src/tasks.ts
var Tasks = class extends Disposable16 {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
  }
  /**
   * Gets all tasks that are available in the current sandbox.
   */
  async getTasks() {
    const tasks = await this.pitcherClient.clients.task.getTasks();
    return Object.values(tasks.tasks).map(taskFromDTO);
  }
  /**
   * Gets a task by its ID.
   */
  async getTask(taskId) {
    const task = await this.pitcherClient.clients.task.getTask(taskId);
    if (!task) {
      return void 0;
    }
    return taskFromDTO(task);
  }
  /**
   * Runs a task by its ID.
   */
  async runTask(taskId) {
    const task = await this.pitcherClient.clients.task.runTask(taskId);
    return taskFromDTO(task);
  }
};
function taskFromDTO(value) {
  return {
    id: value.id,
    name: value.name,
    command: value.command,
    runAtStart: value.runAtStart,
    preview: value.preview,
    shellId: value.shell?.shellId ?? null,
    ports: value.ports.map((port) => new PortInfo(port.port, port.url))
  };
}

// src/sandbox.ts
var SandboxWithoutClient = class extends import_pitcher_common33.Disposable {
  constructor(pitcherClient) {
    super();
    this.pitcherClient = pitcherClient;
    /**
     * Namespace for all filesystem operations on this sandbox.
     */
    this.fs = this.addDisposable(new FileSystem(this.pitcherClient));
    /**
     * Namespace for running shell commands on this sandbox.
     */
    this.shells = this.addDisposable(new Shells(this.pitcherClient));
    /**
     * Namespace for detecting open ports on this sandbox, and getting preview URLs for
     * them.
     */
    this.ports = this.addDisposable(new Ports(this.pitcherClient));
    /**
     * Namespace for all setup operations on this sandbox (installing dependencies, etc).
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    this.setup = this.addDisposable(new Setup(this.pitcherClient));
    /**
     * Namespace for all task operations on a sandbox. This includes running tasks,
     * getting tasks, and stopping tasks.
     *
     * In CodeSandbox, you can create tasks and manage them by creating a `.codesandbox/tasks.json`
     * in the sandbox. These tasks become available under this namespace, this way you can manage
     * tasks that you will need to run more often (like a dev server).
     *
     * More documentation: https://codesandbox.io/docs/learn/devboxes/task#adding-and-configuring-tasks
     *
     * This provider is *experimental*, it might get changes or completely be removed
     * if it is not used.
     */
    this.tasks = this.addDisposable(new Tasks(this.pitcherClient));
    this.addDisposable(this.pitcherClient);
  }
  /**
   * The ID of the sandbox.
   */
  get id() {
    return this.pitcherClient.instanceId;
  }
  /**
   * Get the URL to the editor for this sandbox. Keep in mind that this URL is not
   * available if the sandbox is private, and the user opening this sandbox does not
   * have access to the sandbox.
   */
  get editorUrl() {
    return `https://codesandbox.io/p/devbox/${this.id}`;
  }
  // TODO: Bring this back once metrics polling does not reset inactivity
  // /**
  //  * Get the current system metrics. This return type may change in the future.
  //  */
  // public async getMetrics(): Promise<SystemMetricsStatus> {
  //   await this.pitcherClient.clients.system.update();
  //   const barrier = new Barrier<_protocol.system.SystemMetricsStatus>();
  //   const initialMetrics = this.pitcherClient.clients.system.getMetrics();
  //   if (!initialMetrics) {
  //     const disposable = this.pitcherClient.clients.system.onMetricsUpdated(
  //       (metrics) => {
  //         if (metrics) {
  //           barrier.open(metrics);
  //         }
  //       }
  //     );
  //     disposable.dispose();
  //   } else {
  //     barrier.open(initialMetrics);
  //   }
  //   const barrierResult = await barrier.wait();
  //   if (barrierResult.status === "disposed") {
  //     throw new Error("Metrics not available");
  //   }
  //   const metrics = barrierResult.value;
  //   return {
  //     cpu: {
  //       cores: metrics.cpu.cores,
  //       used: metrics.cpu.used / 100,
  //       configured: metrics.cpu.configured,
  //     },
  //     memory: {
  //       usedKiB: metrics.memory.used * 1024 * 1024,
  //       totalKiB: metrics.memory.total * 1024 * 1024,
  //       configuredKiB: metrics.memory.total * 1024 * 1024,
  //     },
  //     storage: {
  //       usedKB: metrics.storage.used * 1000 * 1000,
  //       totalKB: metrics.storage.total * 1000 * 1000,
  //       configuredKB: metrics.storage.configured * 1000 * 1000,
  //     },
  //   };
  // }
  /**
   * Disconnect from the sandbox, this does not hibernate the sandbox (but it will
   * automatically hibernate after an inactivity timer).
   */
  disconnect() {
    this.pitcherClient.disconnect();
    this.dispose();
  }
};
var Sandbox = class extends SandboxWithoutClient {
  constructor(sandboxClient, pitcherClient) {
    super(pitcherClient);
    this.sandboxClient = sandboxClient;
  }
  /**
   * This creates a copy of the current sandbox, both memory and disk is copied, which means
   * that running processes will continue to run in the forked sandbox.
   */
  async fork() {
    return this.sandboxClient.create({
      template: this.id
    });
  }
  /**
   * Hibernate the sandbox. This will snapshot the disk and memory of the sandbox, so it
   * can be restored later from the exact current state. Will resolve once the sandbox is hibernated.
   */
  async hibernate() {
    this.dispose();
    this.pitcherClient.disconnect();
    await this.sandboxClient.hibernate(this.id);
  }
  /**
   * Shutdown the sandbox. This will stop all running processes and stop the sandbox. When you
   * start the sandbox next time, you will still have the same files and state as when you
   * shut down the sandbox.
   *
   * Will resolve once the sandbox is shutdown.
   */
  async shutdown() {
    this.dispose();
    this.pitcherClient.disconnect();
    await this.sandboxClient.shutdown(this.id);
  }
  /**
   * Reboot the sandbox. This will shutdown the sandbox, and then start it again. Files in
   * the project directory (`/project/sandbox`) will be preserved.
   *
   * Will resolve once the sandbox is rebooted.
   */
  async reboot() {
    await this.shutdown();
    const newSandbox = await this.sandboxClient.open(this.id);
    Object.assign(this, newSandbox);
  }
  /**
   * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
   * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
   * than it can scale down to, it can become very slow.
   */
  async updateTier(tier) {
    await this.sandboxClient.updateTier(this.id, tier);
  }
};

// src/utils/rate-limit.ts
var RATE_LIMIT_HEADERS = {
  sandboxes: {
    unit: "sandboxes",
    remaining: "x-csb-sandbox-hourly-remaining",
    reset: "x-csb-sandbox-hourly-reset",
    used: "x-csb-sandbox-hourly-used"
  },
  requests: {
    unit: "requests",
    remaining: "x-csb-rate-hourly-remaining",
    reset: "x-csb-rate-hourly-reset",
    used: "x-csb-rate-hourly-used"
  },
  vms: {
    unit: "concurrently running vms",
    remaining: "x-csb-vms-remaining",
    used: "x-csb-vms-used"
  }
};
var RateLimitError = class _RateLimitError extends Error {
  constructor() {
    super(...arguments);
    this.type = "rate-limit";
  }
  static fromResponse(response, errorPrefix, serverError) {
    const headers = response.headers;
    const rateLimitRemainingExceeded = Object.values(RATE_LIMIT_HEADERS).find(
      (headers2) => {
        const remaining = response.headers.get(headers2.remaining);
        return remaining && parseInt(remaining) <= 0;
      }
    );
    if (rateLimitRemainingExceeded) {
      const total = parseInt(
        response.headers.get(rateLimitRemainingExceeded.remaining) ?? "0"
      ) + parseInt(response.headers.get(rateLimitRemainingExceeded.used) ?? "0");
      let message = `${errorPrefix}: 0 of ${total} ${rateLimitRemainingExceeded.unit} remaining.`;
      if (rateLimitRemainingExceeded.reset) {
        message += ` Limit resets at ${headers.get(
          rateLimitRemainingExceeded.reset
        )}.`;
      }
      message += " Contact hello@codesandbox.io to raise your rate limit.";
      return new _RateLimitError(message);
    }
    return new _RateLimitError(`${errorPrefix}: ${serverError}`);
  }
};

// src/utils/handle-response.ts
function handleResponse(result, errorPrefix) {
  if (result.response.status === 429 && "error" in result) {
    const error = result.error.errors[0];
    throw RateLimitError.fromResponse(result.response, errorPrefix, error);
  }
  if (result.response.status === 404) {
    throw new Error(errorPrefix + ": Sandbox not found");
  }
  if (result.response.status === 403) {
    throw new Error(errorPrefix + ": Unauthorized");
  }
  if (result.response.status === 502) {
    throw new Error(errorPrefix + ": Bad gateway");
  }
  if ("error" in result) {
    const error = result.error.errors[0];
    throw new Error(errorPrefix + ": " + error);
  }
  if (!result.data || !result.data.data) {
    throw new Error(errorPrefix + ": No data returned");
  }
  return result.data.data;
}

// src/sandbox-client.ts
var DEFAULT_SUBSCRIPTIONS = {
  client: {
    status: true
  },
  file: {
    status: true,
    selection: true,
    ot: true
  },
  fs: {
    operations: true
  },
  git: {
    status: true,
    operations: true
  },
  port: {
    status: true
  },
  setup: {
    progress: true
  },
  shell: {
    status: true
  },
  system: {
    metrics: true
  }
};
var VMTier = class _VMTier {
  constructor(name, cpuCores, memoryGiB, diskGB) {
    this.name = name;
    this.cpuCores = cpuCores;
    this.memoryGiB = memoryGiB;
    this.diskGB = diskGB;
  }
  static {
    /** 1 CPU, 2GiB RAM */
    this.Pico = new _VMTier("Pico", 1, 2, 20);
  }
  static {
    /** 2 CPU, 4GiB RAM */
    this.Nano = new _VMTier("Nano", 2, 4, 20);
  }
  static {
    /** 4 CPU, 8GiB RAM */
    this.Micro = new _VMTier("Micro", 4, 8, 20);
  }
  static {
    /** 8 CPU, 16GiB RAM */
    this.Small = new _VMTier("Small", 8, 16, 30);
  }
  static {
    /** 16 CPU, 32GiB RAM */
    this.Medium = new _VMTier("Medium", 16, 32, 40);
  }
  static {
    /** 32 CPU, 64GiB RAM */
    this.Large = new _VMTier("Large", 32, 64, 50);
  }
  static {
    /** 64 CPU, 128GiB RAM */
    this.XLarge = new _VMTier("XLarge", 64, 128, 50);
  }
  static fromName(name) {
    return _VMTier[name];
  }
  /**
   * Returns the tier that complies to the given minimum specs.
   * @param cpuCores Amount of CPU cores needed
   * @param memoryGiB Amount of memory needed in GiB
   * @param diskGB Amount of disk space needed in GB
   */
  static fromSpecs(specs) {
    return Object.values(_VMTier).find(
      (tier) => tier.cpuCores >= specs.cpu && tier.memoryGiB >= specs.memGiB && (specs.diskGB === void 0 || tier.diskGB >= specs.diskGB)
    );
  }
};
function startOptionsFromOpts(opts) {
  if (!opts) return void 0;
  return {
    ipcountry: opts.ipcountry,
    tier: opts.vmTier?.name,
    hibernation_timeout_seconds: opts.hibernationTimeoutSeconds
  };
}
var SandboxClient = class {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  get defaultTemplate() {
    if (this.apiClient.getConfig().baseUrl?.includes("codesandbox.stream")) {
      return "7ngcrf";
    }
    return "pcz35m";
  }
  /**
   * Open, start & connect to a sandbox that already exists
   */
  async open(id, startOpts) {
    return this.connectToSandbox(id, () => this.start(id, startOpts));
  }
  /**
   * Try to start a sandbox that already exists, it will return the data of the started
   * VM, which you can pass to the browser. In the browser you can call `connectToSandbox` with this
   * data to control the VM without sharing your CodeSandbox API token in the browser.
   *
   * @param id the ID of the sandbox
   * @returns The start data, contains a single use token to connect to the VM
   */
  async start(id, opts) {
    const startResult = await vmStart({
      client: this.apiClient,
      body: startOptionsFromOpts(opts),
      path: {
        id
      }
    });
    const data = handleResponse(startResult, `Failed to start sandbox ${id}`);
    return data;
  }
  async create(opts) {
    const templateId = opts?.template || this.defaultTemplate;
    const privacy = opts?.privacy || "public";
    const tags = opts?.tags || ["sdk"];
    const path2 = opts?.path || "/SDK";
    const tagsWithSdk = tags.includes("sdk") ? tags : [...tags, "sdk"];
    const result = await sandboxFork({
      client: this.apiClient,
      body: {
        privacy: privacyToNumber(privacy),
        title: opts?.title,
        description: opts?.description,
        tags: tagsWithSdk,
        path: path2,
        start_options: opts?.autoConnect === false ? void 0 : startOptionsFromOpts(opts || {})
      },
      path: {
        id: typeof templateId === "string" ? templateId : templateId.id
      }
    });
    const sandbox = handleResponse(result, "Failed to create sandbox");
    return this.connectToSandbox(sandbox.id, () => {
      if (sandbox.start_response) {
        return Promise.resolve(sandbox.start_response);
      }
      return this.start(sandbox.id, opts);
    });
  }
  async fork(id, opts = {}) {
    return this.create({ ...opts, template: id });
  }
  /**
   * Shuts down a sandbox. Files will be saved, and the sandbox will be stopped.
   *
   * @param id The ID of the sandbox to shutdown
   */
  async shutdown(id) {
    const response = await vmShutdown({
      client: this.apiClient,
      path: {
        id
      }
    });
    handleResponse(response, `Failed to shutdown sandbox ${id}`);
  }
  /**
   * Hibernates a sandbox. Files will be saved, and the sandbox will be put to sleep. Next time
   * you start the sandbox it will be resumed from the last state it was in.
   *
   * @param id The ID of the sandbox to hibernate
   */
  async hibernate(id) {
    const response = await vmHibernate({
      client: this.apiClient,
      path: {
        id
      }
    });
    handleResponse(response, `Failed to hibernate sandbox ${id}`);
  }
  /**
   * Updates the specs that this sandbox runs on. It will dynamically scale the sandbox to the
   * new specs without a reboot. Be careful when scaling specs down, if the VM is using more memory
   * than it can scale down to, it can become very slow.
   *
   * @param id The ID of the sandbox to update
   * @param tier The new VM tier
   */
  async updateTier(id, tier) {
    const response = await vmUpdateSpecs({
      client: this.apiClient,
      path: { id },
      body: {
        tier: tier.name
      }
    });
    handleResponse(response, `Failed to update sandbox tier ${id}`);
  }
  async connectToSandbox(id, startVm) {
    const pitcherClient = await initPitcherClient(
      {
        appId: "sdk",
        instanceId: id,
        onFocusChange() {
          return () => {
          };
        },
        requestPitcherInstance: async () => {
          const data = await startVm();
          const headers = this.apiClient.getConfig().headers;
          if (headers.get("x-pitcher-manager-url")) {
            const preferredManager = headers.get("x-pitcher-manager-url")?.replace("/api/v1", "").replace("https://", "");
            const baseUrl = this.apiClient.getConfig().baseUrl?.replace("api", "global-scheduler");
            await fetch(
              `${baseUrl}/api/v1/cluster/${data.id}?preferredManager=${preferredManager}`
            ).then((res) => res.json());
          }
          return {
            bootupType: data.bootup_type,
            pitcherURL: data.pitcher_url,
            workspacePath: data.workspace_path,
            userWorkspacePath: data.user_workspace_path,
            pitcherManagerVersion: data.pitcher_manager_version,
            pitcherVersion: data.pitcher_version,
            latestPitcherVersion: data.latest_pitcher_version,
            pitcherToken: data.pitcher_token,
            cluster: data.cluster
          };
        },
        subscriptions: DEFAULT_SUBSCRIPTIONS
      },
      () => {
      }
    );
    return new Sandbox(this, pitcherClient);
  }
};
function privacyToNumber(privacy) {
  switch (privacy) {
    case "public":
      return 0;
    case "unlisted":
      return 1;
    case "private":
      return 2;
  }
}

// src/index.ts
function ensure(value, message) {
  if (!value) {
    throw new Error(message);
  }
  return value;
}
function getBaseUrl(token) {
  if (token.startsWith("csb_")) {
    return "https://api.codesandbox.io";
  }
  return "https://api.together.ai/csb/sdk";
}
var CodeSandbox = class {
  constructor(apiToken, opts = {}) {
    this.opts = opts;
    this.apiToken = apiToken || ensure(
      typeof process !== "undefined" ? process.env?.CSB_API_KEY || process.env?.TOGETHER_API_KEY : void 0,
      "CSB_API_KEY or TOGETHER_API_KEY is not set"
    );
    this.baseUrl = opts.baseUrl ?? getBaseUrl(this.apiToken);
    this.apiClient = L(
      z({
        baseUrl: this.baseUrl,
        headers: {
          Authorization: `Bearer ${this.apiToken}`,
          ...opts.headers ?? {}
        }
      })
    );
    this.sandbox = new SandboxClient(this.apiClient);
  }
};

// src/bin/utils/constants.ts
var BASE_URL = process.env.BASE_URL ?? "https://api.codesandbox.io";
var getApiKey = () => {
  const _API_KEY = process.env.CSB_API_KEY;
  if (!_API_KEY) {
    console.error("CSB_API_KEY environment variable is not set");
    console.error("You can generate one at https://codesandbox.io/t/api");
    process.exit(1);
  }
  return _API_KEY;
};

// src/bin/utils/hash.ts
var import_crypto = require("crypto");
var import_fs5 = require("fs");
var import_promises = require("fs/promises");
var import_path6 = require("path");
var import_ignore = __toESM(require_ignore());
var MAX_FILES = 5e4;
async function hashDirectory(dirPath) {
  const ig = (0, import_ignore.default)();
  const gitignorePath = (0, import_path6.join)(dirPath, ".gitignore");
  const dockerignorePath = (0, import_path6.join)(dirPath, ".dockerignore");
  const csbIgnorePath = (0, import_path6.join)(dirPath, ".csbignore");
  ig.add(".git/**");
  if ((0, import_fs5.existsSync)(gitignorePath)) {
    ig.add((0, import_fs5.readFileSync)(gitignorePath, "utf8"));
  }
  if ((0, import_fs5.existsSync)(dockerignorePath)) {
    ig.add((0, import_fs5.readFileSync)(dockerignorePath, "utf8"));
  }
  if ((0, import_fs5.existsSync)(csbIgnorePath)) {
    ig.add((0, import_fs5.readFileSync)(csbIgnorePath, "utf8"));
  }
  const relevantFiles = [];
  const fileHashes = [];
  async function processDirectory(currentPath) {
    const files = await (0, import_promises.readdir)(currentPath);
    await Promise.all(
      files.map(async (file) => {
        if (relevantFiles.length >= MAX_FILES) {
          throw new Error(`Directory contains more than ${MAX_FILES} files`);
        }
        const fullPath = (0, import_path6.join)(currentPath, file);
        const relativePath = (0, import_path6.relative)(dirPath, fullPath);
        if (ig.ignores(relativePath)) {
          return;
        }
        const stats = await (0, import_promises.stat)(fullPath);
        if (stats.isDirectory()) {
          await processDirectory(fullPath);
        } else if (stats.isFile()) {
          const fileContent = await (0, import_promises.readFile)(fullPath);
          const fileHash = (0, import_crypto.createHash)("sha256").update(fileContent).digest("hex");
          fileHashes.push(fileHash);
          relevantFiles.push(relativePath);
        }
      })
    );
  }
  await processDirectory(dirPath);
  fileHashes.sort();
  relevantFiles.sort();
  const finalHash = (0, import_crypto.createHash)("sha256").update(fileHashes.join("")).digest("hex");
  return {
    hash: finalHash,
    files: relevantFiles
  };
}

// src/bin/commands/build.ts
var buildCommand = {
  command: "build <path>",
  describe: "Build an efficient memory snapshot from a directory. This snapshot can be used to create sandboxes quickly.",
  builder: (yargs) => yargs.option("ip-country", {
    describe: "Cluster closest to this country to create the snapshot in, this ensures that sandboxes created of this snapshot will be created in the same cluster",
    type: "string"
  }).option("from-sandbox", {
    describe: "Use and update an existing sandbox as a template",
    type: "string"
  }).option("skip-files", {
    describe: "Skip writing files to the sandbox",
    type: "boolean"
  }).option("cluster", {
    describe: "Cluster to create the sandbox in",
    type: "string"
  }).positional("path", {
    describe: "Path to the project",
    type: "string",
    demandOption: "Path to the project is required"
  }),
  handler: async (argv) => {
    const API_KEY = getApiKey();
    const apiClient = L(
      z({
        baseUrl: BASE_URL,
        headers: {
          Authorization: `Bearer ${API_KEY}`
        }
      })
    );
    const spinner = (0, import_ora.default)("Indexing folder...").start();
    try {
      const getSdk = (cluster2) => {
        const headers = cluster2 ? {
          "x-pitcher-manager-url": `https://${cluster2}.pitcher.csb.app/api/v1`
        } : {};
        return {
          sdk: new CodeSandbox(API_KEY, {
            baseUrl: BASE_URL,
            headers
          }),
          cluster: cluster2
        };
      };
      const { sdk, cluster } = getSdk(argv.cluster);
      const { hash, files: filePaths } = await hashDirectory(argv.path);
      spinner.succeed(`Indexed ${filePaths.length} files`);
      const shortHash = hash.slice(0, 6);
      const tag = `sha:${shortHash}-${cluster || ""}`;
      spinner.start(`Creating or updating sandbox...`);
      const { alreadyExists, sandboxId } = argv.fromSandbox ? {
        alreadyExists: true,
        sandboxId: argv.fromSandbox
      } : await createSandbox(apiClient, tag);
      if (alreadyExists && !argv.fromSandbox) {
        spinner.succeed("Sandbox snapshot has been created before:");
        console.log(sandboxId);
        return;
      }
      if (argv.fromSandbox) {
        spinner.succeed(`Sandbox reused: ${sandboxId}`);
      } else {
        spinner.succeed(`Sandbox created: ${sandboxId}`);
      }
      if (argv.cluster) {
        spinner.start(`Starting sandbox in cluster ${argv.cluster}...`);
      } else {
        spinner.start(`Starting sandbox...`);
      }
      const sandbox = await sdk.sandbox.open(sandboxId, {
        ipcountry: argv.ipCountry
      });
      spinner.succeed("Sandbox opened");
      if (!argv.skipFiles) {
        spinner.start("Writing files to sandbox...");
        let i4 = 0;
        for (const filePath of filePaths) {
          i4++;
          spinner.start(`Writing file ${i4} of ${filePaths.length}...`);
          const fullPath = import_path7.default.join(argv.path, filePath);
          const content = await import_fs6.promises.readFile(fullPath);
          const dirname3 = import_path7.default.dirname(filePath);
          await sandbox.fs.mkdir(dirname3, true);
          await sandbox.fs.writeFile(filePath, content, {
            create: true,
            overwrite: true
          });
        }
        spinner.succeed("Files written to sandbox");
        spinner.start("Rebooting sandbox...");
        await sandbox.reboot();
        spinner.succeed("Sandbox rebooted");
      }
      const disposableStore = new import_pitcher_common35.DisposableStore();
      const handleProgress = async (progress2) => {
        if (progress2.state === "IN_PROGRESS" && progress2.steps.length > 0) {
          const step = progress2.steps[progress2.currentStepIndex];
          if (!step) {
            return;
          }
          const spinnerMessage = `Running setup: ${progress2.currentStepIndex + 1} / ${progress2.steps.length}: ${step.name}`;
          spinner.info(spinnerMessage);
          const shellId = step.shellId;
          if (shellId) {
            const shell = await sandbox.shells.open(shellId, {
              ptySize: {
                cols: process.stderr.columns,
                rows: process.stderr.rows
              }
            });
            disposableStore.add(shell);
            disposableStore.add(
              shell.onOutput((data) => {
                process.stderr.write(data);
              })
            );
          }
        } else if (progress2.state === "FINISHED") {
          spinner.succeed("Setup finished");
        } else if (progress2.state === "STOPPED") {
          const step = progress2.steps[progress2.currentStepIndex];
          if (!step) {
            return;
          }
          if (step.finishStatus === "FAILED") {
            throw new Error(`Setup step failed: ${step.name}`);
          }
        }
      };
      const progress = await sandbox.setup.getProgress();
      await handleProgress(progress);
      disposableStore.add(sandbox.setup.onSetupProgressUpdate(handleProgress));
      await sandbox.setup.waitForFinish();
      disposableStore.dispose();
      spinner.succeed("Sandbox built");
      const tasksWithStart = (await sandbox.tasks.getTasks()).filter(
        (t3) => t3.runAtStart === true
      );
      let tasksWithPorts = tasksWithStart.filter((t3) => t3.preview?.port);
      const isMultipleTasks = tasksWithStart.length > 1;
      spinner.info(
        `Started ${tasksWithStart.length} ${isMultipleTasks ? "tasks" : "task"}: ${tasksWithStart.map((t3) => t3.name).join(", ")}`
      );
      const updatePortSpinner = () => {
        const isMultiplePorts = tasksWithPorts.length > 1;
        spinner.start(
          `Waiting for ${isMultiplePorts ? "ports" : "port"} ${tasksWithPorts.map((t3) => t3.preview?.port).join(", ")} to open...`
        );
      };
      if (tasksWithPorts.length > 0) {
        updatePortSpinner();
        await Promise.all(
          tasksWithPorts.map(async (task) => {
            const port = task.preview?.port;
            if (!port) {
              return;
            }
            let timeout;
            const portInfo = await Promise.race([
              sandbox.ports.waitForPort(port),
              new Promise(
                (_3, reject) => timeout = setTimeout(
                  () => reject(
                    new Error(
                      `Waiting for port ${port} timed out after 60s`
                    )
                  ),
                  6e4
                )
              )
            ]);
            clearTimeout(timeout);
            if (!(portInfo instanceof PortInfo)) {
              throw portInfo;
            }
            while (true) {
              const res = await fetch(portInfo.getPreviewUrl());
              if (res.status < 400) {
                spinner.succeed(`Port ${port} is open (status ${res.status})`);
                break;
              } else {
                spinner.fail(
                  `Port ${port} is not open yet (status ${res.status}), retrying in 1 second...`
                );
                await new Promise((resolve5) => setTimeout(resolve5, 1e3));
              }
            }
            tasksWithPorts = tasksWithPorts.filter((t3) => t3.id !== task.id);
            updatePortSpinner();
          })
        );
        spinner.succeed("All ports are open");
      } else {
        spinner.succeed(
          "No ports to open, waiting 5 seconds for tasks to run..."
        );
        await new Promise((resolve5) => setTimeout(resolve5, 5e3));
      }
      spinner.start("Creating memory snapshot...");
      await sandbox.hibernate();
      spinner.succeed(
        "Snapshot created, you can use this sandbox id as your template:"
      );
      console.log(sandbox.id);
    } catch (error) {
      spinner.fail(
        error instanceof Error ? error.message : "Unknown error occurred"
      );
      process.exit(1);
    }
  }
};
async function createSandbox(apiClient, shaTag) {
  const sandbox = handleResponse(
    await sandboxCreate({
      client: apiClient,
      body: {
        files: {},
        privacy: 1,
        tags: ["sdk", shaTag],
        path: "/SDK-Templates",
        runtime: "vm",
        is_frozen: true
      }
    }),
    "Failed to create sandbox"
  );
  return { alreadyExists: false, sandboxId: sandbox.id };
}

// src/bin/commands/sandbox/fork.ts
var import_ora2 = __toESM(require_ora());
async function forkSandbox(sandboxId) {
  const sdk = new CodeSandbox();
  const spinner = (0, import_ora2.default)("Forking sandbox...").start();
  const sandbox2 = await sdk.sandbox.fork(sandboxId);
  spinner.succeed("Sandbox forked successfully");
  sandbox2.disconnect();
  console.log(sandbox2.id);
}

// src/bin/commands/sandbox/hibernate.ts
var import_ora3 = __toESM(require_ora());
async function hibernateSandbox(sandboxId) {
  const sdk = new CodeSandbox();
  const spinner = (0, import_ora3.default)("Hibernating sandbox...").start();
  await sdk.sandbox.hibernate(sandboxId);
  spinner.succeed("Sandbox hibernated successfully");
  console.log(sandboxId);
}

// src/bin/commands/sandbox/shutdown.ts
var import_ora4 = __toESM(require_ora());
async function shutdownSandbox(sandboxId) {
  const sdk = new CodeSandbox();
  const spinner = (0, import_ora4.default)("Shutting down sandbox...").start();
  await sdk.sandbox.shutdown(sandboxId);
  spinner.succeed("Sandbox shutdown successfully");
  console.log(sandboxId);
}

// src/bin/main.ts
yargs_default(hideBin(process.argv)).usage("CodeSandbox SDK CLI - Manage your CodeSandbox projects").demandCommand(1, "Usage: csb <command> [options]").scriptName("csb").strict().recommendCommands().command(buildCommand).command(
  "sandbox <action> <id>",
  "Manage sandboxes",
  (yargs) => {
    return yargs.positional("action", {
      describe: "Action to perform on the sandbox",
      choices: ["hibernate", "fork", "shutdown"],
      type: "string"
    }).positional("id", {
      describe: "ID of the sandbox",
      type: "string",
      demandOption: true
    });
  },
  async (argv) => {
    if (argv.action === "hibernate") {
      await hibernateSandbox(argv.id);
    } else if (argv.action === "fork") {
      await forkSandbox(argv.id);
    } else if (argv.action === "shutdown") {
      await shutdownSandbox(argv.id);
    }
  }
).parse();
/*! Bundled license information:

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

yargs-parser/build/lib/string-utils.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/tokenize-arg-string.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser-types.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/index.js:
  (**
   * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
   * CJS and ESM environments.
   *
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)
*/
